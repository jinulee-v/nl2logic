{"id": "entailmentbank_validation_0", "nl": "the sun rising / setting occurs once per day.", "fol": "", "prediction": ["To express the statement \"the sun rising/setting occurs once per day\" in first-order logic, we need predicates to represent the rising and setting events of the sun, and we assume a temporal context (say, using a day predicate).\n\n```FOL\nRisesOncePerDay := all d. (Day(d) -> (exists t1. (Rises(sun, t1, d)) & -exists t2. (Rises(sun, t2, d) & t2 != t1)))\nSetsOncePerDay := all d. (Day(d) -> (exists t1. (Sets(sun, t1, d)) & -exists t2. (Sets(sun, t2, d) & t2 != t1)))\n\nSunRiseSetOncePerDay := RisesOncePerDay & SetsOncePerDay\n```\n\nThis uses:\n- `Day(d)`: identifies `d` as a day.\n- `Rises(sun, t, d)`: the sun rises at time `t` on day `d`.\n- `Sets(sun, t, d)`: the sun sets at time `t` on day `d`.\n- The logic ensures there is exactly one rising and one setting event per day by finding a unique time `t1` for each, with no other distinct times `t2`.", "exists y. (Rising(sun, y) & Setting(sun, y) & DailyOccurrence(y))", "exists t1, t2. (Rises(sun, t1) & Sets(sun, t2) & OccursOncePerDay(Rises(sun, t1)) & OccursOncePerDay(Sets(sun, t2)))", "all d. (Day(d) -> exists e. ((Event(e) & (Rising(e, sun) | Setting(e, sun))) & OccursOncePer(d, e)))"]}
{"id": "entailmentbank_validation_1", "nl": "the sun rising is a kind of event.", "fol": "", "prediction": ["Event(rising(sun))", "Event(sun_rising)", "Event(sun_rising)", "Event(sun_rising)"]}
{"id": "entailmentbank_validation_2", "nl": "the sun setting is a kind of event.", "fol": "", "prediction": ["Event(sun_setting)", "Event(sun_setting)", "Event(sunset)", "Event(SunSetting)"]}
{"id": "entailmentbank_validation_3", "nl": "the sun rising and setting is the event that occurs once per day.", "fol": "", "prediction": ["Exists e. (Event(e) & Rises(sun, e) & Sets(sun, e) & OccursOncePerDay(e))", "exists e. (Event(e) & Rises(sun, e) & Sets(sun, e) & OccursOncePerDay(e))", "Event(rising_and_setting_of_sun) & OccursOncePerDay(rising_and_setting_of_sun)", "```\nall d. (Day(d) -> exists e. (Event(e) & OccursOncePerDay(e, d) & Rises(sun, e) & Sets(sun, e)))\n```"]}
{"id": "entailmentbank_validation_4", "nl": "a star produces light and heat.", "fol": "", "prediction": ["exists x. (Star(x) & ProducesLight(x) & ProducesHeat(x))", "Star(s) -> (ProducesLight(s) & ProducesHeat(s))", "ProducesLight(star) & ProducesHeat(star)", "StarProduces(x) -> (Light(x) & Heat(x))"]}
{"id": "entailmentbank_validation_5", "nl": "a source of something emits / produces / generates / provides that something.", "fol": "", "prediction": ["all x. all y. ((SourceOf(x, y)) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all s, y. (SourceOf(s, y) -> (Emits(s, y) | Produces(s, y) | Generates(s, y) | Provides(s, y)))", "all x, y. (SourceOf(x, y) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all x. all y. (SourceOf(x, y) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))"]}
{"id": "entailmentbank_validation_6", "nl": "a star is a source of light.", "fol": "", "prediction": ["SourceOfLight(star)", "SourceOfLight(star)", "exists x. (Star(x) -> SourceOfLight(x))", "SourceOfLight(star)"]}
{"id": "entailmentbank_validation_7", "nl": "as the source of light becomes closer, that source of light will appear brighter.", "fol": "", "prediction": ["all x. (SourceOfLight(x) & BecomesCloser(x) -> WillAppearBrighter(x))", "all x. ((SourceOfLight(x) & BecomesCloser(x)) -> AppearsBrighter(x))", "exists x. (SourceOfLight(x) & Closer(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))"]}
{"id": "entailmentbank_validation_8", "nl": "distance is a property of space and includes ordered values of close / far.", "fol": "", "prediction": ["exists x. (Distance(x) & PropertyOf(x, space) & IncludesOrderedValues(x, close, far))", "all x. (Space(x) -> exists y. (Property(y) & Distance(y, x) & IncludesOrderedValues(y, close, far)))", "all x. ((PropertyOf(x, space) & IncludesOrderedValues(x, close, far)) <-> Distance(x))", "all x. (Space(x) -> exists y. (Property(distance) & Includes(y, OrderedValues(Close, Far))))"]}
{"id": "entailmentbank_validation_9", "nl": "as the distance of the star to earth decreases, the star will appear brighter.", "fol": "", "prediction": ["all x. (Star(x) & DecreasesDistanceTo(x, earth) -> AppearsBrighter(x))", "all x. (Star(x) -> (Decreases(Distance(x, earth)) -> AppearsBrighter(x)))", "all x. (Star(x) & DecreasesDistanceToEarth(x) -> AppearsBrighter(x))", "all x. (Star(x) & Decreases(Distance(x, earth)) -> AppearsBrighter(x))"]}
{"id": "entailmentbank_validation_10", "nl": "a star is a kind of celestial object / celestial body.", "fol": "", "prediction": ["all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialBody(x))", "all x. (Star(x) -> CelestialObject(x))"]}
{"id": "entailmentbank_validation_11", "nl": "apparent magnitude is a measure of the brightness of a celestial object / celestial body as observed on earth.", "fol": "", "prediction": ["all x. ((CelestialObject(x) | CelestialBody(x)) & ObservedOnEarth(x) -> Measure(ApparentMagnitude, Brightness(x)))", "Measure(apparent_magnitude, Brightness(celestial_object, observed_on_earth))", "Measure(apparent_magnitude, Brightness(celestial_object, observed_on_earth))", "all x. (ApparentMagnitude(x) -> MeasureOfBrightness(x) & ObservedOnEarth(x) & CelestialObject(x))"]}
{"id": "entailmentbank_validation_12", "nl": "apparent magnitude is a measure of the brightness of a star as observed on earth.", "fol": "", "prediction": ["Measure(apparent_magnitude, Brightness(star, earth))", "Measure(apparent_magnitude, Brightness(star, observed_on(earth)))", "Measure(apparent_magnitude, Brightness(star, ObservedOn(earth)))", "all x. (ApparentMagnitude(x) -> exists y. (Star(y) & ObservedBrightnessOnEarth(x, y)))"]}
{"id": "entailmentbank_validation_13", "nl": "united states is located in the northern hemisphere.", "fol": "", "prediction": ["LocatedInNorthernHemisphere(united_states)", "LocatedInNorthernHemisphere(united_states)", "LocatedIn(united_states, northern_hemisphere)", "LocatedIn(united_states, northern_hemisphere)"]}
{"id": "entailmentbank_validation_14", "nl": "new york / new york state is a state located in the united states of america.", "fol": "", "prediction": ["State(new_york_state) & LocatedIn(new_york_state, usa)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)"]}
{"id": "entailmentbank_validation_15", "nl": "new york state is located in the northern hemisphere.", "fol": "", "prediction": ["LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)"]}
{"id": "entailmentbank_validation_16", "nl": "december is during the winter in the northern hemisphere.", "fol": "", "prediction": ["During(december, winter) & In(northern_hemisphere, winter)", "During(december, winter) & In(northern_hemisphere, winter)", "During(december, winter) & In(northern_hemisphere, december)", "During(december, winter) & In(northern_hemisphere, december)"]}
{"id": "entailmentbank_validation_17", "nl": "december is during the winter for new york state.", "fol": "", "prediction": ["During(december, Winter(new_york_state))", "During(december, Winter, new_york_state)", "During(december, WinterPeriodFor(new_york_state))", "During(december, Winter(new_york_state))"]}
{"id": "entailmentbank_validation_18", "nl": "winter has the least sunlight.", "fol": "", "prediction": ["HasLeastSunlight(winter)", "HasLeastSunlight(winter)", "HasLeastSunlight(winter)", "Winter(winter) & all x. (Sunlight(winter, x) -> all y. (Season(y) & y != winter -> Sunlight(y, z) & z > x))"]}
{"id": "entailmentbank_validation_19", "nl": "new york state has the least sunlight during december.", "fol": "", "prediction": ["Exists x. (State(x) & Name(x, new_york) & all y. (Month(y) & Name(y, december) & LeastSunlight(x, y)))", "LeastSunlight(new_york_state, december)", "LeastSunlight(new_york_state, december)", "HasLeastSunlight(new_york_state, december)"]}
{"id": "entailmentbank_validation_20", "nl": "earth is a kind of planet.", "fol": "", "prediction": ["Planet(earth)", "Planet(earth)", "KindOfPlanet(earth)", "KindOf(earth, planet)"]}
{"id": "entailmentbank_validation_21", "nl": "the earth rotates on its tilted axis.", "fol": "", "prediction": ["RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnAxis(earth, tilted_axis)", "RotatesOnTiltedAxis(earth)"]}
{"id": "entailmentbank_validation_22", "nl": "earth is a planet that rotates on its tilted axis.", "fol": "", "prediction": ["Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)"]}
{"id": "entailmentbank_validation_23", "nl": "rotation is the circular movement of an object around a center / axis.", "fol": "", "prediction": ["all x. (Rotation(x) -> exists y. (ObjectCircularMovement(x, y) & AroundCenterOrAxis(x, y)))", "all x. (Rotation(x) -> exists y. (Object(y) & CircularMovement(y, CenterOrAxis(x))))", "all x. (Rotation(x) -> exists y. (ObjectMovesAround(x, y) & (Center(y) | Axis(y))))", "all x. (Rotation(x) -> exists y. (CircularMovement(x, y) & CenterOrAxis(y)))"]}
{"id": "entailmentbank_validation_24", "nl": "a planet rotating causes cycles of day and night on that planet.", "fol": "", "prediction": ["all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), DayNightCycles(x)))"]}
{"id": "entailmentbank_validation_25", "nl": "earth rotating on its axis causes the cycle of day and night on earth.", "fol": "", "prediction": ["Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "FOL Translation:\nRotates(earth, axis) -> Causes(CycleOfDayNight(earth))"]}
{"id": "entailmentbank_validation_26", "nl": "gradens contain plants.", "fol": "", "prediction": ["all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))"]}
{"id": "entailmentbank_validation_27", "nl": "gardens are located outside.", "fol": "", "prediction": ["all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))"]}
{"id": "entailmentbank_validation_28", "nl": "the plants in the gardens are located outside.", "fol": "", "prediction": ["all x. ((Plant(x) & InGarden(x)) -> LocatedOutside(x))", "all x. (PlantInGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))"]}
{"id": "entailmentbank_validation_29", "nl": "if something is outside during the day then that something will receive sunlight.", "fol": "", "prediction": ["all x. (Outside(x) & DuringDay(x) -> ReceivesSunlight(x))", "all x. ((Outside(x) & DuringDaytime(x)) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. ((OutsideDuringTheDay(x)) -> ReceivesSunlight(x))"]}
{"id": "entailmentbank_validation_30", "nl": "the plants in the gardens will receive sunlight during the day.", "fol": "", "prediction": ["all x. (PlantInGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (PlantInGarden(x) -> (Daytime -> ReceivesSunlight(x)))", "all x. (Plant(x) & InGarden(x) -> ReceivesSunlightDuringDay(x))", "all p. (Plant(p) & InGarden(p) -> ReceivesSunlightDuringDay(p))"]}
{"id": "entailmentbank_validation_31", "nl": "a plant requires sunlight to grow.", "fol": "", "prediction": ["all x. (Plant(x) -> (RequiresSunlight(x) & ToGrow(x)))", "all x. (Plant(x) -> RequiresSunlightToGrow(x))", "all x. (Plant(x) -> (RequiresSunlight(x) & CanGrow(x)))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))"]}
{"id": "entailmentbank_validation_32", "nl": "the plants in the gardens will receive sunlight to grow during the day.", "fol": "", "prediction": ["all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & GrowDuringDay(x)))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & ToGrow(x) & During(y, day)))", "all x. ((Plant(x) & InGarden(x)) -> (ReceivesSunlightToGrow(x, daytime)))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & ReceivesSunlight(x, y) & ToGrow(x) & Daytime(y)))"]}
{"id": "entailmentbank_validation_33", "nl": "summer has the most sunlight.", "fol": "", "prediction": ["MostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "Sunlight(most, summer)"]}
{"id": "entailmentbank_validation_34", "nl": "the plants in the gardens will receive the most sunlight in summer to grow during the day.", "fol": "", "prediction": ["Let's decompose the sentence for translation into first-order logic:\n\n- Subject: \"the plants in the gardens\"\n- Condition: \"will receive the most sunlight in summer\"\n- Purpose/Result: \"to grow during the day\"\n\nNow, breaking it down into predicates and logical structure:\n\n- `Plant(x)`: x is a plant.\n- `InGarden(x, y)`: x is a plant in garden y.\n- `ReceivesMostSunlightInSummer(x)`: x receives the most sunlight in summer.\n- `GrowDuringDay(x)`: x grows during the day.\n\nWe can incorporate the fact that this is a declarative statement about particular plants in gardens:\n\nFOL Translation:\nall x, y. ((Plant(x) & InGarden(x, y)) -> (ReceivesMostSunlightInSummer(x) & GrowDuringDay(x)))", "Let me clarify the sentence before translating it into first-order logic (FOL). The sentence implies that plants that are located in gardens receive the most sunlight during the summer, and this sunlight is received during the day, which contributes to their growth.\n\nFOL Translation:\nall x. ((Plant(x) & InGarden(x)) -> (ReceivesMostSunlightInSummer(x) & GrowsDuringDay(x)))", "all x. ((Plant(x) & InGarden(x)) -> (WillReceiveMostSunlightInSummer(x) & GrowDuringDay(x)))", "exists x. (Plant(x) & InGarden(x) & exists z. (Garden(z) & In(z, x)) -> all t. (Summer(t) -> (ReceivesMostSunlight(x, t) & CanGrowDuringDay(x))))"]}
{"id": "entailmentbank_validation_35", "nl": "andy lives in southern hemisphere.", "fol": "", "prediction": ["LivesInSouthernHemisphere(andy)", "LivesIn(andy, southern_hemisphere)", "LivesIn(andy, southern_hemisphere)", "LivesInSouthernHemisphere(andy)"]}
{"id": "entailmentbank_validation_36", "nl": "it is august.", "fol": "", "prediction": ["Month(august)", "The sentence \"It is August\" simply states a fact about the current month, so it can be represented in FOL as a predicate indicating a specific month:\n\n```plaintext\nMonth(august)\n```", "The month 'August' can be represented as a constant, and the current time period being August can be expressed with a predicate.\n\nFOL Translation:\nCurrentMonth(august)", "Month(august)"]}
{"id": "entailmentbank_validation_37", "nl": "august is during the winter in the southern hemisphere.", "fol": "", "prediction": ["DuringWinter(august, southern_hemisphere)", "During(august, winter) & Location(august, southern_hemisphere)", "During(august, winter) & In(southern_hemisphere)", "During(august, winter, southern_hemisphere)"]}
{"id": "entailmentbank_validation_38", "nl": "andy will experience winter in southern hemisphere in august.", "fol": "", "prediction": ["ExperienceWinter(andy, southern_hemisphere, august)", "ExperienceWinter(andy, southern_hemisphere, august)", "WillExperienceWinter(andy, southern_hemisphere, august)", "ExperiencesWinterInAugust(andy, southern_hemisphere)"]}
{"id": "entailmentbank_validation_39", "nl": "the sun is a kind of star.", "fol": "", "prediction": ["Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)"]}
{"id": "entailmentbank_validation_40", "nl": "the earth revolves around the sun.", "fol": "", "prediction": ["RevolvesAround(earth, sun)", "RevolvesAround(earth, sun)", "Revolves(earth, sun)", "Revolves(earth, sun)"]}
{"id": "entailmentbank_validation_41", "nl": "earth revolving the sun is an example of a planet revolving around its star.", "fol": "", "prediction": ["Example(earth, RevolvesAround(earth, sun)) & Planet(earth) & Star(sun) & RevolvesAround(earth, sun)", "Example(earth, sun, Revolving(Around(planet, star))) & Revolving(earth, sun) & planet = earth & star = sun", "Example(Orbits(earth, sun), all x (Planet(x) -> exists y (Star(y) & Orbits(x, y))))", "Example(earth, sun, planetRevolvingAroundStar) & Planet(earth) & Star(sun) & RevolvesAround(earth, sun)"]}
{"id": "entailmentbank_validation_42", "nl": "a complete revolution / orbit of a planet around its star takes 1 / one planetary year.", "fol": "", "prediction": ["all x. (Planet(x) -> exists y. (Star(y) & Orbits(x, y) & TakesCompleteRevolution(x, y, one_planetary_year)))", "all x. (Planet(x) -> exists y. (Star(y) & Orbits(x, y) & TakesOnePlanetaryYear(x, y)))", "all x. all y. ((Planet(x) & Star(y) & Orbits(x, y)) -> RevolutionTime(x, y) = planetary_year)", "all x y. ((Planet(x) & Star(y) & Orbits(x, y)) -> TakesCompleteOrbit(x, y, one_planetary_year))"]}
{"id": "entailmentbank_validation_43", "nl": "a complete revolution of earth around the sun takes an earth year.", "fol": "", "prediction": ["exists x. (CompleteRevolution(x) & Of(x, earth) & Around(x, sun) -> Takes(x, earth_year))", "exists x. (RevolutionOf(earth, sun, x) & Complete(x) & Takes(x, earth_year))", "TakesCompleteRevolutionAndTakesTime(year, earth, sun)", "exists x. (CompleteRevolution(x) & Earth(x) & Around(x, sun) & Takes(x, earth_year))"]}
{"id": "entailmentbank_validation_44", "nl": "earth rotating on its tilted axis occurs once per day.", "fol": "", "prediction": ["RotatesOncePerDayOnTiltedAxis(earth)", "Rotates(earth, axis_of(earth), once_per_day)", "OccursOncePerDay(RotatesOnTiltedAxis(earth))", "OccursOncePerDay(EarthRotatingOnTiltedAxis)"]}
{"id": "entailmentbank_validation_45", "nl": "the earth is a planet that rotates on its tilted axis once per day.", "fol": "", "prediction": ["Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & OncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)"]}
{"id": "entailmentbank_validation_46", "nl": "the earth rotating on its tilted axis causes the cycles of day and night on earth.", "fol": "", "prediction": ["Causes(RotatesOnTiltedAxis(earth), DayNightCycles(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "Causes(RotatingOnTiltedAxis(earth), CyclesOfDayNight(earth))", "Causes(RotatingOnTiltedAxis(earth), DayNightCycles(earth))"]}
{"id": "entailmentbank_validation_47", "nl": "mercury is located in the solar system.", "fol": "", "prediction": ["LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)"]}
{"id": "entailmentbank_validation_48", "nl": "mercury is a kind of planet.", "fol": "", "prediction": ["Planet(mercury)", "Planet(mercury)", "Planet(mercury)", "Planet(mercury)"]}
{"id": "entailmentbank_validation_49", "nl": "mercury is a planet in the solar system.", "fol": "", "prediction": ["Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InTheSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)"]}
{"id": "entailmentbank_validation_50", "nl": "planets in the solar system orbit the sun.", "fol": "", "prediction": ["all x. (PlanetInSolarSystem(x) -> Orbits(x, sun))", "all x. (PlanetInSolarSystem(x) -> Orbits(x, sun))", "all x. (PlanetInSolarSystem(x) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))"]}
{"id": "entailmentbank_validation_51", "nl": "mercury is a planet orbits the sun in the solar system.", "fol": "", "prediction": ["Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & In(sun, solar_system)"]}
{"id": "entailmentbank_validation_52", "nl": "a complete orbit of mercury around the sun takes one mercury year.", "fol": "", "prediction": ["CompleteOrbit(mercury, sun) -> TakesTime(mercury_year)", "Exists z. (CompleteOrbit(mercury, sun, z) & Equals(z, OneMercuryYear))", "Exists x. ((Orbit(mercury, sun) & CompleteOrbit(x, mercury, sun)) -> TakesOneMercuryYear(x))", "TakesCompleteOrbit(mercury, sun, mercury_year)"]}
{"id": "entailmentbank_validation_53", "nl": "one mercury year is about 88 earth days.", "fol": "", "prediction": ["YearLength(mercury, 88 * earth_day)", "One possible translation of \"one mercury year is about 88 earth days\" into FOL could be:\n\nYearOnMercury(mercuryyear) & Duration(mercuryyear, earthdays) & Approximately(earthdays, 88)\n\nHere, the notation captures that there's a concept of a \"mercury year\" which has a duration that approximately equals 88 earth days.", "Year(mercury, 88 * EarthDay)", "Year(mercury) = About(88, Day(earth))"]}
{"id": "entailmentbank_validation_54", "nl": "a complete orbit of mercury around the sun takes around 88 earth days.", "fol": "", "prediction": ["Exists x, y. (Mercury(x) & Sun(y) & OrbitsAround(x, y) & TakesTime(x, 88, EarthDays))", "Exists x. Exists y. (Mercury(x) & Sun(y) & OrbitsAround(x, y) & TakesTime(x, 88, EarthDay))", "Exists x. (Orbit(x, mercury, sun) & TakesTime(x, 88, earth_days))", "Exists x. (Orbit(mercury, x) & Around(x, sun) & Takes(x, approximately_88_earth_days))"]}
{"id": "entailmentbank_validation_55", "nl": "the new moon is when the dark half of the moon faces the earth.", "fol": "", "prediction": ["NewMoonOccurs(x) <-> (DarkHalfOfMoonFaces(x, earth))", "NewMoon(moon) <-> FacesDarkHalf(moon, earth)", "NewMoon(x) <-> (DarkHalfOfMoon(y) & Faces(y, earth))", "NewMoon(phase) <-> (DarkHalfFacesEarth(moon, phase))"]}
{"id": "entailmentbank_validation_56", "nl": "the new moon is when the moon is in between the sun and the earth.", "fol": "", "prediction": ["NewMoon(x) <-> (Moon(x) & Between(x, sun, earth))", "NewMoon(moon) <-> (Position(moon) = Between(sun, earth))", "NewMoon(x) <-> (Moon(x) & PositionBetween(x, sun, earth))", "NewMoon(moon) <-> (Between(moon, sun, earth))"]}
{"id": "entailmentbank_validation_57", "nl": "the new moon is when the moon could block the earth from the sun.", "fol": "", "prediction": ["NewMoon(when(x, Block(moon, earth, sun)))", "NewMoon(moon) <-> (CanBlockFrom(moon, earth, sun))", "NewMoon(moon) <-> exists x. (Earth(x) & Sun(y) & Blocks(moon, x, y))", "NewMoon(x) <-> (Moon(x) & CanBlockFrom(x, earth, sun))"]}
{"id": "entailmentbank_validation_58", "nl": "a solar eclipse is when the moon blocks the earth from the sun.", "fol": "", "prediction": ["exists x. (SolarEclipse(x) <-> (Moon(m) & Sun(s) & Earth(e) & Blocks(m, e, s)))", "SolarEclipse(x) <-> (Moon(m) & Earth(e) & Sun(s) & Blocks(m, e, s))", "exists e. (SolarEclipse(e) <-> exists m, o, s. (Moon(m) & Earth(o) & Sun(s) & Blocks(m, o, s)))", "exists t. (SolarEclipse(t) <-> (exists m, e, s. (Moon(m) & Earth(e) & Sun(s) & Blocks(m, e, s))))"]}
{"id": "entailmentbank_validation_59", "nl": "a solar eclipse could only happen during the new moon.", "fol": "", "prediction": ["all x. (SolarEclipse(x) -> DuringNewMoon(x))", "all x. (SolarEclipse(x) -> HappensDuringNewMoon(x))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all x. (SolarEclipse(x) -> NewMoonPeriod())"]}
{"id": "entailmentbank_validation_60", "nl": "objects generally are made of ice in the kuiper belt.", "fol": "", "prediction": ["all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "FOL Translation:\nall x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))", "all x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))"]}
{"id": "entailmentbank_validation_61", "nl": "icy can be used to describe objects that are made of ice.", "fol": "", "prediction": ["all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))"]}
{"id": "entailmentbank_validation_62", "nl": "objects in kuiper belt are icy.", "fol": "", "prediction": ["all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))"]}
{"id": "entailmentbank_validation_63", "nl": "a comet orbit occurs usually once per 1000 years.", "fol": "", "prediction": ["exists x. (CometOrbit(x) & OccursOncePer(x, 1000))", "all x. (CometOrbit(x) -> HappensOncePerYears(x, 1000))", "all x. (CometOrbit(x) -> OccursEvery1000Years(x))", "all x. (CometOrbit(x) -> OccursUsuallyOncePerThousandYears(x))"]}
{"id": "entailmentbank_validation_64", "nl": "a comet is a kind of celestial object.", "fol": "", "prediction": ["CelestialObject(comet)", "exists x. (Comet(x) -> CelestialObject(x))", "CelestialObject(comet)", "Comet(x) -> CelestialObject(x)"]}
{"id": "entailmentbank_validation_65", "nl": "comet orbits are elliptical.", "fol": "", "prediction": ["all x. (Comet(x) -> OrbitsElliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))"]}
{"id": "entailmentbank_validation_66", "nl": "comets are the kind of celestial object that has a highly elliptical orbit and has a period of over 1000 years.", "fol": "", "prediction": ["all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))"]}
{"id": "entailmentbank_validation_67", "nl": "the milky way galaxy appears as a glowing band across the night sky.", "fol": "", "prediction": ["AppearsAs(milky_way, glowing_band) & Across(milky_way, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band, night_sky)", "AppearsAs(milky_way, glowing_band) & Across(milky_way, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band) & Across(glowing_band, night_sky)"]}
{"id": "entailmentbank_validation_68", "nl": "a student observes a glowing band across the night sky.", "fol": "", "prediction": ["exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, night_sky)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, nightSky)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & NightSky(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, NightSky)))"]}
{"id": "entailmentbank_validation_69", "nl": "the student observes the milky way galaxy at night.", "fol": "", "prediction": ["Exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "exists s, g, t. (Student(s) & MilkyWayGalaxy(g) & Night(t) & Observes(s, g, t))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "Observes(student, milky_way_galaxy) & AtNight(student)"]}
{"id": "entailmentbank_validation_70", "nl": "looking at bright objects has a negative impact on the eyes.", "fol": "", "prediction": ["all x. (BrightObject(x) -> hasNegativeImpactOnEyes(LookingAt(x)))", "all x. (BrightObject(x) -> NegativeImpact(LookingAt(x), Eyes))", "all x. (BrightObject(x) -> all y. (Eye(y) -> HasNegativeImpactOnLooking(x, y)))", "all x. (BrightObject(x) -> all y. (Eyes(y) -> HasNegativeImpactOn(x, y)))"]}
{"id": "entailmentbank_validation_71", "nl": "the moon is less bright than the sun.", "fol": "", "prediction": ["Bright(moon, sun) & -Bright(sun, moon)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)"]}
{"id": "entailmentbank_validation_72", "nl": "looking at the moon has less of a negative impact on the eyes.", "fol": "", "prediction": ["FOL Translation:\nall x. (LookingAt(x, moon) -> LessNegativeImpactOnEyes(x))", "exists x. (Moon(x) & all y. (Eye(y) & LookingAt(x, y) -> LessNegativeImpact(LookingAt(x, y))))", "all x. (LookingAt(x, moon) -> HasLessNegativeImpactOnEyes(x))", "exists x. (Moon(x) & all y. (Eyes(y) -> LessNegativeImpact(LookingAt(x), y)))"]}
{"id": "entailmentbank_validation_73", "nl": "the surface of the earth contains mountains.", "fol": "", "prediction": ["exists y. (Surface(y) & Earth(y) & Contains(y, mountains))", "exists x. (SurfaceOf(earth, x) & ContainsMountains(x))", "exists x. (Earth(x) & contains(x, mountains))", "FOL Translation:\nexists x. (SurfaceOf(earth, x) & Contains(x, mountains))"]}
{"id": "entailmentbank_validation_74", "nl": "the surface of the moon contains mountains.", "fol": "", "prediction": ["exists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "exists x. (SurfaceOf(moon, x) & Contains(x, mountains))", "exists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "exists x. (SurfaceOf(moon, x) & Contains(x, mountains))"]}
{"id": "entailmentbank_validation_75", "nl": "both the surface of the moon and the surface of the earth contain mountains.", "fol": "", "prediction": ["Surface(moon, m-moon) & Surface(earth, m-earth) & ContainsMountains(m-moon) & ContainsMountains(m-moon)", "`Surface(moon, s1) & Surface(earth, s2) & ContainsMountains(s1) & ContainsMountains(s2)`", "`ContainsSurface(moon, mountains) & ContainsSurface(earth, mountains)`", "Surface(moon, earth) & all x. ((PartOf(x, Surface(moon)) | PartOf(x, Surface(earth))) -> ContainsMountains(x))"]}
{"id": "entailmentbank_validation_76", "nl": "the asteroid belt is located between mars and jupiter.", "fol": "", "prediction": ["LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)"]}
{"id": "entailmentbank_validation_77", "nl": "the asteroid belt contains the largest concentration of asteroids in the solar system.", "fol": "", "prediction": ["Exists x. (AsteroidBelt(x) & ContainsLargestConcentrationOfAsteroidsInSolarSystem(x))", "Contains(asteroid_belt, largest_concentration_of_asteroids_in_solar_system)", "Contains(asteroid_belt, largest_concentration_of_asteroids_in_solar_system)", "Contains(asteroid_belt, largest_concentration_of_asteroids_in_solar_system)"]}
{"id": "entailmentbank_validation_78", "nl": "the asteroid belt that contains the most asteroids is located between mars and jupiter.", "fol": "", "prediction": ["`exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))`", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))"]}
{"id": "entailmentbank_validation_79", "nl": "the sun is average in temperature for a star in our galaxy.", "fol": "", "prediction": ["AverageTemperatureStar(sun) & Star(sun) & InGalaxy(sun, ourgalaxy)", "AverageTemperature(sun, star, our_galaxy)", "AverageTemperature(sun) & Star(sun) & InGalaxy(sun)", "AverageTemperature(sun) & Star(sun) & LocatedIn(sun, our_galaxy)"]}
{"id": "entailmentbank_validation_80", "nl": "the sun is average in size for a star in our galaxy.", "fol": "", "prediction": ["AverageSize(sun)\n\n(Note: This translation assumes that \"average in size for a star in our galaxy\" is a property of the sun, represented by the predicate `AverageSize(sun)`. To add more specifics or context about the size average specifically related to the stars in the galaxy, you could introduce additional predicates and structure, but given the style of your examples, the focus seems to be on stating a property directly.)", "AverageSize(sun) & Star(sun) & InGalaxy(sun)", "Star(sun) & AverageInSizeForStarInGalaxy(sun)", "Star(sun) & AverageSizeForStarInGalaxy(sun, our_galaxy)"]}
{"id": "entailmentbank_validation_81", "nl": "the sun is average in siza and average in temperature in our galaxy.", "fol": "", "prediction": ["AverageInSize(sun) & AverageInTemperature(sun) & InGalaxy(sun, our_galaxy)", "AverageSize(sun) & AverageTemperature(sun) & In(galaxy, sun)", "AverageInSize(sun) & AverageInTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun) & InGalaxy(sun, our_galaxy)"]}
{"id": "entailmentbank_validation_82", "nl": "as the mass of a celestial object decreases, the surface gravity of that celestial object weakens.", "fol": "", "prediction": ["all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Decreases(SurfaceGravity(x))))", "all x. ((CelestialObject(x) & Decreases(Mass(x))) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) & Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))"]}
{"id": "entailmentbank_validation_83", "nl": "as the force of gravity decreases, the weight of the object will decrease.", "fol": "", "prediction": ["all x y. ((ForceOfGravityDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x y. ((ForceOfGravityDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x. all y. ((ForceOfGravity(x) < Decreases(y)) -> (Weight(y) < Decreases(y)))", "all x y. ((Object(x) & ForceOfGravity(y) & Decreases(y)) -> Decreases(Weight(x)))"]}
{"id": "entailmentbank_validation_84", "nl": "as the mass of a celestial object decreases, the weight of an object on that celestial object will decrease.", "fol": "", "prediction": ["all x. all y. (CelestialObject(x) & Object(y) -> (MassDecrease(x) -> WeightDecreaseOn(y, x)))", "all c, o. (CelestialObject(c) & Object(o) -> all m1, m2. (Mass(c, m1) & Mass(c, m2) & m1 < m2 -> WeightOn(o, c, m1) < WeightOn(o, c, m2)))", "all x y. ((CelestialObject(x) & Object(y)) -> (Decreases(Mass(x)) -> Decreases(WeightOn(y, x))))", "all x all y. ((CelestialObject(x) & Object(y) & Decreases(Mass(x))) -> Decreases(WeightOn(y, x)))"]}
{"id": "entailmentbank_validation_85", "nl": "the earth has more mass than the moon.", "fol": "", "prediction": ["HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMassThan(earth, moon)", "HasMoreMass(earth, moon)"]}
{"id": "entailmentbank_validation_86", "nl": "an object weighs more on earth than on the moon because earth has more mass than the moon.", "fol": "", "prediction": ["all x. (Object(x) -> (WeighsMoreOn(x, earth, moon) <-> (Mass(earth) > Mass(moon))))", "exists x. (Object(x) -> (WeighsMoreOn(x, earth, moon) & all y z. ((Earth(y) & Moon(z) & MoreMass(y, z)) -> WeighsMoreOn(object, y, z))))", "all x. ((Object(x) & WeighsMoreOnEarthThanOnMoon(x)) <- (HasMoreMass(earth, moon)))", "exists x. (Object(x) -> exists y exists z. (Earth(y) & Moon(z) & HasMoreMassThan(y, z) & WeighsMoreOn(x, y) & WeighsLessOn(x, z)))"]}
{"id": "entailmentbank_validation_87", "nl": "less is the opposite of more.", "fol": "", "prediction": ["Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)"]}
{"id": "entailmentbank_validation_88", "nl": "an object will weigh less on the moon than on the earth because the moon has less mass than the earth.", "fol": "", "prediction": ["FOL Translation:\nall x. (Object(x) -> (Mass(moon) < Mass(earth) -> WeightOnMoon(x) < WeightOnEarth(x))) & (Mass(moon) < Mass(earth))", "exists x. (Object(x) -> (WeighsLessOn(x, moon, earth) & all y. ((Moon(y) & HasLessMassThan(y, earth)) -> WeighsLessOn(x, moon, earth))))", "exists x. (Object(x) -> (WeighsLessOn(x, moon, earth) & LessMass(moon, earth)))", "all x. (Object(x) -> (WeighsLessOn(x, moon, earth) <-> HasLessMass(moon, earth)))"]}
{"id": "entailmentbank_validation_89", "nl": "an astronaut is a kind of object.", "fol": "", "prediction": ["all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))"]}
{"id": "entailmentbank_validation_90", "nl": "an astronaut will weigh less on the moon than on earth because the moon has less mass than the earth.", "fol": "", "prediction": ["exists x. (Astronaut(x) -> (WeighsLessOnMoonThanOnEarth(x) & Mass(moon) < Mass(earth)))", "exists x. (Astronaut(x) -> (WeighLessOn(x, moon, earth) & (Mass(moon) < Mass(earth))))", "exists x. (Astronaut(x) -> (WeighLessOn(x, moon, earth) & (LessMass(moon, earth) -> WeighLessOn(x, moon, earth))))", "exists a. (Astronaut(a) & Less(Weight(a, moon), Weight(a, earth)) & Less(Mass(moon), Mass(earth)))"]}
{"id": "entailmentbank_validation_91", "nl": "using a telescope to photograph solar events requires a light filter.", "fol": "", "prediction": ["all x. (UsingTelescopeToPhotograph(x) & SolarEvent(x) -> RequiresLightFilter(x))", "all x. (UsingTelescopeToPhotographSolarEvents(x) -> Requires(x, LightFilter))", "all x. ((UsingTelescope(x) & ToPhotograph(x, SolarEvents)) -> Requires(x, LightFilter))", "all x. ((UseTelescope(x) & Photograph(x, SolarEvents)) -> Requires(x, LightFilter))"]}
{"id": "entailmentbank_validation_92", "nl": "a solar flare is a kind of solar event.", "fol": "", "prediction": ["KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "SolarFlare(flare) -> SolarEvent(flare)", "SolarFlare(x) -> SolarEvent(x)"]}
{"id": "entailmentbank_validation_93", "nl": "a solar prominence is a kind of solar event.", "fol": "", "prediction": ["Kind(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)"]}
{"id": "entailmentbank_validation_94", "nl": "using a telescope to photograph a solar prominence and a solar flare requires a light filter.", "fol": "", "prediction": ["all x. ((Use(x, telescope) & Photograph(x, solar_prominence) & Photograph(x, solar_flare)) -> Requires(x, light_filter))", "all x y z. ((Telescope(x) & Photographs(x, y) & Photographs(x, z) & SolarProminence(y) & SolarFlare(z)) -> RequiresLightFilter(x))", "all x. ((Telescope(x) & UsedToPhotograph(x, SolarProminence) & UsedToPhotograph(x, SolarFlare)) -> Requires(x, LightFilter))", "exists t. exists p. exists f. (Telescope(t) & Photograph(p) & SolarProminence(p) & SolarFlare(f) -> RequiresLightFilter(t))"]}
{"id": "entailmentbank_validation_95", "nl": "if something is required for something else then that something allows that something else.", "fol": "", "prediction": ["all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x all y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))"]}
{"id": "entailmentbank_validation_96", "nl": "detailed observation of celestial objects requires a telescope.", "fol": "", "prediction": ["all x. (CelestialObject(x) -> exists y. (DetailedObservation(x, y) & Telescope(y) & Requires(y, Telescope)))", "all x. (CelestialObject(x) -> (DetailedObservation(x) -> exists y. (Telescope(y) & Requires(x, y))))", "all x. (CelestialObject(x) -> DetailedObservation(x) -> Requires(DetailedObservation(x), Telescope))", "FOL Translation:\nall x. (CelestialObject(x) -> (DetailedObservation(x) -> exists y. (Telescope(y) & Requires(DetailedObservation(x), y))))"]}
{"id": "entailmentbank_validation_97", "nl": "telescopes allow the detailed observation of celestial objects.", "fol": "", "prediction": ["exists x. (Telescope(x) -> AllowsDetailedObservationOfCelestialObjects(x))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> all y. (CelestialObject(y) -> AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> all y. (CelestialObject(y) -> AllowsDetailedObservation(x, y)))"]}
{"id": "entailmentbank_validation_98", "nl": "a planet is a kind of celestial object / celestial body.", "fol": "", "prediction": ["all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))"]}
{"id": "entailmentbank_validation_99", "nl": "telescopes allow the detailed observation of planets.", "fol": "", "prediction": ["exists x. (Telescope(x) & all y. (Planet(y) -> AllowDetailedObservation(x, y)))", "all x. (Telescope(x) -> allowsDetailedObservationOf(x, planet))", "all x. (Telescopes(x) -> exists y. (Planet(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> exists y. (Planet(y) & AllowsDetailedObservation(x, y)))"]}
{"id": "entailmentbank_validation_100", "nl": "gravity causes orbits.", "fol": "", "prediction": ["FOL Translation:\nall x all y. (Orbits(x, y) -> GravityCausesOrbit(x, y))", "all x y. (Orbits(x, y) -> CausedBy(Orbits(x, y), Gravity))", "exists x exists y. (GravityCausesOrbits(x, y))", "all x. all y. (Orbits(x, y) -> GravityCauses(x, y))"]}
{"id": "entailmentbank_validation_101", "nl": "gravity causes the earth to revolve around the sun.", "fol": "", "prediction": ["Exists x, y, z. (Gravity(x) & Earth(y) & Sun(z) & Causes(x, RevolvesAround(y, z)))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolvesAround(earth, sun))", "Causes(gravity, RevolvesAround(earth, sun))"]}
{"id": "entailmentbank_validation_102", "nl": "the moon orbits the earth.", "fol": "", "prediction": ["Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)"]}
{"id": "entailmentbank_validation_103", "nl": "gravity causes the moon to orbit the earth.", "fol": "", "prediction": ["Exists y. (Gravity(y) & Causes(y, Orbits(moon, earth)))", "Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "GravityCausesToOrbit(moon, earth)"]}
{"id": "entailmentbank_validation_104", "nl": "gravity causes both the orbit of the earth around the sun and the orbit of the moon around the earth.", "fol": "", "prediction": ["Causes(gravity, Orbit(earth, sun)) & Causes(gravity, Orbit(moon, earth))", "exists g. (Gravity(g) & Causes(g, Orbit(earth, sun)) & Causes(g, Orbit(moon, earth)))", "Causes(gravity, Orbits(earth, sun)) & Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))"]}
{"id": "entailmentbank_validation_105", "nl": "spring tide is when the distance between high tide and low tide is the greatest.", "fol": "", "prediction": ["SpringTide(x) <-> GreatestDistanceBetweenHighAndLowTide(x)", "SpringTide(when(Distance(HighTide, LowTide), Greatest))", "SpringTide(x) <-> (Tide(x) & exists y. exists z. (HighTide(y) & LowTide(z) & DistanceBetween(y, z) = Greatest))", "SpringTide(s) <-> GreatestDistanceBetweenHighLowTide(s)"]}
{"id": "entailmentbank_validation_106", "nl": "spring tides occur during a full moon.", "fol": "", "prediction": ["all x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "FOL Translation:\nall x. (FullMoon(x) -> Occurs(SpringTide, x))", "all x. (FullMoon(x) -> SpringTideOccurs(x))", "all x. (SpringTide(x) -> OccursDuring(x, full_moon))"]}
{"id": "entailmentbank_validation_107", "nl": "the highest tides occur during a full moon.", "fol": "", "prediction": ["all x. (HighestTides(x) -> OccurDuringFullMoon(x))", "all x. (HighestTide(x) -> OccursDuring(x, FullMoon))", "All x. (HighestTide(x) -> OccursDuring(x, full_moon))", "all t. (HighestTide(t) <-> exists m. (FullMoon(m) & OccursDuring(t, m)))"]}
{"id": "entailmentbank_validation_108", "nl": "marine fossils means fossils of marine animals.", "fol": "", "prediction": ["all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(y, x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimalFossil(x))", "all x. (MarineFossil(x) <-> FossilOfMarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(x, y))"]}
{"id": "entailmentbank_validation_109", "nl": "marine animals are water animals.", "fol": "", "prediction": ["all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))"]}
{"id": "entailmentbank_validation_110", "nl": "marine fossils are fossils of water animals.", "fol": "", "prediction": ["all x. (MarineFossil(x) -> exists y. (Fossil(x) & WaterAnimal(y) & FossilOf(x, y)))", "all x. (MarineFossil(x) -> Fossil(x) & exists y. (WaterAnimal(y) & Of(x, y)))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))"]}
{"id": "entailmentbank_validation_111", "nl": "marine fossils are found in mountains.", "fol": "", "prediction": ["all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))"]}
{"id": "entailmentbank_validation_112", "nl": "fossils of water animals are found in mountains.", "fol": "", "prediction": ["exists x. (Fossil(x) & WaterAnimal(y) & FoundIn(x, mountains) & PartOf(x, y))", "exists x. (Fossil(x) & WaterAnimalFossil(x) & FoundInMountains(x))", "exists x exists y. (Fossil(x) & WaterAnimal(y) & FoundInMountains(x) & Of(x, y))", "exists x. (Fossil(x) & OfWaterAnimal(x) & FoundInMountains(x))"]}
{"id": "entailmentbank_validation_113", "nl": "if fossils of a water animal or plant are found in a place then that place used to be covered by water in the past.", "fol": "", "prediction": ["all x. all y. ((FossilOfWaterAnimalOrPlant(y) & FoundIn(y, x)) -> UsedToBeCoveredByWaterInThePast(x))", "all x. all p. ((Fossil(x) & (WaterAnimal(x) | Plant(x)) & FoundIn(x, p)) -> WaterCoveredInPast(p))", "all z. ((exists x. (Fossil(x) & (WaterAnimal(x) | Plant(x)) & FoundIn(x, z))) -> CoveredByWaterInPast(z))", "all x. ((exists y. ((WaterAnimal(y) | Plant(y)) & FossilOf(y, x))) -> CoveredByWaterInPast(x))"]}
{"id": "entailmentbank_validation_114", "nl": "the mountains used to be covered by water in the past.", "fol": "", "prediction": ["exists x. (Mountain(x) & CoveredByWaterInPast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))"]}
{"id": "entailmentbank_validation_115", "nl": "a mountain is a kind of environment.", "fol": "", "prediction": ["all x. (Mountain(x) -> Environment(x))", "Mountain(m) -> Environment(m)", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))"]}
{"id": "entailmentbank_validation_116", "nl": "if something used to be in the past then that something has changed.", "fol": "", "prediction": ["all x. (UsedToBeInThePast(x) -> HasChanged(x))", "FOL Translation:\nall x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))"]}
{"id": "entailmentbank_validation_117", "nl": "a body of water is a kind of environment.", "fol": "", "prediction": ["all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))"]}
{"id": "entailmentbank_validation_118", "nl": "the environment has changed from a body of water to mountains.", "fol": "", "prediction": ["Change(environment, body_of_water, mountains)", "Exists e. (Environment(e) & ChangedFromTo(e, BodyOfWater, Mountains))", "Changed(environment, WaterBody, Mountains)", "Change(environment, water, mountains)"]}
{"id": "entailmentbank_validation_119", "nl": "environments are found on the crustal surface of earth.", "fol": "", "prediction": ["all x. (Environment(x) -> FoundOn(x, crustal_surface_of_earth))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all e. (Environment(e) -> FoundOnCrustalSurfaceOfEarth(e))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))"]}
{"id": "entailmentbank_validation_120", "nl": "the environments on the crustal surface of earth have changed from a body of water to mountains.", "fol": "", "prediction": ["exists e. (Environment(e) & OnCrustalSurfaceOf(earth, e) & Changed(e, body_of_water, mountains))", "Exists phrases: \\text{Shallow water, Mountains} \n\nFOL Translation:\nChange(Typeof_Crustal_Surface(the crustal surface of earth), Shallow water, Mountains)", "exists e. (Environment(e) & OnCrustalSurface(e, earth) & ChangedFrom(e, body_of_water, mountains))", "exists e1, e2. (Environment(e1) & Environment(e2) & OnCrustalSurfaceOfEarth(e1) & OnCrustalSurfaceOfEarth(e2) & ChangedFrom(e1, body_of_water) & ChangedTo(e2, mountains))"]}
{"id": "entailmentbank_validation_121", "nl": "organisms remains can be preserved in sedimentary rock.", "fol": "", "prediction": ["all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & PreservedIn(x, y)))", "exists x, y. (OrganismRemains(x) & SedimentaryRock(y) & CanBePreservedIn(x, y))", "all x. (RemainsOfOrganism(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "exists x. (OrganismRemains(x) & exists y. (SedimentaryRock(y) & PreservedIn(x, y)))"]}
{"id": "entailmentbank_validation_122", "nl": "fossils are the remains of organisms or part of organisms.", "fol": "", "prediction": ["all x. (Fossil(x) -> exists y. (RemainsOf(x, y) & (Organism(y) | PartOfOrganism(y))))", "all x. (Fossil(x) -> exists y. (Organism(y) & (RemainsOf(x, y) | PartOf(y))))", "all x. (Fossil(x) -> (exists y. (RemainsOf(x, y) & Organism(y)) | PartOfOrganism(x)))", "all x. (Fossil(x) -> exists y. (RemainsOf(x, y) & (Organism(y) | PartOf(y, organism))))"]}
{"id": "entailmentbank_validation_123", "nl": "fossils are mostly found in sedimentary rock.", "fol": "", "prediction": ["all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> MostlyFoundIn(x, sedimentary_rock))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> MostlyFoundIn(x, sedimentary_rock))"]}
{"id": "entailmentbank_validation_124", "nl": "a mineral usually has a crystal structure.", "fol": "", "prediction": ["all x. (Mineral(x) -> exists y. (CrystalStructure(y) & HasStructure(x, y)))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "exists x. (Mineral(x) & UsuallyHasCrystalStructure(x))"]}
{"id": "entailmentbank_validation_125", "nl": "a quartz is made of six-sided transparent crystals.", "fol": "", "prediction": ["all x. (Quartz(x) -> exists y. (SixSided(y) & Transparent(y) & Crystal(y) & MadeOf(x, y)))", "all x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y)))", "all x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y)))", "all x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & Shape(y, six_sided) & Transparent(y)))"]}
{"id": "entailmentbank_validation_126", "nl": "quartz is a kind of mineral.", "fol": "", "prediction": ["Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)"]}
{"id": "entailmentbank_validation_127", "nl": "different classes of rocks are formed by different methods.", "fol": "", "prediction": ["all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (ClassOfRocks(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))"]}
{"id": "entailmentbank_validation_128", "nl": "class is a measure of how a rock is formed.", "fol": "", "prediction": ["Measure(class, HowFormed(rock))", "Measure(class, HowRockIsFormed)", "MeasureOfFormation(class, rock)", "Measure(class, How(RockFormation))"]}
{"id": "entailmentbank_validation_129", "nl": "the method by which a rock is formed can be used to classify rocks.", "fol": "", "prediction": ["all x. (Rock(x) -> exists y. (MethodOfFormation(y, x) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & MethodOfFormation(x, m) -> CanBeUsedToClassify(x, m))", "all x y. (Rock(x) & MethodUsedToForm(y, x) -> CanClassifyRocks(y))", "all x. (Rock(x) & MethodOfFormation(x, y) -> CanBeUsedToClassify(x, y))"]}
{"id": "entailmentbank_validation_130", "nl": "the origin of a rock means the method by which a rock is formed.", "fol": "", "prediction": ["all x. (Rock(x) -> exists y. (Origin(x, y) & Method(y) & FormedBy(y, x)))", "all x. (Rock(x) -> (Origin(x) <-> MethodOfFormation(x)))", "all x. (Rock(x) -> (exists y. (OriginOf(x, y) <-> MethodOfFormation(x, y))))", "all x. (Rock(x) -> (Origin(x) <-> MethodOfFormation(x)))"]}
{"id": "entailmentbank_validation_131", "nl": "the origin of rocks can be used to classify rocks.", "fol": "", "prediction": ["all x. (Rock(x) -> exists y. (OriginOf(y, x) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) -> exists y. (Origin(y) & CanClassifyBy(x, y)))", "all x. (Rock(x) & OriginOf(x, y) -> CanBeUsedToClassify(x))", "all x. (Rock(x) & OriginCanBeUsedToClassify(x))"]}
{"id": "entailmentbank_validation_132", "nl": "rock formation can be used to study the history of rocks on earth.", "fol": "", "prediction": ["all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistory(x, earth))", "all x. (RockFormation(x) -> CanBeUsedToStudy(x, HistoryOfRocksOnEarth))"]}
{"id": "entailmentbank_validation_133", "nl": "the formation of something is a kind of process.", "fol": "", "prediction": ["all x. (Formation(x) -> Process(x))", "all x. (FormationOf(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))"]}
{"id": "entailmentbank_validation_134", "nl": "studying rock formations can mean studying the history and processes of earth.", "fol": "", "prediction": ["all x. (Studying(x) & RockFormations(x) -> (Means(Studying(x), Studying(HistoryOf(earth))) & Means(Studying(x), Studying(ProcessesOf(earth)))))", "exists x. (StudyingRockFormations(x) -> (StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x)))", "all x. (StudyingRockFormations(x) -> (StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x)))", "all x. (StudyingRockFormations(x) -> StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x))"]}
{"id": "entailmentbank_validation_135", "nl": "structural geologists study rock formations.", "fol": "", "prediction": ["all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> studies(x, RockFormations))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))"]}
{"id": "entailmentbank_validation_136", "nl": "structural geologists study the history and processes of earth.", "fol": "", "prediction": ["all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))"]}
{"id": "entailmentbank_validation_137", "nl": "how earth's environment changed is a part of the history of earth's environment.", "fol": "", "prediction": ["PartOf(HistoryOf(EarthEnvironmentChange), EarthEnvironmentChange)", "PartOf(HowChanged(environment_of_earth), History(environment_of_earth))", "PartOf(HowChanged(earthEnvironment), History(earthEnvironment))", "PartOf(HowEnvironmentChanged(earth), HistoryOf(Environment(earth)))"]}
{"id": "entailmentbank_validation_138", "nl": "fossils can be used to study the history of organisms and environments on earth.", "fol": "", "prediction": ["exists x. (Fossil(x) -> CanBeUsedToStudyHistoryOfOrganismsAndEnvironmentsOnEarth(x))", "all x. (Fossil(x) -> CanBeUsedToStudy(x, HistoryOfOrganisms) & CanBeUsedToStudy(x, EnvironmentsOnEarth))", "FOL Translation:\nall x. (Fossil(x) -> (CanBeUsedToStudy(x, HistoryOfOrganisms) & CanBeUsedToStudy(x, HistoryOfEnvironments) & OnEarth(x)))", "FOL Translation:\nall f. (Fossil(f) -> CanBeUsedToStudyHistoryOfOrganismsAndEnvironmentsOnEarth(f))"]}
{"id": "entailmentbank_validation_139", "nl": "studying fossils in rock formations can mean studying the history and processes of earth.", "fol": "", "prediction": ["exists x. (Fossil(x) & InRockFormation(x) -> CanMean(Studying(x), Studying(HistoryAndProcessesOf(earth))))", "exists x. (Fossils(x) & RockFormations(y) & Studying(x, y) -> StudyingHistoryAndProcessesOfEarth(x, y))", "all x. ((StudyingFossilsInRockFormations(x)) -> (StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x)))", "exists x, y, z. (Fossil(x) & RockFormation(y) & Studying(x, y) -> Studying(x, z) & History(z) & ProcessesOf(earth, z))"]}
{"id": "entailmentbank_validation_140", "nl": "paleontologists study fossils in rock formations.", "fol": "", "prediction": ["all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudyIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & InRockFormation(y) & Studies(x, y)))", "all x. (Paleontologist(x) -> exists y. (RockFormation(y) & exists z. (Fossil(z) & In(y, z) & Studies(x, z))))"]}
{"id": "entailmentbank_validation_141", "nl": "paleontologists study the history and processes of earth.", "fol": "", "prediction": ["all x. (Paleontologist(x) -> Studies(x, history) & Studies(x, processes) & RelatedTo(history, earth) & RelatedTo(processes, earth))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))"]}
{"id": "entailmentbank_validation_142", "nl": "structural geologists and paleontologists both study the history and processes of earth.", "fol": "", "prediction": ["all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) -> StudiesHistoryAndProcessesOfEarth(x)) & (Paleontologist(x) -> StudiesHistoryAndProcessesOfEarth(x)))", "all x. ((StructuralGeologist(x) -> StudiesHistoryAndProcessesOfEarth(x)) & (Paleontologist(x) -> StudiesHistoryAndProcessesOfEarth(x)))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))"]}
{"id": "entailmentbank_validation_143", "nl": "metamorphic rocks do not contain fossils.", "fol": "", "prediction": ["all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))"]}
{"id": "entailmentbank_validation_144", "nl": "nearly all fossils are found in sedimentary rock.", "fol": "", "prediction": ["all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "To express \"nearly all\" in first-order logic, we can translate it as a concept where there exists only a small set of exceptions to the rule. However, standard first-order logic does not handle quantitative concepts like \"nearly all\" directly. In practical terms, one might simplify \"nearly all\" to \"most,\" but even \"most\" is not directly translatable to first-order logic. So typically, the translation in logic is approximate.\n\nFor the purpose of translating the given instruction into a logical form, one simple approach is to use an implication and an existential statement for exceptions which approximates the meaning:\n\nFOL Translation:\n`all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))`\n\nThis means, for all entities `x` that are fossils, there exists a sedimentary rock `y` that the fossil is found in, implying that the typical case for fossils is to be found in sedimentary rock. This doesn't capture \"nearly all,\" but represents the usual interpretation pragmatically as \"typical.\"", "To capture \"nearly all fossils,\" we'll translate it as \"for almost all fossils,\" which closely parallels \"all\" but acknowledges a minor exception. In FOL logic, we will represent it by saying that for a fossil not found in sedimentary rock, it is an uncommon or rare scenario.\n\nFOL Translation:\nall x. (Fossil(x) -> (FoundInSedimentaryRock(x) | Uncommon(x)))"]}
{"id": "entailmentbank_validation_145", "nl": "fossils are lost / destroyed when sedimentary rock changes to metamorphic rock.", "fol": "", "prediction": ["all x. (Fossil(x) & SedimentaryRockChangesToMetamorphic(x) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & ChangesTo(SedimentaryRock(x), MetamorphicRock(x)) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & SedimentaryRock(x) & ChangesTo(x, MetamorphicRock) -> LostOrDestroyed(x))", "all z. (Fossil(z) & ChangesToMetamorphic(s, m) & SedimentaryRock(s) & MetamorphicRock(m) -> (Lost(z) | Destroyed(z)))"]}
{"id": "entailmentbank_validation_146", "nl": "if fossils are destroyed in rock transition, then there will be gaps in the fossil record.", "fol": "", "prediction": ["all x. (DestroyedInTransition(x) -> Fossil(x) -> GapsInFossilRecord)", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapsInFossilRecord(y))", "all x. (DestroyedInRockTransition(x) & Fossil(x) -> ExistsGapInFossilRecord)", "all x. (Fossil(x) & DestroyedInRockTransition(x) -> GapsInFossilRecord())"]}
{"id": "entailmentbank_validation_147", "nl": "sedimentary rock changing to metamorphic rock causes gaps in the fossil record.", "fol": "", "prediction": ["all x. (SedimentaryRock(x) & ChangesToMetamorphic(x) -> CausesGapsInFossilRecord(x))", "exists x exists y. (SedimentaryRock(x) & MetamorphicRock(y) & ChangesTo(x, y) -> CausesGapsInFossilRecord(y))", "all x. ((SedimentaryRock(x) & ChangesToMetamorphicRock(x)) -> CausesGapsInFossilRecord(x))", "exists x. exists y. (SedimentaryRock(x) & ChangesToMetamorphic(x, y) -> CausesGapsInFossilRecord(y))"]}
{"id": "entailmentbank_validation_148", "nl": "heat is a kind of energy.", "fol": "", "prediction": ["KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)"]}
{"id": "entailmentbank_validation_149", "nl": "metamorphic rocks are formed by rocks being exposed to extreme heat and pressure.", "fol": "", "prediction": ["all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormsFrom(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeatAndPressure(y) & Forms(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedBy(x, y)))"]}
{"id": "entailmentbank_validation_150", "nl": "heat energy can change igneous rock into metamorphic rock.", "fol": "", "prediction": ["all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeToMetamorphicRock(x, y))", "all x. ((IgneousRock(x) & HeatEnergy(e)) -> CanChangeTo(x, MetamorphicRock(x)))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeInto(x, MetamorphicRock))", "all x. ((IgneousRock(x) & HeatEnergy(y)) -> CanChangeInto(x, MetamorphicRock(x)))"]}
{"id": "entailmentbank_validation_151", "nl": "a tree is a kind of habitat.", "fol": "", "prediction": ["Habitat(tree)", "all x. (Tree(x) -> Habitat(x))", "Tree(t) -> Habitat(t)", "Tree(x) -> Habitat(x)"]}
{"id": "entailmentbank_validation_152", "nl": "cutting down trees in a forest causes the number of trees to decrease in that forest.", "fol": "", "prediction": ["all f. all t1. all t2. ((Forest(f) & Tree(t1) & Tree(t2) & In(f, t1) & In(f, t2) & CuttingDown(t1)) -> Decreases(NumberOfTrees(f)))", "FOL Translation:\nall x. all y. ((Forest(x) & CuttingDownTreesIn(y, x)) -> Causes(DecreaseNumberOfTreesIn(x)))", "all f. all x. ((Forest(f) & Tree(x) & InForest(x, f) & CuttingDown(x)) -> Decreases(NumberOfTrees(f)))", "all f. all t. (CutDownTree(f, t) -> DecreasesNumberOfTrees(f))"]}
{"id": "entailmentbank_validation_153", "nl": "cutting down trees in a forest causes the number of habitat to decrease.", "fol": "", "prediction": ["all x. (Tree(x) & InForest(x) & CutDown(x) -> Decreases(NumberOfHabitats))", "all x. (Forest(x) & CuttingDownTrees(x) -> CausesDecreaseInHabitat(x))", "all x. all y. ((CuttingDown(x) & Tree(x) & InForest(x, y)) -> Causes(Decrease(NumberOf(y, Habitat))))", "all x. ((CuttingDownTrees(x) & Forest(x)) -> Causes(NumberOfHabitatsDecreasing(x)))"]}
{"id": "entailmentbank_validation_154", "nl": "an animal requires a habitat for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))"]}
{"id": "entailmentbank_validation_155", "nl": "cutting down trees in a forest causes the number of habitat required by animals for survival to decrease.", "fol": "", "prediction": ["all x. (Tree(x) & InForest(x) & CuttingDown(x) -> exists y. (Habitat(y) & RequiredByAnimalsForSurvival(y) & Decreases(y)))", "all x. (Tree(x) & InForest(x) & CuttingDown(x) -> exists y. (Habitat(y) & RequiredByAnimalsForSurvival(y) & Decreases(y)))", "all x. (Tree(x) & InForest(x) & CuttingDown(x) -> causes(Decrease(HabitatRequiredForSurvival(y)), Animal(y)))", "all x. all y. (Tree(x) & Forest(y) & LocatedIn(x, y) -> Causes(CuttingDown(x), Decrease(NumberOf(HabitatRequiredForSurvival(z)), Animals(z))))"]}
{"id": "entailmentbank_validation_156", "nl": "humans changing ecosystems usually has a negative impact on an ecosystem / organisms living in an ecosystem.", "fol": "", "prediction": ["all x. ((Human(x) & ChangesEcosystem(x)) -> NegativeImpactOn(Ecosystem(y)) | NegativeImpactOn(organism(z)) & LivesIn(z, y))", "FOL Translation:\nall x. (HumanChangingEcosystem(x) -> UsuallyHasNegativeImpact(x, Ecosystem(y)) | UsuallyHasNegativeImpact(x, OrganismLivingInEcosystem(y)))", "all x. (HumanChangingEcosystem(x) -> (usually, exists y. (Ecosystem(y) & OrganismsLivingIn(y) & HasNegativeImpact(x, y))))", "all x, y, z. (HumanChangingEcosystem(x, y) & Ecosystem(y) & Organism(z) & LivesIn(z, y) -> UsuallyHasNegativeImpact(x, y, z))"]}
{"id": "entailmentbank_validation_157", "nl": "humans building homes in an ecosystem causes that ecosystem to change.", "fol": "", "prediction": ["exists e. (Ecosystem(e) & all x. (Human(x) & BuildsHome(x, e) -> Causes(Change(e))))", "exists x. (Ecosystem(x) & exists y. (Human(y) & Builds(y, Home) & In(x, Home) -> Causes(Change(x))))", "all x. ((Ecosystem(x) & exists y. (Human(y) & BuildsHomeIn(y, x))) -> Changes(x))", "exists x. exists y. ((Human(x) & BuildHomeIn(x, y) & Ecosystem(y)) -> CausesChange(y))"]}
{"id": "entailmentbank_validation_158", "nl": "humans building homes in an ecosystem has a negative impact on an ecosystem and organisms living in the ecosystem.", "fol": "", "prediction": ["exists e. (Ecosystem(e) & exists x. (Human(x) & BuildsHomeIn(x, e)) -> all y. (Organism(y) & LivesIn(y, e) -> NegativeImpact(x, e, y)))", "exists e. exists h. exists o. (Ecosystem(e) & Human(h) & Organism(o) & BuildsHomeIn(h, e) & NegativeImpact(BuildsHomeIn(h, e), e) & NegativeImpact(BuildsHomeIn(h, e), o) & LivesIn(o, e))", "all e. (Ecosystem(e) & exists h. (Human(h) & Builds(h, Home, e)) -> all o. ((Organism(o) & LivesIn(o, e)) -> NegativeImpact(Builds(h, Home, e), o)))", "all e. (Ecosystem(e) -> (exists h. (Human(h) & BuildsHomeIn(h, e)) -> (NegativeImpactOn(h, e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(h, o)))))"]}
{"id": "entailmentbank_validation_159", "nl": "a wetland is a kind of ecosystem.", "fol": "", "prediction": ["FOL Translation:\nall x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))"]}
{"id": "entailmentbank_validation_160", "nl": "humans building homes in a wetland has a negative impact on a wetland and organisms living in the wetland.", "fol": "", "prediction": ["exists x. (Human(x) & exists y. (Home(y) & BuildsInWetland(x, y))) -> all z. (Wetland(z) & OrganismLivingInWetland(z) -> NegativeImpact(y, z))", "exists w. (Wetland(w) & exists x. (Human(x) & BuildsHomeIn(x, w) -> NegativeImpactOn(w) & exists y. (Organism(y) & LivesIn(y, w) -> NegativeImpactOn(y))))", "exists w. (Wetland(w) & exists h. (Human(h) & BuildsHomeIn(h, w) -> NegativeImpact(w) & exists o. (Organism(o) & LivesIn(o, w) -> NegativeImpact(o))))", "all w. all h. all o. ((Wetland(w) & Human(h) & Build(h, Home, w) & LivesIn(o, w)) -> NegativeImpact(Build(h, Home, w), w) & NegativeImpact(Build(h, Home, w), o))"]}
{"id": "entailmentbank_validation_161", "nl": "if an animal eats other animals for food, then the animal will be the predator.", "fol": "", "prediction": ["all x. (Animal(x) & exists y. (Animal(y) & Eats(x, y)) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))"]}
{"id": "entailmentbank_validation_162", "nl": "tuna eat fish.", "fol": "", "prediction": ["all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_163", "nl": "tuna is a kind of predator.", "fol": "", "prediction": ["Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)"]}
{"id": "entailmentbank_validation_164", "nl": "tuna is a kind of fish.", "fol": "", "prediction": ["Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)"]}
{"id": "entailmentbank_validation_165", "nl": "tuna is a kind of predatory fish.", "fol": "", "prediction": ["PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "Kind(tuna, PredatoryFish)"]}
{"id": "entailmentbank_validation_166", "nl": "commercial harvesting from the ocean has caused populations of large predatory fish to decrease.", "fol": "", "prediction": ["exists x. (CommercialHarvesting(x) & FromOcean(x) & causes(x, Decrease(PopulationOf(LargePredatoryFish))))", "exists x. (CommercialHarvestingFromOcean(x) & causes(x, all y. (LargePredatoryFish(y) -> DecreasesPopulation(y))))", "exists x, y, z. (CommercialHarvestingFromOcean(x) & LargePredatoryFish(y) & Population(z, y) & CausesDecrease(x, z))", "FOL Translation:\nall x. ((CommercialHarvestingFrom(ocean, x) & LargePredatoryFish(x)) -> DecreaseInPopulation(x))"]}
{"id": "entailmentbank_validation_167", "nl": "commercial harvesting from the ocean has caused the populations of tuna to decrease.", "fol": "", "prediction": ["exists x. (CommercialHarvestingFromOcean(x) & Causes(x, y) & Population(y) & Tuna(y) & Decreases(y))", "exists x. (CommercialHarvestingFromOcean(x) & CausesDecreaseInPopulation(x, tuna))", "FOL Translation:\n\nexists x. (CommercialHarvesting(x) & FromOcean(x) & Causes(x, Decrease(tuna_population)))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Population(tuna))))"]}
{"id": "entailmentbank_validation_168", "nl": "an organism becoming extinct causes a change in the organism's food web.", "fol": "", "prediction": ["all x. (Organism(x) & BecomesExtinct(x) -> exists y. (Change(y) & InFoodWeb(x, y)))", "exists o. (Organism(o) & BecomesExtinct(o) -> exists f. (Change(f) & FoodWeb(f) & RelatedTo(f, o)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (Change(y) & InOrganismFoodWeb(y, x)))", "exists x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y, x) & CausesChange(y)))"]}
{"id": "entailmentbank_validation_169", "nl": "a change in a food web can cause damage to an ecosystem.", "fol": "", "prediction": ["exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamageTo(x, y)))", "exists x, y. (ChangeInFoodWeb(x) & Ecosystem(y) -> CanCauseDamage(x, y))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x. exists y. (ChangeInFoodWeb(x) & Causes(x, y) & Damage(y) & Ecosystem(y))"]}
{"id": "entailmentbank_validation_170", "nl": "extinctions of organisms can cause damage to an ecosystem by changing the food web.", "fol": "", "prediction": ["exists x, y. (Organism(x) & Extinction(x) & Ecosystem(y) -> CanCauseDamage(x, y) & ChangesFoodWeb(x, y))", "all x. (Extinction(x) & Organism(x) -> exists y. (Ecosystem(y) & CanCauseDamage(x, y) & ChangesFoodWeb(x, y)))", "exists o, e. (Extinction(o) & Organism(o) & Ecosystem(e) & CausesDamageTo(o, e) & ChangesFoodWeb(o))", "exists x, y. (Organism(x) & Extinction(x) & Ecosystem(y) & ChangesFoodWebInEcosystem(x, y) -> CausesDamageToEcosystem(x, y))"]}
{"id": "entailmentbank_validation_171", "nl": "california is located on the boundary of two tectonic plates.", "fol": "", "prediction": ["LocatedOnBoundaryOfTwoPlates(california)", "LocatedOnBoundaryOf(california, tectonic_plate1, tectonic_plate2)", "LocatedOnBoundary(california, tectonic_plate1, tectonic_plate2)", "LocatedOnBoundaryOf(california, two_tectonic_plates)"]}
{"id": "entailmentbank_validation_172", "nl": "earthquakes are most common along tectonic plate boundaries.", "fol": "", "prediction": ["all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlongTectonicPlateBoundaries(x))", "all x. (Earthquake(x) -> MostCommonAlongBoundary(x, TectonicPlateBoundary))", "all x. (Earthquake(x) -> CommonAlong(x, TectonicPlateBoundaries))"]}
{"id": "entailmentbank_validation_173", "nl": "massachusetts is not located on the boundary of two tectonic plates.", "fol": "", "prediction": ["-LocatedOnBoundary(massachusetts, tectonic_plate1, tectonic_plate2)", "-LocatedOnBoundaryOfTwoTectonicPlates(massachusetts)", "", ""]}
{"id": "entailmentbank_validation_174", "nl": "earthquakes are more likely to occur in california than in massachusetts.", "fol": "", "prediction": ["LikelyToOccur(earthquake, california, massachusetts)", "all x. (Earthquake(x) -> (OccursIn(x, california) & -OccursIn(x, massachusetts)))", "MoreLikelyToOccur(earthquake, california, massachusetts)", "all x. (Earthquake(x) -> LikelyToOccurIn(x, california) > LikelyToOccurIn(x, massachusetts))"]}
{"id": "entailmentbank_validation_175", "nl": "the oceanic plate is a kind of tectonic plate.", "fol": "", "prediction": ["KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)"]}
{"id": "entailmentbank_validation_176", "nl": "the subduction of tectonic plates may cause magma to surface from underneath.", "fol": "", "prediction": ["exists x, y, z. (TectonicPlate(x) & TectonicPlate(y) & Subduction(x, y) & Magma(z) & Cause(Subduction(x, y), Surface(z)))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(MagmaToSurface))", "exists x. exists y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> exists z. (Magma(z) & MayCauseToSurface(z, Underneath)))", "exists x, y. (Subduction(x) & TectonicPlate(x) & Causes(x, y) & Magma(y) & SurfacesFromUnderneath(y))"]}
{"id": "entailmentbank_validation_177", "nl": "the subduction of an oceanic plate may cause magma to surface from underneath.", "fol": "", "prediction": ["exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x, y. (Subduction(oceanic_plate, x) & Causes(x, y) & Magma(y) & SurfaceFromUnderneath(y))", "exists x exists y. (OceanicPlate(x) & Magma(y) & Subduction(x) -> MayCauseToSurfaceFromUnderneath(y, x))", "exists x y. (OceanicPlate(x) & Subduction(x, y) & (SurfaceMagma(y) | MayCause(SurfaceMagma(y))))"]}
{"id": "entailmentbank_validation_178", "nl": "magma cools down when it comes to the surface from underneath.", "fol": "", "prediction": ["all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurfaceFromUnderneath(x)) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurface(x)) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurfaceFromUnderneath(x)) -> CoolsDown(x))"]}
{"id": "entailmentbank_validation_179", "nl": "the subduction of an oceanic plate will cause magma to surface and cool down.", "fol": "", "prediction": ["exists x. (OceanicPlate(x) & Subducts(x) -> exists y. (Magma(y) & Causes(x, y) & Surfaces(y) & CoolsDown(y)))", "all x y. (Subduction(oceanic_plate(x)) & Causes(y, Surface(magma(y)) & CoolDown(magma(y))))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surface(y) & CoolsDown(y)))"]}
{"id": "entailmentbank_validation_180", "nl": "magma cooling can form volcanic mountains.", "fol": "", "prediction": ["exists x. exists y. (Magma(x) & Cooling(x) & VolcanicMountain(y) & Forms(x, y))", "exists x. (MagmaCooling(x) & CanFormVolcanicMountains(x))", "exists x. (MagmaCooling(x) & CanForm(x, VolcanicMountains))", "all x. (Magma(x) & Cooling(x) -> CanFormVolcanicMountains(x))"]}
{"id": "entailmentbank_validation_181", "nl": "the subduction of an oceanic plate can form volcanic mountians.", "fol": "", "prediction": ["exists x. (OceanicPlate(x) & Subduction(x) -> CanForm(x, VolcanicMountains))", "exists x. exists y. (OceanicPlate(x) & Subducts(x) & VolcanicMountainsForm(y) & Causes(x, y))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(y, x)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(x, y)))"]}
{"id": "entailmentbank_validation_182", "nl": "emitting sulfur dioxide causes acid rain.", "fol": "", "prediction": ["exists x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmittingSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))", "exists x exists y. (Emits(x, sulfur_dioxide) -> Causes(x, y) & AcidRain(y))"]}
{"id": "entailmentbank_validation_183", "nl": "volcanic ash in the atmosphere decreases the temperature by blocking the sun.", "fol": "", "prediction": ["exists x, y. (VolcanicAsh(x) & InAtmosphere(x) & DecreasesTemperature(y) & Blocks(x, sun))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (TemperatureDecreases(y) & Blocks(x, sun)))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (DecreasesTemperature(x, y) & Blocks(x, sun)))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Temperature(y) & Decreases(y) & exists z. (Sun(z) & Blocks(x, z))))"]}
{"id": "entailmentbank_validation_184", "nl": "an erupting volcano releases sulfur gas and ash into the atmosphere.", "fol": "", "prediction": ["exists x. (Volcano(x) & Erupting(x) -> exists y. (SulfurGas(y) & Release(x, y) & Atmosphere(z) & ReleasesInto(y, z)) & exists w. (Ash(w) & Release(x, w) & Atmosphere(z) & ReleasesInto(w, z)))", "exists v. (EruptingVolcano(v) -> exists g. (SulfurGas(g) & Releases(v, g) & ExistsInAtmosphere(g) & exists a. (Ash(a) & Releases(v, a) & ExistsInAtmosphere(a))))", "exists v. (Volcano(v) & Erupting(v) -> (Releases(v, sulfur_gas) & Releases(v, ash) & Into(v, atmosphere)))", "exists x. (Volcano(x) & Erupting(x) -> exists y. (SulfurGas(y) & ReleasedIntoAtmosphere(y)) & exists z. (Ash(z) & ReleasedIntoAtmosphere(z)))"]}
{"id": "entailmentbank_validation_185", "nl": "a volcanic eruption can cause acid rain and decrease the temperature.", "fol": "", "prediction": ["exists x. (VolcanicEruption(x) -> (Causes(x, AcidRain) & Decreases(x, Temperature)))", "exists x. (VolcanicEruption(x) -> (CanCauseAcidRain(x) & CanDecreaseTemperature(x)))", "exists x. (VolcanicEruption(x) -> (CausesAcidRain(x) & DecreasesTemperature(x)))", "exists x. (VolcanicEruption(x) -> (Causes(x, AcidRain) & DecreasesTemperature(x)))"]}
{"id": "entailmentbank_validation_186", "nl": "europe was unusally cold and had acid rain in 1783.", "fol": "", "prediction": ["WasUnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "WasUnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)"]}
{"id": "entailmentbank_validation_187", "nl": "a volcanic eruption may have happened to cause the cold weather and acid rain.", "fol": "", "prediction": ["exists e. (VolcanicEruption(e) & CanCause(e, ColdWeather) & CanCause(e, AcidRain))", "exists x. (VolcanicEruption(x) & MayHaveHappened(x) & Causes(x, ColdWeather) & Causes(x, AcidRain))", "exists e. (VolcanicEruption(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists x. (VolcanicEruption(x) & MayHaveCaused(x, ColdWeather) & MayHaveCaused(x, AcidRain))"]}
{"id": "entailmentbank_validation_188", "nl": "the earth's atmosphere is made of 78 percent nitrogen by mass.", "fol": "", "prediction": ["MadeOf(earth_atmosphere, 78_percent_nitrogen_mass)", "MadeOfByMassPercentage(atmosphere_earth, nitrogen, 78)", "MadeOf(earth_atmosphere, nitrogen, 0.78)", "MadeOf(earths_atmosphere, nitrogen, 0.78_by_mass)"]}
{"id": "entailmentbank_validation_189", "nl": "most means over 50% of something.", "fol": "", "prediction": ["`all x. (Most(x) -> Over50Percent(x))`", "all z. (Most(z) -> OverFiftyPercent(z))", "most(x) -> OverFiftyPercent(x)", "most(x) -> OverFiftyPercent(x)"]}
{"id": "entailmentbank_validation_190", "nl": "the earth's atmosphere is made of mostly nitrogen.", "fol": "", "prediction": ["Exists x. (Atmosphere(earth, x) & MadeMostlyOf(x, nitrogen))", "Exists x. (Atmosphere(x) & PartOf(x, earth) & MadeOfMostly(x, nitrogen))", "MadeOfMostly(earths_atmosphere, nitrogen)", "Exists x. (Atmosphere(x) & PartOf(x, earth) & MadeOfMostly(x, nitrogen))"]}
{"id": "entailmentbank_validation_191", "nl": "oceans cover 70% of the surface of the earth.", "fol": "", "prediction": ["Exists o. (Ocean(o) & Covers(o, earth_surface) & PercentageCoverage(o, 70))", "CoveringSurface(oceans, 0.7, earth_surface)", "Covers(oceans, earth_surface) & PercentageCover(oceans, earth_surface, 70)", "Cover(oceans, earth, 70% * Surface(earth))"]}
{"id": "entailmentbank_validation_192", "nl": "oceans cover most of earth's surface.", "fol": "", "prediction": ["exists x. (Ocean(x) & CoversMostOfSurface(x, earth))", "exists x. (Ocean(x) & CoversMostOfSurface(x, earth))", "exists y. (Ocean(y) & CoversMostOfEarthSurface(y))", "exists y. (Ocean(y) & CoversMostOfSurfaceOf(y, earth))"]}
{"id": "entailmentbank_validation_193", "nl": "an ocean is a kind of body of water.", "fol": "", "prediction": ["all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))"]}
{"id": "entailmentbank_validation_194", "nl": "water covers most of earth's surface.", "fol": "", "prediction": ["exists x. (Water(x) & CoversMostOfSurfaceOf(x, earth))", "FOL Translation:\nCoversMajorityOfSurface(water, earth)", "exists x. (Water(x) & SurfaceOf(earth, y) & Covers(x, y) & MostOf(y))", "FOL Translation:\nCoversMostOfSurface(water, earth)"]}
{"id": "entailmentbank_validation_195", "nl": "oceans contain most of earth's water.", "fol": "", "prediction": ["exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "Exists y. (Ocean(y) & ContainsMostOfEarthsWater(y))", "all x. (Ocean(x) -> ContainsMostWater(x, earth))"]}
{"id": "entailmentbank_validation_196", "nl": "water is made of hydrogen and oxygen.", "fol": "", "prediction": ["Exists x y. (WaterIsMadeOf(x, y) & Hydrogen(x) & Oxygen(y))", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)"]}
{"id": "entailmentbank_validation_197", "nl": "ocean water is made of hydrogen and oxygen.", "fol": "", "prediction": ["MadeOf(ocean_water, hydrogen) & MadeOf(ocean_water, oxygen)", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "Exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))"]}
{"id": "entailmentbank_validation_198", "nl": "oxygen is more common than hydrogen on earth.", "fol": "", "prediction": ["Common(oxygen, earth) & Common(hydrogen, earth) & MoreCommon(oxygen, hydrogen, earth)", "exists x. exists y. (Oxygen(x) & Hydrogen(y) & MoreCommonOnEarth(x, y))", "Exists x. (Location(x) & On(x, earth) & MoreCommon(oxygen, hydrogen, x))", "Common(oxygen, earth) & -Common(hydrogen, earth) & MoreCommon(oxygen, hydrogen, earth)"]}
{"id": "entailmentbank_validation_199", "nl": "oxygen is the most common element found in the compounds that make up ocean water.", "fol": "", "prediction": ["exists x. (Oxygen(x) & MostCommonElement(x) & all y. (CompoundThatMakesUpOceanWater(y) -> FoundIn(x, y)))", "exists y. (Element(y) & MostCommon(y) & FoundIn(y, OceanWaterCompounds) & Oxygen(y))", "exists x. (Oxygen(x) & MostCommonElement(x) & exists y. (Compounds(y) & MakesUp(ocean_water, y) & FoundIn(x, y)))", "exists y. (OceanWater(y) & all z. (Compound(z) & MakesUp(z, y) -> exists x. (Element(x) & FoundIn(x, z) & MostCommon(x, oxygen))))"]}
{"id": "entailmentbank_validation_200", "nl": "if something is permeable, then the water will flow through something easily.", "fol": "", "prediction": ["all x. (Permeable(x) -> WaterFlowsThroughEasily(water, x))", "all x. (Permeable(x) -> exists y. (WaterWillFlowThrough(y, x) & Easily(y)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))"]}
{"id": "entailmentbank_validation_201", "nl": "soil is permeable.", "fol": "", "prediction": ["Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)"]}
{"id": "entailmentbank_validation_202", "nl": "water will flow through soil easily.", "fol": "", "prediction": ["all x. (Water(x) & Soil(y) -> FlowsThroughEasily(x, y))", "all x. (Water(x) & Soil(y) & FlowsThrough(x, y)) -> Easily(x)", "all x. (Soil(x) -> FlowsThroughEasily(water, x))", "all x. (Water(x) & Soil(y) & Contact(x, y) -> FlowsEasilyThrough(x, y))"]}
{"id": "entailmentbank_validation_203", "nl": "color of the soil can be used to indicate the soil component.", "fol": "", "prediction": ["all s. (Soil(s) -> exists c. (Color(c, s) & CanIndicateComponent(c, s)))", "all x. (Soil(x) -> exists y. (SoilComponent(y) & CanIndicate(ColorOfSoil(x), y)))", "exists x. (Soil(x) & ColorUsedToIndicateComponent(ColorOf(x), ComponentOf(x)))", "all x. (SoilComponent(x) -> exists y. (ColorOfSoil(y) & Indicates(y, x)))"]}
{"id": "entailmentbank_validation_204", "nl": "high humus content causes the soil to be brown.", "fol": "", "prediction": ["all x. (HighHumusContent(x) -> Causes(x, SoilBrown))", "exists x. (HighHumusContent(x) -> CausesToBeBrown(Soil(x)))", "all x. (HighHumusContent(x) -> Causes(Brown(Soil(x))))", "all s. (HighHumusContent(s) -> Brown(s))"]}
{"id": "entailmentbank_validation_205", "nl": "brown is a kind of color.", "fol": "", "prediction": ["Kind(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)"]}
{"id": "entailmentbank_validation_206", "nl": "if the soil has high humus content, then the soil will be brown in color.", "fol": "", "prediction": ["HighHumusContent(soil) -> BrownColor(soil)", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all z. (Soil(z) & HighHumusContent(z) -> BrownInColor(z))"]}
{"id": "entailmentbank_validation_207", "nl": "mountains can cause the water in the air mass to condense.", "fol": "", "prediction": ["all m. (Mountain(m) -> all a. (AirMass(a) & HasWater(a) -> CanCauseToCondense(m, a)))", "all x. (Mountain(x) -> exists y. (AirMass(y) & CanCauseCondense(x, y)))", "all x. (Mountain(x) -> CanCauseCondensation(x, AirMass(y), Water(z)))", "all x. (Mountain(x) -> CanCauseCondensation(x, WaterInAirMass))"]}
{"id": "entailmentbank_validation_208", "nl": "mountain is a kind of geographic obstacles.", "fol": "", "prediction": ["all x. (Mountain(x) -> GeographicObstacle(x))", "KindOf(mountain, geographic_obstacles)", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)"]}
{"id": "entailmentbank_validation_209", "nl": "mountain is the geographic obstacle that can cause the water in the air mass to condense.", "fol": "", "prediction": ["exists x. (Mountain(x) & GeographicObstacle(x) & all y. (AirMass(y) & ContainsWater(y) -> CanCauseToCondense(x, y)))", "all x. (Mountain(x) -> (GeographicObstacle(x) & CanCauseCondensation(x, airmasswater)))", "all x. (Mountain(x) -> (GeographicObstacle(x) & CanCauseCondensationInAirMass(x)))", "GeographicObstacle(mountain) & all y. (AirMass(y) -> (CanCauseCondense(mountain, WaterIn(y))))"]}
{"id": "entailmentbank_validation_210", "nl": "if something causes a process then that something is required for that process.", "fol": "", "prediction": ["all x all y. (Causes(x, y) -> RequiredFor(x, y))", "all x all y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x, y. (Causes(x, y) -> RequiredFor(x, y))"]}
{"id": "entailmentbank_validation_211", "nl": "condensation causes clouds to form.", "fol": "", "prediction": ["all x. (Condensation(x) -> CausesToForm(x, clouds))", "all x. (Condensation(x) -> Causes(x, y) & Forms(y, clouds))", "all x. (Condensation(x) -> Causes(x, Form(Clouds)))", "all x. (Condensation(x) -> Causes(x, CloudsToForm))"]}
{"id": "entailmentbank_validation_212", "nl": "condensation is required for clouds to form.", "fol": "", "prediction": ["FOL Translation:\nall x. (Cloud(x) -> ExistsCondensationRequired(x))", "Clouds can form when condensation is present. To negate \"is required,\" we rephrase it with the implication arrow to show that formation without condensation is impossible:\n\n```FOL\nall x. (Forms(x, cloud) -> Requires(x, condensation))\n```", "all x. (CloudsForm(x) -> RequiresCondensation(x))", "FOL Translation:\nall x. (CloudForms(x) -> Requires(x, Condensation))"]}
{"id": "entailmentbank_validation_213", "nl": "erosion is when wind transports sediments from one place to another place for a long distance.", "fol": "", "prediction": ["Erosion(transport(wind, sediments, long_distance))", "Erosion(erosion) & all w, s, p1, p2. ((Wind(w) & Sediments(s) & Transports(w, s, p1, p2) & LongDistance(p1, p2)) -> Erosion(erosion))", "all x. (Erosion(x) <-> (WindTransports(x) & Sediments(x) & FromOnePlaceToAnother(x) & LongDistance(x)))", "all x. (Erosion(x) <-> (TransportByWind(x) & Sediments(x) & TransportFromOnePlaceToAnother(x) & LongDistance(x)))"]}
{"id": "entailmentbank_validation_214", "nl": "sand dunes / arches are formed by the wind transporting and depositing sand.", "fol": "", "prediction": ["all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand) & Forms(x, sand)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y)))", "all x. (SandDune(x) | Arch(x) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand) & Forms(x, sand)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, Sand(x)) & Deposits(y, Sand(x))))"]}
{"id": "entailmentbank_validation_215", "nl": "wind erosion can form sand dunes and arches.", "fol": "", "prediction": ["all x. ((WindErosion(x) & CanForm(x, SandDunes)) & CanForm(x, Arches))", "exists x exists y. (WindErosion(x) & Forms(x, SandDune(y)) & exists z. (Arch(z) & Forms(x, z)))", "exists x. ((WindErosion(x) -> CanForm(x, SandDunes)) & (WindErosion(x) -> CanForm(x, Arches)))", "all x. ((WindErosion(x) & CanForm(y)) -> (SandDune(y) | Arch(y)))"]}
{"id": "entailmentbank_validation_216", "nl": "rain causes erosion.", "fol": "", "prediction": ["all x. (Rain(x) -> Causes(x, erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rains(x) -> Causes(x, erosion))", "all x. (Rain(x) -> Causes(x, Erosion))"]}
{"id": "entailmentbank_validation_217", "nl": "erosion sometimes decreases the amount of nutrients in soil.", "fol": "", "prediction": ["exists x. (Soil(x) & exists y. (Nutrient(y) & Erosion(x, y) & Decreases(x, y)))", "To translate this sentence into first-order logic, we must account for the idea of 'sometimes'. We often do this using existential quantification or introducing a predicate representing the context or specific situations in which the statement is true. Here's one way to translate it:\n\nexists s. (Erosion(s) & Decreases(Erosion(s), AmountOfNutrientsInSoil(s)))", "exists x. (Erosion(x) & OccursSometimes(x) & decreasesAmountOfNutrientsInSoil(x))", "exists x. (Erosion(x) & sometimes(Decreases(x, NutrientsInSoil)))"]}
{"id": "entailmentbank_validation_218", "nl": "rain can decrease the amount of nutrients in soil.", "fol": "", "prediction": ["FOL Translation:\nall x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> CanDecreaseNutrients(Soil(x)))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> CanDecreaseNutrients(x, soil))"]}
{"id": "entailmentbank_validation_219", "nl": "as the availability of water decreases, the environment will become more dry.", "fol": "", "prediction": ["all x. (DecreaseAvailabilityOfWater(x) -> BecomeMoreDry(x))", "all x. (DecreaseAvailabilityOfWater(x) -> BecomesMoreDry(Environment(x)))", "FOL Translation:\nall x. (Decreases(AvailabilityOfWater, x) -> BecomesMoreDry(Environment, x))", "all x. (DecreasesAvailabilityOfWater(x) -> BecomesMoreDry(x))"]}
{"id": "entailmentbank_validation_220", "nl": "drought is when available water decreases in an environment.", "fol": "", "prediction": ["Drought(x) <-> (AvailableWaterDecreases(x) & Environment(x))", "Drought(x) <-> (AvailableWaterDecreases(x) & Environment(x))", "Drought(e) <-> Exists(e1, e2). (AvailableWater(e1) & Environment(e2) & Decreases(e1, e2))", "Drought(x) <-> (exists y. (AvailableWater(y) & Decreases(y) & InEnvironment(y, x)))"]}
{"id": "entailmentbank_validation_221", "nl": "drought causes the environment to be dry.", "fol": "", "prediction": ["exists x. (Drought(x) -> Causes(x, Dry(environment)))", "all x. (Drought(x) -> Causes(x, DryEnvironment))", "all x. (Drought(x) -> Causes(x, DryEnvironment))", "exists x. (Drought(x) -> Causes(x, Dry(environment)))"]}
{"id": "entailmentbank_validation_222", "nl": "dry conditions can cause fire.", "fol": "", "prediction": ["all x. (DryCondition(x) -> CanCause(x, fire))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryConditions(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))"]}
{"id": "entailmentbank_validation_223", "nl": "drought may cause wildfires.", "fol": "", "prediction": ["exists x y. (Drought(x) & Wildfire(y) & Causes(x, y))", "all x. (Drought(x) -> exists y. (Wildfire(y) & MayCause(x, y)))", "exists x. (Drought(x) -> MayCause(x, Wildfire))", "exists x. (Drought(x) -> CanCause(x, wildfire))"]}
{"id": "entailmentbank_validation_224", "nl": "a prairie is a kind of ecosystem.", "fol": "", "prediction": ["all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all z. (Prairie(z) -> Ecosystem(z))"]}
{"id": "entailmentbank_validation_225", "nl": "drought may cause wildfires to a prairie.", "fol": "", "prediction": ["exists x. (Drought(x) & all y. (Prairie(y) -> MayCause(x, Wildfire(y))))", "exists x exists y. (Drought(x) & Prairie(y) -> MayCauseWildfires(x, y))", "exists x. exists y. (Drought(x) & Prairie(y) & Causes(x, Wildfires(y)))", "exists x. (Drought(x) & all y. (Wildfire(y) & Prairie(z) -> MayCause(x, y, z)))"]}
{"id": "entailmentbank_validation_226", "nl": "a barometer is a kind of instrument.", "fol": "", "prediction": ["all x. (Barometer(x) -> Instrument(x))", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)"]}
{"id": "entailmentbank_validation_227", "nl": "a barometer is used to measure air pressure.", "fol": "", "prediction": ["exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) -> UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))"]}
{"id": "entailmentbank_validation_228", "nl": "a barometer is an instrument used to measure air pressure.", "fol": "", "prediction": ["all x. (Barometer(x) -> Instrument(x) & UsedToMeasure(x, airPressure))", "Instrument(barometer) & Measures(barometer, air_pressure)", "Instrument(barometer) & Measures(barometer, air_pressure)", "all x. (Barometer(x) -> Instrument(x) & UsedToMeasure(x, air_pressure))"]}
{"id": "entailmentbank_validation_229", "nl": "a property is a kind of information.", "fol": "", "prediction": ["all x. (Property(x) -> Information(x))", "all x. (Property(x) -> KindOfInformation(x))", "all x. (Property(x) -> KindOfInformation(x))", "all x. (Property(x) -> Information(x))"]}
{"id": "entailmentbank_validation_230", "nl": "temperature is a property of weather.", "fol": "", "prediction": ["all x. (Temperature(x) -> exists y. (Weather(y) & PropertyOf(x, y)))", "exists x. (Temperature(x) & exists y. (Weather(y) & PropertyOf(x, y)))", "all x. (Weather(x) -> HasProperty(x, temperature))", "exists x exists y. (Temperature(x) & Weather(y) & PropertyOf(x, y))"]}
{"id": "entailmentbank_validation_231", "nl": "temperature is a kindof information about weather.", "fol": "", "prediction": ["`all x. (Temperature(x) -> KindOfInformation(x, Weather))`", "all x. (Temperature(x) -> InformationAbout(x, weather))", "all x. (Temperature(x) -> KindOfInformationAbout(x, Weather))", "KindOf(temperature, information) & About(information, weather)"]}
{"id": "entailmentbank_validation_232", "nl": "a thermometer is used to measure temperature.", "fol": "", "prediction": ["exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. Thermometer(x) & UsedToMeasure(x, temperature)", "exists x. (Thermometer(x) -> UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))"]}
{"id": "entailmentbank_validation_233", "nl": "a thermometer is used to measure the information about weather on temperature.", "fol": "", "prediction": ["all x. (Thermometer(x) -> UsedToMeasure(x, TemperatureInfo(weather)))", "all x. (Thermometer(x) -> UsedToMeasure(x, InformationAbout(Weather, Temperature)))", "exists x. (Thermometer(x) & UsedToMeasure(x, information_about_weather_on_temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, WeatherInformation) & RelatedTo(WeatherInformation, Temperature))"]}
{"id": "entailmentbank_validation_234", "nl": "wind direction is a property of weather.", "fol": "", "prediction": ["all x. (WindDirection(x) -> PropertyOf(x, weather))", "all x. (Weather(x) -> exists y. (WindDirection(y) & PropertyOf(y, x)))", "PropertyOf(wind_direction, weather)", "PropertyOf(wind_direction, weather)"]}
{"id": "entailmentbank_validation_235", "nl": "wind direction is a kind of information about weather.", "fol": "", "prediction": ["all x. (WindDirection(x) -> InformationAboutWeather(x))", "KindOfInformation(wind_direction, weather)", "exists x. (WindDirection(x) & InformationAbout(x, weather))", "WeatherInformation(wind_direction)"]}
{"id": "entailmentbank_validation_236", "nl": "a station model is used for displaying information about weather in a particular point and time.", "fol": "", "prediction": ["exists p. exists t. all s. (StationModel(s) -> UsedFor(s, DisplayingInformation(Weather, p, t)))", "exists x. (StationModel(x) & UsedForDisplayingInformationAboutWeather(x))", "exists x. (StationModel(x) & UsedFor(x, Displaying(WeatherInformation, Point, Time)))", "exists s, p, t. (StationModel(s) & UsedFor(s, DisplayingInformation) & AboutWeather(p, t))"]}
{"id": "entailmentbank_validation_237", "nl": "wind direction in a particular point and time is displayed in a station model.", "fol": "", "prediction": ["exists x. all y. (ParticularPoint(x) & ParticularTime(y) -> exists z. (StationModel(z) & DisplaysWindDirection(z, x, y)))", "exists x, y, z. (ParticularPoint(x) & Time(y) & StationModel(z) & Displays(z, WindDirection(x, y)))", "exists x. exists y. exists z. (ParticularPointInTime(x) & WindDirection(x, y) & DisplayedIn(z, y) & StationModel(z))", "all x. all y. all z. ((ParticularPoint(x) & ParticularTime(y) & StationModel(z)) -> DisplaysWindDirection(z, x, y))"]}
{"id": "entailmentbank_validation_238", "nl": "sleet is a kind of precipitation.", "fol": "", "prediction": ["Precipitation(sleet)", "Kind(sleet, precipitation)", "Precipitation(sleet)", "Precipitation(sleet)"]}
{"id": "entailmentbank_validation_239", "nl": "hail is a kind of precipitation.", "fol": "", "prediction": ["KindOf(hail, precipitation)", "Precipitation(hail)", "KindOf(hail, precipitation)", "Precipitation(hail)"]}
{"id": "entailmentbank_validation_240", "nl": "hail and sleet are different kinds of precipitation.", "fol": "", "prediction": ["Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "all x. ((Hail(x) -> Precipitation(x)) & (Sleet(x) -> Precipitation(x)) & (Hail(x) -> -Sleet(x)) & (Sleet(x) -> -Hail(x)))", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & -exists z. (Hail(z) & Sleet(z))"]}
{"id": "entailmentbank_validation_241", "nl": "when one kind of energy changes into another kind of energy, the total amount of energy is constant.", "fol": "", "prediction": ["all x y. ((Energy(x) & Energy(y) & ChangesInto(x, y)) -> Constant(TotalAmountOfEnergy))", "all x y. ((Energy(x) & Energy(y) & ChangesInto(x, y)) -> ConstantTotalEnergy())", "all x, y. (Energy(x) & Energy(y) & ChangesTo(x, y) -> Constant(TotalAmountOfEnergy))", "all x y. ((Energy(x) & Energy(y) & ChangesInto(x, y)) -> IsConstant(TotalAmountOfEnergy))"]}
{"id": "entailmentbank_validation_242", "nl": "energy transformation means one kind of energy changes into another kind of energy.", "fol": "", "prediction": ["Means(energy_transformation, exists x exists y. (Energy(x) & Energy(y) & ChangesInto(x, y) & DifferentKind(x, y)))", "all x. (EnergyTransformation(x) -> exists y, z. (EnergyType(y) & EnergyType(z) & ChangesInto(y, z)))", "all e1, e2. (EnergyTransformation(e1, e2) <-> (Energy(e1) & Energy(e2) & ChangesInto(e1, e2)))", "all x. (EnergyTransformation(x) -> ChangesInto(OneKindOfEnergy(x), AnotherKindOfEnergy(x)))"]}
{"id": "entailmentbank_validation_243", "nl": "when energy transformation happens, the total amount of energy is constant.", "fol": "", "prediction": ["all x. (EnergyTransformation(x) -> Constant(TotalAmountOfEnergy(x)))", "all x. (EnergyTransformation(x) -> TotalEnergyConstant(x))", "all x. (EnergyTransformationHappens(x) -> ConstantTotalEnergy(x))", "all t. (EnergyTransformationHappens(t) -> TotalEnergyConstant(t))"]}
{"id": "entailmentbank_validation_244", "nl": "energy transformation means energy conversion.", "fol": "", "prediction": ["all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))"]}
{"id": "entailmentbank_validation_245", "nl": "when energy conversion happens, the total amount of energy is constant.", "fol": "", "prediction": ["all c. (EnergyConversion(c) -> Constant(TotalAmountOfEnergy(c)))", "all x. (EnergyConversionHappens(x) -> Constant(TotalAmountOfEnergy(x)))", "all x. (EnergyConversion(x) -> Constant(TotalAmountOfEnergy))", "all x. (EnergyConversion(x) -> Constant(TotalAmountOfEnergy(x)))"]}
{"id": "entailmentbank_validation_246", "nl": "solid is a kind of state of matter.", "fol": "", "prediction": ["Kind(solid, state_of_matter)", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))"]}
{"id": "entailmentbank_validation_247", "nl": "heat energy can change the state of matter.", "fol": "", "prediction": ["FOL Translation:\n\nall x. (Matter(x) -> (exists y. (HeatEnergy(y) & CanChangeState(y, x))))", "FOL Translation:\nall x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "FOL Translation:\nall x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))"]}
{"id": "entailmentbank_validation_248", "nl": "liquid is a kind of state of matter.", "fol": "", "prediction": ["StateOfMatter(liquid)", "all z. (Liquid(z) -> StateOfMatter(z))", "KindOf(liquid, StateOfMatter)", "all x. (Liquid(x) -> StateOfMatter(x))"]}
{"id": "entailmentbank_validation_249", "nl": "heat can change a substance from a solid to liquid.", "fol": "", "prediction": ["exists x. (Substance(x) & Solid(x) & exists y. (Liquid(y) & HeatCanChange(x, y)))", "exists x y. (Substance(x) & StateSolid(x) & StateLiquid(y) & HeatCanChange(x, y))", "all x. (Substance(x) & Solid(x) & Heat(y) -> ChangesToLiquid(x, y))", "exists x. exists y. (Substance(x) & Solid(y) & Liquid(y) & CanChangeHeat(x, y))"]}
{"id": "entailmentbank_validation_250", "nl": "melting means a substance changes from a solid into a liquid by increasing heat energy.", "fol": "", "prediction": ["all x. (Substance(x) & Melts(x) -> (ChangesFromSolidToLiquid(x) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) -> (Substance(x) & ChangesFromSolidToLiquid(x) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) -> exists y. (Substance(y) & ChangesFromSolidToLiquid(y) & IncreasesHeatEnergy(y)))", "all x. (Melting(x) <-> (Substance(x) & ChangesFromSolidToLiquid(x) & IncreasesHeatEnergy(x)))"]}
{"id": "entailmentbank_validation_251", "nl": "heat can cause a solid substance to melt.", "fol": "", "prediction": ["all x. (SolidSubstance(x) & Heat(y) -> CanMelt(x, y))", "FOL Translation:\nall x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (SolidSubstance(x) -> (exists y. (Heat(y) & CanCauseToMelt(y, x))))"]}
{"id": "entailmentbank_validation_252", "nl": "ice is a kind of solid.", "fol": "", "prediction": ["Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)"]}
{"id": "entailmentbank_validation_253", "nl": "heat can cause ice to melt.", "fol": "", "prediction": ["all x. (Ice(x) -> (exists y. (Heat(y) & CanCauseToMelt(y, x))))", "FOL Translation:\nall x. (Ice(x) & Heat(y) -> CanCauseToMelt(y, x))", "exists x. exists y. (Heat(x) & Ice(y) & CanCause(x, Melt(y)))", "all x. (Heat(x) -> exists y. (Ice(y) & Causes(x, Melts(y))))"]}
{"id": "entailmentbank_validation_254", "nl": "the sun is a source of radiation / heat called sunlight.", "fol": "", "prediction": ["SourceOfRadiation(sun) & SourceOfHeat(sun) & Called(sunlight, sun)", "Source(sun, sunlight) & Produces(sun, Radiation) & Produces(sun, Heat)", "SourceOfRadiation(heat) & Calls(sunlight, heat) & Equals(sun, sunlight)", "SourceOfRadiation(heat, sunlight) & SourceOfHeat(heat, sunlight) & Source(sun, sunlight)"]}
{"id": "entailmentbank_validation_255", "nl": "the heat energy from the sunlight cause ice to melt.", "fol": "", "prediction": ["exists x y z. (HeatEnergy(x) & From(x, y) & Sunlight(y) & Cause(x, z) & Melts(z) & Ice(z))", "exists x. exists y. exists z. (HeatEnergyFromSunlight(x) & Ice(y) & Melts(y, z) & Causes(x, z))", "exists e1, e2, x. (HeatEnergyFromSunlight(e1) & Ice(x) & Causes(e1, Melts(x)))", "exists e. (HeatEnergyFromSunlight(e) & all i. (Ice(i) & Causes(e, Melts(i))))"]}
{"id": "entailmentbank_validation_256", "nl": "a wagon is a kind of vehicle.", "fol": "", "prediction": ["all x. (Wagon(x) -> Vehicle(x))", "all x. (Wagon(x) -> Vehicle(x))", "all x. (Wagon(x) -> Vehicle(x))", "all x. (Wagon(x) -> Vehicle(x))"]}
{"id": "entailmentbank_validation_257", "nl": "a vehicle is a kind of object.", "fol": "", "prediction": ["all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))"]}
{"id": "entailmentbank_validation_258", "nl": "a wagon is a kind of object.", "fol": "", "prediction": ["all x. (Wagon(x) -> Object(x))", "all x. (Wagon(x) -> Object(x))", "all x. (Wagon(x) -> Object(x))", "Object(wagon)"]}
{"id": "entailmentbank_validation_259", "nl": "rolling is a kind of motion.", "fol": "", "prediction": ["KindOf(rolling, motion)", "KindOf(rolling, motion)", "Motion(rolling)", "Motion(rolling)"]}
{"id": "entailmentbank_validation_260", "nl": "a wagon rolling is an example of an object in motion.", "fol": "", "prediction": ["exists x. (Wagon(x) & Rolling(x) & Example(x, ObjectInMotion))", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(x, ObjectInMotion))", "ExampleRollingObject(wagon) & ObjectInMotion(wagon)", "exists x. (WagonRolling(x) & ExampleOf(x, ObjectInMotion))"]}
{"id": "entailmentbank_validation_261", "nl": "an example of mechanical energy is an object in motion.", "fol": "", "prediction": ["exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))", "exists x. (ExampleOf(x, MechanicalEnergy) & ObjectInMotion(x))", "exists x. (MechanicalEnergyExample(x) & ObjectInMotion(x))", "exists x. (ExampleOf(MechanicalEnergy, x) & Object(x) & InMotion(x))"]}
{"id": "entailmentbank_validation_262", "nl": "a wagon rolling is an example of mechanical energy.", "fol": "", "prediction": ["exists x. (Wagon(x) & Rolling(x) & ExampleOf(MechanicalEnergy, x))", "exists x. (Wagon(x) & Rolling(x) -> ExampleOf(x, MechanicalEnergy))", "exists x. (Wagon(x) & Rolling(x) & IsExampleOf(MechanicalEnergy, Rolling(x)))", "exists x. (WagonRolling(x) & ExampleOf(x, MechanicalEnergy))"]}
{"id": "entailmentbank_validation_263", "nl": "loud means high in sound energy / sound intensity.", "fol": "", "prediction": ["all x. (Loud(x) <-> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) <-> (HasHighSoundEnergy(x) | HasHighSoundIntensity(x)))", "all x. (Loud(x) <-> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) -> HighSoundEnergy(x) / HighSoundIntensity(x))"]}
{"id": "entailmentbank_validation_264", "nl": "sound is a kind of energy.", "fol": "", "prediction": ["KindOf(sound, energy)", "Energy(sound)", "KindOf(sound, energy)", "KindOf(sound, energy)"]}
{"id": "entailmentbank_validation_265", "nl": "a classroom is a kind of area.", "fol": "", "prediction": ["Kind(classroom, area)", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "Classroom(x) -> Area(x)"]}
{"id": "entailmentbank_validation_266", "nl": "the sound in a loud class room is an example of high sound energy.", "fol": "", "prediction": ["SoundInLoudClassRoom(x) -> HighSoundEnergy(x)", "Exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InClassroom(x) & Loud(x) & ExampleOf(x, HighSoundEnergy))"]}
{"id": "entailmentbank_validation_267", "nl": "if an object / something is in the sunlight then that object / that something will absorb solar energy.", "fol": "", "prediction": ["all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_268", "nl": "a sidewalk is located outside.", "fol": "", "prediction": ["all x. (Sidewalk(x) -> LocatedOutside(x))", "all x. (Sidewalk(x) -> LocatedOutside(x))", "Location(sidewalk, outside)", "all x. (Sidewalk(x) -> LocatedOutside(x))"]}
{"id": "entailmentbank_validation_269", "nl": "a sidewalk located outside will absorb solar energy.", "fol": "", "prediction": ["all x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "all x. (Sidewalk(x) & LocatedOutside(x) -> Absorbs(x, solar_energy))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_270", "nl": "absorbing sunlight causes objects to heat.", "fol": "", "prediction": ["all x. (AbsorbsSunlight(x) -> Causes(Heats(x)))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Causes(Heat(x)))"]}
{"id": "entailmentbank_validation_271", "nl": "the sidewalk located outsie will heat.", "fol": "", "prediction": ["First, let's identify the elements in the sentence: \n\n1. \"the sidewalk located outside\" is a specific entity, which we'll denote as `sidewalk_outside`.\n2. \"will heat\" is a predicate about the sidewalk, which we'll represent as `WillHeat`.\n\nNow, let's translate the sentence into first-order logic:\n\nFOL Translation:\nWillHeat(sidewalk_outside)", "Exists s. (Sidewalk(s) & LocatedOutside(s) & WillHeat(s))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))", "Location(sidewalk) = outside & WillHeat(sidewalk)"]}
{"id": "entailmentbank_validation_272", "nl": "if something heat, it will feel hot.", "fol": "", "prediction": ["", "", "", ""]}
{"id": "entailmentbank_validation_273", "nl": "the sidewalk located outside will feel hot.", "fol": "", "prediction": ["exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))"]}
{"id": "entailmentbank_validation_274", "nl": "there is a person in a dark room looking out a window in the day.", "fol": "", "prediction": ["exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDaytime(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDaytime)", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & Daytime)", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))"]}
{"id": "entailmentbank_validation_275", "nl": "if something is in a dark place, then that something will not reflect enough light to be seen.", "fol": "", "prediction": ["all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLight(x))", "all x. (DarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))"]}
{"id": "entailmentbank_validation_276", "nl": "the person in the dark room will not reflect enough light to be seen.", "fol": "", "prediction": ["exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))"]}
{"id": "entailmentbank_validation_277", "nl": "there is a person outside in the day looking into the dark room.", "fol": "", "prediction": ["exists x. (Person(x) & Outside(x) & InTheDay(x) & LookingInto(x, dark_room))", "exists x. (Person(x) & OutsideInDay(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Daytime() & LookingInto(x, DarkRoom))", "exists x. (Person(x) & Outside(x) & Daytime & LooksIntoDarkRoom(x))"]}
{"id": "entailmentbank_validation_278", "nl": "the person outside cannot see the person in the dark room.", "fol": "", "prediction": ["exists x exists y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (PersonOutside(x) & PersonInDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x. exists y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) & -CanSee(x, y))"]}
{"id": "entailmentbank_validation_279", "nl": "a prism refracts light.", "fol": "", "prediction": ["Prism(prism) & Light(light) & Refracts(prism, light)", "Refracts(prism, light)", "Prism(prism) -> Refracts(prism, light)", "exists x. (Prism(x) & exists y. (Light(y) & Refracts(x, y)))"]}
{"id": "entailmentbank_validation_280", "nl": "refracting sunlight / light causes sunlight / light to split into different colors.", "fol": "", "prediction": ["all x. (Refracts(x, sunlight) | Refracts(x, light)) -> Causes(x, SplitsIntoDifferentColors(sunlight) | SplitsIntoDifferentColors(light))", "all x. (Refracting(x, sunlight) -> Causes(x, SplitIntoDifferentColors(sunlight))) | all y. (Refracting(y, light) -> Causes(y, SplitIntoDifferentColors(light)))", "all x. (RefractsSunlight(x) -> CausesSplitIntoColors(x, Sunlight))", "all x. ((Refracting(x, sunlight) | Refracting(x, light)) -> Causes(x, SplitsIntoDifferentColors(sunlight)) | Causes(x, SplitsIntoDifferentColors(light)))"]}
{"id": "entailmentbank_validation_281", "nl": "a prism can refract light and split the light into different colors.", "fol": "", "prediction": ["exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))"]}
{"id": "entailmentbank_validation_282", "nl": "white light is made of all colors of visible light combined.", "fol": "", "prediction": ["FOL Translation:\nMadeOf(white_light, all x. (Color(x) & VisibleLight(x)))", "FOL Translation:\nWhiteLight(x) <-> all y. (VisibleLightColor(y) -> PartOf(y, AllColorsCombined(x)))", "exists x. (WhiteLight(x) & exists y. (ColorsOfVisibleLight(y) & MadeOf(x, y)))", "exists x. (WhiteLight(x) & MadeOf(x, y) & all y. (Color(y) & VisibleLight(y) -> CombinedIn(x, y)))"]}
{"id": "entailmentbank_validation_283", "nl": "a prism can refract white light and split the light into all colors of visible light.", "fol": "", "prediction": ["exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitIntoAllColorsOfVisibleLight(x))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitIntoColorsOfVisibleLight(x)))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & SplitsIntoAllColorsOfVisibleLight(x))"]}
{"id": "entailmentbank_validation_284", "nl": "a vacuum has no matter in it.", "fol": "", "prediction": ["all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))"]}
{"id": "entailmentbank_validation_285", "nl": "sound requires matter to travel.", "fol": "", "prediction": ["all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & Requires(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))"]}
{"id": "entailmentbank_validation_286", "nl": "sound cannot travel through a vacuum.", "fol": "", "prediction": ["all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))"]}
{"id": "entailmentbank_validation_287", "nl": "metal is a thermal / thermal energy conductor.", "fol": "", "prediction": ["Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "ThermalEnergyConductor(metal)", "Conductor(metal, thermal_energy)"]}
{"id": "entailmentbank_validation_288", "nl": "a spoon sometimes is made of metal.", "fol": "", "prediction": ["exists x. (Spoon(x) & SometimesMadeOf(x, metal))", "exists x. (Spoon(x) & MadeOfMetal(x))", "exists x. (Spoon(x) & SometimesMadeOfMetal(x))", "exists x. (Spoon(x) & MadeOfMetal(x))"]}
{"id": "entailmentbank_validation_289", "nl": "a metal spoon is a thermal conductor.", "fol": "", "prediction": ["Metal(spoon) & Spoon(spoon) -> ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "ThermalConductor(metal_spoon)", "ThermalConductor(metal_spoon)"]}
{"id": "entailmentbank_validation_290", "nl": "a hot substance is a source of heat.", "fol": "", "prediction": ["all x. (Hot(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))"]}
{"id": "entailmentbank_validation_291", "nl": "a metal spoon is placed in a pot of hot soup.", "fol": "", "prediction": ["exists x. exists y. (MetalSpoon(x) & PotOfHotSoup(y) & PlacedIn(x, y))", "Exists x. Exists y. Exists z. (MetalSpoon(x) & Pot(y) & HotSoup(z) & PlacedIn(x, y) & Contains(y, z))", "PlacedIn(metal_spoon, pot_of_hot_soup)", "MetalSpoon(x) & PlacedIn(x, y) & Pot(y) & HotSoup(y)"]}
{"id": "entailmentbank_validation_292", "nl": "the hot soup will be a source of heat for the metal spoon.", "fol": "", "prediction": ["exists x. (Soup(x) & Hot(x) & exists y. (Spoon(y) & Metal(y) & SourceOfHeatFor(x, y)))", "exists x. exists y. (Soup(x) & Hot(x) & Spoon(y) & Metal(y) & SourceOfHeatFor(x, y))", "SourceOfHeat(hot_soup, metal_spoon)", "`SourceOfHeat(hot_soup, metal_spoon)`"]}
{"id": "entailmentbank_validation_293", "nl": "if a thermal conductor is exposed to a source of heat, then thermal conduction will make the thermal conductor become hot.", "fol": "", "prediction": ["all x. ((ThermalConductor(x) & ExposedToHeatSource(x)) -> (ThermalConduction(x) -> BecomesHot(x)))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> BecomesHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> WillBecomeHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> ThermalConduction(x) & BecomesHot(x))"]}
{"id": "entailmentbank_validation_294", "nl": "the metal spoon will be heated up by thermal conduction.", "fol": "", "prediction": ["Heating(metal_spoon, thermal_conduction)", "exists x. (MetalSpoon(x) & willBeHeatedUpBy(x, ThermalConduction))", "Exists x. (MetalSpoon(x) & HeatedByThermalConduction(x))", "Exists y. (MetalSpoon(y) & HeatedUpByConduction(y))"]}
{"id": "entailmentbank_validation_295", "nl": "thermal conduction is when heat flows from warmer object to cooler object.", "fol": "", "prediction": ["all x y. ((WarmerObject(x) & CoolerObject(y) & HeatFlows(x, y)) <-> ThermalConduction(HeatFlow(x, y)))", "all x, y. (ThermalConduction(x, y) <-> (HeatFlowsFromTo(x, y) & Warmer(x) & Cooler(y)))", "all x y. ((Warmer(x) & Cooler(y) & HeatFlowsFromTo(x, y)) <-> ThermalConduction(x, y))", "ThermalConduction(x) <-> exists y exists z. (HeatFlowsFromTo(x, y, z) & Warmer(y) & Cooler(z))"]}
{"id": "entailmentbank_validation_296", "nl": "thermal conduction is when materials conduct heat through those materials through collision of particles.", "fol": "", "prediction": ["ThermalConduction(x) <-> (Materials(x) & ConductHeatThroughMaterials(x) & CollisionOfParticles(x))", "Exists m. (ThermalConduction(m) & all x. (Material(x) & ConductHeat(x, m) <-> HeatTransferByParticleCollision(x, m)))", "all x. (ThermalConduction(x) <-> (Material(x) & ConductsHeatThrough(x, x) & CollisionOfParticles(x)))", "all x. (Material(x) & ConductsHeatViaCollisionOfParticles(x) <-> ThermalConduction(x))"]}
{"id": "entailmentbank_validation_297", "nl": "thermal conduction is a heat exchange process involving the collision of particles.", "fol": "", "prediction": ["HeatExchangeProcess(thermal_conduction) & InvolvesParticleCollisions(thermal_conduction)", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, CollisionOfParticles)", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, ParticleCollision)", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, ParticleCollisions)"]}
{"id": "entailmentbank_validation_298", "nl": "longitudinal waves travel through pattern of compressions and rarefactions.", "fol": "", "prediction": ["all x. (LongitudinalWave(x) -> TravelsThroughPatternOf(Compressions(x) & Rarefactions(x)))", "FOL Translation:\nall x. (LongitudinalWave(x) -> TravelsThroughPattern(x, Compressions) & TravelsThroughPattern(x, Rarefactions))", "all x. (LongitudinalWave(x) -> exist y. (Pattern(y) & TravelThrough(x, y) & Compr(y) & Raref(y)))", "exists y. (LongitudinalWave(y) -> exists x. (Pattern(x) & TravelThrough(y, x) & CompressionsIn(x) & RarefactionsIn(x)))"]}
{"id": "entailmentbank_validation_299", "nl": "compression waves produces compressions and rarefactions.", "fol": "", "prediction": ["all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compressions) & Produces(x, Rarefactions)))", "all x. (CompressionWave(x) -> (Produces(x, Compressions) & Produces(x, Rarefactions)))"]}
{"id": "entailmentbank_validation_300", "nl": "longitudinal waves are also called compression waves.", "fol": "", "prediction": ["all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))"]}
{"id": "entailmentbank_validation_301", "nl": "longitudinal waves cause object to move in the same direction of the wave.", "fol": "", "prediction": ["all x. (LongitudinalWave(x) -> exists y. (Object(y) & CausesToMoveInSameDirection(x, y)))", "all x y. (LongitudinalWave(x) & Object(y) & AffectedBy(x, y) -> MovesInSameDirection(y, x))", "all x y. (LongitudinalWave(x) & Object(y) & Causes(x, MoveInSameDirection(y, x)))", "all w. (LongitudinalWave(w) -> all o. (CausesToMoveInDirectionOfWave(w, o)))"]}
{"id": "entailmentbank_validation_302", "nl": "compression waves cause object to move in the same direction of the wave.", "fol": "", "prediction": ["all x. (CompressionWave(x) & Object(y) & Causes(x, y) -> MovesInDirection(y, DirectionOf(x)))", "all x. all y. (CompressionWave(x) & Object(y) & CausesToMoveInSameDirection(x, y))", "all x y. (CompressionWave(x) & Object(y) & Causes(x, Move(y, DirectionOfWave(x))))", "all x. all y. ((CompressionWave(x) & Object(y) & Causes(x, Move(y))) -> MovesInSameDirectionAs(y, x))"]}
{"id": "entailmentbank_validation_303", "nl": "a surface is a part of an object.", "fol": "", "prediction": ["all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all s. (Surface(s) -> exists o. (Object(o) & PartOf(s, o)))"]}
{"id": "entailmentbank_validation_304", "nl": "friction occurs when two object's surfaces move against each other.", "fol": "", "prediction": ["all x, y. (Surface(x) & Surface(y) & MovesAgainst(x, y) -> FrictionOccurs(x, y))", "all x, y. ((Surface(x) & Surface(y) & MovesAgainst(x, y)) -> FrictionOccurs(x, y))", "all x all y. (Object(x) & Object(y) & MovesAgainstEachOther(Surfaces(x), Surfaces(y)) -> FrictionOccurs(x, y))", "all x, y. (Object(x) & Object(y) & MovesAgainstSurface(x, y) -> FrictionOccurs(x, y))"]}
{"id": "entailmentbank_validation_305", "nl": "skidding is when the tire of a vehicle slides on the road without rotating.", "fol": "", "prediction": ["all x. (Skidding(x) <-> (Tire(x) & Vehicle(y) & PartOf(x, y) & SlidesOnRoad(x) & -Rotating(x)))", "all z. (Skidding(z) <-> exists x, y. (Tire(x) & Vehicle(y) & PartOf(x, y) & SlidesOnRoad(x) & -Rotates(x)))", "all x. (Skidding(x) <-> exists y, z. (TireOf(y, z) & Vehicle(y) & SlidesOnRoad(z) & -Rotates(z)))", "all x. (Skidding(x) <-> (Tire(x) & Vehicle(y) & PartOf(x, y) & SlidesOn(x, road) & -Rotating(x)))"]}
{"id": "entailmentbank_validation_306", "nl": "a tire is a kind of object.", "fol": "", "prediction": ["all x. (Tire(x) -> Object(x))", "all x. (Tire(x) -> Object(x))", "Object(tire)", "Object(tire)"]}
{"id": "entailmentbank_validation_307", "nl": "skidding causes friction between the tire and the road.", "fol": "", "prediction": ["exists x exists y exists z. (Skidding(x) & Tire(y) & Road(z) & CausesFriction(x, y, z))", "all x. all y. (Skidding(x, y) -> Causes(Friction(x, y), Between(Tire(x), Road(y))))", "exists x exists y. (Tire(x) & Road(y) & Skidding(x) & Causes(Skidding(x), Friction(x, y)))", "exists x, y. (Skidding(x) & Tire(y) & Road(z) & Causes(x, FrictionBetween(y, z)))"]}
{"id": "entailmentbank_validation_308", "nl": "friction causes the temperature of an object to increase.", "fol": "", "prediction": ["all x. (Object(x) & Friction(y, x) -> Causes(Friction(y, x), IncreaseTemperature(x)))", "all x. (FrictionCauses(x) -> exists y. (Object(y) & IncreasesTemperatureOf(x, y)))", "all x. (Friction(x) -> exists y. (Object(y) & IncreasesTemperature(y)))", "exists x. (Friction(x) -> all y. (Object(y) -> IncreasesTemperature(y)))"]}
{"id": "entailmentbank_validation_309", "nl": "friction causes the temperature of the tire to increase.", "fol": "", "prediction": ["exists x. exists y. (Friction(x) & Tire(y) & Causes(x, TemperatureIncrease(y)))", "exists x. exists y. (Friction(x) & Tire(y) -> CausesTemperatureIncrease(x, y))", "exists x, y. (Friction(x) & Tire(y) & Causes(x, IncreaseTemperature(y)))", "exists x. (Friction(x) & all y. (Tire(y) -> Causes(x, Increase(Temperature(y)))))"]}
{"id": "entailmentbank_validation_310", "nl": "if the tire overheats, some chemical in the tire will vaporized.", "fol": "", "prediction": ["all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & InTire(y, x) & Vaporizes(y)))", "exists x. (ChemicalInTire(x) & Overheats(tire) -> Vaporized(x))", "all t. (Tire(t) & Overheats(t) -> exists c. (Chemical(c) & In(t, c) & WillVaporize(c)))", "all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & In(x, y) & Vaporized(y)))"]}
{"id": "entailmentbank_validation_311", "nl": "if the temperature of the tire keeps increasing, the tire will overheat.", "fol": "", "prediction": ["all x. (Tire(x) & IncreasingTemperature(x) -> WillOverheat(x))", "all x. (Tire(x) & TemperatureIncreases(x) -> WillOverheat(x))", "all x. (Tire(x) & TemperatureIncreasing(x) -> Overheat(x))", "all x. ((Tire(x) & IncreasingTemperature(x)) -> Overheats(x))"]}
{"id": "entailmentbank_validation_312", "nl": "if the temperature of the tire keeps increasing, some chemical in the tire will be vaporized.", "fol": "", "prediction": ["all x. (Tire(x) & TemperatureOf(x, t) & Increasing(t) -> exists y. (Chemical(y) & In(x, y) & WillBeVaporized(y)))", "all t. ((Tire(t) & Increases(Temperature(t))) -> exists c. (Chemical(c) & InTire(c, t) & WillBeVaporized(c)))", "all x. (Tire(x) & IncreasesTemperature(x) -> exists y. (Chemical(y) & InTire(y, x) & WillBeVaporized(y)))", "all x. ((Tire(x) & TemperatureIncreasing(x)) -> exists y. (ChemicalInTire(y, x) & WillBeVaporized(y)))"]}
{"id": "entailmentbank_validation_313", "nl": "friction causes some chemicals in the tire to vaporize.", "fol": "", "prediction": ["exists x. (ChemicalInTire(x) & all y. (Friction(y) -> Causes(y, Vaporize(x))))", "exists x exists y. (Chemical(x) & In(y, tire) & Causes(friction, Vaporize(x)))", "exists x. (Chemical(x) & InTire(x) & exists y. (Friction(y) & Causes(y, Vaporize(x))))", "exists x. (Chemical(x) & InTire(x) & FrictionCausesVaporize(x))"]}
{"id": "entailmentbank_validation_314", "nl": "vaporizing a substance causes smoke.", "fol": "", "prediction": ["all x. (Vaporizing(x) -> CausesSmoke(x))", "all x. (Substance(x) -> (Vaporizing(x) -> Causes(Vaporizing(x), Smoke(x))))", "all x. all y. (Vaporizes(x, y) -> CausesSmoke(y))", "all x. (Vaporizes(x, substance) -> Causes(x, Smoke))"]}
{"id": "entailmentbank_validation_315", "nl": "friction causes the tire to produce smoke.", "fol": "", "prediction": ["exists x exists y exists z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produces(y, z)))", "exists x exists y exists z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produces(y, z)))", "exists x exists y. (Friction(x) & Tire(y) & Causes(x, ProducesSmoke(y)))", "exists x. exists y. exists z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produce(y, z)))"]}
{"id": "entailmentbank_validation_316", "nl": "as the friction increases, the resistance on the object to move will increase.", "fol": "", "prediction": ["all x y. ((FrictionIncreases(x, y)) -> ResistanceToMoveIncreases(y))", "all x. (FrictionIncreases(x) -> ResistanceToMoveIncreases(x))", "all x y. (FrictionIncreases(x) & OnObject(y) -> ResistanceIncreases(y))", "all x. (FrictionIncreases(x) -> ResistanceToMoveIncreases(x))"]}
{"id": "entailmentbank_validation_317", "nl": "as roughness of a surface increases, friction will increase.", "fol": "", "prediction": ["all x. (Surface(x) & IncreasesRoughness(x) -> IncreasesFriction(x))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))"]}
{"id": "entailmentbank_validation_318", "nl": "as the roughness of a surface increases, the resistance on the object to move will increase.", "fol": "", "prediction": ["all x y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y, x)))", "all x, y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y)))", "all x y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMoveOn(y, x)))", "all x y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y, x)))"]}
{"id": "entailmentbank_validation_319", "nl": "carpet has a rough surface.", "fol": "", "prediction": ["Surface(carpet, rough)", "exists x. (Carpet(x) & RoughSurface(x))", "exists x. (Carpet(x) & HasRoughSurface(x))", "exists x. (Surface(x) & Rough(x) & BelongsTo(x, carpet))"]}
{"id": "entailmentbank_validation_320", "nl": "wood has a smooth surface.", "fol": "", "prediction": ["HasSmoothSurface(wood)", "SmoothSurface(wood)", "HasSmoothSurface(wood)", "SmoothSurface(wood)"]}
{"id": "entailmentbank_validation_321", "nl": "the resistance on the object to move on the carpet will be larger than on the wood.", "fol": "", "prediction": ["exists x, y, z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))", "exists x. exists y. exists z. (Object(x) & Carpet(y) & Wood(z) & ResistanceOn(x, y, r1) & ResistanceOn(x, z, r2) & r1 > r2)", "exists x, y, z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x, y, z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))"]}
{"id": "entailmentbank_validation_322", "nl": "a toy car is a kind of object.", "fol": "", "prediction": ["ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(toy_car) & Object(toy_car)"]}
{"id": "entailmentbank_validation_323", "nl": "the resistance on the toy car to move on the carpet is larger than on the wood.", "fol": "", "prediction": ["exists x, y, z, w. (ToyCar(x) & Carpet(y) & Wood(z) & Resistance(x, y) = w & Resistance(x, z) = r & Larger(w, r))", "exists x. (ToyCar(x) & all y. (Carpet(y) -> Resistance(x, y, carpet) > Resistance(x, wood)))", "Larger(Resistance(ToyCar, Carpet), Resistance(ToyCar, Wood))", "exists t. (ToyCar(t) & exists c. (Carpet(c) & exists w. (Wood(w) & Larger(Resistance(t, c), Resistance(t, w)))))"]}
{"id": "entailmentbank_validation_324", "nl": "as the resistance on the object to move increase, the object will move slower.", "fol": "", "prediction": ["exists x. (Object(x) & all y. (ResistanceToMove(y, x) & Increase(y) -> MovesSlower(x)))", "all x, y. (Object(x) & ResistanceIncrease(y, x) -> MoveSlower(x))", "all x. all y. ((Object(x) & ResistanceIncrease(y, x)) -> MovesSlower(x))", "all x. (Object(x) & IncreasesResistance(x) -> MovesSlower(x))"]}
{"id": "entailmentbank_validation_325", "nl": "the toy car will move slower on the carpet than on the wood.", "fol": "", "prediction": ["exists x. (ToyCar(x) & exists y. (Carpet(y) & exists z. (Wood(z) & MovesSlowerOn(x, y, z))))", "exists x. exists y. exists z. (ToyCar(x) & Carpet(y) & Wood(z) & SlowerOn(x, y, z))", "exists x. (ToyCar(x) & all y, z. ((Carpet(y) & Wood(z)) -> MovesSlowerOn(x, y, z)))", "Exists car. Exists carpet. Exists wood. ToyCar(car) & Carpet(carpet) & Wood(wood) & MovesOn(car, carpet, slower) & MovesOn(car, wood, faster) & slower < faster"]}
{"id": "entailmentbank_validation_326", "nl": "a glider is a kind of object.", "fol": "", "prediction": ["Object(glider)", "Glider(glider) & all x. (Glider(x) -> Object(x))", "Object(glider)", "Object(glider)"]}
{"id": "entailmentbank_validation_327", "nl": "flying an object requires lift to oppose the object's weight.", "fol": "", "prediction": ["all x. (Object(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Object(x) -> (exists y. (Fly(x, y) -> RequiresLift(y, Weight(x)))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "FOL Translation:\nall x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))"]}
{"id": "entailmentbank_validation_328", "nl": "flying a glider requires lift to oppose the weight of the glider.", "fol": "", "prediction": ["all x. (Glider(x) -> (Requires(Flying(x), Lift) & Opposes(Lift, Weight(x))))", "all x. (FlyingGlider(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Glider(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. (Glider(x) -> (exists y. (Lift(y) & Opposes(y, Weight(x)) -> CanFly(x))))"]}
{"id": "entailmentbank_validation_329", "nl": "pedals are part of a bicycle for pedalling.", "fol": "", "prediction": ["all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedForPedalling(x)))", "all p. (Pedal(p) -> exists b. (Bicycle(b) & PartOf(p, b) & UsedFor(p, Pedalling)))"]}
{"id": "entailmentbank_validation_330", "nl": "pedalling a bicycle requires moving the pedals in a circular motion.", "fol": "", "prediction": ["all x. (Bicycle(x) -> (Pedalling(x) -> Requires(MovePedalsInCircularMotion(x))))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (PedallingBicycle(x) -> requires(x, exists y. (Pedal(y) & MovingInCircularMotion(y))))", "FOL Translation:\nall x. (Bicycle(x) & Pedalling(x) -> Requires(MovePedalsCircularly(x)))"]}
{"id": "entailmentbank_validation_331", "nl": "the pedals are the part of a bicycle that moves in circular motion.", "fol": "", "prediction": ["all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. ((Pedal(x) & PartOf(x, bicycle)) -> MovesInCircularMotion(x))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & MovesInCircularMotion(x)))", "all x. ((PartOf(x, bicycle) & Pedals(x)) <-> MovesInCircularMotion(x))"]}
{"id": "entailmentbank_validation_332", "nl": "north / northward is a kind of direction.", "fol": "", "prediction": ["Direction(north)", "Direction(north)", "Direction(north)", "Direction(north)"]}
{"id": "entailmentbank_validation_333", "nl": "velocity is a measure of a speed in a direction.", "fol": "", "prediction": ["MeasureOf(velocity, speed, direction)", "Measure(velocity, exists x. (Speed(x) & InDirection(x)))", "Measure(velocity, SpeedInDirection)", "Measure(velocity, SpeedDirection)"]}
{"id": "entailmentbank_validation_334", "nl": "40 m/s describes the speed of an object.", "fol": "", "prediction": ["exists x. (Object(x) & SpeedOf(x, 40_m/s))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & SpeedOf(x, 40))"]}
{"id": "entailmentbank_validation_335", "nl": "40 m/s north describes the velocity of an object.", "fol": "", "prediction": ["exists x. (Object(x) & Velocity(x, 40, north))", "exists x. (Object(x) & VelocityOf(x, 40, m/s, north))", "exists x. (Object(x) & DescribesVelocity(40mps_north, x))", "exists y. (Object(y) & Velocity(y, north) & Magnitude(y, 40))"]}
{"id": "entailmentbank_validation_336", "nl": "inherited characteristics can deterimne the structure of an organism's anatomy.", "fol": "", "prediction": ["all x. (InheritedCharacteristics(x) -> exists y. (Organism(y) & DetermineStructure(x, Anatomy(y))))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructure(x, Anatomy(y)))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructureOfAnatomy(x))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructure(x, OrganismAnatomy(y)))"]}
{"id": "entailmentbank_validation_337", "nl": "the structure of an organism's anatomy is used to classify the organism into the appropriate taxonomic rank.", "fol": "", "prediction": ["all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, y) & AppropriateTaxonomicRank(y)))", "all x. (Organism(x) -> exists y. (Structure(x, y) & UsedForClassification(y, x)))", "all x. (Organism(x) -> exists y. (StructureAnatomyOfOrganism(y, x) & UsedToClassify(y, x)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(y, x) & UsedToClassify(y, x)))"]}
{"id": "entailmentbank_validation_338", "nl": "inherited characteristics can be used to classify an oganism into the apropriate taxonomic rank.", "fol": "", "prediction": ["all x. ((InheritedCharacteristics(x) & Organism(x)) -> exists y. (TaxonomicRank(y) & ClassifiesTo(x, y)))", "all x. (Characteristic(x) & Inherited(x) -> exists y. (Organism(y) & UsedToClassify(x, y) & ClassifyToAppropriateTaxonomicRank(y)))", "all x y. (Organism(x) & InheritedCharacteristics(y, x) -> CanUseToClassify(y, x))", "all c. (InheritedCharacteristic(c) -> exists o, r. (Organism(o) & TaxonomicRank(r) & CanBeUsedToClassify(c, o, r)))"]}
{"id": "entailmentbank_validation_339", "nl": "genes are able to determine the inherited characteristics of a living thing.", "fol": "", "prediction": ["all x. (Gene(x) -> CanDetermineInheritedCharacteristicsOfLivingThing(x))", "all g, c, l. ((Gene(g) & Characteristic(c) & LivingThing(l)) -> Determines(g, c) & InheritedBy(c, l))", "all x. (Gene(x) -> CanDetermineInheritedCharacteristicsOfLivingThing(x))", "all x. (Gene(x) -> exists y. (LivingThing(y) & Determines(x, InheritedCharacteristics(y))))"]}
{"id": "entailmentbank_validation_340", "nl": "genes can be used for classifying organisms.", "fol": "", "prediction": ["all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, Organism))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))"]}
{"id": "entailmentbank_validation_341", "nl": "genes are made of dna.", "fol": "", "prediction": ["all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))"]}
{"id": "entailmentbank_validation_342", "nl": "dna can be used for classifying organisms.", "fol": "", "prediction": ["all x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "exists x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (DNA(x) -> CanBeUsedForClassifying(x, Organisms))", "all x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))"]}
{"id": "entailmentbank_validation_343", "nl": "dna is a kind of molecule.", "fol": "", "prediction": ["Kind(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)"]}
{"id": "entailmentbank_validation_344", "nl": "molecules are used for classifying organisms.", "fol": "", "prediction": ["all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))"]}
{"id": "entailmentbank_validation_345", "nl": "a frog is a kind of amphibian.", "fol": "", "prediction": ["Frog(x) -> Amphibian(x)", "Frog(x) -> Amphibian(x)", "Frog(x) -> Amphibian(x)", "Frog(x) -> Amphibian(x)"]}
{"id": "entailmentbank_validation_346", "nl": "a tadpole is a kind of young / baby frog.", "fol": "", "prediction": ["Tadpole(x) -> YoungFrog(x)", "Tadpole(x) -> YoungFrog(x)", "TadpoleIsYoungFrog(x) <-> (Tadpole(x) & YoungFrog(x))", "Frog(tadpole) & Young(tadpole)"]}
{"id": "entailmentbank_validation_347", "nl": "a tadpole is a kind of young amphibian.", "fol": "", "prediction": ["YoungAmphibian(tadpole)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(t) -> YoungAmphibian(t)", "Tadpole(x) -> YoungAmphibian(x)"]}
{"id": "entailmentbank_validation_348", "nl": "metamorphosis is when an amphibian changes from an immature form to an adult form.", "fol": "", "prediction": ["Metamorphosis(x) -> (exists y. (Amphibian(y) & ChangesFromImmatureToAdultForm(y)))", "all x. (Metamorphosis(x) -> exists y. (Amphibian(y) & ChangesFromTo(y, ImmatureForm, AdultForm)))", "all x. ((Amphibian(x) & UndergoesMetamorphosis(x)) -> (ChangesFrom(x, ImmatureForm(x), AdultForm(x))))", "all x. (Amphibian(x) & ChangesFromImmatureToAdult(x) -> Metamorphosis(x))"]}
{"id": "entailmentbank_validation_349", "nl": "an example of metamorphosis is when a tadpole changes from a an immature form to and adult form.", "fol": "", "prediction": ["MetamorphosisExample(tadpole, immature_form, adult_form)", "exists x, y, z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ChangesFromTo(y, z, ImmatureForm(y), AdultForm(y)))", "exists x y z. (ExampleOf(metamorphosis, x) & Tadpole(x) & ChangesFromTo(x, y, z) & ImmatureForm(y) & AdultForm(z))", "exists x y z. (ExampleOf(metamorphosis, x) & Tadpole(x) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(x, y, z))"]}
{"id": "entailmentbank_validation_350", "nl": "the immature form of a frog is called a tadpole.", "fol": "", "prediction": ["exists x. (Frog(x) & ImmatureForm(x, y) & Called(y, tadpole))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) -> Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) & Called(x, tadpole))"]}
{"id": "entailmentbank_validation_351", "nl": "the adult form of a tadpole is called a frog.", "fol": "", "prediction": ["all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))"]}
{"id": "entailmentbank_validation_352", "nl": "the imature form of a frog is called a tadpole and the adult form of a tadpole is called a frog.", "fol": "", "prediction": ["exists x. (ImmatureForm(x, frog) -> Called(x, tadpole)) & exists y. (AdultForm(y, tadpole) -> Called(y, frog))", "exists x, y. (ImmatureForm(x, frog) & Called(x, tadpole) & AdultForm(y, tadpole) & Called(y, frog))", "all x. (ImmatureFormOf(x, frog) -> Called(x, tadpole)) & all y. (AdultFormOf(y, tadpole) -> Called(y, frog))", "exists x. (ImmatureForm(x, frog) & Called(x, tadpole)) & exists y. (AdultForm(y, tadpole) & Called(y, frog))"]}
{"id": "entailmentbank_validation_353", "nl": "an example of metamorphosis is when a tadpole changes from a tadpole into a frog.", "fol": "", "prediction": ["exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x, y. (MetamorphosisExample(x) & Tadpole(y) & ChangesInto(y, x, Frog(x)))", "exists x. exists y. (MetamorphosisExample(x, y) & Tadpole(x) & Frog(y) & ChangesInto(x, y))", "exists x. (Metamorphosis(x) & ExampleOf(x, \"tadpole changes into frog\"))"]}
{"id": "entailmentbank_validation_354", "nl": "reproduction occurs during adulthood.", "fol": "", "prediction": ["all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> CanReproduce(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))"]}
{"id": "entailmentbank_validation_355", "nl": "an example of reproduction is laying eggs.", "fol": "", "prediction": ["exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (Reproduction(x) & ExampleOf(x, LayingEggs))", "exists x. (ExampleOfReproduction(x) & LayingEggs(x))"]}
{"id": "entailmentbank_validation_356", "nl": "laying eggs occurs during adulthood.", "fol": "", "prediction": ["all x. (Adult(x) -> OccursDuring(LayingEggs, x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> OccursDuring(LayingEggs, x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))"]}
{"id": "entailmentbank_validation_357", "nl": "adulthood is a stage in the life cycle process.", "fol": "", "prediction": ["LifeCycleStage(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "StageInLifeCycle(adulthood)", "StageInLifeCycleProcess(adulthood)"]}
{"id": "entailmentbank_validation_358", "nl": "laying eggs occurs during the adult stage in the life cycle.", "fol": "", "prediction": ["all x. (LayingEggs(x) -> OccursDuring(x, AdultStage))", "all x. (LaysEggs(x) -> OccursDuring(x, AdultStage))", "all x. (AdultStage(x) -> Exists y. (LayingEggs(y) & OccursDuring(y, x)))", "all x. (AdultStage(x) -> OccursDuring(LayingEggs, x))"]}
{"id": "entailmentbank_validation_359", "nl": "a female insect lays eggs.", "fol": "", "prediction": ["exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Female(x) & Insect(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Female(x) & Insect(x) & LaysEggs(x))"]}
{"id": "entailmentbank_validation_360", "nl": "a female insect lays eggs during the adult stage of an insect's life cycle.", "fol": "", "prediction": ["exists x. (Insect(x) & Female(x) -> LaysEggsDuringAdultStage(x))", "exists x. (Insect(x) & Female(x) & exists y. (LaysEggs(x, y) & AdultStage(y) & LifeCycle(y, x)))", "exists x. (Insect(x) & Female(x) -> LaysEggsDuringAdultStage(x))", "exists x, y, z. (FemaleInsect(x) & LaysEggs(x, z) & AdultStage(y) & LifeCycleOf(z, y))"]}
{"id": "entailmentbank_validation_361", "nl": "a cat is a kind of mammal.", "fol": "", "prediction": ["all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))"]}
{"id": "entailmentbank_validation_362", "nl": "mammals give birth to live young.", "fol": "", "prediction": ["all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))"]}
{"id": "entailmentbank_validation_363", "nl": "a cat gives birth to live young.", "fol": "", "prediction": ["all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))"]}
{"id": "entailmentbank_validation_364", "nl": "to give birth to live young means to undergo live birth.", "fol": "", "prediction": ["all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))"]}
{"id": "entailmentbank_validation_365", "nl": "a cat undergoes live birth.", "fol": "", "prediction": ["exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))"]}
{"id": "entailmentbank_validation_366", "nl": "live birth means developing inside the mother instead of an egg.", "fol": "", "prediction": ["all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInsideEgg(x))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))"]}
{"id": "entailmentbank_validation_367", "nl": "a cat develops inside its mother.", "fol": "", "prediction": ["exists x. (Cat(x) -> DevelopsInside(x, Mother(x)))", "all x. (Cat(x) -> exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x. (Cat(x) -> DevelopsInside(x, MotherOf(x)))", "exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))"]}
{"id": "entailmentbank_validation_368", "nl": "the opposite of the same is different.", "fol": "", "prediction": ["all x. (Same(x, x) -> Different(x, x))", "all x. (Same(x, x) -> -Different(x, x))", "all x. (all y. (Same(x, y) <-> -Different(x, y)))", "all x. (Same(x, x) -> Different(x))"]}
{"id": "entailmentbank_validation_369", "nl": "two birds are not in the same taxonomic family.", "fol": "", "prediction": ["exists x. exists y. (Bird(x) & Bird(y) & -(x = y) & -SameTaxonomicFamily(x, y))", "exists x exists y. (Bird(x) & Bird(y) & -(x = y) & -SameTaxonomicFamily(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & -SameTaxonomicFamily(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & -(x = y) & -(TaxonomicFamily(x) = TaxonomicFamily(y)))"]}
{"id": "entailmentbank_validation_370", "nl": "two birds are in different taxonomic families.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & x \u2260 y & exists f, g. (TaxonomicFamily(x, f) & TaxonomicFamily(y, g) & f \u2260 g))", "exists x, y. (Bird(x) & Bird(y) & InDifferentTaxonomicFamilies(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & InDifferentFamilies(x, y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & - (x = y) & exists f1, f2. (TaxonomicFamily(f1) & TaxonomicFamily(f2) & InFamily(x, f1) & InFamily(y, f2) & - (f1 = f2)))"]}
{"id": "entailmentbank_validation_371", "nl": "environments with similar characteristics place similar environmental pressures on the organisms in them.", "fol": "", "prediction": ["all e1 e2 o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(o, e1)) -> SimilarPressures(e1, e2, o))", "all x. (Environment(x) & SimilarCharacteristics(x) -> all y. (OrganismIn(y, x) -> SimilarEnvironmentalPressure(y)))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(e1, o)) -> (PlacesEnvironmentalPressure(e1, o) & SimilarEnvironmentalPressures(e1, e2)))", "all e. ((Environment(e) & SimilarCharacteristics(e)) -> all o. ((OrganismIn(e, o) & SimilarEnvironmentalPressure(e, o))))"]}
{"id": "entailmentbank_validation_372", "nl": "two birds live in environments with similar characteristics.", "fol": "", "prediction": ["exists b1 exists b2. (Bird(b1) & Bird(b2) & b1 \u2260 b2 & exists e1 exists e2. (Environment(e1) & Environment(e2) & LivesIn(b1, e1) & LivesIn(b2, e2) & SimilarCharacteristics(e1, e2)))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & exists z, w. (Environment(z) & Environment(w) & SimilarCharacteristics(z, w) & LivesIn(x, z) & LivesIn(y, w)))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists z. (LivesIn(x, z) & LivesIn(y, z) & EnvironmentHasSimilarCharacteristics(z)))", "exists x. exists y. (Bird(x) & Bird(y) & SimilarCharacteristics(EnvironmentOf(x), EnvironmentOf(y)))"]}
{"id": "entailmentbank_validation_373", "nl": "two birds developed under similar environmental pressures.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & SimilarEnvironmentalPressures(x, y) & DevelopedUnder(x, SimilarEnvironmentalPressures(x, y)) & DevelopedUnder(y, SimilarEnvironmentalPressures(x, y)))"]}
{"id": "entailmentbank_validation_374", "nl": "two birds developed thousands of miles apart.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedThousandsOfMilesApart(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedApart(x, y) & Distance(x, y, thousands_of_miles)) & (x \u2260 y)", "exists x exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y) & x != y)"]}
{"id": "entailmentbank_validation_375", "nl": "if two things are thousands of miles apart then those two things are separate from each other.", "fol": "", "prediction": ["all x, y. (ThousandsOfMilesApart(x, y) -> Separate(x, y))", "all x. all y. ((ThousandsOfMilesApart(x, y)) -> Separate(x, y))", "all x y. ((ThousandMilesApart(x, y)) -> Separate(x, y))", "all x, y. ((ThousandsOfMilesApart(x, y)) -> Separate(x, y))"]}
{"id": "entailmentbank_validation_376", "nl": "two birds developed separate from each other.", "fol": "", "prediction": ["exists x. exists y. (Bird(x) & Bird(y) & x != y & DevelopedSeparateFrom(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x != y & DevelopedSeparateFrom(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedSeparate(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & Separate(x, y) & x != y & Developed(x) & Developed(y))"]}
{"id": "entailmentbank_validation_377", "nl": "two birds developed in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists b1, b2, e1, e2. (Bird(b1) & Bird(b2) & SeparateEnvironments(e1, e2) & DevelopedIn(b1, e1) & DevelopedIn(b2, e2) & SimilarEnvironmentalPressures(e1, e2))", "exists b1, b2, e1, e2. (Bird(b1) & Bird(b2) & SeparateEnvironment(e1) & SeparateEnvironment(e2) & DevelopedIn(b1, e1) & DevelopedIn(b2, e2) & SimilarEnvironmentalPressures(e1, e2))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))"]}
{"id": "entailmentbank_validation_378", "nl": "two birds from different taxonomic families developed in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & NotEqual(TaxonomicFamily(x), TaxonomicFamily(y)) & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x) & UnderSimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))"]}
{"id": "entailmentbank_validation_379", "nl": "convergent evolution is when two species in different taxonomic families develop in different places under similar environmental pressures.", "fol": "", "prediction": ["Exists p1, p2, e1, e2, f1, f2. (Species(p1) & Species(p2) & DifferentTaxonomicFamily(p1, p2) & DevelopInDifferentPlaces(p1, e1) & DevelopInDifferentPlaces(p2, e2) & SimilarEnvironmentalPressures(e1, e2) -> ConvergentEvolution(p1, p2))", "exists x. exists y. (ConvergentEvolution(x, y) & Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x y. (Species(x) & Species(y) & DifferentTaxonomicFamily(x, y) & DevelopInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y) -> ConvergentEvolution(x, y))", "exists x, y. (ConvergentEvolution(x, y) <-> (Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)))"]}
{"id": "entailmentbank_validation_380", "nl": "an example of convergent evolution is two birds from different taxonomic families developing in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x exists y. (ConvergentEvolutionExample(x, y) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopsInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x exists y. (Bird(x) & Bird(y) & FromDifferentTaxonomicFamilies(x, y) & DevelopsInSeparateEnvironments(x, y) & ExperiencesSimilarEnvironmentalPressures(x, y) & ExampleOfConvergentEvolution(x, y))", "Existential quantifiers must be used to show that there exist such birds, and predicates are necessary to represent various relations and concepts involved in the sentence. Here's the FOL translation:\n\nexists x exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & SeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) & ConvergentEvolutionExample(x, y))", "exists x y. (ConvergentEvolutionExample(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))"]}
{"id": "entailmentbank_validation_381", "nl": "winter is a kind of season.", "fol": "", "prediction": ["Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)"]}
{"id": "entailmentbank_validation_382", "nl": "seasons cause change to the environment.", "fol": "", "prediction": ["all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all s. (Season(s) -> exists e. (Environment(e) & CausesChangeTo(s, e)))", "all s. (Season(s) -> exists e. (Environment(e) & CausesChangeTo(s, e)))", "FOL Translation:\nall z. (Season(z) -> exists w. (Environment(w) & CausesChange(z, w)))"]}
{"id": "entailmentbank_validation_383", "nl": "the winter season can cause change to the environment.", "fol": "", "prediction": ["exists w. (WinterSeason(w) & CanCauseChangeToEnvironment(w))", "exists y. (WinterSeason(y) -> exists z. (Environment(z) & CanCauseChangeTo(y, z)))", "exists x. (WinterSeason(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "exists x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))"]}
{"id": "entailmentbank_validation_384", "nl": "usually plants die or become dormant during the winter.", "fol": "", "prediction": ["To translate the sentence 'usually plants die or become dormant during the winter' into first-order logic, we need to capture the idea of occurrence that is usual but not universal. Normally, first-order logic does not directly express probabilistic concepts like \"usually,\" but we can suggest that most or many instances of plants follow this pattern. A possible approach is to use a more general statement with a quantifier suggestive of many rather than all.\n\nHowever, sticking with classic FOL, we can simplify the statement as capturing a general behavior of plants during winter:\n\n```FOL\nall x. (Plant(x) -> (Winter() -> (Die(x) | BecomeDormant(x))))\n```\n\nNote:\n- `Plant(x)`: x is a plant.\n- `Winter()`: It is winter.\n- `Die(x)`: x dies.\n- `BecomeDormant(x)`: x becomes dormant.\n\nThis formula reads: For all x, if x is a plant, then during winter, the plant either dies or becomes dormant. This captures the general tendency without stressing strict universal application.", "all x. (Plant(x) -> (Usually(Winter(w)) -> (Dies(x) | BecomesDormant(x, w))))", "all x. (Plant(x) -> (Winter() -> (Die(x) | BecomeDormant(x))))", "all x. (Plant(x) -> (Usually(Winter) -> (Dies(x) | Dormant(x))))"]}
{"id": "entailmentbank_validation_385", "nl": "an example of a seasonal change is plants dying or becoming dormant in the winter.", "fol": "", "prediction": ["exists x. (ExampleOf(x, SeasonalChange) & (Winter(w) & (PlantsDieInWinter(x, w) | PlantsBecomeDormantInWinter(x, w))))", "exists x. (SeasonalChange(x) & ExampleOf(x, (all y. (Plant(y) -> (DiesInWinter(y) | DormantInWinter(y))))))", "exists x. (SeasonalChange(x) & ExampleOf(x, y) & (all y. (Plant(y) & (DiesInWinter(y) | BecomesDormantInWinter(y)))))", "exists x. (SeasonalChange(x) & ExampleOf(y, x) & (Dying(plants, winter) | BecomingDormant(plants, winter)))"]}
{"id": "entailmentbank_validation_386", "nl": "an animal requires enough nutrients to survive.", "fol": "", "prediction": ["all x. (Animal(x) -> (exists y. (Nutrients(y) & Requires(x, y) & Enough(y) -> Survive(x))))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y, x) -> Survive(x)))", "all x. (Animal(x) -> (exists y. (Nutrients(y) & Requires(x, y) & Enough(y))) -> Survive(x))", "all x. (Animal(x) -> exists y. (Nutrient(y) & RequiresToSurvive(x, y)))"]}
{"id": "entailmentbank_validation_387", "nl": "eating food is used to get nutrients by animals.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Food(y) & Eating(y, x) & UsedToGetNutrients(Eating(y, x))))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eat(x, y), x)))", "all a. (Animal(a) -> exists f, n. (Food(f) & Nutrient(n) & Eating(f, a, n)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eating(y, x))))"]}
{"id": "entailmentbank_validation_388", "nl": "an animal needs to eat food for nutrients.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & ProvidesNutrients(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))"]}
{"id": "entailmentbank_validation_389", "nl": "plants are a source of food for animals.", "fol": "", "prediction": ["all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))"]}
{"id": "entailmentbank_validation_390", "nl": "an animal can eat plants for nutrients.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> CanEatPlantsForNutrients(x))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))"]}
{"id": "entailmentbank_validation_391", "nl": "an example of seasonal change is some animals' food dying in the winter.", "fol": "", "prediction": ["exists a. (ExampleOf(a, SeasonalChange) & exists f. (AnimalFood(f) & Season(winter) & DiesInSeason(f, winter)))", "exists x. (SeasonalChangeExample(x) & SomeAnimalFood(y) & DiesInWinter(y) & ExampleOf(x, y))", "exists x. (SeasonalChangeExample(x) & Causes(x, exists y. (AnimalFood(y) & DiesInWinter(y))))", "exists x. (ExampleOfSeasonalChange(x) & exists y. (AnimalFood(y) & DiesInWinter(y) & ExampleOf(x, y)))"]}
{"id": "entailmentbank_validation_392", "nl": "an example of preparing is storing something for use later.", "fol": "", "prediction": ["Exists x. Exists y. (ExampleOfPreparing(x) & Store(y, x) & ForUseLater(y))", "exists x exists y. (PreparesExample(x) & StoresForLater(x, y))", "exists x. exists y. (ExampleOfPreparing(x) & Storing(y) & ForUseLater(y))", "exists x. (ExampleOfPreparing(x) & exists y. (Stores(y) & ForUseLater(y)))"]}
{"id": "entailmentbank_validation_393", "nl": "if an animal relies on plants for food then that animal must store enough food to last through the winter.", "fol": "", "prediction": ["all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodThroughWinter(x))"]}
{"id": "entailmentbank_validation_394", "nl": "an example of preparing is an animal storing food to last through the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparing(x) & exists y. (Animal(y) & StoresFood(y) & LastsThroughWinter(y) & StoresFoodFor(x, y)))", "exists x. (ExampleOfPreparing(x) & exists y. (Animal(y) & StoresFood(y) & ToLastThroughWinter(y)))", "exists x. (ExampleOfPreparing(x) & exists y. (Animal(y) & StoresFood(y) & ToLastThroughWinter(y) & x = y))", "exists x. (ExampleOfPreparing(x) & exists y. (Animal(y) & StoresFoodForWinter(y)))"]}
{"id": "entailmentbank_validation_395", "nl": "an example of preparing for seasonal change is an animal storing food for the winter.", "fol": "", "prediction": ["Exists e. (ExampleOfPreparingForSeasonalChange(e) & exists x. (Animal(x) & StoresFoodForWinter(x) & e = x))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & StoringFoodForWinter(x))", "exists x. exists y. (ExampleOfPreparingForSeasonalChange(x) & Animal(y) & StoresFoodForWinter(y) & IsExampleOf(x, StoresFoodForWinter(y)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Animal(x) & StoresFoodForWinter(x))"]}
{"id": "entailmentbank_validation_396", "nl": "a squirrel is a kind of animal.", "fol": "", "prediction": ["Squirrel(s) -> Animal(s)", "Animal(squirrel)", "Animal(squirrel)", "Animal(squirrel)"]}
{"id": "entailmentbank_validation_397", "nl": "an example of preparing for seasonal change is a squirrel storing food for the winter.", "fol": "", "prediction": ["exists x. (Example(x) & PreparingForSeasonalChange(x) & exists y. (Squirrel(y) & StoresFoodForWinter(y)))", "exists x, y. (Example(x) & PreparationForSeasonalChange(x) & Squirrel(y) & StoresFood(y) & ForWinter(y) & InstanceOf(x, y))", "exists x, y. (PreparingForSeasonalChange(x) & Squirrel(y) & StoresForWinter(y) & ExampleOf(x, Activity(y)))", "exists x. (ExampleOf(x, PreparingForSeasonalChange) & Squirrel(y) & StoresFor(y, Food, Winter) & HasExample(x, y))"]}
{"id": "entailmentbank_validation_398", "nl": "nut is a kind of food.", "fol": "", "prediction": ["Food(nut)", "KindOfFood(nut)", "Food(nut)", "Food(nut)"]}
{"id": "entailmentbank_validation_399", "nl": "an example of preparing for seasonal change is an squirrel storing nuts for the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Squirrel(y) & StoresNutsForWinter(y) & InstanceOf(x, StoresNutsForWinter(y))))", "ExampleOfPreparingForSeasonalChange(squirrel_nuts_storage, squirrel_stores_nuts_for_winter)", "InvolvesPreparingForSeasonalChange(squirrel, storingNutsForWinter)", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresNutsForWinter(y) & ExampleOf(y, x))"]}
{"id": "entailmentbank_validation_400", "nl": "an animal requires warmth for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))"]}
{"id": "entailmentbank_validation_401", "nl": "winter has cold temperatures / weather.", "fol": "", "prediction": ["Winter(winter) -> Cold(Temperature)", "Cold(winter)", "Cold(winter)", "Cold(winter)"]}
{"id": "entailmentbank_validation_402", "nl": "some animals must move to warmer climates in the winter.", "fol": "", "prediction": ["exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))"]}
{"id": "entailmentbank_validation_403", "nl": "migration is when animals move themselves from a cooler climate to a warmer climate for the winter.", "fol": "", "prediction": ["all x. (Migration(x) <-> (Animal(x) & MoveFromTo(x, cooler_climate, warmer_climate) & ForSeason(x, winter)))", "all x. (Animal(x) & Migration_for_Winter(x) <-> Move(x, CoolerClimate(x), WarmerClimate(x)))", "all x. (Migration(x) <-> (Animal(x) & Move(x) & FromClimateToClimate(x, cooler, warmer) & ForSeason(x, winter)))", "Migration(x) <-> (exists y. exists z. (Animal(x) & CoolerClimate(y) & WarmerClimate(z) & MoveToForWinter(x, y, z)))"]}
{"id": "entailmentbank_validation_404", "nl": "an example of migration is moving to a warmer climate in the winter.", "fol": "", "prediction": ["exists x. (ExampleOfMigration(x) & MovingToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovingToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovingToWarmerClimateInWinter(x))", "exists x y. (ExampleOfMigration(x) & (MoveToWarmerClimateInWinter(y) & Example(x, y)))"]}
{"id": "entailmentbank_validation_405", "nl": "some birds fly south for the winter.", "fol": "", "prediction": ["exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))"]}
{"id": "entailmentbank_validation_406", "nl": "an example of migration is birds flying south in the winter.", "fol": "", "prediction": ["exists x. (MigrationExample(x) & BirdsFlyingSouthInWinter(x))", "ExampleOfMigration(birds_flying_south_in_the_winter)", "ExampleOfMigration(birds_flying_south_in_winter)", "Exists x. (ExampleOfMigration(x) & BirdsFlyingSouthInWinter(x))"]}
{"id": "entailmentbank_validation_407", "nl": "migration is a kind of adaptation.", "fol": "", "prediction": ["KindOf(migration, adaptation)", "Adaptation(migration)", "KindOf(migration, adaptation)", "Adaptation(migration)"]}
{"id": "entailmentbank_validation_408", "nl": "an example of an adaptation is birds migrating south in the winter.", "fol": "", "prediction": ["exists x. (Adaptation(x) & ExampleOf(x, Migration(birds, south, winter)))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigratingSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))"]}
{"id": "entailmentbank_validation_409", "nl": "wasp's stinger contains poison.", "fol": "", "prediction": ["exists x. (WaspStinger(x) -> ContainsPoison(x))", "", "exists x. (Stinger(x) & BelongsTo(x, wasp) & Contains(x, poison))", "Exists x. (Wasp(x) & Contains(Stinger(x), Poison))"]}
{"id": "entailmentbank_validation_410", "nl": "poison causes harm to living things.", "fol": "", "prediction": ["all x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarmTo(y, x))))", "all x. (LivingThing(x) & Poison(p) -> CausesHarmTo(p, x))", "all x. (LivingThing(x) -> exists y. (Poison(y) & CausesHarm(y, x)))", "all x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarmTo(y, x))))"]}
{"id": "entailmentbank_validation_411", "nl": "a wasp's stinger can be used to cause harm to living things.", "fol": "", "prediction": ["exists x. (Wasp(x) & HasStinger(x) & all y. (LivingThing(y) -> CanCauseHarm(Stinger(x), y)))", "exists x. (Wasp(x) & hasStinger(x) & all y. (LivingThing(y) -> CanUseToCauseHarm(hasStinger(x), y)))", "exists x. (Wasp(x) & Stinger(s) & Owns(x, s) & all y. (LivingThing(y) -> CanCauseHarm(s, y)))", "exists x. (WaspStinger(x) -> exists y. (LivingThing(y) & CanCauseHarm(x, y)))"]}
{"id": "entailmentbank_validation_412", "nl": "harming is a kind of defense.", "fol": "", "prediction": ["all x. (Harming(x) -> Defense(x))", "all x. (Harming(x) -> Defense(x))", "Defense(harming)", "all x. (Harming(x) -> Defense(x))"]}
{"id": "entailmentbank_validation_413", "nl": "a stinger is used for defense by a wasp.", "fol": "", "prediction": ["exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. (Stinger(x) & UsedForDefenseBy(x, wasp))", "exists x. exists y. (Stinger(x) & Wasp(y) & UsedForDefenseBy(x, y))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))"]}
{"id": "entailmentbank_validation_414", "nl": "color is a property of an organism that describes what it looks like.", "fol": "", "prediction": ["all x. (Organism(x) -> exists p. (Property(p) & Describes(p, x, Appearance(x)) & Equals(p, Color(x))))", "all x. (Organism(x) -> exists y. (PropertyOf(y, x) & Color(y) & Describes(y, LooksLike(x))))", "all x. (Organism(x) -> exists y. (Property(y) & Color(y) & Describes(y, LooksLike(x))))", "all x. (Organism(x) -> exists y. (Property(y) & Color(y) & Describes(y, x) & LooksLike(y, x)))"]}
{"id": "entailmentbank_validation_415", "nl": "an example of camouflage is an organism looking like its environment.", "fol": "", "prediction": ["exists x. (CamouflageExample(x) & exists y. (Organism(y) & LooksLikeEnvironment(y, x)))", "exists x. (CamouflageExample(x) & Organism(x) & LooksLike(x, Environment(x)))", "exists x. exists y. (ExampleOfCamouflage(x) & Organism(x) & LooksLike(x, y) & Environment(y))", "exists x. ((ExampleOfCamouflage(x) & Organism(x)) & exists y. (Environment(y) & LooksLike(x, y)))"]}
{"id": "entailmentbank_validation_416", "nl": "an example of camouflage is organism having the same color as its environment.", "fol": "", "prediction": ["exists x. (ExampleOfCamouflage(x) & Exists y. (Organism(y) & HasSameColorAsEnvironment(y)))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y, x)))", "exists x. (CamouflageExample(x) & Organism(x) & HasColorAsEnvironment(x))", "exists x. (CamouflageExample(x) & Organism(x) & HasSameColorAsEnvironment(x))"]}
{"id": "entailmentbank_validation_417", "nl": "if an animal's skin is a certain color then that animal is that color.", "fol": "", "prediction": ["all x. (exists c. (HasColorSkin(x, c) -> Color(x, c)))", "all x. all c. ((Animal(x) & SkinColor(x, c)) -> IsColor(x, c))", "all x, y. (Animal(x) & SkinColor(x, y) -> HasColor(x, y))", "all x. all c. (Animal(x) & HasColorSkin(x, c) -> IsColor(x, c))"]}
{"id": "entailmentbank_validation_418", "nl": "an example of camouflage is an animal's skin having the same color as its environment.", "fol": "", "prediction": ["exists x, y, z. (ExampleOf(x, Camouflage) & Animal(y) & SkinOf(y, z) & HasColor(z, Color(w)) & EnvironmentOf(y, w)) \n\nNote: \n- `ExampleOf(x, Camouflage)` implies x is an example of camouflage.\n- `Animal(y)` implies y is the animal.\n- `SkinOf(y, z)` implies z is the skin of animal y.\n- `HasColor(z, Color(w))` implies skin z has the same color as w.\n- `EnvironmentOf(y, w)` implies w is the environment of the animal y.", "exists x. exists y. (ExampleOfCamouflage(x) & Animal(y) & HasSkin(y, x) & MatchesColor(x, Environment(y)))", "exists x, y. (ExampleOf(x, Camouflage) & AnimalSkin(y) & Color(y, Environment(y)) & PartOf(y, x))", "exists x. exists y. (CamouflageExample(x, y) & Animal(x) & SkinOf(x, y) & Color(y, z) & Environment(x, z))"]}
{"id": "entailmentbank_validation_419", "nl": "camouflage is a kind of adaptation for hiding in an environment.", "fol": "", "prediction": ["all x. (Camouflage(x) -> exists y. (Adaptation(y) & ForHidingInEnvironment(y)))", "all x. (Camouflage(x) -> KindOfAdaptation(x) & UsedFor(x, HidingInEnvironment))", "KindOf(camouflage, adaptation) & Purpose(camouflage, hiding) & For(camouflage, environment)", "Adaptation(camouflage) & ForHidingIn(camouflage, environment)"]}
{"id": "entailmentbank_validation_420", "nl": "an animal having the same skin color as its environment is an adaptation for hiding in an environment.", "fol": "", "prediction": ["all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHiding(x, y))", "all x. (Animal(x) & exists y. (SkinColor(x, y) & Environment(z) & SameColor(y, z)) -> AdaptationForHidingInEnvironment(x, z))", "all x. ((Animal(x) & exists y. (SkinColor(x) = EnvironmentColor(y))) -> AdaptationForHiding(x, y))", "all x. ((Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y))) -> AdaptationForHiding(x, y))"]}
{"id": "entailmentbank_validation_421", "nl": "predators usually must see their prey in order to catch them.", "fol": "", "prediction": ["all x. (Predator(x) -> UsuallyMustSeePreyToCatch(x))", "all x. (Predator(x) -> (Usually(See(x, PreyOf(x))) & Must(See(x, PreyOf(x)) & Catch(x, PreyOf(x)))))", "all p. (Predator(p) -> usually(exists q. (Prey(q) & MustSee(p, q) -> CanCatch(p, q))))", "all x. (Predator(x) -> (exists y. (Prey(y) & MustSeeToCatch(x, y))))"]}
{"id": "entailmentbank_validation_422", "nl": "hiding means visibility / ability to be seen decreases for camouflage.", "fol": "", "prediction": ["all x. (Hiding(x) -> (Visibility(x) | AbilityToBeSeen(x)) DecreasesForCamouflage(x))", "FOL Translation:\nall x. (Hiding(x) -> (Camouflage(x) & Decreases(Visibility(x))))", "all x. (Hiding(x) -> DecreasesVisibility(x) & IncreasesCamouflage(x))", "all x. (Hiding(x) -> (Decreases(Visibility(x)) & Camouflage(x)))"]}
{"id": "entailmentbank_validation_423", "nl": "hiding can be used to avoid being seen by predators.", "fol": "", "prediction": ["all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x y. (Hiding(x) & Predator(y) & CanBeUsedToAvoid(x, SeenBy(x, y)))", "FOL Translation:\nall x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))"]}
{"id": "entailmentbank_validation_424", "nl": "not being seen by predators is a kind of protection against predators.", "fol": "", "prediction": ["`all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))`", "all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "FOL Translation:\nall x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "all x. (ProtectionAgainstPredators(x) <-> NotSeenByPredators(x))"]}
{"id": "entailmentbank_validation_425", "nl": "hiding is a kind of protection against predators.", "fol": "", "prediction": ["all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))"]}
{"id": "entailmentbank_validation_426", "nl": "an animal having the same skin color as its environment is a kind of protection against predators.", "fol": "", "prediction": ["all x. all y. (Animal(x) & Environment(y) & SameColor(Skin(x), y) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> ProtectionAgainstPredators(x))", "all x. all y. ((Animal(x) & Environment(y) & HasSkinColor(x, Color(z)) & HasColor(y, Color(z))) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColor(x, y)) -> KindOfProtectionAgainstPredators(x))"]}
{"id": "entailmentbank_validation_427", "nl": "hiding means ability to be seen decreases for camouflage.", "fol": "", "prediction": ["all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> DecreasesAbilityToBeSeenForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))"]}
{"id": "entailmentbank_validation_428", "nl": "to blend into something means ability to be seen decreases when around that something.", "fol": "", "prediction": ["all x y. (BlendInto(x, y) -> DecreasesAbilityToBeSeen(x, y))", "all x. all y. (BlendInto(x, y) -> (AbilityToBeSeenDecreasesWhenAround(x, y)))", "all x, y. (BlendInto(x, y) -> DecreasesVisibility(x, y))", "all x y. (BlendsInto(x, y) -> (AbilityToBeSeenDecreases(x, y) & Around(x, y)))"]}
{"id": "entailmentbank_validation_429", "nl": "to blend into something means to hide in something.", "fol": "", "prediction": ["all x all y. (BlendsInto(x, y) <-> HidesIn(x, y))", "all x, y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))", "all x. all y. (BlendsInto(x, y) <-> HidesIn(x, y))"]}
{"id": "entailmentbank_validation_430", "nl": "white fur blends into snow.", "fol": "", "prediction": ["all x. (HasWhiteFur(x) & IsSnowyEnvironment(y) -> BlendsInto(x, y))", "all x. (HasWhiteFur(x) -> BlendsInto(x, snow))", "all x. (WhiteFur(x) & Snow(y) -> BlendsInto(x, y))", "all x. (WhiteFur(x) & Snow(y) -> BlendsInto(x, y))"]}
{"id": "entailmentbank_validation_431", "nl": "an example of hiding is white fur blending in with snow.", "fol": "", "prediction": ["exists x. (ExampleOfHiding(x) & BlendsInWith(x, snow) & HasWhiteFur(x))", "exists x. (ExampleOfHiding(x) & BlendsIn(x, Snow) & HasWhiteFur(x))", "exists x exists y. (ExampleOfHiding(x) & WhiteFur(x) & BlendsInWith(x, Snow(y)))", "exists x, y. (ExampleOf(x, Hiding) & WhiteFur(x) & BlendsIn(x, Snow(y)))"]}
{"id": "entailmentbank_validation_432", "nl": "an example of camouflage is white fur blending in with snow.", "fol": "", "prediction": ["exists x. (ExampleOfCamouflage(x) & BlendsIn(x, WhiteFur, Snow))", "exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsIn(x, snow))", "exists x. (ExampleOfCamouflage(x) & BlendsIn(x, white_fur, snow))", "exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsInWith(x, snow))"]}
{"id": "entailmentbank_validation_433", "nl": "some leaves have a speckled brown color.", "fol": "", "prediction": ["exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & HasSpeckledBrownColor(x))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))"]}
{"id": "entailmentbank_validation_434", "nl": "some birds have a speckled brown color.", "fol": "", "prediction": ["exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists z. (Bird(z) & SpeckledBrownColor(z))", "exists x. (Bird(x) & HasColor(x, speckled_brown))"]}
{"id": "entailmentbank_validation_435", "nl": "some birds look like leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))"]}
{"id": "entailmentbank_validation_436", "nl": "something that looks like another thing is difficult to distinguish from that thing.", "fol": "", "prediction": ["exists x. exists y. ((LooksLike(x, y) & Thing(x) & Thing(y)) -> DifficultToDistinguishFrom(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))"]}
{"id": "entailmentbank_validation_437", "nl": "some birds are difficult to distinguish from leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguish(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguish(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))"]}
{"id": "entailmentbank_validation_438", "nl": "difficult to distinguish can mean difficult to see in something else.", "fol": "", "prediction": ["exists x exists y. (Distinguish(x, y) & Means(DifficultToSeeIn(x, y)))", "all x. (DifficultToDistinguish(x) -> exists y. (DifficultToSeeIn(y, x)))", "", "all x, y. (DifficultToDistinguish(x, y) -> DifficultToSeeIn(x, y))"]}
{"id": "entailmentbank_validation_439", "nl": "some birds are difficult to see in leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))"]}
{"id": "entailmentbank_validation_440", "nl": "an example of camouflage is a bird looking like leaves.", "fol": "", "prediction": ["exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))", "exists x. (ExampleOfCamouflage(x) & BirdLikeLeaves(x))", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))"]}
{"id": "entailmentbank_validation_441", "nl": "camouflage is used for hiding by animals from predators.", "fol": "", "prediction": ["exists x. exists y. exists z. (Animal(x) & Camouflage(z) & Predator(y) & UsedFor(z, Hiding) & HidingFrom(x, y, z))", "exists x exists y exists z. (Camouflage(x) & UsedFor(x, Hiding(y, z)) & Animal(y) & Predator(z))", "all x. all y. all z. (Animal(y) & Predator(z) & UsesFor(y, camouflage, HidingFrom(y, z)) -> CamouflageUsed(y, z))", "all x. (Animal(x) & exists y. (Predator(y) & UsesCamouflageForHiding(x, y)))"]}
{"id": "entailmentbank_validation_442", "nl": "looking like leaves can be used by birds for hiding from predators.", "fol": "", "prediction": ["all x. (Bird(x) & UsesToHide(x, Predators) -> LookingLikeLeaves(x))", "all x. (LooksLikeLeaves(x) -> exists y. (Bird(y) & UsesForHidingFromPredators(y, x)))", "all x. (LooksLikeLeaf(x) & BirdUsesForHiding(x) -> HidesFromPredators(x))", "FOL Translation:\nall x. (Bird(x) & LooksLikeLeaves(x) -> CanUseForHidingFromPredators(x))"]}
{"id": "entailmentbank_validation_443", "nl": "hiding can be used to avoid something.", "fol": "", "prediction": ["all x. (Hiding(x) -> CanBeUsedToAvoid(x, y))", "all x. (Hiding(x) -> exists y. (Avoids(x, y)))", "all x. (CanBeUsedForHiding(x) -> exists y. (Avoid(y, x)))", "exists x y. (Hiding(x) & Avoids(x, y))"]}
{"id": "entailmentbank_validation_444", "nl": "looking like leaves can be used by birds for avoiding predators.", "fol": "", "prediction": ["exists x. (LooksLikeLeaves(x) & exists y. (Bird(y) & CanUseForAvoidingPredators(y, x)))", "all x. (LooksLikeLeaves(x) -> exists y. (Bird(y) & UsesForAvoidingPredators(y, x)))", "exists x. (Bird(x) & CanUse(x, LooksLikeLeaves, ForAvoidingPredators))", "exists x. (LooksLikeLeaves(x) & exists y. (Bird(y) & CanBeUsedForAvoidingPredators(x, y)))"]}
{"id": "entailmentbank_validation_445", "nl": "keeping warm is the opposite of becoming cold.", "fol": "", "prediction": ["Opposite(KeepingWarm, BecomingCold)", "all x. (KeepingWarm(x) <-> -BecomingCold(x))", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)"]}
{"id": "entailmentbank_validation_446", "nl": "if a living thing becomes too cold then that living thing will die.", "fol": "", "prediction": ["", "all x. (LivingThing(x) & BecomesTooCold(x) -> Dies(x))", "", ""]}
{"id": "entailmentbank_validation_447", "nl": "an animal usually requires warmth for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> UsuallyRequiresWarmthForSurvival(x))", "all x. (Animal(x) -> UsuallyRequiresWarmthForSurvival(x))", "all x. (Animal(x) -> Usually(RequiresWarmthForSurvival(x)))", "all x. (Animal(x) -> TypicallyRequiresWarmthForSurvival(x))"]}
{"id": "entailmentbank_validation_448", "nl": "if the environmental temperature is too cold then an animal in that environment may become cold.", "fol": "", "prediction": ["all x. all y. ((Environment(y) & Animal(x) & In(x, y) & TooCold(Temp(y))) -> MayBecomeCold(x))", "all x. all y. ((Environment(y) & TemperatureTooCold(y) & AnimalInEnvironment(x, y)) -> MayBecomeCold(x))", "all x. (Animal(x) -> (exists y. (Environment(y) & InEnvironment(x, y) & Temperature(y, cold))) -> MayBecomeCold(x))", "all e, a. ((Environment(e) & In(Animals(a, e)) & TooCold(e)) -> MayBecomeCold(a))"]}
{"id": "entailmentbank_validation_449", "nl": "an animal requires warmth in cold temperatures.", "fol": "", "prediction": ["all x. (Animal(x) & ColdTemperature(t) -> RequiresWarmth(x, t))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))"]}
{"id": "entailmentbank_validation_450", "nl": "thick fur can be used for keeping warm.", "fol": "", "prediction": ["all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "FOL Translation:\nall x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))"]}
{"id": "entailmentbank_validation_451", "nl": "thick fur can be used by animals for survival in cold temperatures.", "fol": "", "prediction": ["all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalInCold(x))", "all x. ((Animal(x) & Uses(x, ThickFur, SurvivalInCold)) -> Exists y. (Has(x, y) & ThickFur(y)))", "exists x. (Animal(x) & UsesForSurvival(x, thick_fur, cold_temperatures))", "all x. ((Animal(x) & HasThickFur(x)) -> CanUseForSurvivalInCold(x))"]}
{"id": "entailmentbank_validation_452", "nl": "winter has cold temperatures.", "fol": "", "prediction": ["ColdTemperatures(winter)", "Winter(w) & HasColdTemperatures(w)", "HasColdTemperatures(winter)", "ColdTemperatures(winter)"]}
{"id": "entailmentbank_validation_453", "nl": "thick fur can be used by animals for survival survival during winter.", "fol": "", "prediction": ["FOL Translation:\nall x. (Animal(x) & UsedForSurvivalDuringWinter(thick_fur, x) -> Exists(fur(x), (Thick(fur(x)))))", "all x. (Animal(x) & HasThickFur(x) -> CanBeUsedForSurvivalDuringWinter(x))", "exists x. (Animal(x) & ThickFur(x) & ForSurvivalInWinter(x))", "all x. (Animal(x) & HasThickFur(x) -> CanBeUsedForSurvival(x, winter))"]}
{"id": "entailmentbank_validation_454", "nl": "a bear is a kind of animal.", "fol": "", "prediction": ["Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Animal(bear)"]}
{"id": "entailmentbank_validation_455", "nl": "thick fur can be used by bears for survival during winter.", "fol": "", "prediction": ["FOL Translation:\nall x. (Bear(x) & ThickFur(x) -> UsedForSurvivalDuringWinter(x))", "all b. ((Bear(b) & HasThickFur(b)) -> CanUseForSurvivalDuringWinter(b))", "exists x. (ThickFur(x) & exists y. (Bear(y) & CanUseForSurvivalDuringWinter(y, x)))", "all x. (Bear(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))"]}
{"id": "entailmentbank_validation_456", "nl": "hunting is a kind of method for obtaining food.", "fol": "", "prediction": ["all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))"]}
{"id": "entailmentbank_validation_457", "nl": "animals require food for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> RequiresFoodForSurvival(x))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))"]}
{"id": "entailmentbank_validation_458", "nl": "some animals must hunt to survive.", "fol": "", "prediction": ["exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))"]}
{"id": "entailmentbank_validation_459", "nl": "hunting requires sensing prey.", "fol": "", "prediction": ["all x. (Hunting(x) -> exists y. (Prey(y) & Sensing(x, y)))", "all x. (Hunting(x) -> Requires(x, SensingPrey))", "Hunting(x) -> SensingPrey(x)", "all x. (Hunting(x) -> exists y. (Prey(y) & Senses(x, y)))"]}
{"id": "entailmentbank_validation_460", "nl": "better senses have a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. (Animal(x) & BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & HasBetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & BetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterSenses(x) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_461", "nl": "hearing is used for sensing sound by animals.", "fol": "", "prediction": ["all z. (Animal(z) -> SensesSoundUsing(hearing, z))", "all x. (Animal(x) -> UseFor(Hearing, SensingSound, x))", "all x. (Animal(x) -> exists y. (Sound(y) & UsesForSensing(x, Hearing, y)))", "all x. (Animal(x) -> (exists y. (Sensing(x, y) & Sound(y) & Uses(x, Hearing, y))))"]}
{"id": "entailmentbank_validation_462", "nl": "better hearing has a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all y. (Animal(y) & BetterHearing(y) -> PositiveImpactOnSurvival(y))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_463", "nl": "senses are passed down from parent to offspring.", "fol": "", "prediction": ["all x. (all y. (Parent(x, y) -> all s. (Sense(s, x) -> Sense(s, y))))", "all x. (Offspring(x) -> exists y. (Parent(y) & PassesDownSenses(y, x)))", "all x y z. ((Senses(x) & Parent(y, z) & PassDown(y, z, x)) -> Offspring(z, y))", "all x. (Offspring(x) -> exists y. (Parent(y) & PassesDownSenses(y, x)))"]}
{"id": "entailmentbank_validation_464", "nl": "inheriting is when an inherited characteristic is passed from parent to offspring by genetics / dna.", "fol": "", "prediction": ["all c. (InheritedCharacteristic(c) -> all p, o. (Parent(p) & Offspring(o) & PassesByGeneticsOrDNA(c, p, o) <-> Inheriting(c, p, o)))", "Inheriting(x) <-> (exists y. (Characteristic(y) & Inherited(y) & PassedFromParentToOffspringByGenetics(x, y)))", "all x. (InheritedCharacteristic(x) & PassedFromBy(x, Parent, Offspring, Genetics) <-> Inheriting(x))", "all x. ((InheritedCharacteristic(x) & PassedFromParentToOffspringByGeneticsOrDNA(x)) <-> Inheriting(x))"]}
{"id": "entailmentbank_validation_465", "nl": "senses are an inherited characteristic.", "fol": "", "prediction": ["all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))"]}
{"id": "entailmentbank_validation_466", "nl": "hearing is an inherited characteristic.", "fol": "", "prediction": ["InheritedCharacteristic(hearing)", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "Exists x. (Hearing(x) & InheritedCharacteristic(x))", "InheritsCharacteristic(hearing)"]}
{"id": "entailmentbank_validation_467", "nl": "better hearing is an inherited characteristic that has a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpactOnSurvival(BetterHearing(x), x))", "all x. (Animal(x) -> (InheritedCharacteristic(Hearing(x)) & PositiveImpactOnSurvival(Hearing(x))))"]}
{"id": "entailmentbank_validation_468", "nl": "as the ability of a living thing to survive / to reproduce increases, the likelihood of passing on its traits to its decendents will increase.", "fol": "", "prediction": ["all x. (LivingThing(x) & Increases(AbilityToSurviveOrReproduce(x)) -> Increases(LikelihoodOfPassingOnTraits(x)))", "all x. (LivingThing(x) & Increases(AbilityTo(Survive(x)) | AbilityTo(Reproduce(x))) -> Increases(Likelihood(PassOnTraits(x))))", "all x. (LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x) -> LikelihoodPassingTraitsToDescendantsIncreases(x))", "all x. (LivingThing(x) & AbilityToSurvive(x) & AbilityToReproduce(x) -> (Increase(AbilityToSurvive(x) & AbilityToReproduce(x)) -> Increase(PassingTraitsToDescendants(x))))"]}
{"id": "entailmentbank_validation_469", "nl": "animals with traits that positively impact their survival have a greater ability to survive / reproduce.", "fol": "", "prediction": ["all x. ((Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x))) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. ((Animal(x) & exists t. (Trait(t) & PositiveImpactOnSurvival(t, x))) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> GreaterAbilityToSurviveOrReproduce(x))"]}
{"id": "entailmentbank_validation_470", "nl": "the decendants of an animal with traits that positively impacted their survival will also have traits that positivley impact their survival.", "fol": "", "prediction": ["all x. (Animal(x) & HasTraitsThatImpactSurvivalPositively(x) -> all y. (DescendantOf(y, x) -> HasTraitsThatImpactSurvivalPositively(y)))", "all x. all y. (Descendant(x, y) & Animal(y) & HasSurvivalTraits(y) -> HasSurvivalTraits(x))", "all x. (Animal(x) & HasDescendants(x) & TraitsImpactSurvivalPositively(x) -> all y. (DescendantOf(y, x) -> TraitsImpactSurvivalPositively(y)))", "all x. (Animal(x) & HasTraitsAffectingSurvivalPositively(x) -> all y. (Descendant(y, x) -> HasTraitsAffectingSurvivalPositively(y)))"]}
{"id": "entailmentbank_validation_471", "nl": "the decendants of an animal with better hearing will also have better hearing.", "fol": "", "prediction": ["all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x, y. ((Animal(x) & BetterHearing(x) & Descendant(y, x)) -> BetterHearing(y))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Descendant(x, y) & Animal(y) & BetterHearing(y) -> BetterHearing(x))"]}
{"id": "entailmentbank_validation_472", "nl": "mosquitos can sense carbon dioxide in the air.", "fol": "", "prediction": ["all x. (Mosquito(x) -> CanSenseCO2(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxide(x))", "all x. (Mosquito(x) -> CanSense(x, carbon_dioxide))", "all x. (Mosquito(x) -> CanSenseCarbonDioxide(x))"]}
{"id": "entailmentbank_validation_473", "nl": "animals are a source of carbon dioxide by exhaling.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))"]}
{"id": "entailmentbank_validation_474", "nl": "mosquitos sense animals by sensing their carbon dioxide emissions.", "fol": "", "prediction": ["all x. (Mosquito(x) -> all y. (Animal(y) -> SensesBy(x, y, CarbonDioxideEmissions(y))))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2Emission(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> Senses(x, y, CO2Emissions(y))))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2Emissions(x, y)))"]}
{"id": "entailmentbank_validation_475", "nl": "living things eat their food source.", "fol": "", "prediction": ["all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_476", "nl": "mosquitos eat blood of animals.", "fol": "", "prediction": ["all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))"]}
{"id": "entailmentbank_validation_477", "nl": "animals are a source of food for mosquitos.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))"]}
{"id": "entailmentbank_validation_478", "nl": "sensing food has a positive impact on finding food.", "fol": "", "prediction": ["all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "FOL Translation:\nall x. (Food(x) & Sensing(x) -> PositiveImpact(x, Finding(x)))"]}
{"id": "entailmentbank_validation_479", "nl": "sensing animals has a positive impact on a mosquito's ability to find food.", "fol": "", "prediction": ["all x. (SensingAnimals(x) -> PositiveImpact(x, MosquitoFindsFood))", "all x. (SensingAnimals(x) -> PositiveImpactOnMosquitosAbilityToFindFood(x))", "all x. (SensingAnimals(x) -> PositiveImpactOnFoodFindingAbility(x))", "exists x. (SensingAnimals(x) & PositiveImpact(x, MosquitoFoodFindingAbility))"]}
{"id": "entailmentbank_validation_480", "nl": "sensing carbon dioxide has a positive impact on a mosquito's ability to find food.", "fol": "", "prediction": ["exists x. (Mosquito(x) & SensingCarbonDioxideHelpsFindingFood(x))", "exists x. (Mosquito(x) & HasPositiveImpact(SenseCarbonDioxide(x), AbilityToFindFood(x)))", "exists x exists y. (CarbonDioxide(x) & Mosquito(y) & Sensing(y, x) -> PositiveImpactOnFindingFood(y))", "exists x. (Mosquito(x) & SensingCarbonDioxide(x) -> PositiveImpactOnFindingFood(x))"]}
{"id": "entailmentbank_validation_481", "nl": "if a living thing requires something then that something has a positive impact on that living thing.", "fol": "", "prediction": ["all x y. (Requires(x, y) -> PositiveImpact(y, x))", "all x y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x. all y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x y. (LivingThing(x) & Requires(x, y) -> PositiveImpact(y, x))"]}
{"id": "entailmentbank_validation_482", "nl": "a living things require water for survival.", "fol": "", "prediction": ["all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))"]}
{"id": "entailmentbank_validation_483", "nl": "water has a positive impact on a living thing's survival.", "fol": "", "prediction": ["all x. (LivingThing(x) -> PositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> HasPositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))"]}
{"id": "entailmentbank_validation_484", "nl": "increasing the availability of something that has a positive impact on a living thing's survivial can have a positive impact on that living thing's survival.", "fol": "", "prediction": ["all x y. ((PositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> PositiveImpactOnSurvival(y, x))", "all x. all y. ((HasPositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> HasPositiveImpactOnSurvival(y, x))", "all x. (exists y. (PositiveImpactOnSurvival(y, x) & IncreasedAvailability(y)) -> PositiveImpactOnSurvival(y, x))", "all x. all y. (HasPositiveImpactOnSurvival(y, x) & IncreasedAvailability(x) -> HasPositiveImpactOnSurvival(y, x))"]}
{"id": "entailmentbank_validation_485", "nl": "increasing the availability of water for a living thing has a positive impact on that living thing's survival.", "fol": "", "prediction": ["all x. (LivingThing(x) & IncreasesWaterAvailability(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasedAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) -> (exists y. (Water(y) & Available(y, x)) -> PositiveImpactOnSurvival(x)))"]}
{"id": "entailmentbank_validation_486", "nl": "storing something is a kind of method for increasing the availability of something.", "fol": "", "prediction": ["all x. all y. (Storing(x, y) -> MethodForIncreasingAvailability(x, y))", "all x. (Storing(x) -> MethodForIncreasingAvailability(x))", "all x y. (Storing(x, y) -> MethodForIncreasingAvailability(x, y))", "all x. (Storing(x) -> MethodForIncreasingAvailability(x))"]}
{"id": "entailmentbank_validation_487", "nl": "storing water has a positive impact on a living thing's survival by increasing the availability of water.", "fol": "", "prediction": ["all x. (LivingThing(x) -> (exists y. (StoringWater(y) & IncreasesWaterAvailability(y, x) & PositiveImpactOnSurvival(y, x))))", "exists x. (LivingThing(x) & all y. (Water(y) & Storing(y) -> PositiveImpact(Survival(x), IncreasesAvailability(y))))", "exists x. exists y. (StoringWater(x) & LivingThing(y) -> PositiveImpactOnSurvival(x, y) & IncreasesAvailabilityOfWater(x))", "all x. (LivingThing(x) & StoresWater(x) -> PositiveImpactOnSurvival(x) & IncreasesWaterAvailability(x))"]}
{"id": "entailmentbank_validation_488", "nl": "dry means low in amount of water.", "fol": "", "prediction": ["all x. (Dry(x) <-> LowInAmountOfWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInAmountOfWater(x))"]}
{"id": "entailmentbank_validation_489", "nl": "as dryness increases in an environment, the available water in that environment will decrease.", "fol": "", "prediction": ["all e. ((Environment(e) & Increases(Dryness(e))) -> Decreases(AvailableWater(e)))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))", "all e. ((Environment(e) & Increases(Dryness, e)) -> Decreases(AvailableWater, e))", "all e. (IncreasesDryness(e) -> DecreasesAvailableWater(e))"]}
{"id": "entailmentbank_validation_490", "nl": "a dry environment is low in availability of water.", "fol": "", "prediction": ["all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all z. (DryEnvironment(z) -> LowAvailabilityOfWater(z))"]}
{"id": "entailmentbank_validation_491", "nl": "storing water increases the water available to organisms in a dry environment.", "fol": "", "prediction": ["all x. (DryEnvironment(x) -> (StoringWater(x) -> IncreasesWaterAvailableToOrganisms(x)))", "all e. (DryEnvironment(e) -> (exists w, o. (Water(w) & Organism(o) & Storing(w, e) -> IncreasesWaterAvailableToOrganisms(w, o, e))))", "all x. (DryEnvironment(x) -> (Increases(StoringWater, WaterAvailableToOrganisms(x))))", "exists x. (Water(x) & all y. (Organism(y) & InDryEnvironment(y) -> MoreAvailable(x, y)))"]}
{"id": "entailmentbank_validation_492", "nl": "adapting is when a living thing responds to a change in an environment.", "fol": "", "prediction": ["all x. (LivingThing(x) & Change(y) & Environment(z) & RespondsToChangeIn(x, y, z) <-> Adapting(x))", "all x. all y. all z. ((LivingThing(x) & ChangeInEnvironment(y) & RespondsTo(x, y)) <-> Adapt(x, z))", "all x. (LivingThing(x) & RespondsToChangeInEnvironment(x) <-> Adapting(x))", "all x. (LivingThing(x) -> (exists y. (ChangeInEnvironment(y) & RespondsTo(x, y)) <-> Adapting(x)))"]}
{"id": "entailmentbank_validation_493", "nl": "storing water is an adaptation to a dry environment.", "fol": "", "prediction": ["AdaptationToDryEnvironment(storing_water)", "AdaptationToDryEnvironment(storing_water)", "AdaptationToEnvironment(StoringWater, DryEnvironment)", "Adaptation(storing_water, dry_environment)"]}
{"id": "entailmentbank_validation_494", "nl": "as the available water in an environment increases, the populations of organisms in that environment will increase.", "fol": "", "prediction": ["all e. (Environment(e) -> (Increase(AvailableWater(e)) -> Increase(Populations(e))))", "all e. (Increases(AvailableWater(e)) -> Increases(Populations(e)))", "all e. (exists x. (Environment(e) & Water(x) & In(x, e) & Increases(x)) -> all p. (Organism(p) & In(p, e) -> PopulationIncreases(p)))", "all e. (Environment(e) & Increases(AvailableWater(e)) -> Increases(OrganismPopulation(e)))"]}
{"id": "entailmentbank_validation_495", "nl": "an aquatic animal requires great amounts of water to thrive.", "fol": "", "prediction": ["all x. (AquaticAnimal(x) -> Requires(x, Water) & GreatAmounts(Water) & Thrives(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresWater(x) & GreatAmount(x) & ToThrive(x))", "all x. (AquaticAnimal(x) -> Requires(x, Water, GreatAmounts) & Thrives(x))"]}
{"id": "entailmentbank_validation_496", "nl": "as water increases in an environment, the population of aquatic animals will increase.", "fol": "", "prediction": ["all e. (Increases(water, e) -> Increases(PopulationOfAquaticAnimals, e))", "all e. (Increases(water, e) -> Increases(PopulationOfAquaticAnimals, e))", "all e. (IncreasesWater(e) -> IncreasesPopulation(e, AquaticAnimals))", "all e. (Increase(Water(e)) -> Increase(Population(AquaticAnimals(e))))"]}
{"id": "entailmentbank_validation_497", "nl": "a salamander is a kind of aquatic animal.", "fol": "", "prediction": ["Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)"]}
{"id": "entailmentbank_validation_498", "nl": "as water increases in an environment, the population of salamanders may increase.", "fol": "", "prediction": ["exists x, y. (Environment(x) & SalamanderPopulation(y) & (WaterIncreases(x) -> PopulationMayIncrease(y, x)))", "FOL Translation:\nall e. (Environment(e) & Increases(water, e) -> may_increase(Population(salamanders, e)))", "exists x, y. (WaterIncreases(x) & Environment(x, y) -> PopulationIncrease(salamanders, y))", "all e. (Increase(Water, e) -> CanIncrease(PopulationOfSalamanders, e))"]}
{"id": "entailmentbank_validation_499", "nl": "when a body of water receives more water than it can hold, a flood occurs.", "fol": "", "prediction": ["all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))"]}
{"id": "entailmentbank_validation_500", "nl": "as the amount of water in a body of water increases, the water levels will increase especially at the edge of that body of water.", "fol": "", "prediction": ["all x. (BodyOfWater(x) & AmountOfWaterIncreases(x) -> WaterLevelIncreasesAtEdge(x))", "all x. (BodyOfWater(x) -> (IncreaseAmountWater(x) -> IncreaseWaterLevelAtEdge(x)))", "all x. ((BodyOfWater(x) & Increases(AmountOfWater(x))) -> Increases(WaterLevelAtEdgeOfBody(x)))", "all x. ((BodyOfWater(x) & Increases(AmountOfWaterIn(x))) -> Increases(WaterLevelAtEdgeOf(x)))"]}
{"id": "entailmentbank_validation_501", "nl": "a flood is a result of a large increase of water in a body of water.", "fol": "", "prediction": ["FOL Translation:\nall x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InBodyOfWater(y, x)))", "ResultOfFlood(x) = large_increase_of_water_in_body_of_water(x)", "all x. (Flood(x) -> exists y. (BodyOfWater(y) & LargeIncreaseOfWaterIn(y) & ResultOf(x, y)))", "FOL Translation:\nall x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & In(x, y) & BodyOfWater(y)))"]}
{"id": "entailmentbank_validation_502", "nl": "a body of water is a part of some environments.", "fol": "", "prediction": ["exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))", "exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists e. (Environment(e) & exists w. (BodyOfWater(w) & PartOf(w, e)))"]}
{"id": "entailmentbank_validation_503", "nl": "a flood is a result of a large increase of water in an environment.", "fol": "", "prediction": ["all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, x)))", "all x. (Flood(x) -> exists y. (IncreaseOfWater(y) & Large(y) & InEnvironment(y, x) & Result(x, y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultsIn(y, x) & Environment(y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & Environment(z) & ResultOf(x, y, z)))"]}
{"id": "entailmentbank_validation_504", "nl": "a flood may cause the population of salamander to increase in an environment.", "fol": "", "prediction": ["exists e. (Environment(e) & exists f. (Flood(f) & CanCause(f, exists p. (Population(p, salamander) & Increase(p, e)))))", "exists f. exists s. exists e. (Flood(f) & SalamanderPopulationIncrease(s) & Environment(e) & Causes(f, s, e))", "exists e. (Flood(e) -> exists i. (Environment(i) & causesIncreaseInPopulationOf(salamander, i)))", "exists e, f. (Flood(f) & Environment(e) & CanCause(f, Increase(Population(salamander), e)))"]}
{"id": "entailmentbank_validation_505", "nl": "frogs / turtles / fish / mice / birds are kinds of animals.", "fol": "", "prediction": ["all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))"]}
{"id": "entailmentbank_validation_506", "nl": "alligators eat frogs / turtles / fish / mice / birds.", "fol": "", "prediction": ["all x. (Alligator(x) -> (Eats(x, frogs) & Eats(x, turtles) & Eats(x, fish) & Eats(x, mice) & Eats(x, birds)))", "all x. (Alligator(x) -> (Eats(x, frogs) | Eats(x, turtles) | Eats(x, fish) | Eats(x, mice) | Eats(x, birds)))", "all x. (Alligator(x) -> (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists w. (Fish(w) & Eats(x, w)) | exists u. (Mice(u) & Eats(x, u)) | exists v. (Bird(v) & Eats(x, v))))", "all x. (Alligator(x) -> exists y. ((Frog(y) | Turtle(y) | Fish(y) | Mouse(y) | Bird(y)) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_507", "nl": "alligators eat animals.", "fol": "", "prediction": ["all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_508", "nl": "a predator eats other animals for food.", "fol": "", "prediction": ["Exist x. (Predator(x) & ForAll y. (Animal(y) & Different(x, y) -> EatsForFood(x, y)))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & -(x = y)))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))"]}
{"id": "entailmentbank_validation_509", "nl": "alligators are a kind of predator.", "fol": "", "prediction": ["all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))"]}
{"id": "entailmentbank_validation_510", "nl": "as the population of prey decreases, competition between predators will increase.", "fol": "", "prediction": ["all p. (PreyPopulationDecreases(p) -> exists q. (Predator(q) & CompetitionBetweenPredatorsIncreases(q)))", "exists x y. (PopulationOfPreyDecreases(x) & PopulationOfPrey(x) & Predators(y) & Competes(y) & PopulationOfPrey(x) -> IncreaseCompetition(y))", "all x. (PopulationOfPreyDecreases(x) -> CompeteIncreaseBetweenPredators(x))", "all x. (PreyPopulationDecreases(x) -> exists y. (CompetitionBetweenPredators(y) & Increases(y)))"]}
{"id": "entailmentbank_validation_511", "nl": "as the population of prey decreases, competition between alligators will increase.", "fol": "", "prediction": ["all p. (Decreasing(Population(prey)) -> Increasing(CompetitionAmong(alligator)))", "all p. (PreyPopulationDecreases(p) -> all a1, a2. (Alligator(a1) & Alligator(a2) & a1 != a2 -> CompetitionIncreases(a1, a2)))", "all x. (PopulationDecreases(prey) & Alligator(x) -> CompetitionIncreasesBetween(x))", "FOL Translation:\nall x. all y. (Alligator(x) & Alligator(y) & Decreases(Population(prey)) -> Increases(Competition(x, y)))"]}
{"id": "entailmentbank_validation_512", "nl": "competition may cause animals to act aggressively towards members of their own species.", "fol": "", "prediction": ["all x. (Animal(x) & exists y. (Competition(y) & Involves(y, x)) -> exists z. (MemberOfSpecies(z, SpeciesOf(x)) & ActsAggressivelyTowards(x, z)))", "all x. (Animal(x) -> (exists y. (Competition(y) & Causes(y, x, ActsAggressively(x, SpeciesMember(x))))))", "exists x. (Animal(x) & CompetitionMayCause(x) & exists y. (MemberOfSameSpecies(x, y) -> ActsAggressivelyTowards(x, y)))", "exists x. (Animal(x) & CompetitionExists(x) -> exists y. (MemberOfSameSpecies(x, y) & ActsAggressivelyTowards(x, y)))"]}
{"id": "entailmentbank_validation_513", "nl": "as the population of prey decreases, agression between alligators will increase.", "fol": "", "prediction": ["all t. ((Decreases(Population(prey), t)) -> Increases(AggressionBetween(alligators), t))", "all t. (DecreasingPopulationPrey(t) -> IncreasingAggression(alligator, t))", "all x. (Alligator(x) & Decreases(Population(prey)) -> Increases(AggressionBetween(x, Alligator)))", "all x. (Alligator(x) & Decrease(Population(prey)) -> Increase(Aggression(x)))"]}
{"id": "entailmentbank_validation_514", "nl": "a drought occurs over a period of months / years.", "fol": "", "prediction": ["exists t. (Drought(t) & (PeriodOfMonths(t) | PeriodOfYears(t)))", "exists x. (Drought(x) & PeriodOfMonthsOrYears(x))", "exists x. (Drought(x) & occursOver(x, months) | occursOver(x, years))", "exists x. (Drought(x) & OccursOverPeriod(x, months_or_years))"]}
{"id": "entailmentbank_validation_515", "nl": "drought is when available water decreases in an environment over a period of months / years.", "fol": "", "prediction": ["Drought(x) <-> (exists y. (Water(y) & Environment(z) & Decreases(y, z, x)) & TimePeriod(x) & (MonthsOrYears(x)))", "Drought(d) <-> (exists e. (Environment(e) & PeriodOfMonthsOrYears(t) & Decreases(AvailableWater(e), t)))", "Drought(d) <-> exists e, t. (Environment(e) & AvailableWaterDecreases(e, t) & OverPeriodOfMonthsOrYears(t))", "Drought(x) <-> (Decrease(AvailableWater(x)) & InEnvironment(x) & OverPeriodOfTime(x, months_or_years))"]}
{"id": "entailmentbank_validation_516", "nl": "as available water decreases, the population of plants will decrease.", "fol": "", "prediction": ["all t. (Decreases(AvailableWater(t)) -> Decreases(PopulationOfPlants(t)))", "all x. ((AvailableWater(x) & Decreases(x)) -> Decreases(PopulationOfPlants(x)))", "exists y. (AvailableWater(y) & Decreases(y) -> exists z. (PopulationOfPlants(z) & Decreases(z)))", "all t. (Decreases(AvailableWater, t) -> Decreases(PopulationOfPlants, t))"]}
{"id": "entailmentbank_validation_517", "nl": "a drought that occurs over a period of months / years may cause the population of plants in an environment to decrease.", "fol": "", "prediction": ["exists d. (Drought(d) & OverPeriodOfMonthsOrYears(d) -> exists e. (Environment(e) & causes(d, DecreasePopulationOfPlants(e))))", "exists x. (Drought(x) & OccursOverMonthsOrYears(x) -> all y. (Environment(y) -> exists z. (Plant(z) & InEnvironment(z, y) -> PopulationDecreases(z))))", "exists t. (Drought(t) & OccursOverPeriod(t, months_years)) -> exists e. (Environment(e) & MayCause(t, Decrease(PopulationOf(plants, e))))", "exists x. (Drought(x) & OccursOverMonthsOrYears(x) -> all y. (PlantPopulation(y) & InEnvironment(y) -> MayDecreaseDueToDrought(y, x)))"]}
{"id": "entailmentbank_validation_518", "nl": "a marsh willow herb is a kind of plant.", "fol": "", "prediction": ["all x. (MarshWillowHerb(x) -> Plant(x))", "Plant(marsh_willow_herb)", "MarshWillowHerb(x) -> Plant(x)", "all x. (MarshWillowHerb(x) -> Plant(x))"]}
{"id": "entailmentbank_validation_519", "nl": "a drought that occurs over a period of months / years may cause the population of marsh willow herb in an environment to decrease.", "fol": "", "prediction": ["exists d. (Drought(d) & OverPeriod(d, months_years) -> all e. (Environment(e) -> (exists p. (MarshWillowHerbPopulation(p, e) & Decreases(p)))))", "exists x. (Drought(x) & OccursOverPeriod(x, months_years) -> all y. (Environment(y) & Contains(y, marsh_willow_herb) -> DecreasePopulation(y, marsh_willow_herb)))", "exists d, e1, e2. (Drought(d) & OccursOver(d, e1) & Period(e1, months_years) & MarshWillowHerbPopulation(e2, environment) & MayCause(d, Decrease(e2)))", "exists d. (Drought(d) & OccursOver(d, months_years) -> all e. (Environment(e) -> Causes(d, Decrease(Population(marsh_willow_herb, e)))))"]}
{"id": "entailmentbank_validation_520", "nl": "sweat is used for adjusting to hot temperatures by some animals.", "fol": "", "prediction": ["exists x. (Animal(x) & UsesForSweat(x, AdjustToHotTemperatures))", "exists x. (Animal(x) & usesSweatToAdjustHotTemperatures(x))", "exists x. (Animal(x) & UsesSweatForAdjustingToHotTemperatures(x))", "exists x. (Animal(x) & UsesForAdjustingToHotTemperatures(x, sweat))"]}
{"id": "entailmentbank_validation_521", "nl": "sweat cools a body.", "fol": "", "prediction": ["exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "all x. (Body(x) -> exists y. (Sweat(y) & Cools(y, x)))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))"]}
{"id": "entailmentbank_validation_522", "nl": "when the body is hot, sweat is used to cool the body.", "fol": "", "prediction": ["all x. (Hot(x) -> UsedToCool(sweat, x))", "all x. ((Body(x) & Hot(x)) -> exists y. (Sweat(y) & UsedToCoolBody(y, x)))", "", "all x. (Body(x) & Hot(x) -> exists y. (Sweat(y) & UsedToCool(y, x)))"]}
{"id": "entailmentbank_validation_523", "nl": "panting is when an animal's body is cooled by hanging out their tongue.", "fol": "", "prediction": ["all x. (Animal(x) & Panting(x) -> CooledByHangingOutTongue(x))", "", "all x. ((Animal(x) & Panting(x)) <-> CooledByTongueHanging(x))", ""]}
{"id": "entailmentbank_validation_524", "nl": "panting and sweating are used to cool the body.", "fol": "", "prediction": ["all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))"]}
{"id": "entailmentbank_validation_525", "nl": "cooling means decreasing heat / temperature.", "fol": "", "prediction": ["all x. (Cooling(x) <-> DecreasingHeatOrTemperature(x))", "all x. (Cooling(x) <-> (Decreasing(x, Heat) | Decreasing(x, Temperature)))", "all x. (Cooling(x) -> DecreaseHeatOrTemperature(x))", "all x. (Cooling(x) -> (Decreases(x, heat) | Decreases(x, temperature)))"]}
{"id": "entailmentbank_validation_526", "nl": "if an animal becomes too hot then that animal may die.", "fol": "", "prediction": ["", "", "", ""]}
{"id": "entailmentbank_validation_527", "nl": "cooling can be used by an animal for survival.", "fol": "", "prediction": ["exists x, y. (Animal(x) & Cooling(y) & UsedForSurvival(x, y))", "exists x. (Animal(x) & UseForSurvival(x, cooling))", "exists a. exists c. (Animal(a) & Cooling(c) & UsedForSurvivalBy(c, a))", "exists x. (Animal(x) -> exists y. (Cooling(y) & UsedForSurvivalBy(y, x)))"]}
{"id": "entailmentbank_validation_528", "nl": "if the environmental temperature is too hot then an animal in that environment may become hot.", "fol": "", "prediction": ["all x. ((EnvironmentalTemperatureTooHot(x) & AnimalInEnvironment(y, x)) -> MayBecomeHot(y))", "all x. (Animal(x) & Environment(y) & IsIn(x, y) & TemperatureTooHot(y) -> MayBecomeHot(x))", "all e, x. ((Environment(e) & Animal(x) & LocatedIn(x, e) & TooHot(e)) -> MayBecomeHot(x))", "all t. (EnvironmentalTemperature(t) & TooHot(t) -> exists a. (Animal(a) & InEnvironment(a, t) & MayBecomeHot(a)))"]}
{"id": "entailmentbank_validation_529", "nl": "if the temperature of an animal's environment becomes too hot then that animal must cool itself.", "fol": "", "prediction": ["all x. (Animal(x) & Environment(e) & BecomesTooHot(TemperatureOf(e)) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & EnvironmentOf(y, x) & Temperature(y) = too_hot) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & Environment(y) & TemperatureTooHot(y)) -> MustCoolItself(x))", "all x. ((Animal(x) & Environment(y) & TemperatureBecomesTooHot(y)) -> MustCoolItself(x))"]}
{"id": "entailmentbank_validation_530", "nl": "an animal cooling itself is an adaptation to hot temperatures.", "fol": "", "prediction": ["exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & IsCoolingItself(x) -> AdaptationToHotTemperatures(x))"]}
{"id": "entailmentbank_validation_531", "nl": "an example of adaptations to hot temperatures are panting and sweating.", "fol": "", "prediction": ["exists x. (AdaptationToHotTemperatures(x) & (x = panting | x = sweating))", "Adaptations(hot_temperatures, panting) & Adaptations(hot_temperatures, sweating)", "exists x. (AdaptationToHotTemperature(x) & ExampleOf(x, Panting) & ExampleOf(x, Sweating))", "exists y. (Adaptation(y, hot_temperatures) & (y = panting | y = sweating))"]}
{"id": "entailmentbank_validation_532", "nl": "cellular respiration is when a cell converts from oxygen and carbohydrates into carbon dioxide, water, and energy.", "fol": "", "prediction": ["all x. (CellularRespiration(x) <-> (Converts(x, Oxygen, Carbohydrates, CarbonDioxide, Water, Energy)))", "CellularRespiration(x) <-> (Cell(x) & ConvertsFrom(x, oxygen & carbohydrates) & ConvertsInto(x, carbon_dioxide & water & energy))", "CellularRespiration(x) <-> (Cell(x) & ConvertsFrom(x, [Oxygen, Carbohydrates], [CarbonDioxide, Water, Energy]))", "CellularRespiration(c) <-> all f. (Cell(f) -> Converts(f, OxygenAndCarbohydrates, CarbonDioxideWaterAndEnergy))"]}
{"id": "entailmentbank_validation_533", "nl": "living things require respiration to use energy.", "fol": "", "prediction": ["all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequireRespirationToUseEnergy(x))"]}
{"id": "entailmentbank_validation_534", "nl": "living things must convert oxygen into carbon dioxide to use energy.", "fol": "", "prediction": ["all x. (LivingThing(x) -> MustConvertToUseEnergy(x, Oxygen, CarbonDioxide))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvert(x, oxygen, carbon_dioxide, UseEnergy(x)))"]}
{"id": "entailmentbank_validation_535", "nl": "breathing is when animals convert oxygen into carbon dioxide.", "fol": "", "prediction": ["FOL Translation:\nall x. (Animal(x) & Breathing(x) -> ConvertsTo(x, oxygen, carbon_dioxide))", "all x. (Animal(x) & Breathing(x) -> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> Breathing(x) <-> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> (Breathing(x) <-> Converts(x, oxygen, carbon_dioxide)))"]}
{"id": "entailmentbank_validation_536", "nl": "living things must breathe to use energy.", "fol": "", "prediction": ["all x. (LivingThing(x) -> (MustBreathe(x) & UsesEnergy(x)))", "all x. (LivingThing(x) -> (Breathe(x) -> UseEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & UsesEnergy(x)))", "all x. (LivingThing(x) -> (UsesEnergy(x) -> MustBreathe(x)))"]}
{"id": "entailmentbank_validation_537", "nl": "breathing out is when animals exhale carbon dioxide from their lungs into the air.", "fol": "", "prediction": ["all x. (Animal(x) & ExhalesCO2FromLungs(x) -> BreathingOut(x))", "all x. (Animal(x) -> (BreathesOut(x) <-> (Exhales(x, carbon_dioxide) & From(x, lungs) & Into(x, air))))", "all x. (Animal(x) -> (BreathingOut(x) <-> exists y. (Exhale(x, y) & CarbonDioxide(y) & FromLungs(x, y) & IntoAir(y))))", "all x. (Animal(x) & Exhale(x, carbon_dioxide) & From(x, lungs) & Into(x, air) <-> BreathingOut(x))"]}
{"id": "entailmentbank_validation_538", "nl": "animals are a source of carbon dioxide by breathing.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))"]}
{"id": "entailmentbank_validation_539", "nl": "a source of something produces that something.", "fol": "", "prediction": ["all x, y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x y. (SourceOf(x, y) -> Produces(x, y))", "all x, y. (SourceOf(x, y) -> Produces(x, y))"]}
{"id": "entailmentbank_validation_540", "nl": "animals produce carbon dioxide by breathing.", "fol": "", "prediction": ["all x. (Animal(x) -> ProducesCO2ByBreathing(x))", "all x. (Animal(x) -> Breathing(x) -> Produces(x, carbon_dioxide))", "all x. (Animal(x) -> Produces(x, carbon_dioxide) & By(x, Breathing))", "all x. (Animal(x) -> exists y. (Breathing(x) & Produces(x, y) & CarbonDioxide(y)))"]}
{"id": "entailmentbank_validation_541", "nl": "animals produce carbon dioxide by using energy.", "fol": "", "prediction": ["all x. (Animal(x) -> ProducesCarbonDioxide(x) & UsesEnergy(x))", "all x. (Animal(x) -> ProducesCO2(x) & UsesEnergy(x))", "all x. (Animal(x) -> ProducesCO2ByUsingEnergy(x))", "all x. (Animal(x) -> exists y. (Energy(y) & Uses(x, y) & Produces(x, CarbonDioxide)))"]}
{"id": "entailmentbank_validation_542", "nl": "carbohydrates are used for storing energy.", "fol": "", "prediction": ["all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))"]}
{"id": "entailmentbank_validation_543", "nl": "photosynthesis makes energy for the plant by converting carbon dioxide, water, and sunlight into carbohydrates.", "fol": "", "prediction": ["exists p, c, w, l, e. (Photosynthesis(p) & Plant(e) & CarbonDioxide(c) & Water(w) & Sunlight(l) & Converts(p, c, w, l, Carbohydrates) & MakesEnergyFor(p, e))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & exists z. (Water(z) & exists w. (Sunlight(w) & causes(Photosynthesis, produces(x, Energy) & converts(y, z, w, Carbohydrates))))))", "exists p, e, c, w, s, carb. (Plant(p) & Photosynthesis(p, e) & Converts(p, [c, w, s], carb) & CarbonDioxide(c) & Water(w) & Sunlight(s) & Carbohydrates(carb))", "exists p. (Plant(p) & exists e. (EnergyFor(e, p) & ContributesByPhotosynthesis(e) & convertsInto(e, Carbohydrates) & exists c. (CarbonDioxide(c) & UsedByPhotosynthesis(e, c)) & exists w. (Water(w) & UsedByPhotosynthesis(e, w)) & exists s. (Sunlight(s) & UsedByPhotosynthesis(e, s)))))"]}
{"id": "entailmentbank_validation_544", "nl": "photosynthesis stores energy.", "fol": "", "prediction": ["FOL Translation:\nStoresEnergy(photosynthesis)", "StoresEnergy(photosynthesis)", "all x. (Photosynthesis(x) -> StoresEnergy(x))", "StoresEnergy(photosynthesis)"]}
{"id": "entailmentbank_validation_545", "nl": "if something is required to use something else then that something is a source of that something else.", "fol": "", "prediction": ["all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x. all y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))"]}
{"id": "entailmentbank_validation_546", "nl": "respiration is a source of energy for living things.", "fol": "", "prediction": ["all x. (LivingThing(x) & Respiration(isSourceOfEnergy, x))", "all x. (LivingThing(x) & RespirationSourceOfEnergy(x) -> EnergySource(x, Respiration))", "all x. (LivingThing(x) -> exists y. (SourceOfEnergy(y, x) & Respiration(y)))", "all x. (LivingThing(x) -> exists y. (Respiration(y) & SourceOfEnergyFor(y, x)))"]}
{"id": "entailmentbank_validation_547", "nl": "if something releases something else then that something is the source of that something else.", "fol": "", "prediction": ["all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x all y. (Releases(x, y) -> SourceOf(x, y))"]}
{"id": "entailmentbank_validation_548", "nl": "respiration releases energy.", "fol": "", "prediction": ["all x. (Respiration(x) -> Releases(x, energy))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))"]}
{"id": "entailmentbank_validation_549", "nl": "photosynthesis stores energy and respiration releases energy.", "fol": "", "prediction": ["StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)"]}
{"id": "entailmentbank_validation_550", "nl": "digestion is when stomach acid breaks down food.", "fol": "", "prediction": ["Digestion(x) <-> (exists y. (StomachAcid(y) & BreaksDown(y, x) & Food(x)))", "all x. (Digestion(x) <-> exists y z. (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))", "all x. (Digestion(x) <-> (exists y. (StomachAcid(y) & BreaksDown(y, Food(x)))))", "all x. (Digestion(x) <-> exists y exists z. (StomachAcid(y) & Food(z) & BreaksDown(y, z)))"]}
{"id": "entailmentbank_validation_551", "nl": "the digestive system digests food for the body.", "fol": "", "prediction": ["DigestsFor(digestive_system, food, body)", "DigestsFor(digestive_system, food, body)", "all x. (DigestiveSystem(x) -> exists y. (Food(y) & Digests(x, y) & ForBody(x)))", "all x. (DigestiveSystem(x) -> exists y. (Body(y) & DigestsFoodFor(x, y)))"]}
{"id": "entailmentbank_validation_552", "nl": "the digestive system breaks down food.", "fol": "", "prediction": ["all x. (DigestiveSystem(x) -> all y. (Food(y) -> BreaksDown(x, y)))", "exists x. (DigestiveSystem(x) & exists y. (Food(y) & BreaksDown(x, y)))", "Exists x. (DigestiveSystem(x) & BreaksDown(x, food))", "BreaksDown(digestive_system, food)"]}
{"id": "entailmentbank_validation_553", "nl": "if something is made of something else then that something can be broken down into that something else.", "fol": "", "prediction": ["all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))"]}
{"id": "entailmentbank_validation_554", "nl": "if something is made of something else then that something contains that something else.", "fol": "", "prediction": ["all x y. (MadeOf(x, y) -> Contains(x, y))", "all x all y. (MadeOf(x, y) -> Contains(x, y))", "all x. all y. (MadeOf(x, y) -> Contains(x, y))", "all x, y. (MadeOf(x, y) -> Contains(x, y))"]}
{"id": "entailmentbank_validation_555", "nl": "if something contains something else then that something can be broken down into that something else.", "fol": "", "prediction": ["all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x, y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))"]}
{"id": "entailmentbank_validation_556", "nl": "the digestive system breaks down food into the substances it contains.", "fol": "", "prediction": ["all f. (Food(f) -> exists s. (Substance(s) & Contains(f, s) & BreaksDown(food, s)))", "all x. (DigestiveSystem(x) -> all y. (Food(y) -> exists z. (Substance(z) & BreaksDownInto(x, y, z))))", "all x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDown(digestive_system, x, y)))", "all x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDown(digestive_system, x, y)))"]}
{"id": "entailmentbank_validation_557", "nl": "food contains nutrients for living things.", "fol": "", "prediction": ["all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> NeededBy(y, z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & For(x, LivingThing(y))))"]}
{"id": "entailmentbank_validation_558", "nl": "the digestive system breaks down food into nutrients for the body.", "fol": "", "prediction": ["all x. (DigestiveSystem(x) -> exists y. (Food(y) & BreaksDown(x, y, NutrientsForBody)))", "exists x. (DigestiveSystem(x) -> all y. (Food(y) -> exists z. (Nutrients(z) & BreaksDown(x, y, z) & ForBody(z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & BreaksDown(digestive_system, x, y) & For(y, body)))", "all x. (DigestiveSystem(x) -> all y. (Food(y) -> exists z. (Nutrients(z) & BreaksDownInto(x, y, z) & ForBody(z))))"]}
{"id": "entailmentbank_validation_559", "nl": "scales are a covering around the body of a scaled animal.", "fol": "", "prediction": ["all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & CoversBodyOf(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x) & AroundBody(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scales(y) & CoversBodyOf(y, x)))"]}
{"id": "entailmentbank_validation_560", "nl": "a fish is a kind of scaled animal.", "fol": "", "prediction": ["all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))"]}
{"id": "entailmentbank_validation_561", "nl": "fish is a kind of scaled animal with scales covering around the body.", "fol": "", "prediction": ["all x. (Fish(x) -> ScaledAnimal(x) & ScalesCoverBody(x))", "all x. (Fish(x) -> (ScaledAnimal(x) & CoverWithScales(x, Body(x))))", "all x. (Fish(x) -> (Animal(x) & HasScales(x) & CoversScales(x, Body(x))))", "Fish(x) -> (ScaledAnimal(x) & all y.(Scale(y) & Covers(y, Body(x))))"]}
{"id": "entailmentbank_validation_562", "nl": "scales are used for protection by scaled animals.", "fol": "", "prediction": ["all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (ScaledAnimal(x) -> UsesFor(Scales, Protection, x))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, Scales))"]}
{"id": "entailmentbank_validation_563", "nl": "scales are used for protection by fish.", "fol": "", "prediction": ["all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> UsesForProtection(x, Scales))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) & HasScales(x) -> UsedForProtection(Scales(x), x))"]}
{"id": "entailmentbank_validation_564", "nl": "a human is a kind of animal.", "fol": "", "prediction": ["all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))"]}
{"id": "entailmentbank_validation_565", "nl": "an animal is a kind of living thing.", "fol": "", "prediction": ["all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_566", "nl": "a human is a kind of living thing.", "fol": "", "prediction": ["all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_567", "nl": "a plant is a kind of living thing.", "fol": "", "prediction": ["all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_568", "nl": "an apple tree is a kind of plant.", "fol": "", "prediction": ["Tree(apple_tree) -> Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)"]}
{"id": "entailmentbank_validation_569", "nl": "an apple tree is a kind of living thing.", "fol": "", "prediction": ["LivingThing(apple_tree)", "LivingThing(apple_tree)", "Tree(apple_tree) -> LivingThing(apple_tree)", "Tree(apple) -> LivingThing(apple)"]}
{"id": "entailmentbank_validation_570", "nl": "all living things are made of cells according to the cell theory.", "fol": "", "prediction": ["all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))"]}
{"id": "entailmentbank_validation_571", "nl": "both the human and the apple tree are made of cells.", "fol": "", "prediction": ["MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)"]}
{"id": "entailmentbank_validation_572", "nl": "a plant cell is a kind of cell.", "fol": "", "prediction": ["Cell(plant_cell)", "Cell(plant_cell) & KindOf(plant_cell, cell)", "Cell(plantCell)", "Cell(plant_cell) & KindOf(plant_cell, cell)"]}
{"id": "entailmentbank_validation_573", "nl": "a cell nucleus is a part of a cell.", "fol": "", "prediction": ["exists x. (CellNucleus(x) -> exists y. (Cell(y) & PartOf(x, y)))", "exists x. exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. (Cell(x) & exists y. (CellNucleus(y) & PartOf(y, x)))", "exists x, y. (CellNucleus(x) & Cell(y) & PartOf(x, y))"]}
{"id": "entailmentbank_validation_574", "nl": "a cell nucleus is a part of a plant cell.", "fol": "", "prediction": ["exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))"]}
{"id": "entailmentbank_validation_575", "nl": "a cell wall is a part of a plant cell for supporting and protecting the cell membrane.", "fol": "", "prediction": ["all x. (CellWall(x) -> exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))", "all x. (CellWall(x) & PartOf(x, PlantCell) -> Purpose(x, Protect(CellMembrane)) & Purpose(x, Support(CellMembrane)))", "all x. (CellWall(x) -> exists y. (PartOf(x, y) & PlantCell(y) & Supports(x, z) & CellMembrane(z) & Protects(x, z)))", "all x. ((CellWall(x) & PartOf(x, y) & PlantCell(y)) -> (Supports(x, z) & Protects(x, z) & CellMembrane(z) & PartOf(z, y)))"]}
{"id": "entailmentbank_validation_576", "nl": "chloroplast is a part of a plant cell.", "fol": "", "prediction": ["PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)"]}
{"id": "entailmentbank_validation_577", "nl": "a cell nucleus, chloroplast and a cell wall are part of a plant cell.", "fol": "", "prediction": ["all x. (CellNucleus(x) -> PartOf(x, plant_cell)) & all y. (Chloroplast(y) -> PartOf(y, plant_cell)) & all z. (CellWall(z) -> PartOf(z, plant_cell))", "all x. ((Nucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))", "all z. ((Nucleus(z) | Chloroplast(z) | CellWall(z)) -> PartOf(z, PlantCell))", "exists x. (PlantCell(x) & PartOf(cell_nucleus, x) & PartOf(chloroplast, x) & PartOf(cell_wall, x))"]}
{"id": "entailmentbank_validation_578", "nl": "a computer room is used to control the assembly process in a factory.", "fol": "", "prediction": ["exists x. (ComputerRoom(x) -> exists y. (AssemblyProcess(y) & InFactory(y) & Controls(x, y)))", "exists x. (ComputerRoom(x) & UsedToControl(x, assembly_process) & In(factory, assembly_process))", "exists x. (ComputerRoom(x) & exists y. (AssemblyProcess(y) & Factory(y) & UsedToControl(x, y)))", "exists x. (ComputerRoom(x) & exists y. (Factory(y) & ControlsAssemblyProcess(x, y)))"]}
{"id": "entailmentbank_validation_579", "nl": "the cell nucleus controls many of the functions of the cell.", "fol": "", "prediction": ["exists x. (CellNucleus(x) & all y. ((FunctionOfCell(y) & Controls(x, y))))", "exists c. (Cell(c) & exists n. (Nucleus(n) & PartOf(n, c) & Controls(n, FunctionsOf(c))))", "exists x. (CellNucleus(x) -> exists y. (Cell(y) & Controls(x, y)))", "exists x. exists y. (Cell(x) & Nucleus(y) & PartOf(y, x) & Controls(y, FunctionsOfCell(x)))"]}
{"id": "entailmentbank_validation_580", "nl": "controlling is a kind of function.", "fol": "", "prediction": ["Function(controlling)", "all x. (Controlling(x) -> Function(x))", "KindOf(controlling, function)", "Function(controlling)"]}
{"id": "entailmentbank_validation_581", "nl": "a computer room in a factory has a similar function to the cell nucleus in controlling the functions.", "fol": "", "prediction": ["exists r, f, n. (ComputerRoom(r) & Factory(f) & In(f, r) & CellNucleus(n) & SimilarFunction(r, n) & ControlsFunctions(r) & ControlsFunctions(n))", "all x y. ((ComputerRoom(x) & InFactory(x) & CellNucleus(y)) -> SimilarFunction(x, y, ControlsFunctions))", "exists x. exists y. (ComputerRoom(x) & Factory(y) & In(y, x) & all z. (Function(z, x) <-> Function(z, CellNucleus)))", "exists x. (exists y. (ComputerRoom(x) & Factory(y) & In(x, y)) -> exists z. (exists w. (CellNucleus(z) & SimilarFunctionTo(x, z) & ControlsFunctions(z, w))))"]}
{"id": "entailmentbank_validation_582", "nl": "if something does not contain something else, then that something else cannot be found in that something.", "fol": "", "prediction": ["all x y. (-Contains(x, y) -> -CanBeFoundIn(y, x))", "all x all y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))"]}
{"id": "entailmentbank_validation_583", "nl": "a prokaryotic cell does not contain a nucleus.", "fol": "", "prediction": ["all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))"]}
{"id": "entailmentbank_validation_584", "nl": "a nucleus cannot be found in prokaryotic cells.", "fol": "", "prediction": ["all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))"]}
{"id": "entailmentbank_validation_585", "nl": "photosynthesis makes food for the plant.", "fol": "", "prediction": ["exists y. (Plant(y) & MakesFoodFor(photosynthesis, y))", "exists x. (Plant(x) & MakesFoodFor(photosynthesis, x))", "exists y. (Plant(y) & MakesFoodFor(photosynthesis, y))", "exists y. (Plant(y) -> FoodMadeForBy(y, photosynthesis))"]}
{"id": "entailmentbank_validation_586", "nl": "a leaf performs photosynthesis / gas exchange.", "fol": "", "prediction": ["all x. (Leaf(x) -> (PerformsPhotosynthesis(x) | PerformsGasExchange(x)))", "FOL Translation:\nall x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & GasExchange(x)))"]}
{"id": "entailmentbank_validation_587", "nl": "a leaf makes food for the plant by performing photosynthesis.", "fol": "", "prediction": ["exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & makesFoodFor(x, plant) & PerformsBy(x, photosynthesis))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))"]}
{"id": "entailmentbank_validation_588", "nl": "providing food is a kind of specific life process.", "fol": "", "prediction": ["SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "KindOf(ProvidingFood, SpecificLifeProcess)"]}
{"id": "entailmentbank_validation_589", "nl": "a leaf performs a specific life process of making food for the plants.", "fol": "", "prediction": ["exists x. (Leaf(x) & PerformsLifeProcess(x, make_food_for_plants))", "exists x. (Leaf(x) & PerformsLifeProcess(x, MakeFoodForPlants))", "exists x. (Leaf(x) & PerformsLifeProcessOfMakingFood(x, plant))", "exists x. (Leaf(x) & PerformsSpecificLifeProcess(x) & MakesFoodForPlants(x))"]}
{"id": "entailmentbank_validation_590", "nl": "organs perform specific life process in organisms.", "fol": "", "prediction": ["all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcessIn(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcess(x, y)))"]}
{"id": "entailmentbank_validation_591", "nl": "a leaf in a plant is performing like an organ in organisms.", "fol": "", "prediction": ["exists x, y, z, w. (Leaf(x) & Plant(y) & In(x, y) & Organ(z) & Organism(w) & In(z, w) & PerformsLike(x, z))", "exists x, y. (Leaf(x) & Plant(y) & In(x, y) & exists z, w. (Organ(z) & Organism(w) & In(z, w) & PerformsLike(x, z)))", "exists x, y, z. (Leaf(x) & InPlant(x, y) & Plant(y) & Organ(z) & InOrganisms(z) & PerformsLike(x, z))", "exists x, y, z. (Leaf(x) & InPlant(x, y) & Plant(y) & Organ(z) & InOrganisms(z) & PerformsLike(x, z))"]}
{"id": "entailmentbank_validation_592", "nl": "taking in carbon dioxide is a stage in the photosynthesis process.", "fol": "", "prediction": ["StageInPhotosynthesis(takingInCarbonDioxide)", "StageInPhotosynthesis(taking_in_carbon_dioxide)", "StageInPhotosynthesis(taking_in_carbon_dioxide)", "exists y. (StageOf(y, photosynthesis) & TakesInCarbonDioxide(y))"]}
{"id": "entailmentbank_validation_593", "nl": "absorbing something is a kind of method for taking something in.", "fol": "", "prediction": ["all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))"]}
{"id": "entailmentbank_validation_594", "nl": "absorbing carbon dioxide is a stage in the photosynthesis process.", "fol": "", "prediction": ["exists x. (Stage(x) & InPhotosynthesisProcess(x) & AbsorbingCarbonDioxide(x))", "StageInPhotosynthesis(absorbing_carbon_dioxide)", "StageInPhotosynthesis(absorbing_carbon_dioxide)", "exists x. (Stage(x) & AbsorbingCarbonDioxide(x) & InPhotosynthesisProcess(x))"]}
{"id": "entailmentbank_validation_595", "nl": "carbon dioxide can be found in the air.", "fol": "", "prediction": ["exists x. (CarbonDioxide(x) & FoundIn(x, air))", "exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (CarbonDioxide(x) & FoundInAir(x))"]}
{"id": "entailmentbank_validation_596", "nl": "absorbing carbon dioxide from the air is a stage in the photosynthesis process.", "fol": "", "prediction": ["StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "StageInPhotosynthesis(AbsorbCO2FromAir)", "StageInPhotosynthesis(AbsorbingCarbonDioxideFromAir)", "StageInPhotosynthesis(AbsorbingCO2FromAir)"]}
{"id": "entailmentbank_validation_597", "nl": "plants perform photosynthesis.", "fol": "", "prediction": ["all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformPhotosynthesis(x))"]}
{"id": "entailmentbank_validation_598", "nl": "a plant absorbs carbon dioxide from the air to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) & exists y. (CarbonDioxide(y) & FromAir(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & Air(z) & Absorbs(x, y, z) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & FromAir(y) & AbsorbsForPhotosynthesis(x, y)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & Air(z) & Absorbs(x, y) & From(x, z) & PerformsPhotosynthesis(x)))"]}
{"id": "entailmentbank_validation_599", "nl": "when carbon dioxide in the atmosphere is absorbed by plants, the amount of carbon dioxide in the atmosphere is reduced in the atmosphere.", "fol": "", "prediction": ["all x. (CarbonDioxide(x) & InAtmosphere(x) & absorbedBy(x, plants) -> ReducedAmountInAtmosphere(x))", "exists a, b. (CarbonDioxide(a) & Atmosphere(b) & AbsorbedBy(a, Plants) -> ReducedIn(a, b))", "all x. (Absorbed(x, atmosphere, plants) & CarbonDioxide(x) -> ReducedAmount(x, atmosphere))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedBy(x, Plants) -> ReducedInAtmosphere(x))"]}
{"id": "entailmentbank_validation_600", "nl": "plant photosynthesis reduces the amount of carbon dioxide in the air.", "fol": "", "prediction": ["all x. (Plant(x) & Photosynthesis(x) -> ReducesCarbonDioxideInAir(x))", "exists x. (Plant(x) & Photosynthesis(x) -> Reduces(x, CarbonDioxide, Air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))"]}
{"id": "entailmentbank_validation_601", "nl": "sunlight is a kind of solar energy.", "fol": "", "prediction": ["KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "IsKindOf(sunlight, solar_energy)"]}
{"id": "entailmentbank_validation_602", "nl": "photosynthesis means green plants convert from carbon dioxide and water and solar energy into carbohydrates and food and oxygen for themselves.", "fol": "", "prediction": ["all x. (GreenPlant(x) & Photosynthesis(x) -> Converts(x, (CarbonDioxide & Water & SolarEnergy), (Carbohydrates & Food & OxygenFor(x))))", "all x. ((GreenPlant(x) & Photosynthesis(x)) -> Converts(x, [carbon_dioxide, water, solar_energy], [carbohydrates, food, oxygen]))", "all g. (GreenPlant(g) -> (Converts(g, [CarbonDioxide, Water, SolarEnergy], [Carbohydrates, Food, Oxygen]) & ForThemselves(g)))", "Photosynthesis(x) -> all y. (GreenPlant(y) -> Converts(y, {CarbonDioxide, Water, SolarEnergy}, {Carbohydrates, Food, Oxygen}))"]}
{"id": "entailmentbank_validation_603", "nl": "photosynthesis means plants convert carbon dioxide and water and sunlight into carbohydrates and food and oxygen.", "fol": "", "prediction": ["Photosynthesis -> all x. (Plant(x) -> Converts(x, CarbonDioxide, Water, Sunlight, Carbohydrates, Food, Oxygen))", "PhotosynthesisMeansConversion = all x. (Plant(x) -> all y. (CarbonDioxide(y) & Water(y) & Sunlight(y) & Photosynthesis(x, y) -> exists z. (Carbohydrates(z) & Food(z) & Oxygen(z) & Converts(y, z))))", "all x. (Photosynthesis(x) <-> (all y. (Plant(y) -> Converts(y, CarbonDioxide, Water, Sunlight, Carbohydrates, Food, Oxygen))))", "all x. (Photosynthesis(x) -> Plant(x) & all y. ((CarbonDioxide(y) & Water(y) & Sunlight(y)) -> (Converts(x, y, Carbohydrates) & Converts(x, y, Food) & Converts(x, y, Oxygen))))"]}
{"id": "entailmentbank_validation_604", "nl": "if an orgnism uses a process to convert something into something else, then that something is used for that process.", "fol": "", "prediction": ["all x, y, z, p. ((Organism(x) & UsesProcessToConvert(x, p, y, z)) -> UsedFor(y, p))", "all x. all y. all z. all p. ((Organism(x) & ConvertsWithProcess(x, y, z, p)) -> UsedForProcess(y, p))", "all x. all y. all z. all p. ((Organism(x) & Process(p) & Converts(x, y, z, p)) -> UsedForProcess(y, p))", "all x. all y. all z. all p. ((Organism(x) & UsesProcessToConvert(x, p, y, z)) -> UsedForProcess(y, p))"]}
{"id": "entailmentbank_validation_605", "nl": "a plant uses sunlight for photosynthesis.", "fol": "", "prediction": ["Exists x. (Plant(x) & Uses(x, sunlight) & For(x, photosynthesis))", "Exists x. (Plant(x) -> UsesForPhotosynthesis(x, sunlight))", "exists p. (Plant(p) & UsesForPhotosynthesis(p, sunlight))", "exists x. (Plant(x) -> exists y. (Sunlight(y) & UsesFor(x, y, Photosynthesis)))"]}
{"id": "entailmentbank_validation_606", "nl": "in the photosynthesis process sunlight has the role of raw material.", "fol": "", "prediction": ["InPhotosynthesisProcess(photosynthesis) -> Role(sunlight, RawMaterial, photosynthesis)", "InPhotosynthesisProcess(sunlight) -> HasRole(sunlight, raw_material)", "exists x. (PhotosynthesisProcess(x) -> exists y. (Sunlight(y) & RoleAsRawMaterial(y, x)))", "exists p. (PhotosynthesisProcess(p) & exists m. (Sunlight(m) & HasRoleOf(m, RawMaterial, p)))"]}
{"id": "entailmentbank_validation_607", "nl": "a plant uses the raw material sunlight for photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) -> UsesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) & usesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedForPhotosynthesis(x, y)))", "exists x. (Plant(x) -> UsesFor(x, sunlight, photosynthesis))"]}
{"id": "entailmentbank_validation_608", "nl": "using a raw material sometimes requires absorbing that raw material.", "fol": "", "prediction": ["all x. (RawMaterial(x) -> exists w. (Sometimes(RequiresUsing(x, Absorbing(x, w)))))", "all x. (RawMaterial(x) -> exists y. (Absorbing(x, y) & Requires(x, y)))", "all x. (RawMaterial(x) -> exists y. (RequiresAbsorbing(x, y) & RawMaterial(y)))", "all x. (RawMaterial(x) -> exists y. (RequiresAbsorbing(y, x)))"]}
{"id": "entailmentbank_validation_609", "nl": "a plant absorbs sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) -> (exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x))))", "exists x. (Plant(x) -> AbsorbsSunlight(x) & PerformsPhotosynthesis(x))", "exists x. (Plant(x) -> exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "all x. (Plant(x) -> (exists y. (Sunlight(y) & Absorbs(x, y) & Performs(x, Photosynthesis))))"]}
{"id": "entailmentbank_validation_610", "nl": "a leaf absorbs sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x.(Leaf(x) & exists y.(Sunlight(y) & Absorbs(x, y) & PerformPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & CanPerformPhotosynthesis(x)))", "exists x. (Leaf(x) -> exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesisUsing(x, y)))", "all x. (Leaf(x) -> exists y. (Sunlight(y) & Absorbs(x, y) & Performs(x, Photosynthesis)))"]}
{"id": "entailmentbank_validation_611", "nl": "chlorophyll is found in the cells of leaves.", "fol": "", "prediction": ["exists x. (Chlorophyll(x) & exists y. (CellOfLeaves(y) & FoundIn(x, y)))", "all x. (Leaf(x) -> exists y. (Cell(y) & ContainsChlorophyll(y) & In(x, y)))", "exists x. (Chlorophyll(x) & all y. (Leaf(y) -> InCellsOf(x, y)))", "all x. (Leaf(x) -> exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(y, x)))"]}
{"id": "entailmentbank_validation_612", "nl": "chlorophyll is found in the cells of parts of plants that absorb sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Chlorophyll(x) & all y. ((Cell(y) & PartOf(z, y) & Plant(z) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z)) -> FoundIn(x, y)))", "exists x. (Chlorophyll(x) & exists y. (Cell(y) & PartOf(y, z) & Plant(z) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z) & FoundIn(x, y)))", "exists y. (Chlorophyll(y) & all x. ((PartOfPlant(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x)) -> FoundInCells(y, x)))", "all p. ((PartOfPlant(p) & AbsorbsSunlight(p) & PerformsPhotosynthesis(p)) -> exists c. (Cell(c) & FoundIn(chlorophyll, c) & PartOf(c, p)))"]}
{"id": "entailmentbank_validation_613", "nl": "chlorophyll is used for absorbing sunlight by plants.", "fol": "", "prediction": ["FOL Translation:\nall x. (Plant(x) -> UsesFor(x, chlorophyll, AbsorbSunlight))", "exists p. (Plant(p) & exists c. (Chlorophyll(c) & UsedFor(c, AbsorbingSunlight) & By(p, c)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedForAbsorbingSunlight(x, y)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, Absorbing(sunlight, y))))"]}
{"id": "entailmentbank_validation_614", "nl": "sunlight is a kind of light.", "fol": "", "prediction": ["KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "Kind(sunlight, light)"]}
{"id": "entailmentbank_validation_615", "nl": "light is a kind of energy.", "fol": "", "prediction": ["Energy(light)", "KindOf(light, energy)", "Energy(light)", "KindOf(light, energy)"]}
{"id": "entailmentbank_validation_616", "nl": "sunlight is a kind of light energy.", "fol": "", "prediction": ["LightEnergy(sunlight)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "LightEnergy(sunlight)"]}
{"id": "entailmentbank_validation_617", "nl": "chlorophyll is used for absorbing light energy by plants.", "fol": "", "prediction": ["exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedForAbsorbingLightEnergy(x, y)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbLightEnergy, y)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsesForAbsorbingLightEnergy(y, x)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbingLightEnergy) & By(x, y)))"]}
{"id": "entailmentbank_validation_618", "nl": "some microorganisms have a positive impact on human body.", "fol": "", "prediction": ["exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & HasPositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & HasPositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & HasPositiveImpactOn(x, human_body))"]}
{"id": "entailmentbank_validation_619", "nl": "if something has a positive impact on another thing, then the relationship is benificial.", "fol": "", "prediction": ["all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpactOn(x, y) -> RelationshipIsBeneficial(x, y))", "all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))"]}
{"id": "entailmentbank_validation_620", "nl": "some microorganisms are benificial to human body.", "fol": "", "prediction": ["exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))"]}
{"id": "entailmentbank_validation_621", "nl": "disease-causing microbes have a negative impact on the body.", "fol": "", "prediction": ["all x. (DiseaseCausingMicrobe(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> NegativeImpactOnBody(x))"]}
{"id": "entailmentbank_validation_622", "nl": "if something has a negative impact on another thing, then the relationship is harmful.", "fol": "", "prediction": ["all x y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (HasNegativeImpactOn(x, y) -> HarmfulRelationship(x, y))", "all x, y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))"]}
{"id": "entailmentbank_validation_623", "nl": "some disease-causing microbes are harmful to human body.", "fol": "", "prediction": ["exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & DiseaseCausing(x) & HarmfulToHumanBody(x))", "exists x. (DiseaseCausingMicrobe(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))"]}
{"id": "entailmentbank_validation_624", "nl": "the relationship between human and microorganisms is sometimes beneficial and sometimes harmful.", "fol": "", "prediction": ["exists x exists y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (SometimesBeneficial(Relationship(x, y)) & SometimesHarmful(Relationship(x, y))))", "exists r. (RelationshipBetween(human, microorganisms, r) & (Beneficial(r) & Harmful(r)))"]}
{"id": "entailmentbank_validation_625", "nl": "water is a kind of nonliving thing.", "fol": "", "prediction": ["NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "Nonliving(water)"]}
{"id": "entailmentbank_validation_626", "nl": "a river is a kind of body of water.", "fol": "", "prediction": ["all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))"]}
{"id": "entailmentbank_validation_627", "nl": "a river is a nonliving thing.", "fol": "", "prediction": ["River(x) -> NonlivingThing(x)", "all x. (River(x) -> NonlivingThing(x))", "River(x) -> NonlivingThing(x)", "all x. (River(x) -> NonlivingThing(x))"]}
{"id": "entailmentbank_validation_628", "nl": "preferences are generally learned characteristics.", "fol": "", "prediction": ["all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_629", "nl": "a food preference is a kind of preference.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))"]}
{"id": "entailmentbank_validation_630", "nl": "food preference is a kind of learned characteristics.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_631", "nl": "learned characteristics are similar to acquired characteristics.", "fol": "", "prediction": ["all x y. (LearnedCharacteristic(x) & AcquiredCharacteristic(y) -> Similar(x, y))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x)) & all x. (AcquiredCharacteristic(x) -> LearnedCharacteristic(x) & Similar(x))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x)) & all x. (AcquiredCharacteristic(x) -> LearnedCharacteristic(x))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x))"]}
{"id": "entailmentbank_validation_632", "nl": "food preference is a kind of acquired characteristics.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))"]}
{"id": "entailmentbank_validation_633", "nl": "an animal is a kind of organism.", "fol": "", "prediction": ["all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_634", "nl": "a dog is a kind of animal.", "fol": "", "prediction": ["Dog(x) -> Animal(x)", "all x. (Dog(x) -> Animal(x))", "all x. (Dog(x) -> Animal(x))", "Dog(x) -> Animal(x)"]}
{"id": "entailmentbank_validation_635", "nl": "a dog is a kind of organism.", "fol": "", "prediction": ["all x. (Dog(x) -> Organism(x))", "Dog(d) -> Organism(d)", "Dog(x) -> Organism(x)", "all x. (Dog(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_636", "nl": "an organism's environment affects that organism's acquired characteristics.", "fol": "", "prediction": ["all x. all y. (Organism(x) & Environment(y) & BelongsTo(y, x) -> Affects(y, AcquiredCharacteristics(x)))", "all x. all y. ((Organism(x) & Environment(y) & AffectedBy(x, y)) -> Affects(y, AcquiredCharacteristics(x)))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, x's_acquired_characteristics)))", "all x. (Organism(x) -> exists y. (Environment(x, y) & Affects(y, AcquiredCharacteristics(x))))"]}
{"id": "entailmentbank_validation_637", "nl": "the food preference of a dog is affected by its environment.", "fol": "", "prediction": ["all x. (Dog(x) -> exists y. (Environment(y) & Affects(FoodPreference(x), y)))", "exists x. (Dog(x) -> exists y. (Environment(y) & Affects(FoodPreference(x), y)))", "exists x. (Dog(x) -> exists y. (Environment(y) & AffectsPreference(y, x)))", "all d. all e. (Dog(d) & Environment(e) & AffectedBy(FoodPreference(d), e))"]}
{"id": "entailmentbank_validation_638", "nl": "following orders is a learned characteristic.", "fol": "", "prediction": ["LearnedCharacteristic(following_orders)", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_639", "nl": "an example of following orders is coming when called.", "fol": "", "prediction": ["exists x. (ExampleOfFollowingOrders(x) & ComesWhenCalled(x))", "exists x. (Order(x) & FulfillsOrderByComing(x, Call(x)))", "Example(x) & FollowingOrders(x) & ComesWhenCalled(x)", "exists x, y. (FollowOrders(x) & ExampleOf(y, x) & ComeWhenCalled(y))"]}
{"id": "entailmentbank_validation_640", "nl": "a dog coming when called is a kind of learned characteristic.", "fol": "", "prediction": ["all x. ((Dog(x) & ComesWhenCalled(x)) -> LearnedCharacteristic(x))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))", "Exists x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComingWhenCalled(x)))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_641", "nl": "hunting is a kind of skill.", "fol": "", "prediction": ["Skill(hunting)", "Skill(hunting)", "all x. (Hunting(x) -> Skill(x))", "Skill(hunting)"]}
{"id": "entailmentbank_validation_642", "nl": "skills are learned characteristics / behaviors.", "fol": "", "prediction": ["all x. (Skill(x) -> exists y. (Characteristic(y) & Behavior(y) & Learned(x, y)))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))"]}
{"id": "entailmentbank_validation_643", "nl": "hunting is a kind of learned behaviors.", "fol": "", "prediction": ["all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))"]}
{"id": "entailmentbank_validation_644", "nl": "inherited characteristics are the opposite of learned characteristics.", "fol": "", "prediction": ["all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. ((InheritedCharacteristic(x) -> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) -> -InheritedCharacteristic(x)))", "Opposite(inherited_characteristics, learned_characteristics)", "FOL Translation:\nall x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_645", "nl": "learned characteristics are not inherited from parents.", "fol": "", "prediction": ["all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y, x) & Inherited(x, y)))", "all x. ((LearnedCharacteristic(x) & InheritedFrom(x, y)) -> -InheritedFrom(x, z))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritedFrom(x, y)))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))"]}
{"id": "entailmentbank_validation_646", "nl": "food preference is not inherited from parents.", "fol": "", "prediction": ["all x y. (Parent(x, y) -> -Inherited(FoodPreference(y), x))", "all x, y. (Parent(y, x) -> -InheritsFoodPreference(x, y))", "all x. (Parent(x) -> -InheritsFoodPreference(x))", "all x. (Parent(x) -> -Inherited(FoodPreference(x)))"]}
{"id": "entailmentbank_validation_647", "nl": "the intelligence of animals is an acquired characteristic.", "fol": "", "prediction": ["all x. (Animal(x) -> Exists y. (Characteristic(y) & Intelligence(y) & Acquired(y)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))"]}
{"id": "entailmentbank_validation_648", "nl": "the intelligence of a human is an acquired characteristic.", "fol": "", "prediction": ["exists x. (Human(x) & AcquiredCharacteristic(IntelligenceOf(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) & AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))"]}
{"id": "entailmentbank_validation_649", "nl": "inherited characteristics are the opposite of acquired characteristics.", "fol": "", "prediction": ["all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. ((InheritedCharacteristic(x) -> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) -> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. ((InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) <-> -InheritedCharacteristic(x)))"]}
{"id": "entailmentbank_validation_650", "nl": "the intelligence of a human is not an inherited characteristic.", "fol": "", "prediction": ["all x. (Human(x) -> -(InheritedCharacteristic(Intelligence(x))))", "exists x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))"]}
{"id": "entailmentbank_validation_651", "nl": "genes is a vehicle for passing inherited characteristics from parent to offspring.", "fol": "", "prediction": ["Vehicle(genes) & ForPassing(genes, InheritedCharacteristics) & From(parent, offspring)", "Vehicle(genes) & all x. (all y. (Parent(x, y) -> PassesInheritedCharacteristics(genes, x, y)))", "VehicleForInheritance(genes)", "Vehicle(genes) & For(genes, PassingInheritedCharacteristics) & FromTo(PassingInheritedCharacteristics, parent, offspring)"]}
{"id": "entailmentbank_validation_652", "nl": "a father is a kind of male parent.", "fol": "", "prediction": ["all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))"]}
{"id": "entailmentbank_validation_653", "nl": "a mother is a kind of female parent.", "fol": "", "prediction": ["all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))"]}
{"id": "entailmentbank_validation_654", "nl": "genes are a vehicle for passing inherited characteristics from a mother and a father to offspring.", "fol": "", "prediction": ["all x. (Gene(x) -> VehicleForInheritedCharacteristics(x, mother, father, offspring))", "all g, c, m, f, o. ((Gene(g) & InheritedCharacteristic(c) & Mother(m) & Father(f) & Offspring(o)) -> (VehicleForPassing(g, c, m, f, o)))", "all g. (Gene(g) -> exists m, f, o. (Mother(m) & Father(f) & Offspring(o) & PassesInheritedCharacteristics(g, m, f, o)))", "all x. (Gene(x) -> VehicleForPassingInheritedCharacteristicsFromParentToOffspring(x))"]}
{"id": "entailmentbank_validation_655", "nl": "in sexual reproduction sperm is a vehicle for the genes from the father to the offspring.", "fol": "", "prediction": ["exists x exists y exists z. (SexualReproduction(x) & Sperm(y) & VehicleForGenes(y, x) & Father(z) & TransfersGenesFromTo(y, z, Offspring(x)))", "exists x. (Sperm(x) & VehicleForGenes(x, father) & ToOffspring(x))", "exists x, y, z. (Sperm(x) & Gene(y) & Father(z) & VehicleFor(x, y) & From(y, z) & To(y, Offspring(w)))", "exists sperm, father, offspring, genes. (SexualReproduction(sperm) & VehicleForGenes(sperm, genes) & FromFather(father, genes) & ToOffspring(offspring, genes))"]}
{"id": "entailmentbank_validation_656", "nl": "in sexual reproduction the egg is a vehicle for the genes from the mother to the offspring.", "fol": "", "prediction": ["exists x. (Egg(x) & SexualReproduction(x) & VehicleForGenes(x, mother, offspring))", "Exists x. (Egg(x) & VehicleFor(x, GenesFromMother, Offspring))", "exists x, y, z. (Egg(x) & Mother(y) & Offspring(z) & VehicleForGenesFromTo(x, y, z) & SexualReproduction(x))", "Existentially quantifying over processes and entities involved, the sentence can be translated into FOL as follows:\n\nexists x. (SexualReproduction(x) & Exists y. (Egg(y) & VehicleForGenes(y) & ComesFromMother(y) & ToOffspring(y)))"]}
{"id": "entailmentbank_validation_657", "nl": "genes are passed from a mother and a father to offspring through the egg and sperm.", "fol": "", "prediction": ["all g, o. (Gene(g) & Offspring(o) -> (exists m. (Mother(m) & PassesThroughEgg(g, m, o))) & exists f. (Father(f) & PassesThroughSperm(g, f, o)))", "all g, o, m, f, e, s. ((Gene(g, m) & Gene(g, f) & Offspring(o, e, s)) -> (Passed(g, m, o, e) & Passed(g, f, o, s)))", "all g. (Gene(g) -> exists m, f, o, e, s. (Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassedFrom(m, f, o, e, s, g)))", "all g, m, f, o, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & FromMother(g, m, o) & FromFather(g, f, o)) -> PassedThrough(g, e, s, o))"]}
{"id": "entailmentbank_validation_658", "nl": "genes determine the traits for the living things.", "fol": "", "prediction": ["all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, TraitFor(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, TraitOf(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))"]}
{"id": "entailmentbank_validation_659", "nl": "traits are passed from a mother and a father to offspring through the egg and sperm.", "fol": "", "prediction": ["all x. (Offspring(x) -> exists y z. (Mother(y) & Father(z) & PassTraitsVia(y, egg, x) & PassTraitsVia(z, sperm, x)))", "all x, y, z, w. ((Mother(x) & Father(y) & Offspring(z) & Egg(w) & Sperm(w)) -> PassesTraits(x, y, z, w))", "all t, m, f, o, e, s. ((Trait(t) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassThrough(m, f, t, o, e, s)) <-> (PassedFrom(t, m, o) & PassedFrom(t, f, o) & ViaEgg(t, e) & ViaSperm(t, s)))", "all t, o, e, s. ((Trait(t) & Offspring(o) & Mother(m) & Father(f) & Egg(e) & Sperm(s)) -> (PassedFrom(t, m, o, e) & PassedFrom(t, f, o, s)))"]}
{"id": "entailmentbank_validation_660", "nl": "dna is a kind of nucleic acid.", "fol": "", "prediction": ["KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)"]}
{"id": "entailmentbank_validation_661", "nl": "thymine is found in dna.", "fol": "", "prediction": ["FoundIn(thymine, dna)", "Exists x. (DNA(x) & Contains(x, thymine))", "FoundIn(thymine, dna)", "Exists y. (dna(y) & FoundIn(thymine, y))"]}
{"id": "entailmentbank_validation_662", "nl": "thymine cannot be found in rna.", "fol": "", "prediction": ["all x. (RNA(x) -> -Contains(x, thymine))", "``` \nall x. (RNA(x) -> -ContainsThymine(x))\n```", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))"]}
{"id": "entailmentbank_validation_663", "nl": "if thymine is found in a strand of nucleic acid, then the nucleic acid is dna.", "fol": "", "prediction": ["exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> IsDNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))", "exists x, y. (FoundIn(thymine, x) & StrandOf(x, y) & NucleicAcid(y) -> DNA(y))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> IsDNA(x))"]}
{"id": "entailmentbank_validation_664", "nl": "a researcher found thymine in a strand of nucleic acid.", "fol": "", "prediction": ["exists x, y, z. (Researcher(x) & Found(x, y, z) & Thymine(y) & StrandOfNucleicAcid(z))", "exists x. (Researcher(x) & exists y. (StrandOfNucleicAcid(y) & FoundThymine(x, y)))", "exists x. exists y. (Researcher(x) & StrandOfNucleicAcid(y) & FoundThymineIn(x, y))", "exists x. exists y. (Researcher(x) & Found(x, thymine, y) & StrandOfNucleicAcid(y))"]}
{"id": "entailmentbank_validation_665", "nl": "the researcher found a strand of dna.", "fol": "", "prediction": ["exists x. (StrandOfDNA(x) & Found(researcher, x))", "exists x. (StrandOfDNA(x) & Found(researcher, x))", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))"]}
{"id": "entailmentbank_validation_666", "nl": "if a pure dominant organism is crossed a recessive organism, then the offspring will have a 100% probability of being heterozygous dominant.", "fol": "", "prediction": ["all x. all y. ((PureDominant(x) & Recessive(y) & CrossedWith(x, y)) -> OffspringProbabilityHeterozygousDominant(Offspring(x, y), 1.0))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability100Percent(x, y))", "all x y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominant(x, y))", "all x y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(x, y, 100))"]}
{"id": "entailmentbank_validation_667", "nl": "a scientist crosses a red-flowered plant with a white-flowered plant, and all offspring have red flowers.", "fol": "", "prediction": ["exists x y. (Scientist(x) & RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o)))", "exists x, y. (Scientist(x) & RedFloweredPlant(y) & exists z. (WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))", "exists x. (Scientist(x) & exists y. exists z. (RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))", "exists x. exists y. (Scientist(x) & Plant(y) & RedFlowered(y) & exists z. (Plant(z) & WhiteFlowered(z) & Crosses(x, y, z) & all o. (Offspring(o, x, y, z) -> RedFlowered(o))))"]}
{"id": "entailmentbank_validation_668", "nl": "all the offspring with red flowers are heterozygous dominant.", "fol": "", "prediction": ["all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))"]}
{"id": "entailmentbank_validation_669", "nl": "the offspring with red flowers are crossed with pure recessive white flowered plants.", "fol": "", "prediction": ["exists x, y. (Offspring(x) & HasRedFlowers(x) & Plant(y) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessiveWhiteFlowers(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessivePlant(y) & HasWhiteFlowers(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & Plant(y) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y))"]}
{"id": "entailmentbank_validation_670", "nl": "heterozygous dominant red flowered plants are crossed with pure recessive white flowered plants.", "fol": "", "prediction": ["**Sentence**: Heterozygous dominant red flowered plants are crossed with pure recessive white flowered plants.\n\n**FOL Translation**:  \nall x. (HeterozygousDominantRed(x) -> exists y. (PureRecessiveWhite(y) & Crossed(x, y)))", "exists x, y. (Plant(x) & HeterozygousDominant(x) & RedFlowered(x) & Plant(y) & PureRecessive(y) & WhiteFlowered(y) & CrossedWith(x, y))", "Crossed(HeterozygousDominantRedFloweredPlant(x), PureRecessiveWhiteFloweredPlant(y))", "exists x exists y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))"]}
{"id": "entailmentbank_validation_671", "nl": "crossing a heterozygous dominant organism with a homozygous recessive organism causes their offspring to be dominant or recessive with either of 50% probability.", "fol": "", "prediction": ["all x. (HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(y) & Crosses(x, y) -> all z. (Offspring(z, x, y) -> ((Dominant(z) & Probability(50)) | (Recessive(z) & Probability(50)))))", "all x all y ((HeterozygousDominant(x) & HomozygousRecessive(y)) -> (OffspringOf(x, y, z) -> (Dominant(z) | Recessive(z)) & Probability(Dominant(z), 0.5) & Probability(Recessive(z), 0.5)))", "all x y. ((HeterozygousDominant(x) & HomozygousRecessive(y) & CausesOffspring(x, y, z)) -> (Dominant(z) | Recessive(z)) & Probability(Dominant(z), 0.5) & Probability(Recessive(z), 0.5))", "all x y. ((HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(y) & Crossed(x, y)) -> exists z. (Offspring(z, x, y) & (Dominant(z) & Probability(Dominant(z), 50%) | Recessive(z) & Probability(Recessive(z), 50%))))"]}
{"id": "entailmentbank_validation_672", "nl": "the offspring will have either dominant red flowers or recessive white flowers with either of 50% probability.", "fol": "", "prediction": ["exists x. (Offspring(x) & ((DominantRedFlowers(x) & Probability(x, 50)) | (RecessiveWhiteFlowers(x) & Probability(x, 50))))", "exists x. (Offspring(x) & ((DominantRedFlowers(x) & Probability(x, 50)) | (RecessiveWhiteFlowers(x) & Probability(x, 50))))", "FOL Translation:\nOffspring(x) -> ((DominantRedFlowers(x) | RecessiveWhiteFlowers(x)) & Probability(DominantRedFlowers(x), 0.5) & Probability(RecessiveWhiteFlowers(x), 0.5))", "exists x. (Offspring(x) & ((HasDominantRedFlowers(x) & Probability(x, 50)) | (HasRecessiveWhiteFlowers(x) & Probability(x, 50))))"]}
{"id": "entailmentbank_validation_673", "nl": "each parent carries one sickle cell allele.", "fol": "", "prediction": ["all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))"]}
{"id": "entailmentbank_validation_674", "nl": "sickle cell anemia is a recessive trait in human.", "fol": "", "prediction": ["all x. ((Human(x) & HasTrait(x, sickle_cell_anemia)) -> Recessive(sickle_cell_anemia))", "RecessiveTrait(sickle_cell_anemia, human)", "Trait(sickle_cell_anemia, recessive) & In(human, sickle_cell_anemia)", "RecessiveTrait(sickle_cell_anemia, human)"]}
{"id": "entailmentbank_validation_675", "nl": "each parent has one dominant gene and a recessive gene for sickle cell anemia.", "fol": "", "prediction": ["all x. (Parent(x) -> exists y z. (DominantGene(x, y) & RecessiveGene(x, z) & GeneForSickleCellAnemia(y) & GeneForSickleCellAnemia(z) & y != z))", "all x. (Parent(x) -> exists y. (Gene(y) & Dominant(y) & HasGene(x, y)) & exists z. (Gene(z) & Recessive(z) & HasGene(x, z)))", "all x. (Parent(x) -> exists d. exists r. (DominantGeneForSickleCellAnemia(d) & RecessiveGeneForSickleCellAnemia(r) & HasGene(x, d) & HasGene(x, r)))", "all x. (Parent(x) -> exists y. (DominantGene(x, y) & RecessiveGene(x, y) & GeneForSickleCellAnemia(y)))"]}
{"id": "entailmentbank_validation_676", "nl": "heterozygous dominant organisms have one dominant gene and one recessive gene.", "fol": "", "prediction": ["all x. (HeterozygousDominant(x) -> exists y. (DominantGene(y) & HasGene(x, y)) & exists z. (RecessiveGene(z) & HasGene(x, z)))", "all x. (HeterozygousDominantOrganism(x) -> (HasDominantGene(x) & HasRecessiveGene(x)))", "all x. (HeterozygousDominant(x) -> (exists y. (DominantGene(y) & HasGene(x, y)) & exists z. (RecessiveGene(z) & HasGene(x, z))))", "all x. (HeterozygousDominant(x) -> exists y. (DominantGene(y) & HasGene(x, y)) & exists z. (RecessiveGene(z) & HasGene(x, z)))"]}
{"id": "entailmentbank_validation_677", "nl": "both parents are heterozygous dominant for sickle cell anemia.", "fol": "", "prediction": ["all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))", "exists x. (Parent(x) & HeterozygousDominant(x) & HasTrait(x, sickle_cell_anemia)) & exists y. (x \u2260 y & Parent(y) & HeterozygousDominant(y) & HasTrait(y, sickle_cell_anemia))", "exists x. (Parent(x) & HeterozygousDominantForSickleCellAnemia(x)) & exists y. (Parent(y) & HeterozygousDominantForSickleCellAnemia(y) & x \u2260 y)", "all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))"]}
{"id": "entailmentbank_validation_678", "nl": "if a heterozygous dominant organism is crossed with a heterozygous dominant organism, then the offspring will have a 25% probability of being homozygous recessive.", "fol": "", "prediction": ["all x. all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(offspring_of(x, y)) = 0.25)", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & CrossedWith(x, y)) -> HasProbabilityOfHomozygousRecessiveOffspring(x, y, 0.25))", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringHas25PercentProbabilityOfHomozygousRecessive(x, y))", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringWillHaveProbabilityOfHomozygousRecessive(offspring(x, y), 0.25))"]}
{"id": "entailmentbank_validation_679", "nl": "the offspring of heterozygous dominant parents will have 25% probability of being homozygous recessive for sickle cell anemia.", "fol": "", "prediction": ["all x. (OffspringOfHeterozygousDominantParents(x) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "Given the complexity of the statement and the probabilistic aspect, the translation into FOL would focus on representing the relationship without directly encoding probabilities since FOL is not typically used for probabilistic reasoning. Instead, we will focus on the genetic relationship.\n\nFOL Translation:\nall x. (Offspring(x) & HasParents(x, heterozygous_dominant_parents) -> HasProbability(x, homozygous_recessive_for_sickle_cell_anemia, 0.25))", "all x. ((Offspring(x) & ParentHeterozygousDominant(x)) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "all x. (OffspringOfHeterozygousDominantParents(x) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))"]}
{"id": "entailmentbank_validation_680", "nl": "homozygous recessive organisms will show the recessive trait.", "fol": "", "prediction": ["all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))"]}
{"id": "entailmentbank_validation_681", "nl": "the offspring of heterozygous dominant parents will have 25% probability of having sickle cell anemia.", "fol": "", "prediction": ["all x. ((Offspring(x) & HasParents(x, h1, h2) & HeterozygousDominant(h1) & HeterozygousDominant(h2)) -> ProbabilityOfHavingSickleCellAnemia(x, 0.25))", "all x. ((Offspring(x) & ParentHeterozygousDominant(x)) -> Has25PercentProbabilityOfSickleCellAnemia(x))", "all x. (OffspringOf(x, HeterozygousDominantParents) -> Has25PercentProbabilityOf(SickleCellAnemia(x)))", "all x. ((Offspring(x) & HeterozygousDominantParents(x)) -> Probability(SickleCellAnemia(x)) = 0.25)"]}
{"id": "entailmentbank_validation_682", "nl": "one in four is the same as 25%.", "fol": "", "prediction": ["Equivalent(one_in_four, twenty_five_percent)", "all x. (OneInFour(x) <-> x = TwentyFivePercent)", "The sentence 'one in four is the same as 25%' can be translated into first-order logic as simply stating the equivalence of the two expressions:\n\nEqual(one_in_four, twenty_five_percent)", "all x. ((OneInFour(x) & Percentage(x, 25)) <-> Equals(x, 25))"]}
{"id": "entailmentbank_validation_683", "nl": "one in four of the offspring of heterozygous dominant parents will have sickle cell anemia.", "fol": "", "prediction": ["exists x. (Offspring(x) & Parent1(heterozygous_dominant) & Parent2(heterozygous_dominant) & HasSickleCellAnemia(x) & Probability(x, OneInFour))", "Given \"one in four of the offspring of heterozygous dominant parents will have sickle cell anemia,\" we need to construct a translation assuming a background understanding of genetics and probabilities. \n\nLet's define the predicates and the process step-by-step:\n\n1. **HeterozygousDominantParent(x)**: `x` is a heterozygous dominant parent.\n2. **OffspringOf(x, y)**: `x` is an offspring of `y`.\n3. **HasSickleCellAnemia(x)**: `x` has sickle cell anemia.\n\nWith these predicates, we describe this statement using probability implicitly, using multiple quantifiers. A literal interpretation into FOL that incorporates probabilities as implied logical conditions could be taken by stating that it is possible to classify a structured grouping of offspring based on proportions. \n\nFOL Translation:\n\nexists x, y. (HeterozygousDominantParent(x) & HeterozygousDominantParent(y) ->\n    exists z. (OffspringOf(z, x) & OffspringOf(z, y) & HasSickleCellAnemia(z) & ProbOneInFour(z))) \n\nNote: ProbOneInFour(z) would suggest that the probability of being z (among possible outcomes for offspring) considering sickle cell anemia is one in four. This aspect is more about encoding interpretations in FOL, which doesn\u2019t deal with direct probabilities but can label the context and infer percentages through an abstraction like this.", "all x. (Offspring(x) & HeterozygousDominantParents(x) -> Probability(SickleCellAnemia(x), 0.25))", "all x. (OffspringOf(x, heterozygous_dominant_parents) & OneInFour(x) -> HasSickleCellAnemia(x))"]}
{"id": "entailmentbank_validation_684", "nl": "a plant is a kind of organism.", "fol": "", "prediction": ["all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_685", "nl": "flower is a part of a plant.", "fol": "", "prediction": ["PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)"]}
{"id": "entailmentbank_validation_686", "nl": "the colors of parts of an organism are inherited characteristics.", "fol": "", "prediction": ["all x. (PartOf(x, organism) -> exists y. (Color(x, y) & InheritedCharacteristic(y)))", "all x. (PartOfOrganism(x) -> exists y. (ColorOf(x, y) & InheritedCharacteristic(y)))", "all x. (PartOfOrganism(x) -> exists y. (ColorOfPart(x, y) & InheritedCharacteristic(y)))", "all x y. ((Part(x) & IsPartOf(x, y) & Organism(y)) -> InheritedCharacteristic(Color(x)))"]}
{"id": "entailmentbank_validation_687", "nl": "the color of plants' flowers is a kind of inherited characteristic.", "fol": "", "prediction": ["all x. (Plant(x) -> exists y. (Flower(y) & BelongsTo(y, x) & InheritedCharacteristic(Color(y))))", "exists x. (Plant(x) -> exists y. (Flower(y) & HasColor(y, z) & InheritedCharacteristic(HasColor(y, z))))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y) & InheritedCharacteristic(HasColor(y))))", "all x. (Plant(x) -> exists y. (Flower(y) & PartOf(y, x) & exists c. (Color(c, y) & InheritedCharacteristic(c))))"]}
{"id": "entailmentbank_validation_688", "nl": "inheriting is when an inherited characteristic is passed down from parent to offspring by genetics / dna.", "fol": "", "prediction": ["all c. (InheritedCharacteristic(c) -> all p, o. (Parent(p) & Offspring(o) & PassedDownByGenetics(c, p, o) <-> Inheriting(c)))", "all x, y, z. (InheritedCharacteristic(y) & Parent(x, z) & Offspring(z, x) & PassedDownByGeneticsOrDNA(y, x, z) -> Inheriting(y, x, z))", "all x. ((InheritedCharacteristic(x) & PassedDownFromParentToOffspringByGenetics(x)) <-> Inheriting(x))", "all x. (InheritedCharacteristic(x) -> all y. (Parent(y) -> exists z. (Offspring(z) & PassedDownByGenetics(x, y, z))))"]}
{"id": "entailmentbank_validation_689", "nl": "plants offspring can inherit the flower color from their parents.", "fol": "", "prediction": ["all x. (PlantOffspring(x) -> exists y. (Parent(y, x) & FlowerColor(y, c) -> FlowerColor(x, c)))", "all x. (Plant(x) & exists y. (Offspring(x, y) & Parent(x, y)) -> InheritFlowerColor(y, x))", "all p. (Plant(p) -> exists o, c, p1, p2. (Offspring(o, p) & Parent(p1, o) & Parent(p2, o) & InheritsFlowerColor(o, c) & FlowerColor(p1, c)))", "all x. (Plant(x) & exists y. (Offspring(x, y)) -> exists z. (Parent(z, y) & InheritFlowerColor(y, z)))"]}
{"id": "entailmentbank_validation_690", "nl": "yellow is a kind of color.", "fol": "", "prediction": ["Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)"]}
{"id": "entailmentbank_validation_691", "nl": "the plant offspring has yellow flowers.", "fol": "", "prediction": ["exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (Offspring(x) & HasYellowFlowers(x))", "exists x. (Offspring(x) & Plant(x) & HasYellowFlowers(x))"]}
{"id": "entailmentbank_validation_692", "nl": "the parents of the plant are likely to have yellow flowers.", "fol": "", "prediction": ["exists x. (Parent(x, plant) -> Likely(HaveYellowFlowers(x)))", "exists x. (Parent(x, the_plant) -> LikelyHaveYellowFlowers(x))", "exists x. (Plant(x) & all y. (ParentOf(y, x) -> LikelyHasYellowFlowers(y)))", "exists x. (ParentOf(x, plant) -> LikelyToHaveYellowFlowers(x))"]}
{"id": "entailmentbank_validation_693", "nl": "a newly hatched sea turtle walks toward the ocean.", "fol": "", "prediction": ["exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksToward(x, ocean))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))"]}
{"id": "entailmentbank_validation_694", "nl": "if an animal hatches from an egg then that animal is born.", "fol": "", "prediction": ["all x. (HatchesFromEgg(x) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))"]}
{"id": "entailmentbank_validation_695", "nl": "a sea turtle that is just born walks toward the ocean.", "fol": "", "prediction": ["exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))"]}
{"id": "entailmentbank_validation_696", "nl": "an animal knows how to do instinctive behaviors when it is born.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDoWhenBorn(x, y)))", "all x. (Animal(x) -> (KnowsInstinctiveBehaviorsWhenBorn(x)))", "all x. (Animal(x) -> (exists y. (InstinctiveBehavior(y) & KnowsHowToDo(x, y) & Born(x))))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDo(x, y) & BornWithKnowledge(x)))"]}
{"id": "entailmentbank_validation_697", "nl": "walking toward the ocean is sea turtles' instinct behavior.", "fol": "", "prediction": ["all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "Instinct(sea_turtles, WalkingToward(ocean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))"]}
{"id": "entailmentbank_validation_698", "nl": "a chicken is a kind of bird.", "fol": "", "prediction": ["Bird(chicken)", "Bird(chicken)", "Chicken(x) -> Bird(x)", "Bird(chicken)"]}
{"id": "entailmentbank_validation_699", "nl": "a chick is a kind of young / baby chicken.", "fol": "", "prediction": ["Chick(y) -> YoungChicken(y)", "Young(chick) & Chicken(chick)", "Chick(y) -> (exists x. (Chicken(x) & Young(y, x)))", ""]}
{"id": "entailmentbank_validation_700", "nl": "a chick is a kind of baby bird.", "fol": "", "prediction": ["Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "BabyBird(chick)"]}
{"id": "entailmentbank_validation_701", "nl": "an example of an instinctive behavior is a baby bird pecking at its shell to hatch.", "fol": "", "prediction": ["exists x. (ExampleOfInstinctiveBehavior(x) & BabyBird(y) & PecksAtShellToHatch(y))", "exists x. (InstinctiveBehavior(x) & Example(x, PecksAtShell(baby_bird)))", "exists x y. (InstinctiveBehavior(x) & Example(x, Pecking(baby_bird, y) & Shell(y) & Hatch(baby_bird)))", "exists x. (ExampleOfInstinctiveBehavior(x) & BabyBird(y) & PeckingAtShell(y) & Hatch(y))"]}
{"id": "entailmentbank_validation_702", "nl": "a chick pecking at its shell to hatch is an example of an instictive behavior.", "fol": "", "prediction": ["exists x. exists y. (Chick(x) & Shell(y) & PecksAt(x, y) & Hatching(x, y) & ExampleOf(InstinctiveBehavior, Hatching(x, y)))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))"]}
{"id": "entailmentbank_validation_703", "nl": "receiving the recessive gene for a trait from each parent causes the offspring to have that recessive trait.", "fol": "", "prediction": ["all x. (exists y. (Parent(y, x) & RecessiveGeneForTrait(y)) & exists z. (Parent(z, x) & RecessiveGeneForTrait(z)) & y != z -> HasRecessiveTrait(x))", "all x. (((Parent(y, x) & RecessiveGeneForTrait(y, t)) & (Parent(z, x) & RecessiveGeneForTrait(z, t)) & y != z) -> HasRecessiveTrait(x, t))", "all x. (exists y. (Parent(y, x) & RecessiveGeneForTrait(y, z))) -> (RecessiveTrait(x, z)))", "all x. (exists y. exists z. (Offspring(x) & Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z) & y != z) -> HasRecessiveTrait(x))"]}
{"id": "entailmentbank_validation_704", "nl": "blue eye is a recessive trait in human.", "fol": "", "prediction": ["RecessiveTraitIn(blue_eye, human)", "RecessiveTrait(blue_eye, human)", "all x. (BlueEyeTrait(x) & Human(x) -> RecessiveTrait(x))", "RecessiveTrait(blue_eye, human)"]}
{"id": "entailmentbank_validation_705", "nl": "to have blue eyes requires receiving the recessive gene from each parent.", "fol": "", "prediction": ["all x. (HasBlueEyes(x) -> (exists p1. Parent(p1, x) & RecessiveGeneFrom(p1, x)) & exists p2. Parent(p2, x) & RecessiveGeneFrom(p2, x)))", "all x. (HasBlueEyes(x) -> (exists y. (Parent(y, x) & ReceivesRecessiveGeneFrom(y, x)) & exists z. (Parent(z, x) & ReceivesRecessiveGeneFrom(z, x) & y != z)))", "all x. (HasBlueEyes(x) -> (exists p1. exists p2. (Parent(p1, x) & Parent(p2, x) & ReceivesRecessiveGeneFrom(x, p1) & ReceivesRecessiveGeneFrom(x, p2))))", "all x. (BlueEyes(x) -> exists p1, p2. (Parent(p1, x) & Parent(p2, x) & ReceivesRecessiveGene(x, p1) & ReceivesRecessiveGene(x, p2)))"]}
{"id": "entailmentbank_validation_706", "nl": "an egg cell is a kind of sex cell.", "fol": "", "prediction": ["KindOf(egg_cell, sex_cell)", "SexCell(egg_cell)", "SexCell(egg_cell)", "KindOf(egg_cell, sex_cell)"]}
{"id": "entailmentbank_validation_707", "nl": "a sperm cell is a kind of sex cell.", "fol": "", "prediction": ["", "all x. (SpermCell(x) -> SexCell(x))", "SexCell(sperm_cell)", "all x. (SpermCell(x) -> SexCell(x))"]}
{"id": "entailmentbank_validation_708", "nl": "a mutation in the sex cells of a parent can cause a new trait to appear in the parent's offspring.", "fol": "", "prediction": ["exists x. (MutationInSexCells(x) & Parent(x) -> exists y. (Offspring(y, x) & NewTraitAppears(y)))", "all x. ((Parent(x) & MutationInSexCells(x)) -> exists y. (Offspring(y, x) & NewTraitAppears(y)))", "exists m, p, o. (Mutation(m) & SexCell(m) & Parent(p) & Causes(m, NewTrait(o)) & Offspring(o, p))", "exists x. (MutationInSexCells(x) & Parent(x) -> exists y. (Offspring(y, x) & NewTrait(y)))"]}
{"id": "entailmentbank_validation_709", "nl": "a mutation in sperm or egg of a parent can cause a new trait to appear in the parent's offspring.", "fol": "", "prediction": ["exists p. (Parent(p) & (exists m. (MutationInSpermOrEgg(m, p) & exists o. (Offspring(o, p) & AppearsNewTraitIn(m, o)))))", "exists x. exists y. ((Sperm(x) | Egg(x)) & Parent(y) & MutationIn(x, y)) -> exists z. (Offspring(z, y) & NewTraitAppears(z))", "exists x exists y exists z. (Mutation(x) & InSpermOrEgg(x, y) & Parent(y) & Offspring(z, y) -> CausesNewTrait(x, z))", "exists x, y. ((Parent(x) & (SpermMutation(x) | EggMutation(x))) -> exists z. (Offspring(y, x) & Appears(z, y) & NewTrait(z)))"]}
{"id": "entailmentbank_validation_710", "nl": "smaller dogs have genetic trait of smaller size.", "fol": "", "prediction": ["all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))"]}
{"id": "entailmentbank_validation_711", "nl": "human are breeding german shepherd dogs to other smaller dogs.", "fol": "", "prediction": ["all x. (Human(x) -> exists y exists z. (GermanShepherd(y) & SmallerDog(z) & BreedsTo(x, y, z)))", "exists x. exists y. exists z. (Human(x) & GermanShepherd(y) & SmallerDog(z) & BreedsTo(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherd(y) & SmallerDog(z) & BreedsTo(x, y, z))", ""]}
{"id": "entailmentbank_validation_712", "nl": "human are breeding german shepherd dogs with dogs with genetic trait of smaller size.", "fol": "", "prediction": ["exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & HasTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x, y, z. (Human(x) & Dog(y) & Dog(z) & GermanShepherd(y) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "all x. (Human(x) -> exists y exists z. (GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(y, z, x)))", "```\nall x. (Human(x) -> (Breeds(x, y) & GermanShepherd(y) -> exists z. (Dog(z) & HasGeneticTrait(z, SmallSize))))\n```"]}
{"id": "entailmentbank_validation_713", "nl": "selective breeding is when an organism receives selective genetic traits from its parents by human design.", "fol": "", "prediction": ["For the given sentence, we can break down the components and create a suitable translation:\n\nLet:\n- `SelectiveBreeding(x)` represent that `x` is a selective breeding process.\n- `Organism(x)` indicate that `x` is an organism.\n- `ReceivesSelectiveTraits(x, y)` mean that organism `x` receives selective genetic traits from `y`.\n- `Parents(x, y)` denote that `y` are the parents of `x`.\n- `HumanDesign(z)` indicate that `z` is by human design.\n\nUsing these predicates, we can translate the sentence as follows:\n\nFOL Translation:\nall x. (SelectiveBreeding(x) <-> (exists y. (Organism(y) & ReceivesSelectiveTraits(y, Parents(y)) & HumanDesign(y))))", "SelectiveBreeding(x) <-> (exists y, z, w. (Organism(x) & ReceivesGeneticTraits(x, y) & GeneticTraits(y) & HumanDesigned(w, y) & Parents(x, z)))", "When(x) & ReceivesSelectiveTraits(x, Parent(x), HumanDesign(x)) & Organism(x) -> SelectiveBreeding(x)", "all x. (SelectiveBreeding(x) <-> exists y exists z. (Organism(x) & ReceivesSelectiveGeneticTraits(x, y, z) & Parents(y, z) & HumanDesign(y, z)))"]}
{"id": "entailmentbank_validation_714", "nl": "human breeding german shepherd dogs with dogs with genetic trait of smaller size is an example of selective breeding.", "fol": "", "prediction": ["exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(y) & BreedsWith(x, y, z) & Dog(z) & HasGeneticTrait(z, SmallerSize) & ExampleOf(SelectiveBreeding, BreedsWith(x, y, z)))", "ExampleOfSelectiveBreeding(human, german_shepherd_dogs, dogs_with_genetic_trait_of_smaller_size)", "exists x. (Human(x) & exists y. (GermanShepherd(y) & Dog(y) & exists z. (Dog(z) & HasGeneticTrait(z, SmallerSize) & Breeds(x, y, z) & Example(SelectiveBreeding, Breeds(x, y, z)))))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & BreedsWith(x, y, z) & HasGeneticTrait(z, SmallerSize) & ExampleOf(x, SelectiveBreeding))"]}
{"id": "entailmentbank_validation_715", "nl": "sexual reproduction requires both sperm and egg.", "fol": "", "prediction": ["all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (exists y. (Sperm(y) & Requires(x, y)) & exists z. (Egg(z) & Requires(x, z))))", "FOL Translation:\nall x. (SexualReproduction(x) -> exists y. exists z. (Sperm(y) & Egg(z) & Requires(x, y) & Requires(x, z)))", "all x. (SexualReproduction(x) -> exists y. (Sperm(y) & requires(x, y) & exists z. (Egg(z) & requires(x, z))))"]}
{"id": "entailmentbank_validation_716", "nl": "the sperm production is prevented in male insects.", "fol": "", "prediction": ["all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> Prevents(SpermProduction(x)))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))"]}
{"id": "entailmentbank_validation_717", "nl": "if something required for a process is not produced then that process is prevented from occurring.", "fol": "", "prediction": ["all x. all y. ((RequiredForProcess(y, x) & -Produced(y)) -> PreventedFromOccurring(x))", "all x. all y. ((RequiredFor(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x. (all y. ((RequiredForProcess(y, x) & -Produced(y)) -> PreventedFromOccurring(x)))"]}
{"id": "entailmentbank_validation_718", "nl": "the sexual reproduction process is prevented in the insects.", "fol": "", "prediction": ["all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "all x. (Insect(x) -> -CanReproduceSexually(x))", "all x. (Insect(x) -> -CanReproduceSexually(x))", "all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))"]}
{"id": "entailmentbank_validation_719", "nl": "preventing reproduction decreases the rate of reproduction.", "fol": "", "prediction": ["all x. (PreventingReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventingReproduction(x) -> DecreasesRateOfReproduction(x))"]}
{"id": "entailmentbank_validation_720", "nl": "sexual reproduction is a kind of reproduction.", "fol": "", "prediction": ["KindOf(sexual_reproduction, reproduction)", "all x. (SexualReproduction(x) -> Reproduction(x))", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)"]}
{"id": "entailmentbank_validation_721", "nl": "the reproduction rate in the insects will decrease.", "fol": "", "prediction": ["To translate \"the reproduction rate in the insects will decrease\" into first-order logic, we need to define a predicate to express the concept of a reproduction rate decreasing for insects.\n\nA possible translation could be:\n\nexists x. (Insect(x) & ReproductionRateDecreases(x))", "exists x. (Insect(x) & Decrease(ReproductionRate(x)))", "all x. (Insect(x) -> Decrease(ReproductionRate(x)))", "exists x. (Insect(x) & WillDecrease(ReproductionRate(x)))"]}
{"id": "entailmentbank_validation_722", "nl": "as the rate of reproduction decreases, the population will decrease.", "fol": "", "prediction": ["all x. (ReproductionRateDecreases(x) -> PopulationDecreases(x))", "all x. ((ReproductionRateDecreases(x)) -> PopulationDecreases(x))", "all x. (Decreases(RateOfReproduction(x)) -> Decreases(Population(x)))", "all x. (Decreases(RateOfReproduction(x)) -> Decreases(Population(x)))"]}
{"id": "entailmentbank_validation_723", "nl": "the population of the insects will decrease.", "fol": "", "prediction": ["exists x. (Insect(x) & Decrease(PopulationOf(x)))", "exists x. (Population(x) & Insect(x) & WillDecrease(x))", "FOL Translation:\nDecrease(Population(insects))", "exists x. (Insect(x) & PopulationDecrease(x))"]}
{"id": "entailmentbank_validation_724", "nl": "a hammer often is made of metal.", "fol": "", "prediction": ["exists x. (Hammer(x) & Material(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists z. (Hammer(z) & OftenMadeOf(z, metal))"]}
{"id": "entailmentbank_validation_725", "nl": "when a metal rusts, that metal becomes flaky on the surface.", "fol": "", "prediction": ["all x. ((Metal(x) & Rusts(x)) -> FlakySurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Rusts(x) & Metal(x) -> BecomesFlakyOnSurface(x))"]}
{"id": "entailmentbank_validation_726", "nl": "when a hammer rusts, the hammer will becom flaky on the surface.", "fol": "", "prediction": ["all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> WillBecomeFlakyOnSurface(x))"]}
{"id": "entailmentbank_validation_727", "nl": "kim's hammer is flaky on the surface.", "fol": "", "prediction": ["Exists y. (Hammer(y) & OwnedBy(y, kim) & FlakyOnSurface(y))", "FlakySurface(kims_hammer)", "Flaky(kims_hammer, surface)", "FlakyOnSurface(hammer_kim)"]}
{"id": "entailmentbank_validation_728", "nl": "the hammer has rusted.", "fol": "", "prediction": ["Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)"]}
{"id": "entailmentbank_validation_729", "nl": "rust forming is a kind of chemical change.", "fol": "", "prediction": ["KindOf(rust_forming, chemical_change)", "ChemicalChange(rust_forming)", "KindOf(rust_forming, chemical_change)", "KindOf(rust_forming, chemical_change)"]}
{"id": "entailmentbank_validation_730", "nl": "the hammer has undergone a chemical change.", "fol": "", "prediction": ["ChangeOccurred(hammer, chemical)", "ChemicalChange(hammer)", "Exists x. (Hammer(x) & UndergoChemicalChange(x))", "Exists x. (Hammer(x) & UndergoChemicalChange(x))"]}
{"id": "entailmentbank_validation_731", "nl": "element 3 turns to a greenish color.", "fol": "", "prediction": ["TurnsGreenish(element3)", "TurnsToGreenishColor(element3)", "TurnsGreenish(element3)", "TurnsToColor(element3, greenish)"]}
{"id": "entailmentbank_validation_732", "nl": "an element is a kind of substance.", "fol": "", "prediction": ["all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_733", "nl": "element 3 turning green is an example of a substance turning green.", "fol": "", "prediction": ["exists x. (Element(x) & x = 3 & TurnsGreen(x) & all y. (Substance(y) & TurnsGreen(y) -> ExampleOfTurningGreen(x, y)))", "ExampleOfTurningGreen(element3, Substance) & TurnsGreen(element3) & Substance(element3)", "ExampleOf(TurningGreen(element3), exists y. (Substance(y) & TurningGreen(y)))", "ExampleOf(TurningGreen(element3), exists x. (Substance(x) & TurningGreen(x)))"]}
{"id": "entailmentbank_validation_734", "nl": "if the color of a substance changes then a chemical change may have occurred.", "fol": "", "prediction": ["exists y. (Substance(y) & ColorChanges(y) -> MayHaveOccured(ChemicalChange(y)))", "all x. (ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ChangeInColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ColorChange(Substance(x)) -> MayHaveOccurred(ChemicalChange(x)))"]}
{"id": "entailmentbank_validation_735", "nl": "a chemical change may occur to element 3.", "fol": "", "prediction": ["exists x. (ChemicalChangeOccurs(x) & Element(x, element3))", "exists y. (ChemicalChange(y) & OccursTo(y, element3))", "exists y. (Element(y) & ChemicalChangeMayOccurTo(y) & y = element3)", "exists y. (ChemicalChange(y) & OccursTo(y, element3))"]}
{"id": "entailmentbank_validation_736", "nl": "fire is a kind of chemical reaction.", "fol": "", "prediction": ["ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)"]}
{"id": "entailmentbank_validation_737", "nl": "fire causes burning.", "fol": "", "prediction": ["all x. (Fire(x) -> Causes(x, Burning(y)))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> CausesBurning(x))", "all x. (Fire(x) -> CausesBurning(x))"]}
{"id": "entailmentbank_validation_738", "nl": "burning something with fire is a kind of chemical reaction.", "fol": "", "prediction": ["all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_739", "nl": "a lit candle is a source of fire.", "fol": "", "prediction": ["Candle(y) & Lit(y) -> SourceOfFire(y)", "exists x. (LitCandle(x) -> SourceOfFire(x))", "A lit candle is a specific type of candle that serves as a source of fire. The FOL translation would express that any object identified as a lit candle also serves as a source of fire.\n\nFOL Translation:\nall x. (LitCandle(x) -> SourceOfFire(x))", "all x. (LitCandle(x) -> SourceOfFire(x))"]}
{"id": "entailmentbank_validation_740", "nl": "burning something with a lit candle is a kind of chemical reaction.", "fol": "", "prediction": ["all x y. (Burn(x, y) & LitCandle(y) -> ChemicalReaction(x))", "all x y. (BurningWithLitCandle(x, y) -> ChemicalReaction(x, y))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x. (Burn(x, lit_candle) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_741", "nl": "magnesium is a kind of substance.", "fol": "", "prediction": ["Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)"]}
{"id": "entailmentbank_validation_742", "nl": "burning magnesium with a lit candle is a kind of chemical reaction.", "fol": "", "prediction": ["exists x exists y. (Burn(magnesium, x) & LitCandle(x) & ChemicalReaction(Burning(magnesium, x), y))", "exists x y. (Burns(x, magnesium) & IsLit(y, candle) -> ChemicalReaction(burning(x, y, magnesium)))", "KindOf(ChemicalReaction(burning_mg_with_lit_candle), ChemicalReaction)", "exists x. (BurningMagnesiumWithLitCandle(x) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_743", "nl": "chemical reactions cause chemical change.", "fol": "", "prediction": ["all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> CausesChemicalChange(x))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))"]}
{"id": "entailmentbank_validation_744", "nl": "burning magnesium with fire will lead to a chemical change.", "fol": "", "prediction": ["exists x. (BurningWithFire(magnesium, x) -> ChemicalChange(x))", "exists x exists y. (Burning(x, magnesium) & Fire(y) & LeadsTo(x, ChemicalChange))", "all x. (BurnsWithFire(magnesium, x) -> LeadsToChemicalChange(magnesium))", "exists x exists y. (Magnesium(x) & Fire(y) & Burns(x, y) -> ChemicalChange(x))"]}
{"id": "entailmentbank_validation_745", "nl": "chemical reactions cause new materials to form.", "fol": "", "prediction": ["all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & CausesFormation(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all r. ((ChemicalReaction(r)) -> exists y. (NewMaterial(y) & Causes(r, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y) & Forms(y)))"]}
{"id": "entailmentbank_validation_746", "nl": "chemical change is a kind of chemical reaction.", "fol": "", "prediction": ["all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "Kind(chemical_change, chemical_reaction)", "FOL Translation:\nall x. (ChemicalChange(x) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_747", "nl": "chemical changes cause new materials to form.", "fol": "", "prediction": ["all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))"]}
{"id": "entailmentbank_validation_748", "nl": "an example of a chemical property is the elements making up a compound.", "fol": "", "prediction": ["exists x. (ChemicalProperty(x) & Example(x, y) & exists y. (Elements(y) & MakeUp(y, z) & Compound(z)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, \"elements making up a compound\"))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Compound(y) & exists z. (Element(z) & MakesUp(z, y)))", "exists e, c. (ExampleOf(e, ChemicalProperty) & Compound(c) & MakesUp(e, c, Element))"]}
{"id": "entailmentbank_validation_749", "nl": "water is a kind of compound.", "fol": "", "prediction": ["Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)"]}
{"id": "entailmentbank_validation_750", "nl": "an example of chemical property is the elements making up water.", "fol": "", "prediction": ["exists x. (ChemicalProperty(x) & ExampleOf(x, ComposedOf(elements, water)))", "exists x. (ExampleOfChemicalProperty(x) & ElementsMakingUp(water, x))", "Exists x. (ChemicalPropertyExample(x) & ElementsMakeUp(x, water))", "exists x. (ChemicalProperty(x) & ExampleOf(x, ElementsMakingUp(water)))"]}
{"id": "entailmentbank_validation_751", "nl": "a chemical property of water is that it is made of hydrogen and oxygen.", "fol": "", "prediction": ["ChemicalProperty(water, MadeOf(water, hydrogen) & MadeOf(water, oxygen))", "all x. (ChemicalPropertyOf(x, water) <-> (MadeOf(x, hydrogen) & MadeOf(x, oxygen)))", "ChemicalProperty(water, MadeOf(hydrogen, oxygen))", "ChemicalProperty(water, MadeOf(water, hydrogen, oxygen))"]}
{"id": "entailmentbank_validation_752", "nl": "a compound can be chemically separated into the elements that it is made of.", "fol": "", "prediction": ["all x. (Compound(x) -> exists y. (Elements(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Elements(y) & MadeOf(x, y) & ChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & ChemicallySeparableInto(x, y)))", "all c. (Compound(c) -> exists e. (Element(e) & MadeOf(c, e) & CanBeChemicallySeparatedInto(c, e)))"]}
{"id": "entailmentbank_validation_753", "nl": "water can be separated into hydrogen and oxygen.", "fol": "", "prediction": ["exists w. (Water(w) -> exists h, o. (Hydrogen(h) & Oxygen(o) & CanBeSeparatedInto(w, h, o)))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "all x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))"]}
{"id": "entailmentbank_validation_754", "nl": "carbon dioxide is a new substance produced by sodium bicarbonate.", "fol": "", "prediction": ["NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)"]}
{"id": "entailmentbank_validation_755", "nl": "chemical reactions cause new substances to form.", "fol": "", "prediction": ["all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesToForm(r, s)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesFormation(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesFormation(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & Causes(x, y)))"]}
{"id": "entailmentbank_validation_756", "nl": "sodium bicarbonate releasing carbon dioxide is a chemical reaction.", "fol": "", "prediction": ["ChemicalReaction(Releases(sodium_bicarbonate, carbon_dioxide))", "ChemicalReaction(Releases(sodium_bicarbonate, carbon_dioxide))", "exists x. (SodiumBicarbonate(x) & Releases(x, carbon_dioxide) -> ChemicalReaction(x))", "exists x y. (Releases(x, y) & SodiumBicarbonate(x) & CarbonDioxide(y) -> ChemicalReaction(Releases(x, y)))"]}
{"id": "entailmentbank_validation_757", "nl": "an example of a chemical property is how a material reacts chemically.", "fol": "", "prediction": ["exists x. (Example(x) & ChemicalProperty(x) & exists y. (Material(y) & ReactsChemically(y, x)))", "exists x y. (ChemicalProperty(x) & Material(y) & ExampleOf(x, ReactsChemically(y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Material(y) & ReactsChemically(y))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Material(y) & ReactsChemically(y))"]}
{"id": "entailmentbank_validation_758", "nl": "releasing carbon dioxide is a kind of chemical property of sodium bicarbonate.", "fol": "", "prediction": ["ChemicalPropertyOfReleasing(carbon_dioxide, sodium_bicarbonate)", "KindOfChemicalProperty(ReleasingCarbonDioxide, sodium_bicarbonate)", "ChemicalProperty(sodium_bicarbonate, releasing_carbon_dioxide)", "ChemicalProperty(sodium_bicarbonate, releasing_carbon_dioxide)"]}
{"id": "entailmentbank_validation_759", "nl": "a pencil is a kind of object.", "fol": "", "prediction": ["Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)"]}
{"id": "entailmentbank_validation_760", "nl": "sharpening a pencil changes the shape of the pencil.", "fol": "", "prediction": ["exists x. (Pencil(x) & Sharpen(x) -> ChangesShape(x))", "all x. ((Pencil(x) & Sharpens(y, x)) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_761", "nl": "sharpening a pencil changes the shape of an object.", "fol": "", "prediction": ["exists x. (Object(x) & Pencil(y) & Sharpens(y, x) -> ChangesShape(x))", "exists x. (Sharpening(x, pencil) -> exists y. (Object(y) & ChangesShape(x, y)))", "exists x. (Pencil(x) & Sharpening(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (SharpeningAPencil(x) -> exists y. (Object(y) & ChangesShape(y)))"]}
{"id": "entailmentbank_validation_762", "nl": "tearing paper changes the shape of the paper.", "fol": "", "prediction": ["all x. (Paper(x) & Tears(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Tearing(x) & Paper(x) -> ChangesShape(x))", "all x. (Tearing(x) & Paper(x) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_763", "nl": "paper is a kind of object.", "fol": "", "prediction": ["Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)"]}
{"id": "entailmentbank_validation_764", "nl": "tearing paper changes the shape of an object.", "fol": "", "prediction": ["all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (Paper(x) & Tearing(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. ((Paper(x) & Tearing(x)) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))"]}
{"id": "entailmentbank_validation_765", "nl": "sharpening a pencil and tearing paper both change the shape of the object.", "fol": "", "prediction": ["all x. ((Sharpening(x) | Tearing(x)) -> ChangesShape(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesShape(x, object))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_766", "nl": "shape is a property of the appearance of an object.", "fol": "", "prediction": ["all x. (Object(x) -> exists y. (Appearance(x, y) & Shape(y)))", "all x. (Object(x) -> exists y. (Appearance(y) & Shape(y) & PropertyOf(y, x)))", "all x. (Object(x) -> exists y. (Appearance(y) & Shape(y, x)))", "all x. ((Object(x) & AppearanceProperty(y) & Shape(y)) -> PropertyOf(y, x))"]}
{"id": "entailmentbank_validation_767", "nl": "sharpening a pencil and tearing paper both change the appearance of the object.", "fol": "", "prediction": ["all x. ((SharpenPencil(x) | TearPaper(x)) -> ChangesAppearance(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesAppearance(x))", "all x. ((Sharpening(x) | Tearing(x)) -> ChangesAppearance(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesAppearance(x))"]}
{"id": "entailmentbank_validation_768", "nl": "appearance is a kind of physical property.", "fol": "", "prediction": ["all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))"]}
{"id": "entailmentbank_validation_769", "nl": "sharpending a pencil and tearing paper both change the physical property of the object.", "fol": "", "prediction": ["all x. ((SharpenPencil(x) | TearPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((Pencil(x) & Sharpens(x)) -> ChangesPhysicalProperty(x)) & all y. ((Paper(y) & Tears(y)) -> ChangesPhysicalProperty(y))", "FOL Translation:\nall x. ((Sharpening(x) & Pencil(x)) -> ChangesPhysicalProperty(x)) & all y. ((Tearing(y) & Paper(y)) -> ChangesPhysicalProperty(y))", "exists x, y. (Pencil(x) & TearableObject(y) & Sharpens(x) & Tears(y) & ChangesPhysicalProperty(x) & ChangesPhysicalProperty(y))"]}
{"id": "entailmentbank_validation_770", "nl": "if something undergoes a physical change then the physical properties of that something will change.", "fol": "", "prediction": ["all x. (UndergoesPhysicalChange(x) -> ChangeInPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> Change(PhysicalProperties(x)))"]}
{"id": "entailmentbank_validation_771", "nl": "pencil and paper underwent a physical change.", "fol": "", "prediction": ["exists x. exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x exists y. (Pencil(x) & Paper(y) & UndergoPhysicalChange(x) & UndergoPhysicalChange(y))", "exists x. exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x, y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))"]}
{"id": "entailmentbank_validation_772", "nl": "heat means temperature increases.", "fol": "", "prediction": ["all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))"]}
{"id": "entailmentbank_validation_773", "nl": "a solid is heated.", "fol": "", "prediction": ["Heated(solid)", "exists x. (Solid(x) & Heated(x))", "Heated(solid)", "exists x. (Solid(x) & Heated(x))"]}
{"id": "entailmentbank_validation_774", "nl": "the temperature of the solid increases.", "fol": "", "prediction": ["Increase(Temperature(solid))", "exists x. (Solid(x) & Increases(TemperatureOf(x)))", "exists x. (Solid(x) & TemperatureIncreases(x))", "IncreaseTemperature(solid)"]}
{"id": "entailmentbank_validation_775", "nl": "a solid is a kind of substance.", "fol": "", "prediction": ["all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_776", "nl": "the temperature of the solid substance increases.", "fol": "", "prediction": ["exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "Increase(Temperature(SolidSubstance))", "exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "IncreasesTemperature(solid_substance)"]}
{"id": "entailmentbank_validation_777", "nl": "as the temperature of a substance increases, the molecules in that substance will move faster.", "fol": "", "prediction": ["all x. (Substance(x) & Increases(Temperature(x)) -> MovesFaster(MoleculesIn(x)))", "all x. (Substance(x) & IncreasesTemperature(x) -> MoleculesMoveFaster(x))", "all x. (Substance(x) & Increases(Temperature(x)) -> Increases(Speed(MoleculeIn(x))))", "all x. all t1, t2. (Substance(x) & TemperatureOf(x, t1) & TemperatureOf(x, t2) & Higher(t2, t1) -> all m. (MoleculeIn(m, x) -> MovesFaster(m, t2)))"]}
{"id": "entailmentbank_validation_778", "nl": "the molecules in the solid substance moves faster.", "fol": "", "prediction": ["all x. (Molecule(x) & InSolidSubstance(x) -> MovesFaster(x))", "exists x. (SolidSubstance(x) & Molecule(y, x) -> MovesFaster(y))", "exists x. (SolidSubstance(x) & all y. (MoleculeIn(y, x) -> MovesFaster(y)))", "exists x. (Molecules(x) & InSolidSubstance(x) & MovesFaster(x))"]}
{"id": "entailmentbank_validation_779", "nl": "faster means an increase / higher in speed.", "fol": "", "prediction": ["all x. (Faster(x) -> IncreaseInSpeed(x) | HigherInSpeed(x))", "all x y. (Faster(x, y) <-> (Speed(x) > Speed(y)))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x y. (Faster(x, y) <-> (IncreaseInSpeed(x, y) | HigherSpeed(x, y)))"]}
{"id": "entailmentbank_validation_780", "nl": "the molecules in the solid substance increases in speed.", "fol": "", "prediction": ["exists x. (Molecule(x) & In(solid_substance, x) -> IncreasesInSpeed(x))", "exists s. (SolidSubstance(s) & all m. (Molecule(m) & In(s, m) -> IncreasesInSpeed(m)))", "exists x. (Molecule(x) & In(solid_substance, x) & IncreasesInSpeed(x))", "FOL Translation:\nall x. (Molecule(x) & In(solid_substance, x) -> IncreasesInSpeed(x))"]}
{"id": "entailmentbank_validation_781", "nl": "proton is a kind of subatomic particles.", "fol": "", "prediction": ["SubatomicParticle(proton)", "SubatomicParticle(proton)", "Kind(proton, subatomic_particles)", "KindOf(proton, subatomic_particle)"]}
{"id": "entailmentbank_validation_782", "nl": "neutrons are a kind of subatomic particle.", "fol": "", "prediction": ["all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))"]}
{"id": "entailmentbank_validation_783", "nl": "atomic mass is determined by the sum of protons and neutrons numbers in an atom.", "fol": "", "prediction": ["all a. (Atom(a) -> AtomicMass(a) = Sum(NumberOfProtons(a), NumberOfNeutrons(a)))", "all x. (Atom(x) -> AtomicMassDeterminedBySumOfProtonsAndNeutrons(x))", "all x. (Atom(x) -> exists y. exists z. exists w. (Protons(x, y) & Neutrons(x, z) & AtomicMass(x, w) & Equals(w, Sum(y, z))))", "all a. (Atom(a) -> exists p n. (ProtonNumber(a, p) & NeutronNumber(a, n) & AtomicMass(a) = p + n))"]}
{"id": "entailmentbank_validation_784", "nl": "atomic mass is determined by the sum of protons and neutrons particle numbers.", "fol": "", "prediction": ["all x. (AtomicMass(x) -> exists y. (exists z. (Protons(y) & Neutrons(z) & DeterminedBy(x, Sum(y, z)))))", "all x. (AtomicMass(x) <-> (exists y, z. (Protons(x, y) & Neutrons(x, z) & Sum(y, z, x))))", "all x. (AtomicMass(x) <-> exists y, z, w. (Sum(y, z, w) & Protons(y, x) & Neutrons(z, x) & ParticleNumbersSum(w, x)))", "all x. (AtomicMass(x) <-> exists y exists z exists w. (Protons(y) & Neutrons(z) & ParticleNumber(y, w) & ParticleNumber(z, w) & Sum(w, x)))"]}
{"id": "entailmentbank_validation_785", "nl": "a proton has a positive 1 electric charge.", "fol": "", "prediction": ["exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "Exists x. (Proton(x) & ElectricCharge(x, Positive1))", "Exists x. (Proton(x) & ElectricCharge(x, positive_1))", "Exists x. (Proton(x) -> HasElectricCharge(x, positive1))"]}
{"id": "entailmentbank_validation_786", "nl": "a electron has a negative -1 electric charge.", "fol": "", "prediction": ["exists x. (Electron(x) & ElectricCharge(x, -1) & Negative(x))", "exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & ElectricCharge(x, negative_1))"]}
{"id": "entailmentbank_validation_787", "nl": "equal numbers of protons and electrons result in a neutral 0 electric charge.", "fol": "", "prediction": ["all x y z. ((EqualNumberOf(protons, x, electrons, y) & ResultIn(x, y, z) & ElectricCharge(z)) -> Neutral(z, 0))", "all n, p, e. ((EqualNumbers(n, p, e) & Protons(p) & Electrons(e)) -> NeutralCharge(n))", "all n. (EqualNumbersOfProtonsAndElectrons(n) -> NeutralCharge(n))", "all x y z. ((ProtonCount(x, y) & ElectronCount(x, z) & y = z) -> NeutralCharge(x))"]}
{"id": "entailmentbank_validation_788", "nl": "a neutron has a neutral electric charge.", "fol": "", "prediction": ["exists x. (Neutron(x) & HasNeutralCharge(x))", "Exists x. (Neutron(x) & NeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))"]}
{"id": "entailmentbank_validation_789", "nl": "equal numbers of protons and electrons and any number of neutrons result in a neutral 0 electric charge.", "fol": "", "prediction": ["all n, m, p. ((EqualProtonsElectrons(n, m) & AnyNumberOfNeutrons(p)) -> NeutralCharge(n, m, p))", "all x. (exists y. (Protons(x, y) & Electrons(x, y)) & exists z. (Neutrons(x, z)) -> NeutralCharge(x))", "all x. (Atom(x) & EqualProtonsElectrons(x) & AnyNumberNeutrons(x) -> NeutralCharge(x, 0))", "all x. all y. all z. ((EqualNumbersOf(x, y, protons, electrons) & NeutronsNumber(z)) -> NeutralElectricCharge(0))"]}
{"id": "entailmentbank_validation_790", "nl": "an atom is made of protons / neutrons / electrons.", "fol": "", "prediction": ["all a. (Atom(a) -> exists p. (Proton(p) & PartOf(p, a)) & exists n. (Neutron(n) & PartOf(n, a)) & exists e. (Electron(e) & PartOf(e, a)))", "all a. (Atom(a) -> exists p, n, e. (Proton(p) & Neutron(n) & Electron(e) & MadeOf(a, p) & MadeOf(a, n) & MadeOf(a, e)))", "all a. (Atom(a) -> (exists p. Proton(p) & PartOf(p, a)) & (exists n. Neutron(n) & PartOf(n, a)) & (exists e. Electron(e) & PartOf(e, a)))", "FOL Translation:\nall x. (Atom(x) -> exists p, n, e. (Proton(p) & Neutron(n) & Electron(e) & MadeOf(x, p) & MadeOf(x, n) & MadeOf(x, e)))"]}
{"id": "entailmentbank_validation_791", "nl": "if an atom has an equal number of protons and electrons, then the atom will have a neutral charge.", "fol": "", "prediction": ["all x. ((Atom(x) & exists n. (NumberOfProtons(x, n) & NumberOfElectrons(x, n))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists y. exists z. (Proton(y) & Electron(z) & NumberOf(y, x) = NumberOf(z, x))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (NumberOfProtons(x, n) & NumberOfElectrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))"]}
{"id": "entailmentbank_validation_792", "nl": "an normal atom has a neutral electric charge.", "fol": "", "prediction": ["all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (Atom(x) & Normal(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))"]}
{"id": "entailmentbank_validation_793", "nl": "that atom has an equal number of protons and electrons.", "fol": "", "prediction": ["exists x. (Atom(x) & EqualNumber(Protons(x), Electrons(x)))", "Exists x. (Atom(x) & EqualProtonsElectrons(x))", "Exists x. (Atom(x) & Equal(Protons(x), Electrons(x)))", "Atom(that) & exists x, y. (ProtonCount(that, x) & ElectronCount(that, y) & x = y)"]}
{"id": "entailmentbank_validation_794", "nl": "iron in contact with water and oxygen will rust.", "fol": "", "prediction": ["all x. ((Iron(x) & ContactWithWater(x) & ContactWithOxygen(x)) -> WillRust(x))", "all x. (Iron(x) & exists y. (ContactWith(x, y) & Water(y)) & exists z. (ContactWith(x, z) & Oxygen(z)) -> Rusts(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))"]}
{"id": "entailmentbank_validation_795", "nl": "iron in contact with water and oxygen causes a chemical change.", "fol": "", "prediction": ["all x y z. ((Iron(x) & InContactWith(x, y) & Water(y) & InContactWith(x, z) & Oxygen(z)) -> CausesChemicalChange(x))", "all x y z. (Iron(x) & InContactWith(x, y) & Water(y) & InContactWith(x, z) & Oxygen(z) -> Causes(ChemicalChange, x))", "all x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) -> CausesChemicalChange(x))", "exists x, y, z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) -> CausesChemicalChange(x))"]}
{"id": "entailmentbank_validation_796", "nl": "iron in contact with water and oxygen is an example of chemical reactions.", "fol": "", "prediction": ["exists x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) & ExampleOf(x, ChemicalReaction))", "exists x. (IronInContactWithWaterAndOxygen(x) & ChemicalReaction(x))", "exists x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) & ExampleOf(x, ChemicalReaction))", "ExampleOf(ChemicalReaction, Contact(iron, water) & Contact(iron, oxygen))"]}
{"id": "entailmentbank_validation_797", "nl": "alkaline earth metals are highly chemically reactive.", "fol": "", "prediction": ["all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))"]}
{"id": "entailmentbank_validation_798", "nl": "elements from the same group in the periodic table are chemically reactive in a similar way.", "fol": "", "prediction": ["all x, y. (Element(x) & Element(y) & SameGroup(x, y) -> ChemicallyReactiveInSimilarWay(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ReactsSimilarly(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroupInPeriodicTable(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))"]}
{"id": "entailmentbank_validation_799", "nl": "elements that belong to alkaline earth metals are highly chemically reactive.", "fol": "", "prediction": ["all x. (BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))"]}
{"id": "entailmentbank_validation_800", "nl": "magnesium belongs to alkaline earth metal family, group 2 on the periodic table.", "fol": "", "prediction": ["BelongsToFamily(magnesium, alkaline_earth_metals) & Group(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metal) & BelongsToGroup(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metals) & Group(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & OnPeriodicTable(magnesium)"]}
{"id": "entailmentbank_validation_801", "nl": "magnesium is highly chemically reactive.", "fol": "", "prediction": ["HighlyChemicallyReactive(magnesium)", "HighlyChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)"]}
{"id": "entailmentbank_validation_802", "nl": "an element cannot be decomposed into two or more different substances by simple chemical methods.", "fol": "", "prediction": ["all x. (Element(x) -> -exists y z. (Substance(y) & Substance(z) & Different(y, z) & CanBeDecomposedBySimpleChemMethods(x, y, z)))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & DecomposableBySimpleChemicalMethods(x, y, z)))", "all x. (Element(x) -> -exists y. exists z. (DifferentSubstances(y, z) & CanBeDecomposedBySimpleChemicalMethods(x, y, z)))", "all x. (Element(x) -> -exists y exists z. (DifferentSubstances(y, z) & DecomposableBySimpleChemicalMethods(x, y, z)))"]}
{"id": "entailmentbank_validation_803", "nl": "sulfur cannot be decomposed into different substances by simple chemical methods.", "fol": "", "prediction": ["Material(sulfur) & -exists y. (DifferentSubstances(sulfur, y) & SimpleChemicalMethodsDec(sulfur, y))", "-all x. (Sulfur(x) -> CanBeDecomposedIntoDifferentSubstancesBySimpleChemicalMethods(x))", "`-exists x. (DecomposedIntoDifferentSubstancesBySimpleChemicalMethods(sulfur, x))`", "Element(sulfur) & -exists y. (DifferentSubstance(y) & SimpleChemicalMethod(z) & DecomposesInto(sulfur, y, z))"]}
{"id": "entailmentbank_validation_804", "nl": "sulfur is a kind of element.", "fol": "", "prediction": ["Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)"]}
{"id": "entailmentbank_validation_805", "nl": "iron is a kind of element.", "fol": "", "prediction": ["Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)"]}
{"id": "entailmentbank_validation_806", "nl": "the chemical symbol for iron is fe.", "fol": "", "prediction": ["ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)"]}
{"id": "entailmentbank_validation_807", "nl": "fe is the chemical symbol for iron element.", "fol": "", "prediction": ["ChemicalSymbol(fe, iron) & Element(iron)", "ChemicalSymbol(fe, iron) & Element(iron)", "ChemicalSymbol(fe, iron) & Element(iron)", "ChemicalSymbol(fe, iron) & Element(iron)"]}
{"id": "entailmentbank_validation_808", "nl": "if a substance is made of one element, then the substance is called an element.", "fol": "", "prediction": ["all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledAnElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))"]}
{"id": "entailmentbank_validation_809", "nl": "oxygen gas is made of only oxygen element.", "fol": "", "prediction": ["all x. (OxygenGas(x) -> exists y. (Contains(x, y) & OxygenElement(y)))", "exists x. (OxygenGas(x) & MadeOfOnly(x, oxygen))", "all x. (OxygenGas(x) -> containsOnlyElement(x, oxygen))", "all x. (OxygenGas(x) -> all y. (PartOf(y, x) -> OxygenElement(y)))"]}
{"id": "entailmentbank_validation_810", "nl": "oxygen gas is an element.", "fol": "", "prediction": ["Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)"]}
{"id": "entailmentbank_validation_811", "nl": "o2 is a chemical formula for oxygen gas.", "fol": "", "prediction": ["ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormula(o2, oxygen_gas)", "ChemicalFormulaFor(o2, oxygen_gas)"]}
{"id": "entailmentbank_validation_812", "nl": "o2 is an element.", "fol": "", "prediction": ["Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)"]}
{"id": "entailmentbank_validation_813", "nl": "the chemical symbol for tellurium is te.", "fol": "", "prediction": ["ChemicalSymbol(tellurium, te)", "SymbolFor(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)"]}
{"id": "entailmentbank_validation_814", "nl": "tellurium is a kind of metalloid.", "fol": "", "prediction": ["Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)"]}
{"id": "entailmentbank_validation_815", "nl": "te is a kind of metalloid.", "fol": "", "prediction": ["IsKindOf(te, metalloid)", "IsKindOf(te, metalloid)", "Metalloid(te)", "Metalloid(te)"]}
{"id": "entailmentbank_validation_816", "nl": "antimony is a kind of metalloid.", "fol": "", "prediction": ["Metalloid(antimony)", "Metalloid(antimony)", "KindOf(antimony, metalloid)", "Metalloid(antimony)"]}
{"id": "entailmentbank_validation_817", "nl": "the chemical symbol for antimony is sb.", "fol": "", "prediction": ["ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbolFor(antimony, sb)", "ChemicalSymbol(antimony, sb)"]}
{"id": "entailmentbank_validation_818", "nl": "sb is a kind of metalloid.", "fol": "", "prediction": ["KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "Kind(sb, metalloid)"]}
{"id": "entailmentbank_validation_819", "nl": "sb and te are both metalloids.", "fol": "", "prediction": ["Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)"]}
{"id": "entailmentbank_validation_820", "nl": "helium / neon / argon / krypton / xenon / radon belongs to noble gases family, group 18 on the periodic table.", "fol": "", "prediction": ["BelongsToNobleGasesFamily(helium) & Group18(helium) & BelongsToNobleGasesFamily(neon) & Group18(neon) & BelongsToNobleGasesFamily(argon) & Group18(argon) & BelongsToNobleGasesFamily(krypton) & Group18(krypton) & BelongsToNobleGasesFamily(xenon) & Group18(xenon) & BelongsToNobleGasesFamily(radon) & Group18(radon)", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> NobleGas(x) & Group18(x))", "BelongsToGroup(helium, noble_gases) & BelongsToGroup(neon, noble_gases) & BelongsToGroup(argon, noble_gases) & BelongsToGroup(krypton, noble_gases) & BelongsToGroup(xenon, noble_gases) & BelongsToGroup(radon, noble_gases) & InGroup(helium, 18) & InGroup(neon, 18) & InGroup(argon, 18) & InGroup(krypton, 18) & InGroup(xenon, 18) & InGroup(radon, 18)", "BelongsToNobleGases(helium) & BelongsToNobleGases(neon) & BelongsToNobleGases(argon) & BelongsToNobleGases(krypton) & BelongsToNobleGases(xenon) & BelongsToNobleGases(radon) & InGroup18(helium) & InGroup18(neon) & InGroup18(argon) & InGroup18(krypton) & InGroup18(xenon) & InGroup18(radon)"]}
{"id": "entailmentbank_validation_821", "nl": "elements in group 18 have complete outer electron shells on the periodic table of elements.", "fol": "", "prediction": ["all x. (Element(x) & Group18(x) -> CompleteOuterElectronShell(x) & PeriodicTable(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShells(x))", "all x. ((Element(x) & Group18(x) & OnPeriodicTable(x)) -> HasCompleteOuterElectronShell(x))"]}
{"id": "entailmentbank_validation_822", "nl": "helium, neon, argon, krypton, xenon, and radon have complete outer electron shells.", "fol": "", "prediction": ["HaveCompleteOuterShell(helium) & HaveCompleteOuterShell(neon) & HaveCompleteOuterShell(argon) & HaveCompleteOuterShell(krypton) & HaveCompleteOuterShell(xenon) & HaveCompleteOuterShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "HasCompleteOuterElectronShell(helium) & HasCompleteOuterElectronShell(neon) & HasCompleteOuterElectronShell(argon) & HasCompleteOuterElectronShell(krypton) & HasCompleteOuterElectronShell(xenon) & HasCompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)"]}
{"id": "entailmentbank_validation_823", "nl": "if the outermost electron shell of an atom is complete, then the element of those atoms will not react with other elements easily.", "fol": "", "prediction": ["FOL Translation:\nall x. (Atom(x) & CompleteOutermostElectronShell(x) -> -ReactsEasily(ElementOfAtoms(x)))", "all x. (Atom(x) & CompleteOuterShell(x) -> all y. (ElementOf(x, y) -> -ReactsEasilyWithOtherElements(y)))", "all a. ((Atom(a) & CompleteOuterShell(a)) -> -ReactsEasily(ElementOf(a), OtherElements))", "all x. ((Atom(x) & CompleteOuterElectronShell(x)) -> all y. (ElementOf(x, y) -> -ReactsEasilyWithOtherElements(y)))"]}
{"id": "entailmentbank_validation_824", "nl": "helium, neon, argon, krypton, xenon, and radon will not react with other elements easily.", "fol": "", "prediction": ["all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))", "all x. ( (x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x) )", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))"]}
{"id": "entailmentbank_validation_825", "nl": "water is a kind of substance.", "fol": "", "prediction": ["Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)"]}
{"id": "entailmentbank_validation_826", "nl": "boiling means matter / a substance changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["all x. (Boiling(x) -> (Matter(x) | Substance(x)) & ChangesFromLiquidToGas(x) & IncreasesHeatEnergy(x))", "Boiling(x) <-> (Matter(x) | Substance(x) & ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x))", "all x. (Boiling(x) -> exists y. (MatterOrSubstance(y) & ChangesState(y, Liquid, Gas) & ByIncreasingHeatEnergy(y)))", "all x. (Boiling(x) -> (Liquid(x) & Substance(x) & IncreasesHeatEnergy(x) -> Gas(x)))"]}
{"id": "entailmentbank_validation_827", "nl": "water boiling is when water changes from a liquid into a gas.", "fol": "", "prediction": ["\u2200x. (WaterBoiling(x) \u2194 (Water(x) & ChangesFromTo(x, liquid, gas)))", "Boiling(water) <-> ChangesState(water, liquid, gas)", "all x. (Water(x) & Liquid(x) & ChangesToLiquid(x) & ChangesToGas(x) -> Boiling(x))", "Boiling(water) <-> ChangesState(water, liquid, gas)"]}
{"id": "entailmentbank_validation_828", "nl": "water is in the gas state, called water vapor / steam, for temperatures above 100 c.", "fol": "", "prediction": ["all x. (Water(x) & Temperature(x) > 100 -> InGasState(x) & (Called(x, water_vapor) | Called(x, steam)))", "all x. (Water(x) & AboveTemperature(x, 100) -> GasState(x) & (Called(x, watervapor) | Called(x, steam)))", "all x. (Water(x) & Temperature(x) > 100 -> GasState(x) & (Called(x, water_vapor) | Called(x, steam)))", "all w, t. ((Water(w) & Temperature(t) & t > 100) -> GasState(w) & (Called(w, water_vapor) | Called(w, steam)))"]}
{"id": "entailmentbank_validation_829", "nl": "water is in the liquid state, called liquid water, for temperatures between 0 c and 100 c.", "fol": "", "prediction": ["all t. ((Temperature(t) & GreaterThan(t, 0) & LessThan(t, 100)) -> LiquidState(water, t))", "FOL Translation:\nall t. ((Temperature(t) & GreaterThan(t, 0) & LessThan(t, 100)) -> State(water, liquid))", "all t. ((Temperature(t) & GreaterThanOrEqual(t, 0) & LessThanOrEqual(t, 100)) -> State(water, liquid))", "all t. ((0 < t & t < 100) -> InLiquidState(water, t))"]}
{"id": "entailmentbank_validation_830", "nl": "water boiling is when water changes from liquid water to water vapor.", "fol": "", "prediction": ["all x. (WaterBoiling(x) <-> (ChangesFrom(x, LiquidWater) & ChangesTo(x, WaterVapor)))", "all w. (WaterBoiling(w) <-> Changes(w, LiquidWater, WaterVapor))", "all x. (WaterBoiling(x) <-> (ChangesFrom(x, LiquidWater) & ChangesTo(x, WaterVapor)))", "`all x. (Boiling(x) & Water(x) -> ChangesState(x, liquidWater, waterVapor))`"]}
{"id": "entailmentbank_validation_831", "nl": "water boiling is when water changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["WaterBoiling(x) <-> (ChangeState(x, liquid, gas) & CausedBy(x, Increase(HeatEnergy)))", "all x. (Boiling(x) & Water(x) -> ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x))", "all x. (WaterBoiling(x) <-> (ChangesFromTo(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. ((Water(x) & Boiling(x)) <-> (ChangesFrom(x, liquid, gas) & IncreasesHeatEnergy(x)))"]}
{"id": "entailmentbank_validation_832", "nl": "a puddle is a kind of body of water.", "fol": "", "prediction": ["BodyOfWater(puddle)", "BodyOfWater(puddle)", "BodyOfWater(puddle)", "BodyOfWater(puddle)"]}
{"id": "entailmentbank_validation_833", "nl": "being in the sun will cause the puddle to absorb heat energy.", "fol": "", "prediction": ["exists x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))", "exists x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))", "exists y. (Puddle(y) -> all x. (InSun(x) -> Causes(x, AbsorbHeatEnergy(y))))", "To translate the given sentence into first-order logic (FOL), let's identify the main components: \n\n- The event \"being in the sun\" is associated with a causal relationship.\n- The entity \"the puddle\" needs to be specified.\n- The outcome is \"the puddle to absorb heat energy.\"\n\nWe recognize the sentence as asserting that some condition \"being in the sun\" leads to an effect \"absorb heat energy.\"\n\nLet:\n- `Puddle(x)` represent \"x is a puddle.\"\n- `InSun(x)` represent \"x is in the sun.\"\n- `AbsorbsHeatEnergy(x)` represent \"x absorbs heat energy.\"\n\nNow, the sentence \"Being in the sun will cause the puddle to absorb heat energy\" can be interpreted in FOL as a causal relationship for all puddles:\n\n``` \nall x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))\n```"]}
{"id": "entailmentbank_validation_834", "nl": "the puddle will evaporate.", "fol": "", "prediction": ["Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)"]}
{"id": "entailmentbank_validation_835", "nl": "an example of evaporation is a body of water drying up by absorbing heat energy.", "fol": "", "prediction": ["exists x. exists y. (ExampleOf(x, Evaporation) & BodyOfWater(y) & DriesUp(y) & AbsorbsHeatEnergy(y, x))", "exists x exists y. (Example(x) & Evaporation(y) & IsAnExampleOf(x, y) & BodyOfWater(x) & DriesUp(x) & AbsorbsHeatEnergy(x))", "exists x. (ExampleOf(x, Evaporation) & BodyOfWater(x) & DriesUp(x) & Absorbs(x, HeatEnergy))", "exists x. (ExampleOfEvaporation(x) & BodyOfWaterDryingUp(x) & AbsorbsHeatEnergy(x))"]}
{"id": "entailmentbank_validation_836", "nl": "a puddle drying in the sun is an example of evaporation.", "fol": "", "prediction": ["exists x. (Puddle(x) & DriesInSun(x) & ExampleOf(x, Evaporation))", "Exists x. Exists y. (Puddle(x) & Sun(y) & DryingIn(x, y) & ExampleOf(x, Evaporation))", "Exists x, y. (Puddle(x) & DryingInSun(x, y) & Sun(y) & ExampleOf(x, Evaporation))", "Exists x. (Puddle(x) & DryingInSun(x) -> ExampleOf(x, evaporation))"]}
{"id": "entailmentbank_validation_837", "nl": "if something is in the sunlight then that something will absorb solar energy.", "fol": "", "prediction": ["all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_838", "nl": "a bucket of water in in the sunlight.", "fol": "", "prediction": ["Exists x. (BucketOfWater(x) & InSunlight(x))", "InBucketWater(bucket) & InSunlight(bucket)", "Exists z. (Bucket(z) & Contains(z, water) & InSunlight(z))", "exists x. (BucketOfWater(x) & InSunlight(x))"]}
{"id": "entailmentbank_validation_839", "nl": "the water in the bucket will absorb solar energy.", "fol": "", "prediction": ["exists x. (Water(x) & InBucket(x) -> WillAbsorbSolarEnergy(x))", "exists x. (Water(x) & InBucket(x) -> AbsorbsSolarEnergy(x))", "exists x. (Water(x) & InBucket(x) -> WillAbsorbSolarEnergy(x))", "Exists x. (Water(x) & InBucket(x) -> WillAbsorbSolarEnergy(x))"]}
{"id": "entailmentbank_validation_840", "nl": "if a substance absorbs solar energy then that substance will increase in temperature.", "fol": "", "prediction": ["all x. (AbsorbsSolarEnergy(x) -> IncreasesTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))"]}
{"id": "entailmentbank_validation_841", "nl": "the water in the bucket will increase in temperature.", "fol": "", "prediction": ["exists x. (Water(x) & InBucket(x) -> IncreasesInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> IncreasesInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> IncreasesInTemperature(x))", "exists x. (WaterInBucket(x) -> WillIncreaseInTemperature(x))"]}
{"id": "entailmentbank_validation_842", "nl": "evaporation means a substance changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["all x. (Evaporation(x) <-> (Substance(x) & ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. (Evaporation(x) -> exists y. (Substance(y) & ChangesState(y, liquid, gas) & IncreasesHeatEnergy(y)))", "all s. ((Evaporation(s) & Substance(s) & Liquid(s)) -> exists g. (Gas(g) & ChangesTo(s, g) & IncreasesHeatEnergy(s)))", "all x. (Evaporation(x) -> exists y. (Substance(y) & ChangesFromTo(y, liquid, gas) & IncreasesHeatEnergy(y)))"]}
{"id": "entailmentbank_validation_843", "nl": "the water in the bucket will evaporate.", "fol": "", "prediction": ["Evaporates(water_in_bucket)", "Evaporates(water_in_bucket)", "Exists x. (Water(x) & InBucket(x) -> WillEvaporate(x))", "Exists x. (Water(x) & InBucket(x) -> WillEvaporate(x))"]}
{"id": "entailmentbank_validation_844", "nl": "gas is a kind of substance.", "fol": "", "prediction": ["Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)"]}
{"id": "entailmentbank_validation_845", "nl": "substances are made of molecules.", "fol": "", "prediction": ["all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))"]}
{"id": "entailmentbank_validation_846", "nl": "a gas is made of its molecules.", "fol": "", "prediction": ["all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))"]}
{"id": "entailmentbank_validation_847", "nl": "a gas is heated and its temperature increases.", "fol": "", "prediction": ["exists x. (Gas(x) & Heated(x) & IncreaseTemperature(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "all x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "all g. all t. ((Gas(g) & Heated(g) & Temperature(t) & RelatedTo(t, g)) -> Increases(t))"]}
{"id": "entailmentbank_validation_848", "nl": "as the temperature of a substance increases, the molecules in that substance will move faster / farther apart.", "fol": "", "prediction": ["all x. (Substance(x) & TemperatureIncreases(x) -> (MoleculesMoveFaster(x) & MoleculesMoveFartherApart(x)))", "all s. (Substance(s) & Increases(Temperature(s)) -> (all m. (Molecule(m, s) -> (MovesFaster(m) & MovesFartherApart(m)))))", "all x. (Substance(x) & IncreasesTemperature(x) -> (exists y. (Molecule(y) & In(x, y) -> (MovesFaster(y) & MovesFartherApart(y)))))", "all x. (Substance(x) & IncreasesTemperature(x) -> (all y. (Molecule(y) & In(x, y)) -> MoveFaster(y) & FartherApart(y, y)))"]}
{"id": "entailmentbank_validation_849", "nl": "the molecules in the gas will move faster.", "fol": "", "prediction": ["all x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "exists x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "exists x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "all x. (Molecule(x) & InGas(x) -> MoveFaster(x))"]}
{"id": "entailmentbank_validation_850", "nl": "comparing a property of two objects requires knowing the property of each object.", "fol": "", "prediction": ["all x y z. (Property(z, x) & Property(z, y) -> RequiresKnowledge(Property(z, x)) & RequiresKnowledge(Property(z, y)) -> CompareProperties(x, y, z))", "all x, y, p. (Property(p, x) & Property(p, y) -> RequiresKnowledge(p, x) & RequiresKnowledge(p, y) -> CanCompare(x, y, p))", "all x all y all p ((PropertyOf(x, p) & PropertyOf(y, p)) -> RequiresKnowledge(PropertyOf(x, p)) & RequiresKnowledge(PropertyOf(y, p)) & RequiresKnowledge(Comparing(x, y, p)))", "all x y p. ((Object(x) & Object(y) & Property(p) & Compares(p, x, y)) -> (KnowsProperty(x, p) & KnowsProperty(y, p)))"]}
{"id": "entailmentbank_validation_851", "nl": "a rock is a kind of object.", "fol": "", "prediction": ["ObjectType(rock, object)", "Rock(x) -> Object(x)", "Object(rock)", "ObjectKind(rock, object)"]}
{"id": "entailmentbank_validation_852", "nl": "mass is a property of objects / matter.", "fol": "", "prediction": ["all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. (Object(x) -> HasProperty(x, mass)) & HasProperty(matter, mass)", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))"]}
{"id": "entailmentbank_validation_853", "nl": "comparing the mass of two rocks requires knowing the mass of each rock.", "fol": "", "prediction": ["all x, y. (Rock(x) & Rock(y) & ComparingMass(x, y) -> (KnownMass(x) & KnownMass(y)))", "all x, y. ((Rock(x) & Rock(y) & x != y) -> (RequiresComparingMass(x, y, KnowingMass(x) & KnowingMass(y))))", "all x y. (Rock(x) & Rock(y) & x != y -> (Requires(KnowMass(x) & KnowMass(y), CompareMass(x, y))))", "all x, y. (Rock(x) & Rock(y) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))"]}
{"id": "entailmentbank_validation_854", "nl": "student is trying to compare the mass of two small rocks.", "fol": "", "prediction": ["exists x, y. (Student(x) & SmallRock(y) & SmallRock(z) & TryingToCompareMass(x, y, z))", "exists x, y. (Student(z) & SmallRock(x) & SmallRock(y) & IsComparingMass(z, x, y))", "exists x, y. (Student(z) & TryToCompare(z, x, y) & Rock(x) & Rock(y) & Small(x) & Small(y) & Mass(x) & Mass(y))", "exists x, y, z. (Student(x) & TryingToCompare(x, y, z) & SmallRock(y) & SmallRock(z) & Mass(y) & Mass(z))"]}
{"id": "entailmentbank_validation_855", "nl": "the student has to know the mass of each rock to compare them.", "fol": "", "prediction": ["all x. (Rock(x) -> HasToKnow(student, Mass(x))) & Compare(student, Rock).", "all x. (Rock(x) -> KnowMass(student, x)) -> CanCompare(student, rocks)", "all x. (Rock(x) -> (Student(y) & HasToKnowMass(y, x) & CanCompare(y, x)))", "exists x. (Student(x) -> (all y. (Rock(y) -> MustKnowMass(x, y)) & CompareRocks(x)))"]}
{"id": "entailmentbank_validation_856", "nl": "a balance is used for measuring mass / weight of an object / of a substance.", "fol": "", "prediction": ["exists x. (Balance(x) & UsedFor(x, Measuring) & MeasuringOf(Mass) | MeasuringOf(Weight) & of(Object) | of(Substance))", "exists x. (Balance(x) & UsedFor(x, Measuring(Mass/Weight)))", "exists x. (Balance(x) & all y. (ObjectOrSubstance(y) -> UsedForMeasuringMassOrWeight(x, y)))", "exists x. (Balance(x) & UsedForMeasuring(x, Mass(y) | Weight(y)))"]}
{"id": "entailmentbank_validation_857", "nl": "a balance is a kind of instrument.", "fol": "", "prediction": ["all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))"]}
{"id": "entailmentbank_validation_858", "nl": "the student can use balance to know the mass of each rock to compare them.", "fol": "", "prediction": ["exists x. (Student(x) -> (exists y. (Balance(y) & CanUse(x, y))) & all z. (Rock(z) -> exists m. (Mass(m, z) & Know(x, m))) & CanCompare(x, z))", "exists x. (Student(x) & exists b. (Balance(b) & forall y. (Rock(y) -> CanKnowMass(x, y, b))) & CanCompareMasses(x))", "exists x. (Student(x) & CanUseBalance(x) & all y. (Rock(y) -> exists z. (KnowsMassOf(x, y) & Balance(z) & Uses(x, z, y))) & ComparesRocks(x))", "exists x. (Student(x) & exists y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> exists m. (Mass(z, m) & KnowMass(x, z, m))) & CompareMasses(x)))"]}
{"id": "entailmentbank_validation_859", "nl": "a balance is used for measuring mass of a substance.", "fol": "", "prediction": ["exists x. (Balance(x) -> UsedFor(x, MeasuringMass(y)))", "exists x. (Balance(x) -> UsedForMeasuringMass(x, substance))", "exists b. (Balance(b) & all s. (Substance(s) -> UsedForMeasuringMass(b, s)))", "exists x y. (Balance(x) & Substance(y) & UsedFor(x, MeasuringMass(y)))"]}
{"id": "entailmentbank_validation_860", "nl": "sand is a kind of substance.", "fol": "", "prediction": ["Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)"]}
{"id": "entailmentbank_validation_861", "nl": "a balance can be used for measure the mass of sand.", "fol": "", "prediction": ["exists z. (Balance(z) -> CanBeUsedFor(z, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedToMeasureMassOf(x, sand))", "exists x. (Balance(x) & CanBeUsedFor(x, MeasureMass(sand)))", "all x. (Balance(x) -> CanBeUsedFor(x, Measure(mass, sand)))"]}
{"id": "entailmentbank_validation_862", "nl": "determining something often requires measuring that something.", "fol": "", "prediction": ["all x. (Determining(x) -> requires(Measure(x)))", "all x. (Determining(x) -> exists y. (Something(y) & Requires(Measuring(x, y))))", "all x. (Determining(x) -> OftenRequires(x, y) & Measuring(y))", "all x. (Determining(x) -> often exists y. (Measure(y) & y = x))"]}
{"id": "entailmentbank_validation_863", "nl": "determining the mass of the sand requires using a balance to measure the mass of the sand.", "fol": "", "prediction": ["all x. (Sand(x) -> (DeterminingMass(x) <-> RequiresUsingBalance(MeasureMass(x))))", "Requires(DeterminingMass(sand), UsingBalanceToMeasureMass(sand))", "Requires(DeterminingMassOfSand, UsingBalanceToMeasureMassOfSand)", "Requires(DeterminingMass(sand), UsingBalanceToMeasureMass(sand))"]}
{"id": "entailmentbank_validation_864", "nl": "a balance is used for measuring the mass of an object.", "fol": "", "prediction": ["exists x. (Balance(x) & UsedFor(x, Measuring(mass)) & exists y. Object(y) & Measures(x, Mass(y)))", "all x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "exists x. (Balance(x) & all y. (Object(y) -> UsedFor(x, MeasuringMassOf(y))))", "exists x. (Balance(x) & all y. (Object(y) -> UsedForMeasuringMass(x, y)))"]}
{"id": "entailmentbank_validation_865", "nl": "density can be calculated by measuring the mass of an object divided by the volume of that object.", "fol": "", "prediction": ["all x. (Object(x) -> (Calculable(Density(x)) <-> (exists m, v. (Measure(m, Mass(x)) & Measure(v, Volume(x)) & Density(x) = m/v))))", "all x. (Object(x) -> CanCalculateDensityBy(x, Dividing(Mass(x), Volume(x))))", "all x. (Object(x) -> DensityCanBeCalculated(x) <-> (MeasureMass(x) / MeasureVolume(x)))", "all x. (Object(x) -> exists m, v. (Mass(x, m) & Volume(x, v) & Density(x) = m/v))"]}
{"id": "entailmentbank_validation_866", "nl": "a graduated cylinder is used to measure volume of an object.", "fol": "", "prediction": ["exists x. (GraduatedCylinder(x) -> exists y. (Object(y) & MeasuresVolumeOf(x, y)))", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolume(x, y))", "exists x. (GraduatedCylinder(x) -> UsedToMeasure(x, Object(y), Volume(y)))", "exists x. (GraduatedCylinder(x) & all y. (Object(y) -> UsedToMeasureVolume(x, y)))"]}
{"id": "entailmentbank_validation_867", "nl": "the density of an object can be measured using a graduated cylinder and a balance.", "fol": "", "prediction": ["all x. (Object(x) -> CanBeMeasuredUsing(x, graduated_cylinder) & CanBeMeasuredUsing(x, balance))", "all x. (Object(x) -> CanMeasureDensityUsing(x, graduated_cylinder, balance))", "all x. (Object(x) -> CanBeMeasuredUsingGraduatedCylinderAndBalance(x))", "all x. (Object(x) -> CanMeasureDensity(x, graduated_cylinder, balance))"]}
{"id": "entailmentbank_validation_868", "nl": "a marble is a kind of object.", "fol": "", "prediction": ["Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)"]}
{"id": "entailmentbank_validation_869", "nl": "the density of a marble can be measured using a graduated cylinder and a balance.", "fol": "", "prediction": ["exists x. (Marble(x) -> exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x. (Marble(x) & exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x. (Marble(x) -> exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x. (Marble(x) & exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))"]}
{"id": "entailmentbank_validation_870", "nl": "if a unit of for something is being measured, then it requires a measurement tool for measuring that something.", "fol": "", "prediction": ["all x y. (Unit(x) & MeasuredFor(x, y) -> requiresMeasurementTool(y))", "all x y. (UnitOf(x, y) & Measured(y) -> exists z. (MeasurementTool(z) & Requires(z, y)))", "all x y. (UnitOf(x, y) & BeingMeasured(x) -> exists z. (MeasurementTool(z) & Requires(y, z)))", "all x y. ((UnitOf(x, y) & Measured(y)) -> requires(x, y, MeasurementTool(x, y)))"]}
{"id": "entailmentbank_validation_871", "nl": "milliliters ml are a metric unit used for measuring volume.", "fol": "", "prediction": ["all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, Volume)))", "all z. (Milliliter(z) -> MetricUnit(z) & UsedFor(z, MeasuringVolume))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, MeasuringVolume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, MeasuringVolume)))"]}
{"id": "entailmentbank_validation_872", "nl": "measuring milliliters requires a tool for measuring volume.", "fol": "", "prediction": ["all x. (Milliliter(x) -> exists y. (Tool(y) & MeasuresVolume(y)))", "all x. (Measuring(x, milliliters) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (Tool(y) & MeasuresVolume(y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))"]}
{"id": "entailmentbank_validation_873", "nl": "measuring milliliters requires a graduated cylinder.", "fol": "", "prediction": ["all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (Milliliters(x) -> RequiresGraduatedCylinder(Measuring(x)))", "all x. (Millimeter(x) -> RequiresGraduatedCylinder(x))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))"]}
{"id": "entailmentbank_validation_874", "nl": "a sample in a cylindrical container has a cylindrical shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Sample(x) & InContainer(x, cylindrical) & Shape(x, cylindrical) & HasFixedVolume(x))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & IsIn(x, y) & CylindricalShape(x) & HasFixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. exists y. (Sample(x) & Container(y) & Cylindrical(y) & In(y, x) & Cylindrical(x) & FixedVolume(x))"]}
{"id": "entailmentbank_validation_875", "nl": "a sample is a kind of matter.", "fol": "", "prediction": ["Matter(sample)", "Matter(sample)", "Matter(sample)", "Matter(sample)"]}
{"id": "entailmentbank_validation_876", "nl": "the matter has the same shape as the container and fixed volume.", "fol": "", "prediction": ["Matter(m) & Container(c) & HasSameShapeAs(m, c) & FixedVolume(m)", "exists x. (Matter(x) & exists y. (Container(y) & SameShape(x, y) & FixedVolume(x)))", "exists x, y. (Matter(x) & Container(y) & SameShapeAs(x, y) & FixedVolume(x))", "exists x. (Matter(x) & Shape(x, container) & FixedVolume(x))"]}
{"id": "entailmentbank_validation_877", "nl": "matter with variable shape changes shape in different container.", "fol": "", "prediction": ["all x y z. (Matter(x) & VariableShape(x) & Container(y) & Container(z) & InDifferentContainers(y, z) & In(x, y) & In(x, z) -> ChangesShape(x, y, z))", "all x. (Matter(x) & VariableShape(x) -> all y. (Container(y) -> (In(y, Container1) & In(x, Container2) & Container1 != Container2) -> ChangesShape(x)))", "all x. (Matter(x) & VariableShape(x) -> all y z. ((Container(y) & Container(z) & Different(y, z)) -> ChangesShapeIn(x, y, z)))", "all x. (Matter(x) & VariableShape(x) -> all y. (Container(y) & InDifferentContainer(x, y) -> ChangesShape(x, y)))"]}
{"id": "entailmentbank_validation_878", "nl": "the matter may have a variable shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & (VariableShape(x) & FixedVolume(x)))", "exists x. (Matter(x) & VariableShape(x) & FixedVolume(x))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "FOL Translation:\nexists x. (Matter(x) & CanHaveVariableShape(x) & HasFixedVolume(x))"]}
{"id": "entailmentbank_validation_879", "nl": "the matter may have a fixed shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & FixedShape(x) & FixedVolume(x))", "exists x. (Matter(x) & FixedShape(x) & FixedVolume(x))", "exists x. (Matter(x) & (HasFixedShape(x) & HasFixedVolume(x)))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))"]}
{"id": "entailmentbank_validation_880", "nl": "the matter may have a fixed or variable shape and fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & (HasFixedShape(x) | HasVariableShape(x)) & HasFixedVolume(x))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))"]}
{"id": "entailmentbank_validation_881", "nl": "matter in the solid phase has definite shape.", "fol": "", "prediction": ["all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. ((Matter(x) & SolidPhase(x)) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))"]}
{"id": "entailmentbank_validation_882", "nl": "matter in the solid phase has definite volume.", "fol": "", "prediction": ["all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))"]}
{"id": "entailmentbank_validation_883", "nl": "matter in solid phase has definite volume and definite shape.", "fol": "", "prediction": ["all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))"]}
{"id": "entailmentbank_validation_884", "nl": "matter in the liquid phase has variable shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))"]}
{"id": "entailmentbank_validation_885", "nl": "matter in the liquid phase has definite volume.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x))"]}
{"id": "entailmentbank_validation_886", "nl": "matter in the liquid phase has a variable shape and definite volume.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x) & DefiniteVolume(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))"]}
{"id": "entailmentbank_validation_887", "nl": "the matter may be in solid phase or in liquid phase.", "fol": "", "prediction": ["exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) -> (SolidPhase(x) | LiquidPhase(x)))"]}
{"id": "entailmentbank_validation_888", "nl": "seeing small things with bare eyes is difficult.", "fol": "", "prediction": ["all x. (SmallThing(x) & SeenWithBareEyes(x) -> Difficult(Seeing(x)))", "all x. (SmallThing(x) -> Difficult(SeeWithBareEyes(x)))", "FOL Translation:\nall x. (Small(x) & SeenWithBareEyes(x) -> DifficultToSee(x))", "all x. (SmallThing(x) -> -CanSeeWithBareEyes(x))"]}
{"id": "entailmentbank_validation_889", "nl": "an insect usually has a small size.", "fol": "", "prediction": ["all x. (Insect(x) -> Usually(HasSmallSize(x)))", "all x. (Insect(x) -> Usually(HasSmallSize(x)))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "all y. (Insect(y) -> UsuallySmallSize(y))"]}
{"id": "entailmentbank_validation_890", "nl": "seeing an insect with bare eyes is difficult.", "fol": "", "prediction": ["exists x. (Insect(x) & Difficult(SeeWithBareEyes(x)))", "exists x. (Insect(x) & DifficultToSeeWithBareEyes(x))", "all x. (Insect(x) & SeenWithBareEyes(x) -> DifficultToSee(x))", "all x. (Insect(x) -> DifficultToSeeWithBareEyes(x))"]}
{"id": "entailmentbank_validation_891", "nl": "magnifying glass is used to see small things by making objects appear bigger.", "fol": "", "prediction": ["exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & all y. (Object(y) & AppearsBigger(y) & UsesMagnifyingGlass(y) -> SeeSmallThingsWith(x, y)))", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "exists x. (MagnifyingGlass(x) & UsedFor(x, SeeSmallThings) & MakesObjectsAppearBigger(x))"]}
{"id": "entailmentbank_validation_892", "nl": "magnifying glass can be used to see an insect by making it appear bigger.", "fol": "", "prediction": ["exists x. (Insect(x) -> CanBeUsedToSeeWithMagnifyingGlass(magnifying_glass, x) & AppearsBiggerThrough(magnifying_glass, x))", "exists x. (Insect(x) -> exists y. (MagnifyingGlass(y) & UsedToSee(x, y) & MakesAppearBigger(y, x)))", "exists x. (MagnifyingGlass(x) & CanBeUsedToSeeInsect(x) & MakesAppearBigger(x))", "exists x. (Insect(x) -> (exists y. (MagnifyingGlass(y) & CanBeUsedToSee(y, x) & MakesAppearBigger(y, x))))"]}
{"id": "entailmentbank_validation_893", "nl": "a hand lens is a kind of magnifying glass.", "fol": "", "prediction": ["KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)"]}
{"id": "entailmentbank_validation_894", "nl": "a hand lens can help seeing the insect by magnifying the insect.", "fol": "", "prediction": ["exists h, i. (HandLens(h) & Insect(i) -> CanHelpSeeing(h, i) & Magnifies(h, i))", "exists x exists y. (HandLens(x) & Insect(y) & CanHelpSeeing(x, y) & Magnifies(x, y))", "exists x. (HandLens(x) & HelpsSeeingInsectByMagnifying(x))", "exists x. (HandLens(x) -> all y. (Insect(y) -> (HelpsSeeingByMagnifying(x, y))))"]}
{"id": "entailmentbank_validation_895", "nl": "building a doghouse requires cutting materials into a fixed size.", "fol": "", "prediction": ["all x. (Building(x, doghouse) -> Requires(x, exists y. (Material(y) & CutToFixedSize(y))))", "all x. (BuildingDoghouse(x) -> exists y. (Material(y) & Requires(Cutting(y, FixedSize))))", "all x. (Building(x, doghouse) -> exists y. (Material(y) & RequiresCuttingToSize(y, fixed_size)))", "all x. (Building(x, doghouse) -> Requires(x, (exists y. (Material(y) & Cutting(y, fixed_size)))))"]}
{"id": "entailmentbank_validation_896", "nl": "cutting a material usually requires measuring length.", "fol": "", "prediction": ["all x. (Material(x) -> usually (Cutting(x) -> MeasuringLength(x)))", "all x. (Material(x) -> (Cutting(x) -> MeasuringLength(x)))", "all x. (Material(x) -> RequiresCutting(x, MeasureLength))", "all x. (Material(x) -> (Cutting(x) -> UsuallyRequires(Cutting(x), MeasuringLength)))"]}
{"id": "entailmentbank_validation_897", "nl": "cutting a material when building a doghouse  requires measuring length.", "fol": "", "prediction": ["all x. (CuttingMaterial(x) & BuildingDoghouse(x) -> Requires(x, MeasuringLength))", "all x. (BuildingDoghouse(x) & CuttingMaterial(x) -> Requires(MeasuringLength, x))", "all x. (Material(x) -> (Activity(BuildDoghouse, x) & Action(Cut, x) -> Action(MeasureLength, x)))", "all x. (BuildingDoghouse(x) & Materials(x) & Cutting(x) -> Requires(MeasuringLength(x)))"]}
{"id": "entailmentbank_validation_898", "nl": "a tape can be used to measure length.", "fol": "", "prediction": ["all x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) & CanBeUsedToMeasure(x, length))"]}
{"id": "entailmentbank_validation_899", "nl": "cutting wood when building a doghouse requires using a tape.", "fol": "", "prediction": ["all x. ((CuttingWood(x) & Building(x, doghouse)) -> RequiresUsing(x, tape))", "all x. (Building(x) & Doghouse(x) -> (exists y. (Wood(y) & Cutting(y))) -> Requires(x, Tape(z)))", "all x. (BuildingDoghouse(x) & CuttingWood(x) -> RequiresUsingTape(x))", "all x. ((Build(x, doghouse) & Requires(x, cutting_wood)) -> Requires(x, using_tape))"]}
{"id": "entailmentbank_validation_900", "nl": "food is a kind of substance.", "fol": "", "prediction": ["all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all z. (Food(z) -> Substance(z))"]}
{"id": "entailmentbank_validation_901", "nl": "candy is a kind of food.", "fol": "", "prediction": ["Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)"]}
{"id": "entailmentbank_validation_902", "nl": "candy is a kind of substance.", "fol": "", "prediction": ["Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)"]}
{"id": "entailmentbank_validation_903", "nl": "a thermometer is used to measure temperature of substance.", "fol": "", "prediction": ["exists t. (Thermometer(t) -> exists s. (Substance(s) & UsedToMeasureTemperature(t, s)))", "exists x. exists y. exists z. (Thermometer(x) & Substance(y) & MeasuresTemperatureOf(x, y, z))", "exists x y. (Thermometer(x) & Substance(y) & UsedToMeasureTemperatureOf(x, y))", "exists x. exists y. (Thermometer(x) & Substance(y) -> UsedToMeasureTemperatureOf(x, y))"]}
{"id": "entailmentbank_validation_904", "nl": "a thermometer is used to measure the temperautre of the candy.", "fol": "", "prediction": ["exists x. (Thermometer(x) & UsedToMeasureTemperatureOf(x, candy))", "exists x. (Thermometer(x) & UsedToMeasureTemperatureOf(x, candy))", "exists x. (Thermometer(x) & UsedToMeasureTemperatureOfCandy(x))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature, candy))"]}
{"id": "entailmentbank_validation_905", "nl": "a string is short in length.", "fol": "", "prediction": ["ShortLength(string)", "ShortInLength(string)", "ShortString(x)", "ShortInLength(a_string)"]}
{"id": "entailmentbank_validation_906", "nl": "centimeter is usually used to measure short length.", "fol": "", "prediction": ["all x. (ShortLength(x) -> UsesToMeasure(centimeter, x))", "exists x. (MeasurementUnit(x) & Usual(x, centimeter) & Measures(x, short_length))", "all x. (Length(x) & Short(x) -> UsuallyUsedToMeasure(centimeter, x))", "all x. (ShortLength(x) -> UsuallyUsedToMeasure(centimeter, x))"]}
{"id": "entailmentbank_validation_907", "nl": "centimeter is a better unit to measure the length of the string.", "fol": "", "prediction": ["BetterUnitToMeasure(centimeter, length_of_string)", "BetterUnitToMeasureLength(cm, string)", "BetterUnitToMeasure(string, centimeter, length)", "BetterUnitToMeasureLength(string, centimeter)"]}
{"id": "entailmentbank_validation_908", "nl": "meters m are a metric / si unit used for measuring length.", "fol": "", "prediction": ["MetricUnit(m) & SIUnit(m) & UsedFor(measuring_length, m)", "all m. (Meter(m) & MetricUnit(m) & SIUnit(m) & UsedForMeasuring(m, length))", "all m. (Meter(m) -> MetricSIUnit(m) & UsedForMeasuringLength(m))", "MetricUnit(meters) & SIUnit(meters) & UsedFor(meters, MeasuringLength)"]}
{"id": "entailmentbank_validation_909", "nl": "yard is an imperial unit used for measuring length.", "fol": "", "prediction": ["ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & Measures(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)"]}
{"id": "entailmentbank_validation_910", "nl": "yard and meter are both unit used for measuring length.", "fol": "", "prediction": ["Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & for all x. (MeasuringLength(x) -> (UsedFor(yard, x) & UsedFor(meter, x)))"]}
{"id": "entailmentbank_validation_911", "nl": "1 yard equals to 09 meter.", "fol": "", "prediction": ["Equals(yard, meter)", "Equals(1_yard, 0.9_meter)", "Equals(yard, meter)", "Equals(yard, meter) & yard = 1 & meter = 0.9"]}
{"id": "entailmentbank_validation_912", "nl": "meter is the metric unit that is the most similar to yard.", "fol": "", "prediction": ["MostSimilarTo(yard, meter) & MetricUnit(meter)", "MetricUnit(meter) & Similar(meter, yard) & all x. ((MetricUnit(x) & Similar(x, yard)) -> x = meter)", "MetricUnit(meter) & (forall x. (MetricUnit(x) -> MostSimilarTo(x, yard) <-> x = meter))", "MetricUnit(meter) & MostSimilarTo(meter, yard)"]}
{"id": "entailmentbank_validation_913", "nl": "zinc is a kind of metal.", "fol": "", "prediction": ["Metal(zinc)", "Metal(zinc)", "Kind(zinc, metal)", "KindOf(zinc, metal)"]}
{"id": "entailmentbank_validation_914", "nl": "copper is a kind of metal.", "fol": "", "prediction": ["Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)"]}
{"id": "entailmentbank_validation_915", "nl": "copper and zinc are two metals.", "fol": "", "prediction": ["Metal(copper) & Metal(zinc) & TwoMetals(copper, zinc)", "Metal(copper) & Metal(zinc) & copper \u2260 zinc", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc)"]}
{"id": "entailmentbank_validation_916", "nl": "brass is made of copper and zinc.", "fol": "", "prediction": ["MadeOf(brass, copper) & MadeOf(brass, zinc)", "Material(brass, copper) & Material(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)"]}
{"id": "entailmentbank_validation_917", "nl": "brass is made of two metals.", "fol": "", "prediction": ["exists m. exists n. (Metal(m) & Metal(n) & MadeOf(brass, m) & MadeOf(brass, n) & m \u2260 n)", "exists x. exists y. (Metal(x) & Metal(y) & MadeOf(brass, x, y) & x != y)", "exists x. exists y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x. exists y. (Metal(x) & Metal(y) & x != y & MadeOf(brass, x, y))"]}
{"id": "entailmentbank_validation_918", "nl": "an alloy is made of two or more metals.", "fol": "", "prediction": ["all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & PartOf(y, x) & PartOf(z, x) & y \u2260 z))", "all x. (Alloy(x) -> exists y. exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all a. (Alloy(a) -> exists m1. exists m2. (Metal(m1) & Metal(m2) & MadeOf(a, m1) & MadeOf(a, m2) & m1 \u2260 m2))", "all x. (Alloy(x) -> exists m1, m2. (Metal(m1) & Metal(m2) & MadeOf(x, m1) & MadeOf(x, m2) & m1 != m2))"]}
{"id": "entailmentbank_validation_919", "nl": "brass is a kind of alloy.", "fol": "", "prediction": ["all x. (Brass(x) -> Alloy(x))", "KindOf(brass, alloy)", "Alloy(brass)", "all x. (Brass(x) -> Alloy(x))"]}
{"id": "entailmentbank_validation_920", "nl": "a rough surface can absorb sound.", "fol": "", "prediction": ["FOL Translation:\nall x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "exists x. (RoughSurface(x) -> CanAbsorbSound(x))"]}
{"id": "entailmentbank_validation_921", "nl": "a carpet can absorb sound.", "fol": "", "prediction": ["exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))"]}
{"id": "entailmentbank_validation_922", "nl": "if sound is absorbed, then sound can not reflect off the surface.", "fol": "", "prediction": ["all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Absorbed(x) -> -ReflectsOffSurface(x))", "all x. (Sound(x) & Absorbed(x) -> -ReflectsOffSurface(x))", "all s. (Sound(s) & Absorbed(s) -> -CanReflect(s))"]}
{"id": "entailmentbank_validation_923", "nl": "sound cannot reflect off the surface of a carpet.", "fol": "", "prediction": ["all x. (CarpetSurface(x) -> -CanReflectOff(sound, x))", "all x. (Sound(x) -> -ReflectsOff(x, carpet))", "all x. (Carpet(x) -> -ReflectsOffSurface(sound, x))", "all x y. (Sound(x) & Carpet(y) -> -ReflectsOff(x, y))"]}
{"id": "entailmentbank_validation_924", "nl": "echo is when sound reflects off a smooth surface.", "fol": "", "prediction": ["all x. (Echo(x) <-> exists y exists z. (Sound(y) & ReflectsOff(y, z) & SmoothSurface(z)))", "all x. (Echo(x) <-> exists y. (Sound(y) & ReflectsOff(y, SmoothSurface)))", "all x. (Echo(x) <-> (Sound(y) & Reflects(y, z) & SmoothSurface(z)))", "Echo(x) <-> exists y. (Sound(y) & Reflects(x, y) & SmoothSurface(z) & Off(z, y))"]}
{"id": "entailmentbank_validation_925", "nl": "echo will not be produced.", "fol": "", "prediction": ["-Produced(echo)", "-Produced(echo)", "-Produced(echo)", "-Producing(echo)"]}
{"id": "entailmentbank_validation_926", "nl": "helium is less in density than air.", "fol": "", "prediction": ["LessInDensityThan(helium, air)", "LessDenseThan(helium, air)", "LessInDensity(helium, air)", "LessInDensity(helium, air)"]}
{"id": "entailmentbank_validation_927", "nl": "a balloon is a kind of container.", "fol": "", "prediction": ["Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)"]}
{"id": "entailmentbank_validation_928", "nl": "a balloon filled with helium is an example of a container contains a substance with less density than air.", "fol": "", "prediction": ["exists x. exists y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & Contains(x, y) & Substance(y) & LessDensityThan(y, air))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & exists y. (Substance(y) & Contains(x, y) & LessDensityThan(y, air)))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & exists y. (Substance(y) & Contains(x, y) & LessDensityThan(y, air)))", "exists x, y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & Contains(x, y) & Substance(y) & LessDensityThan(y, air))"]}
{"id": "entailmentbank_validation_929", "nl": "if a container contains a substance with less density than air then that container may move upward.", "fol": "", "prediction": ["all x. all y. ((Container(x) & Contains(x, y) & Density(y) < Density(air)) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Contains(x, y) & LessDensityThan(y, air)) -> MayMoveUpward(x))", "all c. all s. ((Container(c) & Contains(c, s) & DensityLessThan(s, air)) -> MayMoveUpward(c))", "all x. all y. ((Container(x) & Contains(x, y) & LessDensity(y, air)) -> CanMoveUpward(x))"]}
{"id": "entailmentbank_validation_930", "nl": "the balloon filled with helium may move upward if released.", "fol": "", "prediction": ["exists x. (Balloon(x) & FilledWith(x, helium) -> Released(x) -> MayMoveUpward(x))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists x. (Balloon(x) & FilledWithHelium(x) -> Released(x) -> MayMoveUpward(x))"]}
{"id": "entailmentbank_validation_931", "nl": "a white object reflects all visible light.", "fol": "", "prediction": ["all x. ((Object(x) & White(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "FOL Translation:\nall x. (WhiteObject(x) -> all y. (VisibleLight(y) & Reflects(x, y)))", "all x. ((WhiteObject(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((Object(x) & White(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))"]}
{"id": "entailmentbank_validation_932", "nl": "the floor is a kind of object.", "fol": "", "prediction": ["Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)"]}
{"id": "entailmentbank_validation_933", "nl": "a white door will reflect all visible light.", "fol": "", "prediction": ["all x. ((Door(x) & White(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((WhiteDoor(x) -> all y. (VisibleLight(y) -> Reflects(x, y))))", "all x. (Door(x) & White(x) -> Reflects(x, visible_light))", "all x. ((Door(x) & White(x)) -> ReflectsAllVisibleLight(x))"]}
{"id": "entailmentbank_validation_934", "nl": "the ice melts.", "fol": "", "prediction": ["Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)"]}
{"id": "entailmentbank_validation_935", "nl": "melting is a kind of phase change.", "fol": "", "prediction": ["PhaseChange(melting)", "KindOf(melting, phase_change)", "PhaseChange(melting)", "PhaseChange(melting)"]}
{"id": "entailmentbank_validation_936", "nl": "the ice undergoes a phase change.", "fol": "", "prediction": ["PhaseChange(ice)", "Exists x. (Ice(x) & UndergoesPhaseChange(x))", "PhaseChange(ice)", "PhaseChange(ice)"]}
{"id": "entailmentbank_validation_937", "nl": "phase changes do not change mass.", "fol": "", "prediction": ["all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> all y. (Mass(y) -> -(ChangesMass(x, y))))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))"]}
{"id": "entailmentbank_validation_938", "nl": "the mass of the ice will not change.", "fol": "", "prediction": ["For the given sentence, \"the mass of the ice will not change,\" we can define predicates to represent the relevant concepts:\n\n- Let `Mass(x, y)` represent \"x has mass y.\"\n- Let `Ice(x)` represent \"x is ice.\"\n- Let `NotChange(x)` represent \"x does not change.\"\n\nNow, let's translate the sentence into FOL:\n\n```\nexists x. (Ice(x) -> NotChange(Mass(x)))\n```", "Mass(ice) = constant", "Exists x. (Mass(ice, x) & -Change(Mass(ice, x)))", "To translate the sentence \"the mass of the ice will not change\" into first-order logic, we need to establish what is being discussed here: there is specific ice, and its mass remains constant.\n\nLet's use:\n- `Ice(i)` to represent that `i` is ice.\n- `Mass(x, m)` to indicate the mass of `x` is `m`.\n- `Equals(m1, m2)` to represent equality between masses.\n- A constant `c` to represent a specific mass of the ice.\n\nFOL Translation:\n```\nexists i, m. (Ice(i) & Mass(i, m) & all m2. (Mass(i, m2) -> Equals(m, m2)))\n```"]}
{"id": "entailmentbank_validation_939", "nl": "a bubble is made of pockets of gas trapped inside a liquid or solid.", "fol": "", "prediction": ["exists x. (Bubble(x) -> (exists y. (GasPocket(y) & TrappedInside(y, Liquid(x))) | TrappedInside(y, Solid(x))))", "all x. (Bubble(x) -> exists y. (Gas(y) & Trapped(y, x) & (Liquid(x) | Solid(x))))", "all x. (Bubble(x) -> exists y. (Gas(y) & (TrappedInside(y, Liquid) | TrappedInside(y, Solid))))", "Bubble(b) -> exists x. exists y. (Gas(x) & Liquid(y) & TrappedInside(x, y) & MadeOf(b, x) & (Liquid(y) | Solid(y)))"]}
{"id": "entailmentbank_validation_940", "nl": "soap bubbles are made of air trapped inside soap liquid.", "fol": "", "prediction": ["all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, x) & MadeOf(x, SoapLiquid)))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, y, SoapLiquid)))"]}
{"id": "entailmentbank_validation_941", "nl": "air is inside the soap bubbles.", "fol": "", "prediction": ["exists x. (SoapBubble(x) & Inside(air, x))", "exists x. (SoapBubble(x) -> Exists y. (Air(y) & Inside(y, x)))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))"]}
{"id": "entailmentbank_validation_942", "nl": "matter in the liquid phase has definite volume and variable shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "FOL Translation:\nall x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "all x. (Matter(x) & InLiquidPhase(x) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))"]}
{"id": "entailmentbank_validation_943", "nl": "indefinite means variable.", "fol": "", "prediction": ["Means(indefinite, variable)", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> Variable(x))"]}
{"id": "entailmentbank_validation_944", "nl": "matter in the liquid phase has definite volume and indefinite shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))"]}
{"id": "entailmentbank_validation_945", "nl": "substances are made of matter.", "fol": "", "prediction": ["all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))"]}
{"id": "entailmentbank_validation_946", "nl": "a compound is a kind of substance.", "fol": "", "prediction": ["all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_947", "nl": "a compound is made of matter.", "fol": "", "prediction": ["exists c. (Compound(c) & exists m. (Matter(m) & MadeOf(c, m)))", "all c. (Compound(c) -> exists m. (Matter(m) & MadeOf(c, m)))", "exists x. (Compound(x) -> Matter(x))", "all x. (Compound(x) -> MadeOf(x, matter))"]}
{"id": "entailmentbank_validation_948", "nl": "a compound in the liquid phase has definite volume and indefinite shape.", "fol": "", "prediction": ["exists x. (Compound(x) & LiquidPhase(x) & DefiniteVolume(x) & IndefiniteShape(x))", "all x. ((Compound(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "exists x. (Compound(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))"]}
{"id": "entailmentbank_validation_949", "nl": "water is in the solid state, called ice.", "fol": "", "prediction": ["Solid(water) & Ice(water)", "all x. (Water(x) & SolidState(x) -> Called(x, ice))", "Exists x. (Water(x) & SolidState(x) & Called(x, ice))", "SolidState(water, ice)"]}
{"id": "entailmentbank_validation_950", "nl": "hail is a kind of ice.", "fol": "", "prediction": ["Ice(hail)", "KindOf(hail, ice)", "Ice(hail)", "Kind(hail, ice)"]}
{"id": "entailmentbank_validation_951", "nl": "hail is water in solid ice.", "fol": "", "prediction": ["all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> (Water(x) & SolidIce(x)))"]}
{"id": "entailmentbank_validation_952", "nl": "an airplane is used for moving people to far away places.", "fol": "", "prediction": ["exists x. (Airplane(x) & UsedFor(x, MovePeople) & ToFarAwayPlaces(x))", "exists x. (Airplane(x) -> UsedFor(x, MovingPeople) & To(FarAwayPlaces))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))"]}
{"id": "entailmentbank_validation_953", "nl": "an airplane is fast in speed.", "fol": "", "prediction": ["FastSpeed(airplane)", "Fast(airplane, speed)", "FastInSpeed(airplane)", "FastInSpeed(airplane)"]}
{"id": "entailmentbank_validation_954", "nl": "an airplane can move people to far away places quickly.", "fol": "", "prediction": ["exists x. (Airplane(x) -> CanMovePeopleToFarAwayPlacesQuickly(x))", "exists a. (Airplane(a) -> exists x, y. (Person(x) & FarAwayPlace(y) & CanMoveTo(a, x, y) & Quickly(a, x, y)))", "exists x. (Airplane(x) -> all y. (Person(y) -> exists z. (FarAwayPlace(z) & MovesToQuickly(x, y, z))))", "exists x. (Airplane(x) -> CanMovePeopleToFarAwayPlacesQuickly(x))"]}
{"id": "entailmentbank_validation_955", "nl": "a cake is a kind of baked product.", "fol": "", "prediction": ["BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)"]}
{"id": "entailmentbank_validation_956", "nl": "baking is when a human makes food by adding heat.", "fol": "", "prediction": ["all x. (Baking(x) <-> (exists y. (Human(y) & Makes(y, x) & Food(x) & AddsHeat(y, x))))", "Baking(x) <-> (exists y. exists z. (Human(y) & Makes(y, z) & Food(z) & AddsHeat(y, z)))", "all x. (Baking(x) <-> exists y, z. (Human(y) & Makes(y, z) & Food(z) & AddsHeat(y, z)))", "Baking(x) <-> (exists y. (Human(y) & MakesFoodByAddingHeat(y, x)))"]}
{"id": "entailmentbank_validation_957", "nl": "a cake is a product made by human adding heat to it.", "fol": "", "prediction": ["Cake(x) -> (Product(x) & exists y. (Human(y) & AddsHeat(y, x)))", "exists x. (Cake(x) -> exists y. (Product(y) & MadeByHumanAddingHeat(y)))", "exists x. (Cake(x) -> exists y. (Product(y) & MadeBy(y, human) & addsHeatTo(human, x)))", "exists x. (Cake(x) & Product(x) & exists y. (Human(y) & Makes(y, x) & AddsHeat(y, x)))"]}
{"id": "entailmentbank_validation_958", "nl": "transportation technology is a kind of system for moving people and products.", "fol": "", "prediction": ["System(transportation_technology) & KindOf(transportation_technology, MovingSystem) & ForMoving(transportation_technology, People) & ForMoving(transportation_technology, Products)", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> CanMove(transportation_technology, x))", "all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))", "all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))"]}
{"id": "entailmentbank_validation_959", "nl": "transportation technology is used for moving people / products.", "fol": "", "prediction": ["all x. (TransportationTechnology(x) -> UsedFor(x, Moving(people)) | UsedFor(x, Moving(products)))", "exists x exists y. (TransportationTechnology(x) & (People(y) | Products(y)) & UsedFor(x, Moving(y)))", "exists t. (TransportationTechnology(t) & UsedFor(t, MovingPeopleOrProducts))", "exists x y. (TransportationTechnology(x) & (Moving(x, y) & (Person(y) | Product(y))))"]}
{"id": "entailmentbank_validation_960", "nl": "transportation technology is a system that moves people and products.", "fol": "", "prediction": ["all x. (TransportationTechnology(x) -> System(x) & MovesPeopleAndProducts(x))", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "System(transportation_technology) & all x. ((People(x) | Product(x)) -> Moves(transportation_technology, x))", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))"]}
{"id": "entailmentbank_validation_961", "nl": "a refrigerator is used for keeping food fresh for a long period of time.", "fol": "", "prediction": ["all x. (Refrigerator(x) -> UsedFor(x, KeepingFoodFreshForLongPeriod))", "exists x. (Refrigerator(x) & IsUsedFor(x, KeepingFoodFreshForLongPeriod))", "UsedFor(refrigerator, KeepingFoodFreshForLongTime)", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongPeriod))"]}
{"id": "entailmentbank_validation_962", "nl": "the invention of the refrigerator with self-contained unit occurred in 1923.", "fol": "", "prediction": ["Exists r. (Refrigerator(r) & SelfContainedUnit(r) & InventedIn(r, 1923))", "Exists x. (RefrigeratorWithSelfContainedUnit(x) & OccurredInvention(x, 1923))", "exists x. (RefrigeratorWithSelfContainedUnit(x) & Invented(x, 1923))", "Exist y. (Refrigerator(y) & Invention(y, 'self-contained unit', 1923))"]}
{"id": "entailmentbank_validation_963", "nl": "refrigerator is the invention that can keep food fresh for a long period of time.", "fol": "", "prediction": ["Invention(refrigerator) & CanKeepFoodFreshForLong(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLongPeriodOfTime(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLong(refrigerator)", "Invention(refrigerator) & CanKeepFoodFresh(refrigerator, long_period_of_time)"]}
{"id": "entailmentbank_validation_964", "nl": "radio station broadcasting is a source of radio waves.", "fol": "", "prediction": ["SourceOfRadioWaves(radio_station_broadcasting)", "SourceOfRadioWaves(radio_station_broadcasting)", "SourceOfRadioWaves(radio_station_broadcasting)", "exists x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))"]}
{"id": "entailmentbank_validation_965", "nl": "a source of something emits that something.", "fol": "", "prediction": ["all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))"]}
{"id": "entailmentbank_validation_966", "nl": "radio station broadcasting emits radio waves.", "fol": "", "prediction": ["exists x. (RadioStationBroadcasting(x) & EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStation(x) & Broadcasting(x) -> Emits(x, RadioWaves))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))"]}
{"id": "entailmentbank_validation_967", "nl": "radio transmitter emits radio waves.", "fol": "", "prediction": ["Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "exists x. (RadioTransmitter(x) & EmitsRadioWaves(x))", "Exists x. (RadioTransmitter(x) & EmitsRadioWaves(x))"]}
{"id": "entailmentbank_validation_968", "nl": "radio station is a radio transmitter.", "fol": "", "prediction": ["all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "FOL Translation:\nall x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))"]}
{"id": "entailmentbank_validation_969", "nl": "pliers are a kind of hand tool.", "fol": "", "prediction": ["all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))"]}
{"id": "entailmentbank_validation_970", "nl": "pliers are made of two levers for gripping.", "fol": "", "prediction": ["all x. (Pliers(x) -> Exists(y)(Exist(z)(Levers(y) & Levers(z) & MadeOf(x, y) & MadeOf(x, z) & ForGripping(y, x) & ForGripping(z, x))))", "all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & GrippingUse(x)))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> exists y z. (Lever(y) & Lever(z) & MadeOfTwoLeversForGripping(x, y, z)))"]}
{"id": "entailmentbank_validation_971", "nl": "pliers are a tool made of two levers for gripping.", "fol": "", "prediction": ["all x. (Pliers(x) -> Tool(x) & MadeOf(x, TwoLevers) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> (Tool(x) & MadeOfTwoLevers(x) & ForGripping(x)))", "all x. (Pliers(x) -> Tool(x) & MadeOf(x, TwoLevers) & ForGripping(x))"]}
{"id": "entailmentbank_validation_972", "nl": "gripping produces gripping force.", "fol": "", "prediction": ["all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesForce(x, gripping_force))", "all x. (Gripping(x) -> Produces(x, GrippingForce(x)))", "all x. (Gripping(x) -> Produces(x, GrippingForce))"]}
{"id": "entailmentbank_validation_973", "nl": "pliers are a tool that can produce gripping force.", "fol": "", "prediction": ["all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> Tool(x) & CanProduceGrippingForce(x))"]}
{"id": "entailmentbank_validation_974", "nl": "a gripping force can be used to tighten a mechanical fastener.", "fol": "", "prediction": ["exists x y. (GrippingForce(x) & MechanicalFastener(y) -> CanBeUsedToTighten(x, y))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))"]}
{"id": "entailmentbank_validation_975", "nl": "pliers can be used to tighten a mechanical fastener.", "fol": "", "prediction": ["all x. (Pliers(x) -> exists y. (MechanicalFastener(y) & CanUseToTighten(x, y)))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "exists x y. (Pliers(x) & MechanicalFastener(y) & CanBeUsedToTighten(x, y))"]}
{"id": "entailmentbank_validation_976", "nl": "advances in technology sometimes cause human jobs to be replaced by more efficient machines.", "fol": "", "prediction": ["exists t. (AdvanceInTechnology(t) & exists j. (HumanJob(j) & exists m. (EfficientMachine(m) & Causes(t, ReplacedBy(j, m)))))", "exists x. (AdvanceInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & CausesToBeReplaced(x, y, z))))", "exists x. (TechnologyAdvance(x) & exists y. (HumanJob(y) & exists z. (Machine(z) & MoreEfficient(z, y) & Replaces(z, y))))", "exists t. (TechnologyAdvancement(t) & all j. (HumanJob(j) -> exists m. (Machine(m) & MoreEfficient(m, j) & Replaces(m, j))))"]}
{"id": "entailmentbank_validation_977", "nl": "replacing something decreases that something.", "fol": "", "prediction": ["all x. (Decreases(replacing, x) -> -ExistsSame(x))", "all x. (Replaces(something, x) -> Decreases(something, x))", "all x. (exists y. (Replaces(y, x)) -> Decreases(x))", "all x. (Replaces(x, x) -> Decreases(x))"]}
{"id": "entailmentbank_validation_978", "nl": "advances in technology decrease human jobs by replacing them with efficient machines.", "fol": "", "prediction": ["all x. (TechnologyAdvance(x) -> all y. (HumanJob(y) -> exists z. (EfficientMachine(z) & Replaces(z, y))))", "exists x exists y. (AdvancesInTechnology(x) & HumanJob(y) -> (ReplacesWithMachines(x, y) & EfficientMachines(x)))", "exists x. exists y. (AdvancesInTechnology(x) & HumanJobs(y) -> exists z. (EfficientMachine(z) & Replaces(z, y) & Decreases(x, y)))", "exists t, j, m. (AdvancesInTechnology(t) & HumanJobs(j) & EfficientMachines(m) & ReplaceWith(m, j) -> Decrease(t, j))"]}
{"id": "entailmentbank_validation_979", "nl": "having a job has a positive impact on a human.", "fol": "", "prediction": ["all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOnHuman(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))"]}
{"id": "entailmentbank_validation_980", "nl": "decreasing something positive has a negative impact on a thing.", "fol": "", "prediction": ["exists x exists y. (Positive(x) & Thing(y) & Decreasing(x) -> NegativeImpact(x, y))", "all x. all y. (Positive(x) & Decreases(y, x) -> NegativeImpact(y, x))", "all x y. (Positive(x) & Decreasing(x) -> NegativeImpact(x, y))", "all x y. (Positive(x) & Decreases(x) & Impacts(x, y) -> NegativeImpact(y))"]}
{"id": "entailmentbank_validation_981", "nl": "advances in technology decreasing human jobs by more efficient machines has a negative impact on human.", "fol": "", "prediction": ["exists x, y. (AdvanceInTechnology(x) & EffiecentMachine(y) & CausesDecreaseInJobs(x, y) & NegativeImpactOnHuman(x, y))", "exists x, y. (AdvancesInTechnology(x) & Machines(y) & DecreaseHumanJobs(y) & MoreEfficient(y) & NegativeImpactOnHuman(x, y))", "exists x. (AdvanceInTechnology(x) & DecreasesHumanJobs(x) & MoreEfficientMachines(x) & NegativeImpactOnHuman(x))", "exists x. (AdvancesInTechnology(x) & DecreasesHumanJobs(x) & MoreEfficientMachines(x) & HasNegativeImpactOnHumans(x))"]}
{"id": "entailmentbank_validation_982", "nl": "days are a kind of unit for measuring time.", "fol": "", "prediction": ["all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))"]}
{"id": "entailmentbank_validation_983", "nl": "a student wants to record the data of the growth of a vine over a period of a day.", "fol": "", "prediction": ["exists x. (Student(x) & WantsToRecordData(x) & exists y. (DataOfGrowthOfVine(y) & OverPeriodOfDay(y)))", "exists x exists y exists z. (Student(x) & Vine(y) & PeriodOfDay(z) & WantsToRecordGrowth(x, y, z))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOf(y, vine) & Record(x, y) & OverPeriodOfDay(y)))", "exists x. (Student(x) & exists y. (Vine(y) & exists z. (GrowthData(z) & PeriodOfADay(w) & WantsToRecord(x, z, y, w))))"]}
{"id": "entailmentbank_validation_984", "nl": "the student wants to record the data of the growth of a vine over a period of time.", "fol": "", "prediction": ["exists x. (Student(x) & exists y. (DataOfGrowth(y) & Vine(z) & PeriodOfTime(w) & WantsToRecord(x, y, z, w)))", "exists x. (Student(x) & exists y. (Vine(y) & exists z. (Data(z) & Growth(z, y) & exists t. (PeriodOfTime(t) & WantsToRecord(x, z, t)))))", "Student(student) & Vine(vine) & PeriodOfTime(time) & GrowthOf(vine, growth) & Data(data) & WantsToRecord(student, data)", "exists x y z. (Student(x) & Vine(y) & TimePeriod(z) & WantsToRecordDataOfGrowth(x, y, z))"]}
{"id": "entailmentbank_validation_985", "nl": "a line graph is used for showing change / data over time.", "fol": "", "prediction": ["all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all a. (LineGraph(a) -> UsedFor(a, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime) & UsedFor(x, ShowingDataOverTime))"]}
{"id": "entailmentbank_validation_986", "nl": "a line graph an be used to show the data of the growth of the vine over a period of time.", "fol": "", "prediction": ["exists x. (LineGraph(x) & UsedToShow(x, DataOfGrowth(vine, PeriodOfTime)))", "exists x. (LineGraph(x) & UsedToShowDataOf(GrowthOf(vine), PeriodOfTime))", "exists y. (LineGraph(y) & UsedToShow(y, DataOfGrowth(vine, PeriodOfTime)))", "exists x y z. (LineGraph(x) & Data(y) & GrowthOfVine(z) & ShowsData(x, y) & RepresentsGrowth(y, z) & OverTime(z))"]}
