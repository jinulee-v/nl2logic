{"id": "entailmentbank_validation_0", "nl": "the sun rising / setting occurs once per day.", "fol": "", "prediction": ["exists x. (Sun(x) & all y. ((Rises(x, y) | Sets(x, y)) -> OccursOncePerDay(x)))", "exists d. (Day(d) & OccursOncePerDay(SunRising(d)) & OccursOncePerDay(SunSetting(d)))", "all d. (Day(d) -> (exists r. (Rises(sun, d, r) & OncePerDay(d, r))) & exists s. (Sets(sun, d, s) & OncePerDay(d, s))))", "all x. ((Rises(sun, x) | Sets(sun, x)) & Day(x) -> all y. ((Rises(sun, y) | Sets(sun, y)) & Day(y) -> x = y))", "exists x. (Sun(x) & all y. (Day(y) -> (Rising(x, y) & Setting(x, y))))", "exists t1, t2. (Rises(sun, t1) & Sets(sun, t2) & OccursOncePerDay(Rises(sun, t1)) & OccursOncePerDay(Sets(sun, t2)))", "exists x. (Sun(x) & all y. (Day(y) -> (exists z. (Event(z) & Rises(x, z) & OccursOnce(z, y))) & exists w. (Event(w) & Sets(x, w) & OccursOnce(w, y)))))", "exists y. ((Rises(sun, y) | Sets(sun, y)) & Day(y))", "exists x. (Day(x) & OccursOncePerDay(Rise(sun), x) & OccursOncePerDay(Set(sun), x))", "exists x. (SunRising(x) & OccursOncePerDay(x)) & exists y. (SunSetting(y) & OccursOncePerDay(y))", "Exists s. (Sun(s) & all d. (Day(d) -> (RisingOncePerDay(s, d) & SettingOncePerDay(s, d))))", "Rises(sun) & Sets(sun) & all d. (Day(d) -> (OccursOnce(Rising(sun), d) & OccursOnce(Setting(sun), d)))", "OccursOncePerDay(SunRising) & OccursOncePerDay(SunSetting)", "exists y. (Sun(y) & exists z1. (Rises(y, z1) & Day(z1) & exists z2. (Sets(y, z2) & Day(z2) & z1 = z2)))", "all d. (Day(d) -> exists t1, t2. (Rises(sun, t1, d) & Sets(sun, t2, d) & t1 \u2260 t2 & all t. ((Rises(sun, t, d) -> t = t1) & (Sets(sun, t, d) -> t = t2))))", "exists y. (Day(y) & OccursOncePer(y, RisingEvent(sun)) & OccursOncePer(y, SettingEvent(sun)))"]}
{"id": "entailmentbank_validation_1", "nl": "the sun rising is a kind of event.", "fol": "", "prediction": ["Event(Rises(sun))", "Event(Rising(sun))", "Event(sun_rising)", "Event(Rising(sun))", "Event(Rising(sun))", "Event(rising(sun))", "Event(Rising(sun))", "Event(Rising(sun))", "Event(Rising(sun))", "Event(rises(sun))", "Event(sun_rising)", "Event(Rising(sun))", "Event(sun_rising)", "Event(sun_rising)", "Event(Rising(sun))", "Event(Rising(sun))"]}
{"id": "entailmentbank_validation_2", "nl": "the sun setting is a kind of event.", "fol": "", "prediction": ["Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "Event(sun_setting)", "KindOf(SunSetting, Event)", "Event(sun_setting)", "Event(SunSetting)", "Event(sun_setting)", "Event(sunset)", "Event(sun_setting)", "Event(sun_setting) & KindOf(sun_setting, event)", "Event(sun_setting)"]}
{"id": "entailmentbank_validation_3", "nl": "the sun rising and setting is the event that occurs once per day.", "fol": "", "prediction": ["EventOccurOncePerDay(RisingAndSetting(sun))", "exists e. (Event(e) & Rising(sun, e) & Setting(sun, e) & OccursOncePerDay(e))", "Exists e. (Event(e) & Rises(sun, e) & Sets(sun, e) & OccursOncePerDay(e))", "exists e. (Event(e) & Equals(e, SunRisingAndSetting) & OccursOncePerDay(e))", "Exists e. (Event(e) & Rises(sun, e) & Sets(sun, e) & OccursOncePerDay(e))", "Event(OccursOncePerDay, Rising(sun) & Setting(sun))", "OccursOncePerDay(event) & Rising(sun, event) & Setting(sun, event)", "EventOccursOncePerDay(Rising(sun) & Setting(sun))", "OccursOncePerDay(Rising(sun) & Setting(sun))", "Event(sunrise_sunset) & OccursOncePerDay(sunrise_sunset)", "Exists an event, the sun rising and setting, that occurs once per day. \n\nTo translate the sentence:\n\nFOL Translation:\nexists e. (Event(e) & RisingSun(e) & SettingSun(e) & OccursOncePerDay(e))", "EventOccursOncePerDay(RisingAndSetting(sun))", "exists y. (Event(y) & SunRising(y) & SunSetting(y) & OccursOncePerDay(y))", "Event(sunRisingAndSetting) & OccursOncePerDay(sunRisingAndSetting)", "exists e. (Event(e) & Rising(sun, e) & Setting(sun, e) & OccursOncePerDay(e))", "Rising(sun) & Setting(sun) & OccursOncePerDay(RisingAndSetting(sun))"]}
{"id": "entailmentbank_validation_4", "nl": "a star produces light and heat.", "fol": "", "prediction": ["ProducesLight(star) & ProducesHeat(star)", "Star(s) -> (ProducesLight(s) & ProducesHeat(s))", "Star(x) -> (ProducesLight(x) & ProducesHeat(x))", "ProducesLight(star) & ProducesHeat(star)", "Star(a) -> (ProducesLight(a) & ProducesHeat(a))", "ProducesLight(star) & ProducesHeat(star)", "Star(x) -> (ProducesLight(x) & ProducesHeat(x))", "Star(star) -> (ProducesLight(star) & ProducesHeat(star))", "Star(x) -> (ProducesLight(x) & ProducesHeat(x))", "Star(star) -> (ProducesLight(star) & ProducesHeat(star))", "ProducesLight(star) & ProducesHeat(star)", "Star(x) -> (ProducesLight(x) & ProducesHeat(x))", "Star(x) -> (ProducesLight(x) & ProducesHeat(x))", "Star(star) -> (ProducesLight(star) & ProducesHeat(star))", "Star(star) -> (ProducesLight(star) & ProducesHeat(star))", "`Star(x) -> (ProducesLight(x) & ProducesHeat(x))`"]}
{"id": "entailmentbank_validation_5", "nl": "a source of something emits / produces / generates / provides that something.", "fol": "", "prediction": ["all x. all y. (SourceOf(x, y) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all x y. (SourceOf(x, y) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all x. all y. (SourceOf(x, y) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all x. all y. (SourceOf(x, y) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all x, y. (SourceOf(x, y) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all x all y. (SourceOf(x, y) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all s, t. (SourceOf(s, t) -> (Emits(s, t) | Produces(s, t) | Generates(s, t) | Provides(s, t)))", "all x. all y. (SourceOf(x, y) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all x. all y. (SourceOf(x, y) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all x. all y. ((SourceOf(x, y)) -> (Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y)))", "all x. all y. ((SourceOf(x, y)) -> (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y)))", "all z. all a. ((SourceOf(z, a)) -> (Emits(z, a) & Produces(z, a) & Generates(z, a) & Provides(z, a)))", "all x y. ((SourceOf(x, y) & (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y))) -> y)", "all x, y. (SourceOf(x, y) -> Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y))", "all x, y. (SourceOf(x, y) -> Emits(x, y) & Produces(x, y) & Generates(x, y) & Provides(x, y))", "all x y. ((SourceOf(x, y) & (Emits(x, y) | Produces(x, y) | Generates(x, y) | Provides(x, y))))"]}
{"id": "entailmentbank_validation_6", "nl": "a star is a source of light.", "fol": "", "prediction": ["SourceOfLight(star)", "SourceOfLight(star)", "SourceOfLight(star)", "SourceOfLight(star)", "Star(x) -> SourceOfLight(x)", "SourceOfLight(star)", "all x. (Star(x) -> SourceOfLight(x))", "Star(x) -> SourceOfLight(x)", "Star(x) -> SourceOfLight(x)", "SourceOfLight(star)", "SourceOfLight(star)", "SourceOfLight(star)", "Star(x) -> SourceOfLight(x)", "SourceOfLight(star)", "SourceOfLight(star)", "LightSource(star)"]}
{"id": "entailmentbank_validation_7", "nl": "as the source of light becomes closer, that source of light will appear brighter.", "fol": "", "prediction": ["all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "exists x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "exists x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. ((SourceOfLight(x) & BecomesCloser(x)) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "FOL Translation:\nall x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & Closer(x) -> AppearsBrighter(x))", "all x. ((SourceOfLight(x) & BecomesCloser(x)) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))", "all x. (SourceOfLight(x) & BecomesCloser(x) -> AppearsBrighter(x))"]}
{"id": "entailmentbank_validation_8", "nl": "distance is a property of space and includes ordered values of close / far.", "fol": "", "prediction": ["all x. (PropertyOf(x, space) -> (IncludesOrderedValues(x, close) & IncludesOrderedValues(x, far)))", "exists x. (PropertyOfSpace(distance) & all y. ((Close(y) | Far(y)) -> OrderedValue(y)))", "all x. (Space(x) -> Exists y. (Distance(y) & PropertyOf(y, x) & IncludesOrderedValues(y, close, far)))", "all x. (Space(x) -> PropertyOf(x, Distance) & exists y. (OrderedValue(y) & (y = Close | y = Far)))", "all x. (Distance(x) -> (PropertyOfSpace(x) & OrderedValues(x, close) & OrderedValues(x, far)))", "Property(distance, space) & all x. (OrderedValue(x) -> (x = close | x = far))", "all x. (Space(x) -> exists y. (Property(y) & Distance(y) & PartOf(y, x) & IncludesOrderedValues(y, close, far)))", "all x. (Distance(x) -> PropertyOfSpace(x) & IncludesOrderedValues(x, close, far))", "PropertyOf(distance, space) & all x. (OrderedValue(x) -> (Close(x) | Far(x)))", "all x. (Space(x) -> exists y. (PropertyOf(y, x) & y = distance & IncludesOrderedValues(y, close, far)))", "all x. (Space(x) -> exists y. (Distance(y) & PropertyOf(y, x) & exists z. (OrderedValue(z, close) & PartOf(z, y) & OrderedValue(w, far) & PartOf(w, y))))", "`Property(distance) & all x. (Space(x) -> (HasOrderedValues(distance, [close, far])))`", "exists x. (Property(x) & OfSpace(x) & IncludesOrderedValues(x, close) & IncludesOrderedValues(x, far))", "exists x. (Distance(x) & PropertyOf(x, space) & Includes(x, close) & Includes(x, far))", "all x. (Space(x) -> exists y. (Distance(y) & PropertyOf(y, x) & ContainsOrderedValues(y, close, far)))", "all x. (Space(x) -> exists y. (Distance(y) & PropertyOf(y, x) & OrderedValues(y, close, far)))"]}
{"id": "entailmentbank_validation_9", "nl": "as the distance of the star to earth decreases, the star will appear brighter.", "fol": "", "prediction": ["all x. (Star(x) & DecreasesDistanceToEarth(x) -> AppearsBrighter(x))", "all x. all y. (Star(x) & Earth(y) & DecreasesDistanceTo(x, y) -> AppearsBrighter(x))", "all x y. ((Star(x) & DistanceToEarthDecreases(x, y)) -> AppearsBrighter(x, y))", "all x. ((Star(x) & DecreasesDistanceToEarth(x)) -> AppearsBrighter(x))", "all x. (Star(x) -> (Decreases(Distance(x, earth)) -> AppearsBrighter(x)))", "all x. all y. ((Star(x) & DistanceToEarthDecreases(x)) -> AppearsBrighter(x))", "all x. all y. ((Star(x) & Earth(y) & Decreases(Distance(x, y))) -> AppearsBrighter(x))", "all x. (Star(x) -> (Decreases(DistanceToEarth(x)) -> AppearsBrighter(x)))", "all x. (Star(x) & DecreasesDistanceToEarth(x) -> AppearsBrighter(x))", "all x. all y. ((Star(x) & Earth(y) & DecreasesDistance(x, y)) -> AppearsBrighter(x, y))", "all x. (Star(x) -> (Decreases(DistanceToEarth(x)) -> AppearsBrighter(x)))", "exists x, y. (Star(x) & Earth(y) & Decreases(Distance(x, y)) -> AppearsBrighter(x))", "exists x. (Star(x) & all d1 d2. (DecreasesDistanceToEarth(x, d1, d2) -> AppearsBrighter(x, d2)))", "all x. ((Star(x) & DecreasesDistanceToEarth(x)) -> AppearsBrighter(x))", "all x. ((Star(x) & DecreasesDistanceToEarth(x)) -> AppearsBrighter(x))", "all x. all y. (Star(x) & Earth(y) & Decreases(Distance(x, y)) -> AppearsBrighter(x))"]}
{"id": "entailmentbank_validation_10", "nl": "a star is a kind of celestial object / celestial body.", "fol": "", "prediction": ["all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))", "all x. (Star(x) -> CelestialObject(x))"]}
{"id": "entailmentbank_validation_11", "nl": "apparent magnitude is a measure of the brightness of a celestial object / celestial body as observed on earth.", "fol": "", "prediction": ["MeasureOf(apparent_magnitude, Brightness(celestial_body, observed_on_earth))", "all x. (ApparentMagnitude(x) -> MeasureOf(Brightness(x), CelestialObjectOrBody(x), AsObservedOnEarth))", "Measure(apparent_magnitude, Brightness(celestial_object, ObservedOn(earth)))", "```FOL\nall x. (CelestialObject(x) -> exists y. (ApparentMagnitude(y, x) & ObservedOnEarth(y) & MeasuresBrightness(y, x)))\n```", "all x. (CelestialObject(x) | CelestialBody(x) -> MeasureOf(Brightness(x), ApparentMagnitude) & ObservedOn(Earth, x))", "Measure(apparent_magnitude, Brightness(celestial_object, ObservedOn(earth)))", "all x. (ApparentMagnitude(x) -> MeasureOfBrightness(x) & ObservedOnEarth(x))", "all x. (ApparentMagnitude(x) -> MeasureOfBrightness(x) & ObservedOnEarth(x))", "all x. (ApparentMagnitude(x) -> MeasureOfBrightness(x, CelestialObject(x) & ObservedOnEarth(x)))", "Measure(ApparentMagnitude, Brightness(CelestialObject, ObservedOnEarth))", "all x. ((ApparentMagnitude(x) & MeasureOf(Brightness(y), x)) -> (CelestialObject(y) & ObservedOnEarth(y)))", "all x. (ApparentMagnitude(x) -> MeasureOfBrightness(x) & ObservedOnEarth(x) & CelestialObject(x))", "all x. ((CelestialObject(x) | CelestialBody(x)) -> Measure(ApparentMagnitude, Brightness(x)))", "all x. (ApparentMagnitude(x) -> MeasureOf(Brightness(CelestialObject(x)), ObservedOnEarth))", "all x. (ApparentMagnitude(x) -> MeasureOf(BrightnessOf(x), ObservedOnEarth(x)))", "all x. (CelestialObject(x) -> exists y. (BrightnessMeasure(y, x) & ObservedOnEarth(y)))"]}
{"id": "entailmentbank_validation_12", "nl": "apparent magnitude is a measure of the brightness of a star as observed on earth.", "fol": "", "prediction": ["MeasureOf(apparent_magnitude, BrightnessOfStarAsObservedOnEarth)", "all x. (Star(x) -> exists y. (ApparentMagnitude(y) & MeasuresBrightnessOfStar(y, x) & ObservedOnEarth(y)))", "Measure(apparent_magnitude, lambda s. (Star(s) & ObservedOnEarth(s) & Brightness(s)))", "Measure(apparent_magnitude, brightness_of_star_on_earth)", "Measure(apparent_magnitude, brightness_of_star_as_observed_on_earth)", "all x. (ApparentMagnitude(x) -> exists y. (BrightnessOf(y) & Star(y) & ObservedOn(y, earth)))", "all x. (ApparentMagnitude(x) -> exists y. (Brightness(y) & Star(y) & ObservedOnEarth(y)))", "all s. (Star(s) -> exists m. (ApparentMagnitude(m, s) & MeasuresBrightness(m) & ObservedOnEarth(m)))", "all x. (ApparentMagnitude(x) -> exists y. (Star(y) & MeasureOfBrightness(x, y) & ObservedOnEarth(x)))", "Measure(apparent_magnitude, BrightnessObservability(x, y)) & Star(y) & ObservedOn(earth, y)", "all x. (ApparentMagnitude(x) -> exists y. (Star(y) & BrightnessOfOnEarth(x, y)))", "all x. (ApparentMagnitude(x) -> exists y. (MeasureOfBrightness(y) & Star(y) & ObservedOnEarth(y)))", "MeasureOf(apparent_magnitude, Brightness(star)) & ObservedOn(apparent_magnitude, earth)", "Measure(apparent_magnitude, brightness(star, observed_from(earth)))", "Measure(apparent_magnitude, Brightness(star, ObservedOn(earth)))", "Measure(apparent_magnitude, Brightness(star, ObservedOn(earth)))"]}
{"id": "entailmentbank_validation_13", "nl": "united states is located in the northern hemisphere.", "fol": "", "prediction": ["LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedIn(united_states, northern_hemisphere)", "LocatedIn(us, northern_hemisphere)", "LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedIn(united_states, northern_hemisphere)", "LocatedInNorthernHemisphere(united_states)", "LocatedInNorthernHemisphere(united_states)", "LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedInNorthernHemisphere(united_states)", "LocatedIn(united_states, northern_hemisphere)", "LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedInHemisphere(united_states, northern_hemisphere)", "LocatedInNorthernHemisphere(united_states)", "LocatedIn(united_states, northern_hemisphere)", "LocatedInNorthernHemisphere(united_states)"]}
{"id": "entailmentbank_validation_14", "nl": "new york / new york state is a state located in the united states of america.", "fol": "", "prediction": ["State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, usa)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york_state) & LocatedIn(new_york_state, united_states_of_america)", "State(new_york_state) & LocatedIn(new_york_state, united_states_of_america)", "State(nys) & LocatedIn(nys, usa)", "State(new_york_state) & LocatedIn(new_york_state, united_states_of_america)", "State(new_york) & LocatedIn(new_york, usa)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, usa)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)", "State(new_york) & LocatedIn(new_york, united_states_of_america)"]}
{"id": "entailmentbank_validation_15", "nl": "new york state is located in the northern hemisphere.", "fol": "", "prediction": ["LocatedInHemisphere(nys, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedIn(new_york_state, northern_hemisphere)", "LocatedIn(new_york_state, northern_hemisphere)", "Located(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedIn(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedIn(new_york_state, northern_hemisphere)", "LocatedIn(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedIn(nys, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)", "LocatedInHemisphere(new_york_state, northern_hemisphere)"]}
{"id": "entailmentbank_validation_16", "nl": "december is during the winter in the northern hemisphere.", "fol": "", "prediction": ["During(december, Winter(northern_hemisphere))", "During(december, winter) & InHemisphere(northern_hemisphere, december)", "During(december, winter) & In(northern_hemisphere, winter)", "During(december, Winter) & In(december, NorthernHemisphere)", "OccursDuring(december, winter) & In(northern_hemisphere, winter)", "Winter(december) & InTheNorthernHemisphere(december)", "During(december, winter) & In(northern_hemisphere, winter)", "During(december, winter) & In(northern_hemisphere, winter)", "During(december, winter) & In(northern_hemisphere, december)", "During(december, Winter, NorthernHemisphere)", "During(december, winter) & In(northern_hemisphere)", "Winter(december, northern_hemisphere)", "Winter(december, northern_hemisphere)", "During(december, winter) & In(northern_hemisphere, winter)", "During(december, winter, northern_hemisphere)", "During(december, winter) & In(northern_hemisphere)"]}
{"id": "entailmentbank_validation_17", "nl": "december is during the winter for new york state.", "fol": "", "prediction": ["During(december, winter, new_york_state)", "InWinter(december, new_york_state)", "During(december, Winter) & Location(NewYorkState)", "During(december, Winter(new_york_state))", "During(december, Winter(new_york_state))", "During(december, winter, new_york_state)", "During(december, Winter(new_york_state))", "During(december, winter, new_york_state)", "InWinterIn(december, new_york_state)", "During(december, Winter(new_york_state))", "During(december, Winter) & In(new_york_state, Winter)", "During(december, Winter) & Location(december, NewYorkState)", "During(december, Winter) & Location(new_york_state, Winter)", "During(december, winter, new_york_state)", "During(december, Winter(new_york_state))", "During(december, Winter(new_york_state))"]}
{"id": "entailmentbank_validation_18", "nl": "winter has the least sunlight.", "fol": "", "prediction": ["Winter(winter) -> all x. (Season(x) & x = winter -> LeastSunlight(x))", "HasLeastSunlight(winter)", "HasLeastSunlight(winter)", "HasLeastSunlight(winter)", "Sunlight(winter) = Least", "LeastSunlight(winter)", "HasLeastSunlight(winter)", "LeastSunlight(winter)", "LeastSunlight(winter)", "Winter(w) & LeastSunlight(w)", "`Season(winter) & all y. (Season(y) -> (AmountOfSunlight(winter) <= AmountOfSunlight(y)))`", "HasLeastSunlight(winter)", "LeastSunlight(winter)", "LeastSunlight(winter)", "Winter(winter) & all x. (Season(x) & x != winter -> Sunlight(winter) < Sunlight(x))", "LeastSunlight(winter)"]}
{"id": "entailmentbank_validation_19", "nl": "new york state has the least sunlight during december.", "fol": "", "prediction": ["HasLeastSunlight(new_york_state, december)", "HasLeastSunlight(new_york_state, december)", "LeastSunlightInMonth(new_york_state, december)", "HasLeastSunlight(new_york_state, december)", "HasLeastSunlight(new_york_state, december)", "HasLeastSunlightIn(new_york_state, december)", "Existential quantifier is used for at least one existence in a specific context; however, since the sentence specifies 'least' (a superlative), it is more about a comparison at a specific time period. \n\nSince direct translations for superlatives can be complex and usually require additional constructs, the simplest representation respecting the sentence context with current constraints focuses on that relationship:\n\nFOL Translation: \nSunlightIn(new_york_state, december) = LeastSunlight", "HasLeastSunlightInDecember(new_york_state)", "HasLeastSunlightDuring(new_york_state, december)", "`LeastSunlightIn(new_york_state, december)`", "LeastSunlight(new_york_state, december)", "HasLeastSunlight(new_york_state, december)", "all x. (x = new_york_state & Month(december) -> LeastSunlight(x, december))", "HasLeastSunlight(new_york_state, december)", "HasLeastSunlight(new_york_state, december)", "LeastSunlight(new_york_state, december)"]}
{"id": "entailmentbank_validation_20", "nl": "earth is a kind of planet.", "fol": "", "prediction": ["KindOf(earth, planet)", "Planet(earth)", "KindOf(earth, planet)", "Planet(earth)", "Planet(earth)", "Planet(earth)", "KindOf(earth, planet)", "KindOf(earth, planet)", "Planet(earth)", "Planet(earth)", "Planet(earth)", "Planet(earth)", "KindOf(earth, planet)", "KindOf(earth, planet)", "Planet(earth)", "KindOf(earth, planet)"]}
{"id": "entailmentbank_validation_21", "nl": "the earth rotates on its tilted axis.", "fol": "", "prediction": ["RotateOnTiltedAxis(earth)", "Rotates(earth, tilted_axis)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)", "Rotates(earth, tilted_axis_of_earth)", "RotatesOnTiltedAxis(earth)", "RotatesOnTiltedAxis(earth)"]}
{"id": "entailmentbank_validation_22", "nl": "earth is a planet that rotates on its tilted axis.", "fol": "", "prediction": ["Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & Rotates(earth) & HasTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth)"]}
{"id": "entailmentbank_validation_23", "nl": "rotation is the circular movement of an object around a center / axis.", "fol": "", "prediction": ["all x. (Rotation(x) -> CircularMovement(x) & MovementAroundCenterOrAxis(x))", "all x. (Rotation(x) -> CircularMovement(x) & exists y. (CenterOrAxis(y) & MovesAround(x, y)))", "exists x exists y. (Rotation(x) & Object(y) & CircularMovement(x, y) & AroundCenterOrAxis(x, y))", "all x. (Rotation(x) -> exists y. (CircularMovement(x) & Object(x) & CenterOrAxis(y) & MovesAround(x, y)))", "all x. (Rotation(x) -> CircularMovement(x) & exists y. (Object(y) & CenterOrAxis(y)))", "all x. (Rotation(x) -> CircularMovement(x) & exists y. (Center(y) | Axis(y) & MovesAround(x, y)))", "all x. (Rotation(x) -> exists y. (CircularMovementAround(x, y) & (Center(y) | Axis(y))))", "all x. (Rotation(x) -> CircularMovement(x) & exists y. (Object(y) & CenterOrAxis(y)))", "all x. ((Rotation(x) & Object(x)) -> exists y. (Center(y) | Axis(y) & CircularMovementAround(x, y)))", "all x. (Rotation(x) -> exists y. (Object(y) & CenterOrAxis(z) & CircularMovementAround(y, z)))", "all x. (Rotation(x) -> CircularMovement(x) & exists y. (Object(x) & CenterOrAxis(y) & MovesAround(x, y)))", "all x. (Rotation(x) -> (CircularMovement(x) & exists y. (CenterOrAxis(y) & MovesAround(x, y))))", "all x. (Rotation(x) -> Exists y. (CenterOrAxis(y) & CircularMovementAround(x, y)))", "all x. (Rotation(x) -> exists y. (CircularMovement(y) & Object(x) & CenterOrAxis(y, x)))", "all x. (Rotation(x) -> exists y. (CircularMovement(x) & Object(x) & Around(x, y) & (Center(y) | Axis(y))))", "all x. ((Rotation(x) & CircularMovement(x)) -> exists y. (CenterOrAxis(y) & MovesAround(x, y)))"]}
{"id": "entailmentbank_validation_24", "nl": "a planet rotating causes cycles of day and night on that planet.", "fol": "", "prediction": ["all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(CyclesOfDayAndNight(x), x))", "all x. (Planet(x) & Rotating(x) -> Causes(CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(CyclesOfDayAndNight(x), x))", "all x. (Planet(x) & Rotates(x) -> Causes(CyclesOfDayAndNight(x), x))", "all x. (Planet(x) & Rotates(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotates(x) -> Causes(Rotation(x), DayNightCycles(x)))", "all x. (Planet(x) & Rotates(x) -> Causes(Rotating(x), DayNightCycles(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), DayNightCycles(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(CyclesOfDayAndNight(x), x))", "all x. (Planet(x) & Rotates(x) -> Causes(CyclesOfDayAndNight(x), Rotating(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotates(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))", "all x. (Planet(x) & Rotating(x) -> Causes(Rotating(x), CyclesOfDayAndNight(x)))"]}
{"id": "entailmentbank_validation_25", "nl": "earth rotating on its axis causes the cycle of day and night on earth.", "fol": "", "prediction": ["FOL Translation:\nCauses(RotationOnAxis(earth), DayNightCycle(earth))", "Causes(RotatingOnAxis(earth), CycleOfDayAndNight(earth))", "RotatesOnAxis(earth) -> Causes(CycleOfDayAndNight(earth))", "Causes(RotatingOnAxis(earth), CycleOfDayAndNight(earth))", "CycleOfDayAndNight(earth) <-> RotatesOnAxis(earth)", "Rotates(earth, axis_earth) -> Causes(CycleOfDayAndNight(earth))", "RotateOnAxis(earth) -> Causes(DayNightCycle(earth))", "Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "Causes(RotatesOnAxis(earth), CycleOfDayAndNight(earth))", "Causes(RotatesOnAxis(earth), DayNightCycle(earth))", "Causes(RotatingOnAxis(earth), CycleOfDayAndNight(earth))", "FOL Translation:\nRotates(earth, axis) -> Causes(CycleOfDayAndNight, earth)", "RotatesOnAxis(earth) -> Causes(CycleOfDayAndNight(earth))", "Causes(Rotating(earth), CycleOfDayAndNight(earth))", "Causes(RotatingOnAxis(earth), DayAndNightCycle(earth))"]}
{"id": "entailmentbank_validation_26", "nl": "gradens contain plants.", "fol": "", "prediction": ["all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))", "all x. (Garden(x) -> exists y. (Plant(y) & Contains(x, y)))"]}
{"id": "entailmentbank_validation_27", "nl": "gardens are located outside.", "fol": "", "prediction": ["all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))", "all x. (Garden(x) -> LocatedOutside(x))"]}
{"id": "entailmentbank_validation_28", "nl": "the plants in the gardens are located outside.", "fol": "", "prediction": ["all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. ((Plant(x) & InGarden(x)) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (PlantInGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. ((Plant(x) & InGarden(x)) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))", "all x. (Plant(x) & InGarden(x) -> LocatedOutside(x))"]}
{"id": "entailmentbank_validation_29", "nl": "if something is outside during the day then that something will receive sunlight.", "fol": "", "prediction": ["all z. (OutsideDuringDay(z) -> ReceivesSunlight(z))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. ((Outside(x) & Daytime) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. (Outside(x, day) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. ((OutsideDuringDay(x)) -> ReceivesSunlight(x))", "all x. ((Outside(x) & DuringDay(x)) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. ((OutsideDuringDay(x)) -> ReceivesSunlight(x))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))", "all x. ((OutsideDuringDay(x) -> ReceivesSunlight(x)))", "all x. (OutsideDuringDay(x) -> ReceivesSunlight(x))"]}
{"id": "entailmentbank_validation_30", "nl": "the plants in the gardens will receive sunlight during the day.", "fol": "", "prediction": ["all x. (Plant(x) & InGarden(x) -> ReceivesSunlight(x) & During(x, day))", "all x. (InGarden(x) -> (Plant(x) -> ReceivesSunlightDuringDay(x)))", "exists x, y. (Garden(y) & Plant(x) & In(y, x) -> all t. (DuringDay(t) -> ReceivesSunlight(x, t)))", "all x. (Plant(x) & InGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (PlantInGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. ((Plant(x) & InGarden(x)) -> ReceivesSunlightDuringDay(x))", "all x. ((Plant(x) & InGarden(x)) -> (all y. (Garden(y) & In(y, x) -> exists t. (DayTime(t) & ReceivesSunlight(x, t)))))", "all x. (Plant(x) & InGarden(x) -> WillReceiveSunlightDuringDay(x))", "all x. (Plant(x) & InGarden(x) -> ReceivesSunlight(x, during_the_day))", "all x. (PlantInGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (Plant(x) & InGarden(x) -> WillReceiveSunlightDuringDay(x))", "all x. (Plant(x) & InGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (PlantInGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (Plant(x) & InGarden(x) -> ReceivesSunlightDuringDay(x))", "all x. (PlantInGarden(x) -> ReceivesSunlightDuringTheDay(x))", "all x. ((Plant(x) & InGarden(x)) -> exists y. (Sunlight(y) & ReceivedBy(x, y) & DuringDay(y)))"]}
{"id": "entailmentbank_validation_31", "nl": "a plant requires sunlight to grow.", "fol": "", "prediction": ["all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> (RequiresSunlight(x) -> Grow(x)))", "all x. (Plant(x) -> (RequiresSunlight(x) & CanGrow(x)))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> (RequiresSunlight(x) -> CanGrow(x)))", "all x. (Plant(x) -> (Requires(x, sunlight) & CanGrow(x) -> Requires(x, sunlight)))", "all x. (Plant(x) -> (RequiresSunlight(x) -> CanGrow(x)))", "all x. (Plant(x) -> RequiresSunlightToGrow(x))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> (Requires(x, sunlight) & NeedsForGrowth(x, sunlight)))", "all x. (Plant(x) -> (Requires(x, sunlight) & ToGrow(x)))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))", "all x. (Plant(x) -> RequiresSunlightToGrow(x))", "all x. (Plant(x) -> (RequiresSunlightToGrow(x)))"]}
{"id": "entailmentbank_validation_32", "nl": "the plants in the gardens will receive sunlight to grow during the day.", "fol": "", "prediction": ["all x. ((Plant(x) & InGarden(x)) -> (DuringDay(y, Garden(x)) & WillReceiveSunlight(x) & CanGrow(x)))", "exists x, y. (Plant(x) & InGarden(x, y) & Garden(y) -> (Daytime(t) & ReceivesSunlight(x, t) & Grows(x, t)))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & CanGrow(x) & During(y, day)))", "all x. ((Plant(x) & InGarden(x)) -> all y. (Sunlight(y) & DuringDay(y) -> ReceiveSunlightToGrow(x, y)))", "all x. ((Plant(x) & InGarden(x)) -> exists y. (Sunlight(y) & Receives(x, y) & ToGrow(x) & During(y, day)))", "all x. ((Plant(x) & InGarden(x)) -> (exists y. (Sunlight(y) & Receives(x, y) & (Day(z) -> Grow(x)))))", "exists g. (Garden(g) & exists p. (Plant(p) & In(g, p) -> all t. (Time(t) & DuringDay(t) -> (ReceivesSunlight(p, t) & CanGrow(p, t)))))", "exists x. (Garden(x) & all y. (Plant(y) & In(x, y) -> (ReceiveSunlight(y) & Grow(y) & DuringDay(y))))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & ToGrow(x) & DuringDay(y)))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & CanGrow(x) & During(y, day)))", "FOL Translation:\nall x. (Plant(x) & InGarden(x) -> exists y. (Sun(y) & ReceivesSunlight(x, y) & CanGrowDuringDay(x)))", "all x. (Plant(x) & InGarden(x) -> exists y. (Sunlight(y) & Receives(x, y) & ToGrow(x) & DuringDay(y)))", "all x. (PlantInGarden(x) -> (exists y. (Sunlight(y) & Receives(x, y) & DuringDay(y) & CanGrow(x))))", "all x. ((Plant(x) & InGarden(x)) -> (ReceivesSunlight(x, day) & CanGrow(x, day)))", "all x. (Plant(x) & InGarden(x) -> (exists y. (Sunlight(y) & Receives(x, y) & DuringDaytime(y))) & CanGrow(x))", "all x. ((Plant(x) & InGarden(x)) -> exists y. (Sunlight(y) & Receives(x, y) & ToGrow(x) & DuringDay(x)))"]}
{"id": "entailmentbank_validation_33", "nl": "summer has the most sunlight.", "fol": "", "prediction": ["HasMostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "all t. (Season(t) & HasMostSunlight(t) <-> t = summer)", "MostSunlight(summer)", "HasMostSunlight(summer)", "HasMostSunlight(summer)", "HasMostSunlight(summer)", "HasMostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "MostSunlight(summer)", "Summer(summer) & all x. ((Season(x) & x \u2260 summer) -> HasMoreSunlight(summer, x))"]}
{"id": "entailmentbank_validation_34", "nl": "the plants in the gardens will receive the most sunlight in summer to grow during the day.", "fol": "", "prediction": ["exists x. exists y. (Plant(x) & InGarden(x, y) & Garden(y) & InSummer(x) & ReceivesMostSunlight(x) & ToGrowDuringDay(x))", "exists x, y, z. (Plant(x) & Garden(y) & In(y, z) & ReceiveMostSunlight(x, z) & Summer(z) & GrowDuringDay(x, z))", "exists x. (GardenPlants(x) & all y. (Garden(y) & In(x, y) & ReceivesMostSunlightInSummer(x) & GrowsDuringTheDay(x)))", "all x. ((Plant(x) & InGarden(x)) -> (Summer -> (ReceiveMostSunlight(x) & GrowsDuringDay(x))))", "exists g. exists p. (Garden(g) & PlantIn(p, g) -> ReceivesMostSunlightInSummer(p) & GrowsDuringDay(p))", "all x. (Plant(x) & InGarden(x) -> (InSummer & ReceivesMostSunlight(x) & GrowsDuringDay(x)))", "exists x. (Plant(x) & InGarden(x) -> exists y. (Summer(y) & ReceivesMostSunlight(x, y) & all z. (Day(z) & Grows(x, z))))", "exists x, y. (Plant(x) & Garden(y) & LocatedIn(x, y) -> all z. (Summer(z) -> ReceivesMostSunlight(x, z) & CanGrowDuringDay(x, z)))", "exists x. (Plant(x) & InGarden(x) & (Season(summer) & ReceivesMostSunlightInDay(x, summer) -> GrowsDuringDay(x)))", "all x. ((Plant(x) & InGarden(x) & InSummer(daytime)) -> ReceivesMostSunlight(x, daytime) & Grows(x, daytime))", "all x. ((Plant(x) & LocatedInGarden(x)) -> (ReceivesMostSunlightInSummer(x) & GrowsDuringDay(x)))", "exists x, y. (Plant(x) & Garden(y) & In(x, y) -> (Season(summer) & MostSunlightDuringDay(x) & GrowsDuringDay(x)))", "all x. (Plant(x) & InGardens(x) -> (exists y. (Summer(y) & ReceivesMostSunlightDuringDay(x, y) & GrowDuringDay(x))))", "exists x. (Garden(x) & all y. (PlantInGarden(y, x) -> (Summer -> (ReceivesSunlight(y) & ToGrowDuringTheDay(y)))))", "all x. ((Plant(x) & InGarden(x)) -> exists y. (Summer(y) & ReceivesMostSunlight(x, y) & DuringTheDay(y) & Grows(x, y)))", "exists x. (Plant(x) & InGarden(x) -> all y. (Garden(y) & In(x, y) -> all t. (Summer(t) & Daytime(t) -> ReceivesMostSunlight(x, t) & Grows(x, t))))"]}
{"id": "entailmentbank_validation_35", "nl": "andy lives in southern hemisphere.", "fol": "", "prediction": ["LivesIn(andy, southern_hemisphere)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesIn(andy, southern_hemisphere)", "LivesInHemisphere(andy, southern)", "LivesInSouthernHemisphere(andy)", "LivesIn(andy, southern_hemisphere)", "LivesInHemisphere(andy, southern)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInSouthernHemisphere(andy)", "LivesInHemisphere(andy, southern)"]}
{"id": "entailmentbank_validation_36", "nl": "it is august.", "fol": "", "prediction": ["August(it_is)", "August()", "Month(august)", "August(now)", "August(now)", "August(month).", "Month(august)", "Month(august)", "August(august)", "Month(august)", "August(august)", "August(august)", "August(it_is_august)", "Month(august)", "Month(august)", "August(august)"]}
{"id": "entailmentbank_validation_37", "nl": "august is during the winter in the southern hemisphere.", "fol": "", "prediction": ["During(august, Winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, Winter, southern_hemisphere)", "During(august, Winter) & Location(august, SouthernHemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "During(august, winter, southern_hemisphere)", "WinterIn(australia)", "During(august, winter, southern_hemisphere)", "During(august, winter) & In(southern_hemisphere, august)"]}
{"id": "entailmentbank_validation_38", "nl": "andy will experience winter in southern hemisphere in august.", "fol": "", "prediction": ["ExperienceWinterIn(andy, southern_hemisphere, august)", "", "Experience(andy, winter, southern_hemisphere, august)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperiencesWinterInMonth(andy, southern_hemisphere, august)", "ExperienceWinterInSouthernHemisphereInAugust(andy)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperiencesWinter(andy, southern_hemisphere, august)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperienceWinterInAugustInSouthernHemisphere(andy)", "ExperienceWinter(andy, southern_hemisphere, august)", "ExperiencesWinter(andy, southern_hemisphere, august)", "ExperiencesWinterInAugust(andy, southern_hemisphere)", "ExperienceWinter(andy, southern_hemisphere, august)"]}
{"id": "entailmentbank_validation_39", "nl": "the sun is a kind of star.", "fol": "", "prediction": ["Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)", "Star(sun)"]}
{"id": "entailmentbank_validation_40", "nl": "the earth revolves around the sun.", "fol": "", "prediction": ["Revolves(earth, sun)", "Revolves(earth, sun)", "Revolves(earth, sun)", "RevolvesAround(earth, sun)", "RevolvesAround(earth, sun)", "RevolvesAround(earth, sun)", "Revolves(earth, sun)", "RevolvesAround(earth, sun)", "RevolvesAround(earth, sun)", "Revolves(earth, sun)", "Revolves(earth, sun)", "RevolvesAround(earth, sun)", "Revolves(earth, sun)", "Revolves(earth, sun)", "Revolves(earth, sun)", "RevolvesAround(earth, sun)"]}
{"id": "entailmentbank_validation_41", "nl": "earth revolving the sun is an example of a planet revolving around its star.", "fol": "", "prediction": ["Example(earth, Revolving(earth, sun)) & Planet(earth) & Orbits(earth, sun) & Star(sun)", "AnExampleOf(Revolves(earth, sun), all x. (Planet(x) & Revolves(x, StarOf(x))))", "Example(PlanetRevolvesAroundStar(earth, sun), RevolvesAroundItsStar(earth, sun))", "Revolves(earth, sun) & ExampleOf(Revolves(earth, sun), all x. (Planet(x) -> exists y. (Star(y) & Revolves(x, y))))", "Revolves(earth, sun) & Planet(earth) & Star(sun) & Example(Revolves(earth, sun), all x y. (Planet(x) & Star(y) & Revolves(x, y)))", "Example(earth_revolves_sun, planet_revolves_star) & Revolves(earth, sun) & Planet(earth) & Star(sun) & all x y. (Revolves(x, y) & Planet(x) & Star(y) -> planet_revolves_star)", "Example(earth, sun, PlanetRevolvingAroundStar) & Revolves(earth, sun) & Planet(earth) & Star(sun)", "Example(earth, Revolves(earth, sun), Planet(earth) & RevolvesAround(earth, sun) & Star(sun))", "IsExample(Revolves(earth, sun), exists x exists y. (Planet(x) & Star(y) & Revolves(x, y)))", "Revolves(earth, sun) & ExampleOf(Revolves(earth, sun), exists x exists y. (Planet(x) & Star(y) & RevolvingAround(x, y)))", "Example(PlanetRevolvingAroundStar(earth, sun), Revolving(earth, sun)) & Revolving(earth, sun) & Planet(earth) & Star(sun)", "Example(earth, sun, (PlanetRevolvesAroundStar(x, y) & Planet(x) & Star(y)))", "Example(earthRevolvingSun, PlanetRevolvingStar) & Planet(earth) & Star(sun) & Revolves(earth, sun)", "Revolves(earth, sun) & ExampleOf(Revolves(earth, sun), exists x exists y. (Planet(x) & Star(y) & Revolves(x, y)))", "ExampleOf(Revolve(earth, sun), exists x exists y. (Planet(x) & Star(y) & Revolve(x, y)))", "Revolves(earth, sun) & Planet(earth) & Star(sun) & all x all y. ((Planet(x) & Star(y) & Revolves(x, y)) -> Example(Revolves(earth, sun), Revolves(x, y)))"]}
{"id": "entailmentbank_validation_42", "nl": "a complete revolution / orbit of a planet around its star takes 1 / one planetary year.", "fol": "", "prediction": ["all x. (Planet(x) -> exists y. (Star(y) & Orbits(x, y) -> CompleteRevolutionTakes(x, y, one_planetary_year)))", "exists x exists y. (Planet(x) & Star(y) & Orbits(x, y) -> RevolutionTime(x, y) = planetary_year)", "all x, y. ((Planet(x) & Orbits(x, y) & Star(y)) -> TakesCompleteRevolution(x, y, one_planetary_year))", "all x. (Planet(x) -> (exists y. (Star(y) & Orbits(x, y) & RevolutionTime(x, y) = OnePlanetaryYear)))", "all x. all y. ((Planet(x) & Star(y) & Orbits(x, y)) -> (RevolutionTime(x, y) = one_planetary_year))", "all x. (all y. (Orbits(x, y) & Star(y) & Planet(x) -> TakesOnePlanetaryYear(Revolution(x, y))))", "all x. (Planet(x) -> (exists y. (Star(y) & Orbits(x, y) & RevolutionTakesOneYear(x, y))))", "all x. all y. ((Planet(x) & Star(y) & Orbits(x, y)) -> RevolutionDuration(x, y) = PlanetaryYear(x, y))", "all x. all y. ((Planet(x) & Star(y) & Orbits(x, y)) -> RevolutionDuration(x, y) = OnePlanetaryYear)", "all x. (exists y. (Planet(x) & Star(y) & Orbits(x, y)) -> RevolutionTime(x, y) = PlanetaryYear(x))", "all x. (Planet(x) -> exists y. (Star(y) & Orbits(x, y) & CompleteRevolutionTakes(x, y, one_planetary_year)))", "all x. ((Planet(x) & exists y. (Star(y) & Orbits(x, y))) -> RevolutionTakesOneYear(x, y))", "all x y. ((Planet(x) & Star(y) & Orbits(x, y)) -> TakesCompleteRevolutionAround(x, y, one_planetary_year))", "all x, y. ((Planet(x) & Star(y) & Orbits(x, y)) -> CompleteRevolutionTakesOneYear(x, y))", "all x. all y. ((Planet(x) & Star(y) & Orbits(x, y)) -> TakesCompleteRevolution(x, y, one_planetary_year))", "all x. (Planet(x) -> exists y. (Star(y) & Orbits(x, y) & TakesCompleteRevolution(x, y, planetary_year(x))))"]}
{"id": "entailmentbank_validation_43", "nl": "a complete revolution of earth around the sun takes an earth year.", "fol": "", "prediction": ["CompleteRevolution(earth, sun, earth_year)", "exists x. exists y. (CompleteRevolutionAround(x, y, earth, sun) & TimeTaken(x, y, earth_year))", "CompleteRevolution(earth, sun, year)", "exists x. (Revolution(x) & CompletesEarthAround(sun, x) & Takes(x, earthYear))", "Revolution(earth, sun) & Complete(Revolution(earth, sun)) -> Takes(Revolution(earth, sun), earth_year)", "CompleteRevolution(earth, sun) -> TakesTime(EarthYear(earth))", "A complete revolution of Earth around the Sun is defined by Earth completing one orbital cycle or path around the Sun, which is conventionally known as an \"Earth year\". Here\u2019s how this can be translated into first-order logic:\n\nFOL Translation:\nCompleteRevolution(earth, sun, earthYear) & Takes(oneCompleteRevolution(earth, sun), earthYear).", "CompleteRevolution(earth, sun, earth_year)", "RevolutionComplete(earth, sun, earth_year)", "exists x. (Revolution(x) & Completes(x, earth, sun) & Takes(x, earthYear))", "Takes(CompleteRevolution(earth, sun), earth_year)", "A complete revolution of Earth around the Sun takes an Earth year.\n\nFOL Translation:\nCompleteRevolution(earth, sun) -> TakesTime(earth_year)", "CompleteRevolution(earth, sun, earth_year)", "Exists x, Exists y, ((Earth(x) & Sun(y)) & CompletesRevolutionIn(x, y, earth_year))", "Exists e, s. (Earth(e) & Sun(s) & RevolutionAround(e, s) -> TakesTime(e, s, EarthYear))", "CompleteRevolution(earth, around, sun, earth_year)"]}
{"id": "entailmentbank_validation_44", "nl": "earth rotating on its tilted axis occurs once per day.", "fol": "", "prediction": ["OccursOncePerDay(Rotating(earth, TiltedAxis(earth)))", "OccursOncePerDay(RotatingOnTiltedAxis(earth))", "OccursOncePerDay(RotatingOnTiltedAxis(earth))", "RotatesOnTiltedAxisOncePerDay(earth)", "OccursOncePerDay(RotatingOnTiltedAxis(earth))", "RotatesOnTiltedAxis(earth) & OccursOncePerDay(RotatesOnTiltedAxis(earth))", "OccursOncePerDay(EarthRotatingOnTiltedAxis(earth))", "OccursOncePerDay(rotatingOnTiltedAxis(earth))", "OccursOncePerDay(RotateOnTiltedAxis(earth))", "OccursOncePerDay(Rotating(earth, TiltedAxis(earth)))", "OccursOncePerDay(RotatingOnTiltedAxis(earth))", "OccursOncePerDay(EarthRotatingOnTiltedAxis(earth))", "OccursOncePerDay(events(EarthRotatesOnTiltedAxis, earth))", "`OccursOncePerDay(RotatesOnTiltedAxis(earth))`", "OccursOncePerDay(RotatingOnTiltedAxis(earth))", "OccursOncePerDay(EarthRotatingOnTiltedAxis(earth))"]}
{"id": "entailmentbank_validation_45", "nl": "the earth is a planet that rotates on its tilted axis once per day.", "fol": "", "prediction": ["Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & CompletesRotationPerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxisOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)", "Planet(earth) & RotatesOnTiltedAxis(earth) & RotatesOncePerDay(earth)"]}
{"id": "entailmentbank_validation_46", "nl": "the earth rotating on its tilted axis causes the cycles of day and night on earth.", "fol": "", "prediction": ["Causes(RotatingOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "Causes(RotatesOnTiltedAxis(earth), DayNightCycles(earth))", "Causes(RotationOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "Causes(RotatingOnTiltedAxis(earth), DayNightCycles(earth))", "RotatingOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "Cause(RotateOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CycleOfDayAndNight(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "Causes(RotatingOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "Causes(RotatesOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "RotatesOnTiltedAxis(earth) -> Causes(CyclesOfDayAndNight(earth))", "Causes(RotatingOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "Causes(RotatingOnTiltedAxis(earth), CyclesOfDayAndNight(earth))", "Causes(RotatesOnTiltedAxis(earth), DayNightCycles(earth))"]}
{"id": "entailmentbank_validation_47", "nl": "mercury is located in the solar system.", "fol": "", "prediction": ["LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)", "LocatedIn(mercury, solar_system)"]}
{"id": "entailmentbank_validation_48", "nl": "mercury is a kind of planet.", "fol": "", "prediction": ["Planet(mercury)", "Planet(mercury)", "Planet(mercury)", "Planet(mercury)", "KindOf(mercury, planet)", "KindOf(mercury, planet)", "Planet(mercury)", "Planet(mercury)", "Planet(mercury)", "KindOf(mercury, planet)", "Planet(mercury)", "KindOf(mercury, planet)", "KindOf(mercury, planet)", "Planet(mercury)", "Planet(mercury)", "Planet(mercury)"]}
{"id": "entailmentbank_validation_49", "nl": "mercury is a planet in the solar system.", "fol": "", "prediction": ["Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)", "Planet(mercury) & InSolarSystem(mercury)"]}
{"id": "entailmentbank_validation_50", "nl": "planets in the solar system orbit the sun.", "fol": "", "prediction": ["all x. (PlanetInSolarSystem(x) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. (PlanetInSolarSystem(x) -> Orbits(x, sun))", "all x. ((Planet(x) & InSolarSystem(x)) -> Orbits(x, sun))", "all x. (Planet(x) & InSolarSystem(x) -> Orbits(x, sun))"]}
{"id": "entailmentbank_validation_51", "nl": "mercury is a planet orbits the sun in the solar system.", "fol": "", "prediction": ["Planet(mercury) & Star(sun) & SolarSystem(solar_system) & Orbits(mercury, sun) & In(sun, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & In(sun, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & In(solar_system, sun)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & In(sun, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & In(mercury, solar_system)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(sun)", "Planet(mercury) & Orbits(mercury, sun) & InSolarSystem(mercury) & InSolarSystem(sun)"]}
{"id": "entailmentbank_validation_52", "nl": "a complete orbit of mercury around the sun takes one mercury year.", "fol": "", "prediction": ["CompleteOrbit(mercury, sun, one_mercury_year)", "TakesOneMercuryYear(CompleteOrbit(mercury, sun))", "CompleteOrbit(mercury, sun, one_mercury_year)", "CompleteOrbit(mercury, sun, mercury_year)", "FOL Translation:\nCompleteOrbit(mercury, sun) & Takes(mercury_orbit, mercury_year)", "Takes(MakeCompleteOrbit(mercury, sun), Duration(OneMercuryYear))", "TakesOneMercuryYear(CompleteOrbit(mercury, sun))", "CompleteOrbit(mercury, sun) & Takes(mercury, Orbit(mercury, sun), mercury_year)", "OrbitComplete(mercury, sun) -> TakesTime(mercury, one_mercury_year)", "CompleteOrbit(mercury, sun, mercury_year)", "CompleteOrbit(mercury, sun) & Takes(mercury, one_mercury_year)", "CompleteOrbit(mercury, sun) & TakesTime(mercury, mercuryYear)", "CompleteOrbit(mercury, sun, mercury_year)", "Exists y. (Orbit(orbit_of_mercury, y) & Completes(orbit_of_mercury, mercury_year) & Around(orbit_of_mercury, sun))", "Existential quantification can't be used for a complete determination in this sentence. Here, the predicate will assert the described condition about Mercury and its orbital period:\n\nFOL Translation:\nCompleteOrbit(mercury, sun, mercury_year)", "Orbit(mercury, sun, mercury_year)"]}
{"id": "entailmentbank_validation_53", "nl": "one mercury year is about 88 earth days.", "fol": "", "prediction": ["YearDuration(mercury, approx_88_earth_days)", "LengthOfYear(mercury, 88 * earth_day)", "DurationOfYear(mercury, days_88) & Approximate(days_88, days_88_earth) & EarthDays(days_88_earth, 88)", "Year(mercury) = Days(88, earth)", "DaysInYear(mercury, 88) & Unit(earth, day)", "Length(MercuryYear, 88Days)", "OneYear(mercury) = About(EightyEightDays(earth))", "Exists x, y. (Mercury(x) & Year(x) & Earth(y) & Day(y) & AboutEquals(Duration(x), 88 * Duration(y)))", "Year(mercury) = 88 * Day(earth)", "OneTranslation(applicable_no=1=one; imperative_degree=exact_original=Expanded,Note_on_unqualified_Execution_item='default_mercury')", "Year(mercury, 88, earth_days)", "Year(mercury) = About88Days(earth)", "Exists x. (MercuryYear(x) & AboutEqualToLengthOf(x, 88Days))", "One way to express this sentence in first-order logic is by representing the relationship between a mercury year and earth days with a predicate. We'll use `OneMercuryYear(x)` to represent a mercury year and `EarthDays(y)` to represent earth days. We can use an equality relation to relate their quantities:\n\nFOL Translation:\nOneMercuryYear(mercury_year) = EarthDays(eighty_eight)", "Duration(mercury_year, earth_day) = 88", "OneMercuryYear(mercury_year) & EarthDays(duration_88_days) & AboutEqual(mercury_year, duration_88_days)"]}
{"id": "entailmentbank_validation_54", "nl": "a complete orbit of mercury around the sun takes around 88 earth days.", "fol": "", "prediction": ["OrbitCompleteTime(mercury, sun, 88)", "CompleteOrbit(mercury, sun, 88)", "Exists x. (Orbit(x) & Object(x, mercury) & Center(x, sun) & Duration(x, 88))", "OrbitComplete(mercury, sun) & TakesTime(mercury, orbit, 88, earth_days)", "OrbitPeriod(mercury, sun, 88)", "OrbitPeriod(mercury, sun, 88_earth_days)", "CompleteOrbit(mercury, sun, 88)", "Exists x. (Orbit(x, mercury, sun) & TakesDays(x, 88))", "TakesCompleteOrbit(mercury, sun, 88_earth_days)", "CompleteOrbit(mercury, sun) & TimeTaken(mercury, 88, earth_days)", "CompleteOrbitDuration(mercury, sun, 88_days)", "FOL Translation:\nTakesCompleteOrbit(mercury, sun, 88_earth_days)", "OrbitCompleteTime(mercury, sun, 88_earth_days)", "Exists x. (Orbit(x, mercury, sun) & CompleteOrbit(x) & Takes(x, 88, earth_days))", "Exists x. (OrbitCompletes(mercury, sun, x) & ApproximatelyEqual(x, 88_days))", "OrbitComplete(mercury, sun, 88)"]}
{"id": "entailmentbank_validation_55", "nl": "the new moon is when the dark half of the moon faces the earth.", "fol": "", "prediction": ["NewMoon(new_moon) <-> FacesDarkHalf(new_moon, earth)", "NewMoonOccursWhen(x) <-> (Moon(x) & DarkHalfFacesEarth(x))", "NewMoon(x) <-> (DarkHalfMoon(y) & Faces(y, earth))", "NewMoon(new_moon) <-> (DarkHalf(moon) & Faces(moon, earth))", "NewMoon(new_moon) <-> FacesDarkHalf(earth, new_moon)", "NewMoon(x) <-> (DarkHalfOfMoonFacingEarth(x))", "NewMoon(the_new_moon) <-> FacesDarkHalfOfMoon(the_new_moon, earth)", "NewMoon(new_moon) <-> (DarkHalfOfMoon(dark_half_of_moon) & Faces(dark_half_of_moon, earth))", "NewMoon(x) <-> (DarkHalfOfMoon(x) & Faces(x, earth))", "NewMoon(when(DarkHalfFacing(moon, earth)))", "NewMoon(new_moon) <-> DarkHalf(moon) & Faces(DarkHalf(moon), earth)", "NewMoon(t) <-> (DarkHalf(moon) & Faces(moon, earth, t))", "NewMoon(x) <-> (DarkHalfMoon(x) & Faces(x, earth))", "NewMoon(t) <-> DarkHalfOfMoonFacesEarth(t)", "NewMoon(moon) <-> DarkHalf(moon) & Faces(moon, earth)", "NewMoon(new_moon) <-> FacesDarkHalf(moon, earth)"]}
{"id": "entailmentbank_validation_56", "nl": "the new moon is when the moon is in between the sun and the earth.", "fol": "", "prediction": ["NewMoon(new_moon) <-> (Moon(new_moon) & Between(new_moon, sun, earth))", "NewMoon(x) <-> (Moon(x) & exists y z. (Sun(y) & Earth(z) & Between(x, y, z)))", "all z. (NewMoon(z) <-> (Moon(z) & Between(z, sun, earth)))", "NewMoon(moon) <-> Between(moon, sun, earth)", "NewMoon(moon) <-> Between(moon, sun, earth)", "Moon(new_moon) & Position(new_moon, between(sun, earth))", "NewMoon(x) <-> (Moon(x) & InBetween(x, sun, earth))", "NewMoon(x) <-> (Moon(x) & exists y. (Sun(y) & exists z. (Earth(z) & Between(x, y, z))))", "FOL Translation:\nall x. (NewMoon(x) <-> (Moon(x) & Between(x, sun, earth)))", "Exists m. ((NewMoon(m) <-> (Moon(m) & InBetween(m, sun, earth))))", "exists z. (NewMoon(z) <-> (Moon(z) & InBetween(z, sun, earth)))", "FOL Translation:\nNewMoon(x) <-> (Between(x, sun, earth) & Moon(x))", "NewMoon(x) <-> (Moon(x) & Exists(y; z). (Sun(y) & Earth(z) & Between(x, y, z)))", "NewMoon(new_moon) <-> (Between(moon, sun, earth))", "NewMoon(x) <-> (Moon(x) & InBetween(x, sun, earth))", "NewMoon(moon) <-> (Between(moon, sun, earth))"]}
{"id": "entailmentbank_validation_57", "nl": "the new moon is when the moon could block the earth from the sun.", "fol": "", "prediction": ["NewMoon(x) <-> (Moon(x) & CanBlock(x, earth, sun))", "NewMoon(x) <-> (exists y. (Moon(y) & CanBlock(y, earth, sun)))", "NewMoon(x) <-> BlockFromSunToEarth(moon, sun, earth)", "NewMoon(x) <-> (Moon(x) & exists y. (Block(x, earth, sun)))", "NewMoon(new_moon) <-> (exists x. (Moon(x) & CouldBlockEarthFromSun(x)))", "NewMoon(moon) <-> CanBlock(moon, earth, sun)", "NewMoon(new_moon) <-> exists x. (Moon(x) & Blocks(x, earth, sun))", "NewMoonOccursAt(new_moon, t) <-> (exists x. (Moon(x) & CanBlockFrom(x, earth, sun)))", "NewMoon(when(moon, exists x. (Blocks(x, earth, sun))))", "NewMoon(new_moon) -> (exists y. (Moon(y) & CanBlock(y, earth, sun)))", "NewMoonOccursWhen(Moon, Sun, Earth, Blocks) & Blocks(Moon, Earth, Sun)", "NewMoon(x) <-> (Moon(x) & CanBlock(x, earth, sun))", "NewMoon(new_moon) <-> (Moon(moon) & CanBlockFrom(moon, earth, sun))", "When(moon, new_moon) -> CanBlockFrom(moon, earth, sun)", "NewMoon(moon) <-> (exists y. (Block(moon, earth, sun)))", "Exists t. (NewMoon(t) & CouldBlock(moon, earth, sun, t))"]}
{"id": "entailmentbank_validation_58", "nl": "a solar eclipse is when the moon blocks the earth from the sun.", "fol": "", "prediction": ["exists x, y, z. (SolarEclipse(x) <-> (Moon(y) & Earth(z) & Blocks(y, z, sun)))", "exists e. (SolarEclipse(e) <-> exists m, b, s. (Moon(m) & Blocks(m, b, s) & Earth(b) & Sun(s)))", "SolarEclipse(e) <-> exists x, y, z. (Moon(x) & Earth(y) & Sun(z) & Blocks(x, y, z))", "exists e. (SolarEclipse(e) <-> (exists m, s. (Moon(m) & Earth(e) & Sun(s) & Blocks(m, e, s))))", "exists e. (SolarEclipse(e) <-> exists m, s, t. (Moon(m) & Earth(t) & Sun(s) & Blocks(m, t, s)))", "exists x. (SolarEclipse(x) <-> exists y z. (Moon(y) & Earth(z) & Blocks(y, z, sun)))", "SolarEclipse(x) <-> (Moon(m) & Blocks(m, earth, sun))", "SolarEclipse = exists x. (Moon(x) & Blocks(x, earth, sun))", "exists e. (SolarEclipse(e) & exists m. (Moon(m) & Blocks(e, m, earth, sun)))", "SolarEclipse(e) <-> exists m, s. (Moon(m) & Sun(s) & Blocks(m, Earth, s))", "exists x. (SolarEclipse(x) <-> (Moon(m) & Blocks(m, Earth, Sun)))", "SolarEclipse(e) <-> exists m, e, s. (Moon(m) & Earth(e) & Sun(s) & Blocks(m, e, s))", "exists x. (SolarEclipse(x) <-> exists y. (Moon(y) & Blocks(y, earth, sun)))", "A solar eclipse can be represented as a specific scenario involving the positions of celestial objects. Here's the FOL interpretation:\n\nSolarEclipse(x) <-> (Moon(y) & Earth(z) & Sun(w) & Blocks(y, z, w))", "exists x. (SolarEclipse(x) <-> (Moon(m) & Sun(s) & Earth(e) & Blocks(m, e, s)))", "exists x. (SolarEclipse(x) & happensWhen(x, exists y. (Moon(y) & Blocks(y, Earth, Sun))))"]}
{"id": "entailmentbank_validation_59", "nl": "a solar eclipse could only happen during the new moon.", "fol": "", "prediction": ["all e. (SolarEclipse(e) -> exists m. (NewMoon(m) & HappensDuring(e, m)))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all e. (SolarEclipse(e) -> exists m. (NewMoon(m) & HappensDuring(e, m)))", "all x. (SolarEclipse(x) -> During(x, NewMoon))", "all x. (SolarEclipse(x) -> OccursDuring(x, NewMoon))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all x. (SolarEclipse(x) -> NewMoon(y) & HappensDuring(x, y))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & During(x, y)))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all x. (SolarEclipse(x) -> NewMoonDuring(x))", "all x. (SolarEclipse(x) -> occursDuring(x, NewMoon))", "all e. (SolarEclipse(e) -> exists n. (NewMoon(n) & HappensDuring(e, n)))", "all x. (SolarEclipse(x) -> NewMoon(x))", "all x. (SolarEclipse(x) -> exists y. (NewMoon(y) & HappensDuring(x, y)))", "all x. (SolarEclipse(x) -> NewMoonOccursDuring(x))"]}
{"id": "entailmentbank_validation_60", "nl": "objects generally are made of ice in the kuiper belt.", "fol": "", "prediction": ["all x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))", "all x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))", "all x. (InKuiperBelt(x) -> MadeOfIce(x))", "all x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))", "all x. (InKuiperBelt(x) -> Usually(MadeOfIce(x)))", "all x. (ObjectInKuiperBelt(x) -> GenerallyMadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (Object(x) & InKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> GenerallyMadeOfIce(x))", "all x. (InKuiperBelt(x) -> MadeOfIce(x))", "all x. (InKuiperBelt(x) -> Usually(MadeOfIce(x)))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))", "all x. (ObjectInKuiperBelt(x) -> MadeOfIce(x))"]}
{"id": "entailmentbank_validation_61", "nl": "icy can be used to describe objects that are made of ice.", "fol": "", "prediction": ["all x. (MadeOfIce(x) -> Describes(x, icy))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAs(x, icy))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> Icy(x))", "all x. (MadeOfIce(x) -> CanBeDescribedAs(x, icy))", "all x. (MadeOfIce(x) -> CanBeDescribedAsIcy(x))"]}
{"id": "entailmentbank_validation_62", "nl": "objects in kuiper belt are icy.", "fol": "", "prediction": ["all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all z. (ObjectInKuiperBelt(z) -> Icy(z))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (InKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (InKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))", "all x. (ObjectInKuiperBelt(x) -> Icy(x))"]}
{"id": "entailmentbank_validation_63", "nl": "a comet orbit occurs usually once per 1000 years.", "fol": "", "prediction": ["Exists y. (Comet(y) & OrbitsOnceIn1000Years(y))", "exists x. (Comet(x) & Orbits(x) & OccursOncePerThousandYears(x))", "exists x. (CometOrbit(x) & OccursUsuallyOncePer1000Years(x))", "all x. (CometOrbit(x) -> OccursOncePer(x, 1000Years))", "all x. (CometOrbit(x) -> OccursOncePerThousandYears(x))", "exists x. (CometOrbit(x) & OccursUsuallyOncePerYears(x, 1000))", "exists x. (Comet(x) -> OrbitsEvery(x, 1000))", "exists x. (CometOrbit(x) & OccursOncePer1000Years(x))", "`all x. (CometOrbit(x) -> OccursEvery1000Years(x))`", "exists x. (Comet(x) -> OrbitOccursEvery1000Years(x))", "exists x. (CometOrbitOccurs(x) & UsuallyOncePer1000Years(x))", "all x. (CometOrbit(x) -> OccursOncePer(1000, Years))", "exists x. (CometOrbit(x) & OccursOncePer1000Years(x))", "exists x. (CometOrbit(x) & OccursOncePer1000Years(x))", "exists x. (CometOrbit(x) & OccursOncePerXYears(x, 1000))", "exists x. (CometOrbit(x) & UsuallyOccursOncePer1000Years(x))"]}
{"id": "entailmentbank_validation_64", "nl": "a comet is a kind of celestial object.", "fol": "", "prediction": ["Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "all x. (Comet(x) -> CelestialObject(x))", "CelestialObject(comet)", "Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "all x. (Comet(x) -> CelestialObject(x))", "Comet(x) -> CelestialObject(x)", "CelestialObject(comet)", "Comet(x) -> CelestialObject(x)", "Comet(x) -> CelestialObject(x)", "CelestialObject(comet)", "Comet(x) -> CelestialObject(x)"]}
{"id": "entailmentbank_validation_65", "nl": "comet orbits are elliptical.", "fol": "", "prediction": ["all x. (Comet(x) -> EllipticalOrbit(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (Comet(x) -> OrbitsElliptical(x))", "all c. (Comet(c) -> OrbitsElliptical(c))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (Comet(x) -> OrbitsElliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (CometOrbit(x) -> Elliptical(x))", "all z. (CometOrbit(z) -> Elliptical(z))", "all x. (CometOrbit(x) -> Elliptical(x))", "all x. (Comet(x) -> EllipticalOrbit(x))", "all x. (Comet(x) -> EllipticalOrbit(x))", "all z. (Comet(z) -> EllipticalOrbit(z))", "all x. (CometOrbit(x) -> Elliptical(x))", "all z. (Comet(z) -> OrbitsElliptical(z))"]}
{"id": "entailmentbank_validation_66", "nl": "comets are the kind of celestial object that has a highly elliptical orbit and has a period of over 1000 years.", "fol": "", "prediction": ["all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & PeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & PeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all z. (Comet(z) -> (CelestialObject(z) & HasHighlyEllipticalOrbit(z) & HasPeriodOver1000Years(z)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & PeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & PeriodOverThousandYears(x)))", "all z. (Comet(z) -> (CelestialObject(z) & HasHighlyEllipticalOrbit(z) & PeriodOver1000Years(z)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & PeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))", "all x. (Comet(x) -> (CelestialObject(x) & HighlyEllipticalOrbit(x) & PeriodOver1000Years(x)))", "all x. ((Comet(x) & CelestialObject(x)) -> (HasHighlyEllipticalOrbit(x) & HasPeriodOver1000Years(x)))"]}
{"id": "entailmentbank_validation_67", "nl": "the milky way galaxy appears as a glowing band across the night sky.", "fol": "", "prediction": ["Exists x. (MilkyWayGalaxy(x) & AppearsAs(x, GlowingBand) & Across(x, NightSky))", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAs(milky_way_galaxy, glowing_band) & Across(glowing_band, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band, night_sky)", "GlowingBand(milky_way_galaxy, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAs(milky_way_galaxy, glowing_band, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band_across_the_night_sky)", "AppearsAs(milky_way_galaxy, GlowingBand(night_sky))", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAsGlowingBand(milky_way, night_sky)", "AppearsAs(milky_way_galaxy, glowing_band_across_night_sky)", "AppearsAs(milky_way_galaxy, glowing_band, night_sky)", "AppearsAsGlowingBandAcrossNightSky(milky_way_galaxy)"]}
{"id": "entailmentbank_validation_68", "nl": "a student observes a glowing band across the night sky.", "fol": "", "prediction": ["exists x. (Student(x) & exists y. (GlowingBand(y) & Across(y, NightSky) & Observes(x, y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & NightSky(z) & Across(y, z)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & AcrossNightSky(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & NightSky(z) & Observes(x, y, z)))", "exists x, y, z. (Student(x) & Observes(x, y) & GlowingBand(y) & AcrossNightSky(y) & NightSky(z))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & AtNight(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Across(y, nightSky) & Observes(x, y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, NightSky)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, NightSky)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & AcrossNightSky(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & exists z. (NightSky(z) & Across(y, z))))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & AppearsAtNightSky(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & Across(y, NightSky)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Observes(x, y) & OccursAtNight(y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & Across(y, NightSky) & Observes(x, y)))", "exists x. (Student(x) & exists y. (GlowingBand(y) & NightSky(z) & Observes(x, y) & In(z, y)))"]}
{"id": "entailmentbank_validation_69", "nl": "the student observes the milky way galaxy at night.", "fol": "", "prediction": ["exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "Existentially translates to: `exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight)`", "Student(john) & MilkyWay(mw) & ObservesAtNight(john, mw)", "Student(student) & MilkyWayGalaxy(milky_way_galaxy) & Night(night) & Observes(student, milky_way_galaxy, night)", "Student(student) & Observes(student, milky_way_galaxy) & AtNight(student)", "Exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "Student(the_student) & MilkyWay(milky_way) & Observes(the_student, milky_way) & AtNight(the_student)", "Exists x. (Student(x) & Observes(x, milky_way) & Time(at_night))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(observes))", "Exists x. (Student(x) & Exists y. (MilkyWayGalaxy(y) & ObservesAtNight(x, y)))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(observation))", "Student(x) & MilkyWay(y) & Observes(x, y) & AtNight()", "Exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))", "exists x. (Student(x) & Observes(x, milky_way_galaxy) & AtNight(x))"]}
{"id": "entailmentbank_validation_70", "nl": "looking at bright objects has a negative impact on the eyes.", "fol": "", "prediction": ["all x. (BrightObject(x) -> (exists y. (Eyes(y) & LookingAt(x, y) -> NegativeImpactOn(y))))", "all x. (BrightObject(x) -> all y. (Eyes(y) & LooksAt(y, x) -> HasNegativeImpactOn(x, y)))", "all x. (BrightObject(x) -> all y. (Eye(y) & LooksAt(y, x) -> HasNegativeImpact(x, y)))", "all x. (BrightObject(x) -> HasNegativeImpactOnEyes(LookingAt(x)))", "all x. (BrightObject(x) -> HasNegativeImpactOnEyes(LookingAt(x)))", "all x. (BrightObject(x) -> NegativeImpactOnEyes(LookAt(x)))", "all x. (BrightObject(x) -> HasNegativeImpactOnEyes(LookingAt(x)))", "all x. (BrightObject(x) -> resultsInNegativeImpactOnEyes(LookAt(x)))", "exists x. (BrightObject(x) -> all y. (Eye(y) & LooksAt(x, y) -> HasNegativeImpact(x, y)))", "all x. (BrightObject(x) & LooksAt(x) -> NegativeImpactOnEyes)", "all x. (BrightObject(x) -> all y. (Eye(y) -> HasNegativeImpact(LookingAt(x, y))))", "all x. (BrightObject(x) -> exists y. (Eye(y) & LooksAt(x, y) -> NegativeImpactOn(y)))", "all x. ((BrightObject(x) & LooksAt(x, eyes)) -> NegativeImpactOn(x, eyes))", "all x. (BrightObject(x) -> all y. (Eye(y) & LooksAt(y, x) -> NegativeImpact(x, y)))", "all x. (BrightObject(x) -> ImpactsNegativelyOnEyes(x))", "all x. (BrightObject(x) -> all y. (Eye(y) -> HasNegativeImpact(LookingAt(x), y)))"]}
{"id": "entailmentbank_validation_71", "nl": "the moon is less bright than the sun.", "fol": "", "prediction": ["LessBright(moon, sun)", "LessBright(moon, sun)", "Bright(moon) & Bright(sun) & LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBrightThan(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)", "LessBright(moon, sun)"]}
{"id": "entailmentbank_validation_72", "nl": "looking at the moon has less of a negative impact on the eyes.", "fol": "", "prediction": ["exists x. (LookingAt(x, moon) & LessNegativeImpact(x, eyes))", "It seems challenging to translate the given sentence directly into first-order logic while maintaining a clear and accurate representation. However, here's one way to represent the provided sentence in an abstract and logically-structured manner:\n\n```\nall x. (LookingAt(x, moon) -> HasLessNegativeImpact(x, eyes))\n```\n\nExplanation:\n- This translation assumes a general context where looking at anything, or \"x\", can be considered.\n- `LookingAt(x, moon)` represents the action where \"x\" is looking at the moon.\n- `HasLessNegativeImpact(x, eyes)` captures the idea that this action has less of a negative impact on the eyes.", "all x. (LookingAtMoon(x) -> HasLessNegativeImpactOnEyes(x))", "`-exists x. (Activity(x) & LooksAt(x, moon) & HasNegativeImpactOnEyes(x))`", "exists x. (Moon(x) & all y. (Eyes(y) -> LessNegativeImpact(LookingAt(x), y)))", "exists x. (Moon(x) & all y. (Eyes(y) -> LessNegativeImpact(LookingAt(x), y)))", "Exists a phenomenon y that is looking at the moon and for every person x this has less of a negative impact on the eyes compared to other possible activities:\n\nexists y. (Activity(y) & LookAtMoon(y) & all x. (Person(x) & HasEyes(x) -> LessNegativeImpactOnEyes(y, x)))", "exists x. (Moon(x) & Viewing(x) & LessNegativeImpactOnEyes(Viewing(x)))", "The translation would rely on representing \"looking at the moon,\" \"negative impact,\" and \"on the eyes.\" Let's assume predicates: `LookingAt(x, y)`, `Moon(y)`, `NegativeImpact(z)`, `On(z, w)`, `Eyes(w)`, and `LessThan(a, b)` to denote the relation of having less impact compared to another. Without a direct comparative element to denote specifically what it's less than (like looking at the sun), we focus on the structure.\n\nFOL Translation:\nexists z, w. (LookingAt(x, moon) & Moon(moon) & NegativeImpact(z) & On(z, w) & Eyes(w) & LessThan(NegativeImpact(LookingAt(x, moon)), b)) \n\nHowever, since it's not comparing directly with another object/entity's impact, this is a broad translation where `b` would need definition externally, or this is formulated around a presumed context (e.g., comparing something implicit like `looking at the sun`).", "all x. (LookingAt(x, moon) -> HasLessNegativeImpactOnEyes(x))", "exists x. (Moon(x) & all y. (Eyes(y) & LessNegativeImpact(LookingAt(x), y)))", "exists x. (Moon(x) & NegativeImpactOnEyes(y, x) & LessImpact(y, x))", "all x. (LooksAt(x, moon) -> LessNegativeImpactOnEyes(x))", "all x. (LookingAt(x, moon) -> LessNegativeImpactOnEyes(x))", "There isn't a standardized way to translate \\\"less negative impact\\\" directly into a single predicate in first-order logic. However, we can express this idea using predicates that describe \"impact\" and \"less negative\" in a general sense. Here's a possible translation using these concepts:\n\nexists x. all y. ((Moon(x) & Eyes(y)) -> HasNegativeImpact(y, x) & LessImpact(y, x))\n\nHere, `Moon(x)` expresses that `x` is the moon, `Eyes(y)` expresses that `y` relates to eyes, `HasNegativeImpact(y, x)` denotes that `x` has a negative impact on `y`, and `LessImpact(y, x)` asserts that the impact on `y` by looking at `x` is less negative compared to some standard or expected level. Note: This translation attempts to represent the essence of the statement as best as possible, given the abstract nature of \"less negative impact.\"", "all x. (LookingAt(x, moon) & ImpactOnEyes(x, negative) -> LessImpact(x))"]}
{"id": "entailmentbank_validation_73", "nl": "the surface of the earth contains mountains.", "fol": "", "prediction": ["Existence refers to specific features of a particular noun. Here's how to translate that sentence:\n\nFOL Translation:\nexists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(earth, x) & Contains(x, mountains))", "`exists x. (SurfaceOf(x, earth) & Contains(x, mountains))`", "exists x. (Surface(x) & PartOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(x, earth) & ContainsMountains(x))", "exists x. (Surface(x) & Earth(x) & Contains(x, y) & Mountain(y))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (SurfaceOfEarth(x) & ContainsMountains(x))", "exists x. (SurfaceOfEarth(x) & Contains(x, mountains))", "exists x. (SurfaceOfEarth(x) & ContainsMountains(x))", "exists x. (SurfaceOf(x, earth) & Contains(x, mountains))", "exists x. (EarthSurface(x) & contains(x, mountains))"]}
{"id": "entailmentbank_validation_74", "nl": "the surface of the moon contains mountains.", "fol": "", "prediction": ["exists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "exists x. (Surface(x) & Of(x, moon) & Contains(x, y) & Mountain(y))", "exists x. (SurfaceOf(moon, x) & ContainsMountain(x))", "exists y. (Surface(y) & PartOf(y, moon) & Contains(y, mountain))", "exists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "exists x. (Surface(x) & PartOf(x, moon) & ContainsMountains(x))", "FOL Translation:\nexists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "Exists x. (MoonSurface(x) & ContainsMountains(x))", "exists x. (Surface(x) & PartOf(x, moon) & ContainsMountains(x))", "SurfaceOf(moon, x) & Contains(x, mountains)", "exists x. (PartOf(x, moon) & Surface(x) & Contains(x, mountains))", "exists x. (SurfaceOf(x, moon) & Contains(x, mountains))", "Exists x. (SurfaceOf(moon, x) & ContainsMountains(x))", "exists x. (MoonSurface(x) & exists y. (Mountain(y) & Contains(x, y)))", "SurfaceOf(moon, surface_of_moon) & all x. (Mountain(x) -> Contains(surface_of_moon, x))", "exists x. (Surface(moon, x) & Contains(x, y) & Mountain(y))"]}
{"id": "entailmentbank_validation_75", "nl": "both the surface of the moon and the surface of the earth contain mountains.", "fol": "", "prediction": ["`Surface(moon) & Surface(earth) & Contains(Surface(moon), mountains) & Contains(Surface(earth), mountains)`", "`Contains(surface_of_moon, mountains) & Contains(surface_of_earth, mountains)`", "ContainsSurfaceFeature(moon, mountains) & ContainsSurfaceFeature(earth, mountains)", "Contains(surface_of_moon, mountains) & Contains(surface_of_earth, mountains)", "SurfaceOf(moon, surface1) & SurfaceOf(earth, surface2) & Contains(surface1, mountains) & Contains(surface2, mountains)", "`exists x. (SurfaceOf(moon, x) & Contains(x, mountains)) & exists y. (SurfaceOf(earth, y) & Contains(y, mountains))`", "ContainsSurfaceFeature(moon, mountains) & ContainsSurfaceFeature(earth, mountains)", "`Surface(moon, s1) & Surface(earth, s2) & Contains(s1, m) & Mountain(m) & Contains(s2, m) & Mountain(m)`", "SurfaceOf(moon, surface1) & SurfaceOf(earth, surface2) & Contains(surface1, mountains) & Contains(surface2, mountains)", "Contains(surface(moon), mountains) & Contains(surface(earth), mountains)", "ContainMountains(Surface(moon)) & ContainMountains(Surface(earth))", "`Contains(surface_moon, mountains) & Contains(surface_earth, mountains)`", "Contains(surface_of_moon, mountains) & Contains(surface_of_earth, mountains)", "ContainsMountains(surface_of_moon) & ContainsMountains(surface_of_earth)", "ContainsSurfaceFeature(surface_moon, mountains) & ContainsSurfaceFeature(surface_earth, mountains)", "ContainsSurfaceMoon(x) -> Contains(x, mountain) & ContainsSurfaceEarth(y) -> Contains(y, mountain)"]}
{"id": "entailmentbank_validation_76", "nl": "the asteroid belt is located between mars and jupiter.", "fol": "", "prediction": ["LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "Located(asteroid_belt, Between(mars, jupiter))", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)", "LocatedBetween(asteroid_belt, mars, jupiter)"]}
{"id": "entailmentbank_validation_77", "nl": "the asteroid belt contains the largest concentration of asteroids in the solar system.", "fol": "", "prediction": ["FOL Translation:\nConcentration(compare. AsteroidBelt(largest), InSolarSystem(solar_system))", "Exists x. (AsteroidBelt(x) & Contains(x, MaxConcentrationOfAsteroidsInSolarSystem))", "Contains(asteroid_belt, largest_concentration_of_asteroids, solar_system)", "Contains(asteroid_belt, largest_concentration_of_asteroids_in_solar_system)", "exists x. (AsteroidBelt(x) & ContainsLargestConcentrationOfAsteroids(x) & InSolarSystem(x))", "Contains(asteroid_belt, largest_concentration_of_asteroids, solar_system)", "Contains(asteroid_belt, largest_concentration_asteroids) & In(asteroid_belt, solar_system)", "Contains(asteroid_belt, largest_concentration_of(asteroids, solar_system))", "Contains(asteroid_belt, largest_concentration_of_asteroids) & In(solar_system, asteroid_belt)", "`AsteroidBeltContainsLargestConcentrationOfAsteroidsInSolarSystem`", "Contains(asteroid_belt, largest_concentration_of_asteroids, solar_system)", "Contains(asteroid_belt, largest_concentration_of_asteroids) & In(solar_system, largest_concentration_of_asteroids)", "Contains(asteroid_belt, LargestConcentration(asteroids)) & In(solar_system, asteroid_belt)", "Contains(asteroid_belt, largest_concentration_of_asteroids) & In(asteroid_belt, solar_system)", "Contains(asteroid_belt, largest_concentration_of_asteroids, solar_system)", "Contains(asteroid_belt, largest_concentration(ast, ast)) & In(solar_system, asteroid_belt)"]}
{"id": "entailmentbank_validation_78", "nl": "the asteroid belt that contains the most asteroids is located between mars and jupiter.", "fol": "", "prediction": ["exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "FOL Translation:\nexists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "Exists z. (AsteroidBelt(z) & ContainsMostAsteroids(z) & LocatedBetween(z, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "`exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))`", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "Exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))", "exists x. (AsteroidBelt(x) & ContainsMostAsteroids(x) & LocatedBetween(x, mars, jupiter))"]}
{"id": "entailmentbank_validation_79", "nl": "the sun is average in temperature for a star in our galaxy.", "fol": "", "prediction": ["AverageTemperature(sun) & Star(sun) & InGalaxy(sun)", "AverageTemperature(sun, our_galaxy) & Star(sun)", "AverageTemperature(sun) & Star(sun) & InOurGalaxy(sun)", "AverageTemperatureForStar(sun)", "AverageTemperatureForAStar(sun)", "AverageTemperature(sun) & exists y. (Star(y) & InGalaxy(y))", "AverageTemperature(sun) & Star(sun) & InGalaxy(sun, our_galaxy)", "AverageInTemperature(sun) & Star(sun) & InOurGalaxy(sun)", "AverageTemperature(sun)", "Star(sun) & AverageTemperature(sun) & InOurGalaxy(sun)", "AverageTempForStarInGalaxy(sun)", "Star(sun) & AverageTemperature(sun, galaxy)", "AverageTemperature(sun, our_galaxy_star) & Star(sun) & InOurGalaxy(sun)", "AverageTemperature(sun) & Star(sun) & InGalaxy(sun, ourGalaxy)", "AverageTemperature(sun, star)", "AverageTemperature(sun) & Star(sun) & InGalaxy(sun, our_galaxy)"]}
{"id": "entailmentbank_validation_80", "nl": "the sun is average in size for a star in our galaxy.", "fol": "", "prediction": ["AverageSize(sun) & Star(sun) & InOurGalaxy(sun)", "AverageSizeForStar(sun) & Star(sun)", "AverageSizeForStarInGalaxy(sun)", "AverageInSizeForStar(sun) & InGalaxy(sun, our_galaxy)", "Star(sun) & AverageSizeForStarInGalaxy(sun)", "AverageSize(sun) & Star(sun) & InOurGalaxy(sun)", "Star(sun) & AverageSizeForStarInGalaxy(sun)", "AverageSize(sun) & InGalaxy(sun, our_galaxy) & all x. (Star(x) & InGalaxy(x, our_galaxy) -> AverageSize(x) = AverageSize(sun))", "Star(sun) & AverageSizeForStar(sun, galaxy)", "Star(sun) & AverageSizeForStar(sun)", "Star(sun) & AverageSize(sun)", "AverageSizeForStar(sun) & InGalaxy(sun, our_galaxy)", "AverageSize(sun) & all y. (Star(y) & InGalaxy(y, our_galaxy) -> AverageSize(y))", "Star(sun) & AverageSize(sun) & Star(sun) & InOurGalaxy(sun)", "AverageSizeForStarInGalaxy(sun)", "AverageSize(sun) & Star(sun) & ExistsIn(sun, our_galaxy) & all y. (Star(y) & ExistsIn(y, our_galaxy) -> AverageSize(y))"]}
{"id": "entailmentbank_validation_81", "nl": "the sun is average in siza and average in temperature in our galaxy.", "fol": "", "prediction": ["AverageInSize(sun) & AverageInTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun) & InGalaxy(sun, our_galaxy)", "AverageSize(sun) & AverageTemperature(sun) & InOurGalaxy(sun)", "AverageSize(sun) & AverageTemperature(sun) & In(sun, galaxy)", "AverageSize(sun) & AverageTemperature(sun) & InGalaxy(sun, our_galaxy)", "AverageSize(sun) & AverageTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun) & InGalaxy(sun, our_galaxy)", "AverageInSize(sun) & AverageInTemperature(sun) & In(galaxy, sun)", "AverageInSize(sun) & AverageInTemperature(sun) & InGalaxy(sun, our_galaxy)", "AverageSize(sun) & AverageTemperature(sun)", "AverageInSize(sun) & AverageInTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun)", "AverageSize(sun) & AverageTemperature(sun) & InOurGalaxy(sun)", "AverageSize(sun) & AverageTemperature(sun) & InOurGalaxy(sun)", "AverageSize(sun) & AverageTemperature(sun) & InGalaxy(sun, our_galaxy)"]}
{"id": "entailmentbank_validation_82", "nl": "as the mass of a celestial object decreases, the surface gravity of that celestial object weakens.", "fol": "", "prediction": ["all x. (CelestialObject(x) & Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) & Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) & Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))", "all x. ((CelestialObject(x) & Decreases(Mass(x))) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) -> (Decrease(Mass(x)) -> Weaken(SurfaceGravity(x))))", "all x. (CelestialObject(x) -> (MassDecreases(x) -> GravityWeakens(x)))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))", "all x. ((CelestialObject(x) & Decreases(Mass(x))) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))", "all x. (CelestialObject(x) & DecreasesMass(x) -> WeakensSurfaceGravity(x))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))", "all x. ((CelestialObject(x) & Decreases(Mass(x))) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) & Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))", "all x. (CelestialObject(x) -> (Decreases(Mass(x)) -> Weakens(SurfaceGravity(x))))", "all x. (CelestialObject(x) -> Decreases(Mass(x)) -> Weakens(SurfaceGravity(x)))"]}
{"id": "entailmentbank_validation_83", "nl": "as the force of gravity decreases, the weight of the object will decrease.", "fol": "", "prediction": ["all x. (Object(x) & Decreases(GravityForce) -> Decreases(Weight(x)))", "all x y. ((GravityForceDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x. (Object(x) & GravityDecreases -> WeightDecrease(x))", "all x y. ((Gravity(x) & ForceDecreases(x)) -> (Object(y) & WeightDecreases(y)))", "all x y. ((Gravity(x) & Object(y) & Decreases(ForceOfGravity(x))) -> Decreases(Weight(y)))", "all x. all y. (Object(x) & ForceGravityDecreases(y) -> WeightDecreases(x))", "all x. (all y. ((GravityForceDecreases(x) & Object(y) & AffectsGravityOn(x, y)) -> WeightDecreases(y)))", "all x. all y. ((ForceOfGravityDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x. (Decreases(GravityForce(x)) -> Decreases(WeightOf(x)))", "all x y. ((ForceOfGravityDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x y. (Object(x) & ForceOfGravityDecreases(y) -> WeightDecreases(x))", "all x y. ((ForceOfGravity(x) & Decreases(x)) -> (Weight(y) & Decreases(y)))", "all x. all y. ((ForceOfGravityDecreases(x) & Object(y)) -> WeightDecreases(y))", "all x. all y. (Object(x) & Decreases(Gravity(y)) -> Decreases(Weight(x, y)))", "all x. all y. (ForceOfGravityDecreases(x) & Object(y) -> WeightDecreases(y))", "all x. (Object(x) -> (Decreases(GravityForce) -> Decreases(Weight(x))))"]}
{"id": "entailmentbank_validation_84", "nl": "as the mass of a celestial object decreases, the weight of an object on that celestial object will decrease.", "fol": "", "prediction": ["all x y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x y. (CelestialObject(x) & Object(y) -> (Decrease(Mass(x)) -> Decrease(WeightOn(y, x))))", "all x. all y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x. (CelestialObject(x) -> all y. (ObjectOnCelestialObject(y, x) & Decreases(Mass(x)) -> Decreases(Weight(y, x))))", "all x, y. (CelestialObject(x) & Object(y) & Decreases(Mass(x), t) -> Decreases(WeightOn(y, x), t))", "all x all y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x y. ((CelestialObject(x) & Object(y) & Decreases(Mass(x))) -> Decreases(WeightOn(y, x)))", "all x y. ((CelestialObject(x) & Object(y) & Decreases(Mass(x))) -> Decreases(Weight(y, x)))", "all x y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x. all y. ((CelestialObject(x) & Object(y)) -> (Decreases(Mass(x)) -> Decreases(Weight(y, x))))", "all x y. (CelestialObject(x) & Object(y) -> (Decreases(Mass(x)) -> Decreases(WeightOn(y, x))))", "all x. all y. ((CelestialObject(x) & Object(y) & Decreases(Mass(x))) -> Decreases(WeightOn(y, x)))", "all x y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x, y. (CelestialObject(x) & Object(y) & Decreases(Mass(x)) -> Decreases(WeightOn(y, x)))", "all x y. ((CelestialObject(x) & Object(y) & DecreasesMass(x)) -> DecreasesWeightOn(y, x))"]}
{"id": "entailmentbank_validation_85", "nl": "the earth has more mass than the moon.", "fol": "", "prediction": ["HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "Mass(earth, m1) & Mass(moon, m2) & m1 > m2", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMassThan(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMass(earth, moon)", "HasMoreMassThan(earth, moon)", "HasMoreMass(earth, moon)"]}
{"id": "entailmentbank_validation_86", "nl": "an object weighs more on earth than on the moon because earth has more mass than the moon.", "fol": "", "prediction": ["all x. (Object(x) -> (WeighsMoreOn(x, earth, moon) <-> (HasMoreMass(earth, moon) & GravitationalForceHigher(earth, moon))))", "exists x. (Object(x) & WeightMoreOnEarth(x) & WeightLessOnMoon(x)) & Mass(earth) > Mass(moon) & (Mass(earth) > Mass(moon) -> WeightMoreOnEarth(x))", "First, we identify the components that need translation:\n\n1. Objects weigh more on earth: Let's assume we have a function `WeightOn(x, y)` representing the weight of object `x` on celestial body `y`.\n\n2. Because: This indicates a causal relation or reason.\n\n3. Earth has more mass than the moon: We represent this with a function `Mass(y)` to denote the mass of celestial body `y`.\n\nNow, we can translate the sentence:\n\nFOL Translation:\n``` \nall x. (WeightOn(x, earth) > WeightOn(x, moon) <- Mass(earth) > Mass(moon))\n```", "exists x. (Object(x) & all y. (y = earth & all z. (z = moon & WeighsMoreOn(x, y, z) & MoreMass(y, z))))", "exists x. (Object(x) & GreaterWeightOnEarth(x) & MoreMass(earth, moon) & Causes(MoreMass(earth, moon), GreaterWeightOnEarth(x)))", "exists x. (Object(x) & WeighsMoreOnEarth(x) & all y. (Earth(y) & Mass(y) > all z. (Moon(z) & Mass(z)) -> WeighsMoreOnEarth(x)))", "exists x. (Object(x) & WeighsMoreOnEarthThanOnMoon(x)) & HasMoreMass(earth, moon)", "exists x. (Object(x) & WeighsMoreOnEarthThanOnMoon(x)) & MoreMass(earth, moon) -> WeighsMoreOnEarthThanOnMoon(x)", "exists x. (Object(x) -> (WeighsMoreOnEarth(x) & Mass(earth) > Mass(moon)))", "all x. (Object(x) -> WeighsMoreOnEarthThanOnMoon(x)) & MoreMass(earth, moon) -> (WeighsMoreOnEarthThanOnMoon(x))", "exists x. exists y. (Object(x) & Planet(earth) & Moon(y) & WeighsMoreOn(x, earth, y) & Mass(earth) > Mass(y))", "all x. (Object(x) -> (WeighsMoreOnEarth(x) & WeighsLessOnMoon(x) & all y z. (Earth(y) & Moon(z) & Mass(y, m1) & Mass(z, m2) & m1 > m2 -> WeighsMoreOnEarth(x) & WeighsLessOnMoon(x))))", "all x. (Object(x) & WeighsMoreOnEarthThanOnMoon(x) <-> (Mass(earth) > Mass(moon)))", "all x. (Object(x) -> (WeighsMoreOnEarth(x) & (Mass(earth) > Mass(moon)) -> WeighsMoreOnEarth(x, moon)))", "exists x. (Object(x) -> (WeighsMoreOnEarthThanOnMoon(x) & Mass(earth) > Mass(moon)))", "all x. (Object(x) -> (WeighsMoreOn(x, earth, moon) <-> HasMoreMass(earth, moon)))"]}
{"id": "entailmentbank_validation_87", "nl": "less is the opposite of more.", "fol": "", "prediction": ["Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)", "Opposite(less, more)"]}
{"id": "entailmentbank_validation_88", "nl": "an object will weigh less on the moon than on the earth because the moon has less mass than the earth.", "fol": "", "prediction": ["exists x. (Object(x) -> (WeighsLessOn(x, moon, earth) & LessMass(moon, earth)))", "all x. (Object(x) -> (WeighsLessOn(x, moon, earth) <-> HasLessMass(moon, earth)))", "exists x. (Object(x) -> (WeightOnMoon(x) < WeightOnEarth(x)) & (Mass(moon) < Mass(earth)))", "exists x. (Object(x) -> WeighLessOn(x, moon, earth) & HasLessMass(moon, earth))", "LowerWeightOnMoon(x) :- Object(x), Mass(moon) < Mass(earth)\n\nIn first-order logic:\n\nall x. (Object(x) & LessMass(moon, earth) -> WeighsLessOnMoonThanEarth(x))", "all x. (Object(x) -> (WeighsLessOn(x, moon, earth) <-> LessMass(moon, earth)))", "exists x. (Object(x) -> (LessMass(moon, earth) -> (WeighsLessOn(x, moon, earth))))", "all x. (Object(x) -> (WeighsLessOnMoonThanOnEarth(x) <-> (Mass(moon) < Mass(earth))))", "exists x. (Object(x) -> all y. (CelestialBody(y) & (y = moon | y = earth) ->\n(WeighsLessOn(x, moon, earth) <-> (Mass(moon) < Mass(earth)))))", "all x. (Object(x) -> ( (Mass(moon) < Mass(earth)) -> WeighsLessOn(x, moon, earth) ))", "all x. (Object(x) -> (Mass(moon) < Mass(earth) -> WeighsLessOn(x, moon, earth)))", "exists x. (Object(x) -> (WeighLessOn(x, moon, earth) & (HasLessMass(moon, earth))))", "exists x. (Object(x) -> (WeighsLessOnMoonThanOnEarth(x) & Mass(moon) < Mass(earth)))", "all x. (Object(x) -> WeighsLessOnMoonThanOnEarth(x)) & LessMass(moon, earth)", "all x. (Object(x) -> (WeighLessOn(x, moon, earth) <- (LessMass(moon, earth) & Cause(LessMass(moon, earth), WeighLessOn(x, moon, earth)))))", "all x. (Object(x) -> (LessMass(moon, earth) -> (WeighsLessOn(x, moon, earth))))"]}
{"id": "entailmentbank_validation_89", "nl": "an astronaut is a kind of object.", "fol": "", "prediction": ["all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "all x. (Astronaut(x) -> Object(x))", "Astronaut(x) -> Object(x)"]}
{"id": "entailmentbank_validation_90", "nl": "an astronaut will weigh less on the moon than on earth because the moon has less mass than the earth.", "fol": "", "prediction": ["exists x. (Astronaut(x) -> (WeighLessOnMoon(x) & (LessMass(moon, earth) -> WeighLessOnMoon(x))))", "all x. (Astronaut(x) -> WeighsLess(x, moon, earth)) & Mass(moon) < Mass(earth)", "exists x. (Astronaut(x) -> WeighLessOn(x, moon, earth) & HasLessMass(moon, earth))", "exists x. (Astronaut(x) & LessWeightOnMoon(x) & For(muon, earth, (HasLessMass(muon, earth) -> LessWeightOnMoon(x))))", "exists x. (Astronaut(x) & all y. (y = moon -> (LessMass(y, earth) & WeighsLessOn(x, y, earth))))", "exists x. (Astronaut(x) & WeightLessOn(x, moon, earth) & LessMass(moon, earth))", "Exists x. (Astronaut(x) -> (Mass(moon) < Mass(earth) & WeighsLessOn(x, moon, earth)))", "Exists x. (Astronaut(x) -> (WeighsOnLessThan(x, moon, earth) & (HasLessMass(moon, earth))))", "exists x. (Astronaut(x) & LessMass(moon, earth) -> WeighsLessOn(x, moon, earth))", "exists x. (Astronaut(x) -> (WeighLessOn(x, moon, earth) & LessMass(moon, earth)))", "exists x. (Astronaut(x) & LessMass(moon, earth) -> WeightOnMoon(x) < WeightOnEarth(x))", "FOL Translation:\nall x. (Astronaut(x) -> (WeighLessOn(x, moon, earth) & (Mass(moon) < Mass(earth))))", "exists x. (Astronaut(x) & WeightOn(x, moon) < WeightOn(x, earth) & Mass(moon) < Mass(earth))", "all a. (Astronaut(a) -> (WeighsLessOn(a, moon, earth) & HasLessMass(moon, earth)))", "exists x. (Astronaut(x) -> (WeighsLessOnMoonThanOnEarth(x) & HasLessMass(moon, earth)))", "exists x. (Astronaut(x) & exists y. (y = moon) & exists z. (z = earth) & WeighsLessOn(x, y, z) & Mass(y) < Mass(z)))"]}
{"id": "entailmentbank_validation_91", "nl": "using a telescope to photograph solar events requires a light filter.", "fol": "", "prediction": ["all x. (Telescope(x) & PhotographsSolarEvents(x) -> RequiresLightFilter(x))", "all x. (PhotographUsingTelescope(x) & SolarEvent(x) -> RequiresLightFilter(x))", "all x. (UsingTelescope(x) & PhotographSolarEvents(x) -> Requires(x, LightFilter))", "all x. ((UsesTelescope(x) & Photographs(x, SolarEvents)) -> Requires(x, LightFilter))", "all x. (UsingTelescopeToPhotographSolarEvents(x) -> Requires(x, LightFilter))", "all x. (UsingTelescopeToPhotographSolarEvents(x) -> Requires(x, LightFilter))", "all x. ((Uses(x, telescope) & Photographs(x, solar_events)) -> Requires(x, light_filter))", "all x. (UsingTelescopeToPhotograph(x) & SolarEvent(x) -> Requires(x, LightFilter))", "all x. (UsingTelescopeToPhotograph(x, SolarEvent) -> Requires(x, LightFilter))", "all x. (UseTelescopeToPhotographSolarEvents(x) -> Requires(x, LightFilter))", "all x. ((UsesTelescopeToPhotographSolarEvents(x)) -> RequiresLightFilter(x))", "FOL Translation:\nall u. ((UsingTelescopeToPhotographSolarEvents(u)) -> RequiresLightFilter(u))", "all x. (UsesTelescopeToPhotographSolarEvents(x) -> RequiresLightFilter(x))", "For this translation, we define the predicates as follows:\n- `UsesTelescopeToPhotographSolarEvents(x)`: x uses a telescope to photograph solar events\n- `RequiresLightFilter(x)`: x requires a light filter\n\nFOL Translation:\nall x. (UsesTelescopeToPhotographSolarEvents(x) -> RequiresLightFilter(x))", "all x. (PhotographSolarEventUsingTelescope(x) -> Requires(x, LightFilter))", "all x. (UsingTelescopeToPhotographSolarEvent(x) -> RequiresLightFilter(x))"]}
{"id": "entailmentbank_validation_92", "nl": "a solar flare is a kind of solar event.", "fol": "", "prediction": ["SolarFlare(solarflare) -> SolarEvent(solarflare)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "SolarFlare(f) -> SolarEvent(f)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "Kind(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "KindOf(solar_flare, solar_event)", "SolarFlare(x) -> SolarEvent(x)", "KindOf(solar_flare, solar_event)"]}
{"id": "entailmentbank_validation_93", "nl": "a solar prominence is a kind of solar event.", "fol": "", "prediction": ["KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "Kind(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "KindOf(solar_prominence, solar_event)", "all x. (SolarProminence(x) -> SolarEvent(x))", "KindOf(solar_prominence, solar_event)", "SolarProminence(x) -> SolarEvent(x)"]}
{"id": "entailmentbank_validation_94", "nl": "using a telescope to photograph a solar prominence and a solar flare requires a light filter.", "fol": "", "prediction": ["all x. (Telescope(x) & UsesFor(x, Photograph(SolarProminence) & Photograph(SolarFlare)) -> Requires(x, LightFilter))", "exists x. (Telescope(x) & exists y. (SolarProminence(y) & exists z. (SolarFlare(z) & RequiresLightFilter(Photograph(x, y), Photograph(x, z)))))", "exists x. (Telescope(x) -> (Photograph(x, solar_prominence) & Photograph(x, solar_flare) -> Requires(x, light_filter)))", "exists x. (Telescope(x) & exists y. (Photograph(y, SolarProminence) & Photograph(y, SolarFlare) & Requires(y, LightFilter)))", "all x. (UsingTelescopeToPhotograph(x, SolarProminence) & UsingTelescopeToPhotograph(x, SolarFlare) -> Requires(x, LightFilter))", "exists x. exists y. (Telescope(x) & LightFilter(y) -> (Photograph(x, solar_prominence) & Photograph(x, solar_flare) -> Requires(x, y)))", "exists x. (Telescope(x) & Photograph(x, solar_prominence) & Photograph(x, solar_flare) -> Requires(x, light_filter))", "exists x, y, z. ((Telescope(x) & SolarProminence(y) & SolarFlare(z) & UsesToPhotograph(x, y) & UsesToPhotograph(x, z)) -> Requires(x, LightFilter))", "exists t, p, f, s, l. (Telescope(t) & SolarProminence(p) & SolarFlare(f) & LightFilter(l)) -> Requires(Photograph(p, f, t), l)", "all x. ((Telescope(x) & Photographs(x, solar_prominence) & Photographs(x, solar_flare)) -> Requires(x, light_filter))", "exists x exists y exists z. (Telescope(x) & SolarProminence(y) & SolarFlare(z) & Requires(Photograph(x, y, z), LightFilter))", "all x y z. ((Telescope(x) & Photographs(x, y) & SolarProminence(y) & SolarFlare(z)) -> Requires(x, LightFilter))", "exists x, y, z, w. (Telescope(x) & SolarProminence(y) & SolarFlare(z) & LightFilter(w) & (Photograph(x, y) & Photograph(x, z) -> Requires(w)))", "exists x, y, z. ((Telescope(x) & PhotoSolarProminence(x, y) & PhotoSolarFlare(x, z)) -> Requires(x, LightFilter(x)))", "exists x y. (Telescope(x) & SolarProminence(y) & SolarFlare(y) & UsingToPhotograph(x, y) -> RequiresLightFilter(x))", "exists x y z w. (Telescope(x) & SolarProminence(y) & SolarFlare(z) & LightFilter(w) -> (PhotographWith(x, y) & PhotographWith(x, z) -> Requires(x, w)))"]}
{"id": "entailmentbank_validation_95", "nl": "if something is required for something else then that something allows that something else.", "fol": "", "prediction": ["all x, y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x, y. (RequiredFor(x, y) -> Allows(x, y))", "all x, y. (RequiredFor(x, y) -> Allows(x, y))", "all x all y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. ((RequiredFor(x, y)) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x y. (RequiredFor(x, y) -> Allows(x, y))", "all x, y. (RequiredFor(x, y) -> Allows(x, y))", "all x all y. (RequiredFor(x, y) -> Allows(x, y))"]}
{"id": "entailmentbank_validation_96", "nl": "detailed observation of celestial objects requires a telescope.", "fol": "", "prediction": ["all x. (DetailedObservation(x) & CelestialObject(x) -> Requires(x, telescope))", "all x. (DetailedObservation(x) & CelestialObject(x) -> Requires(x, Telescope))", "all x. (CelestialObject(x) & DetailedObservation(x) -> Requires(x, Telescope))", "all x. (CelestialObject(x) -> RequiresDetailedObservation(x, telescope))", "all x. (CelestialObject(x) -> (exists y. (Observation(y) & DetailedObservationOf(y, x))) -> Requires(y, telescope))", "all x. (CelestialObject(x) -> RequiresDetailedObservation(x) -> RequiresTelescope(Observation(x)))", "all x. (CelestialObject(x) -> exists y. (Telescope(y) & RequiresDetailedObservation(x, y)))", "all x. (CelestialObject(x) -> (exists y. (DetailedObservationOf(x, y) & Telescope(y))))", "all x. (CelestialObject(x) -> RequiresTelescope(DetailedObservation(x)))", "all x. (CelestialObject(x) -> (DetailedObservation(x) -> exists y. (Telescope(y) & Requires(DetailedObservation(x), y))))", "all x. (CelestialObject(x) & DetailedObservation(x) -> Requires(x, Telescope))", "all x. (CelestialObject(x) & DetailedObservation(x) -> Requires(x, telescope))", "all x. (CelestialObject(x) -> Requires(Telescope, DetailedObservation(x)))", "all x. (CelestialObject(x) & DetailedObservation(x) -> Requires(x, telescope))", "all x. (CelestialObject(x) -> (Requires(DetailedObservation(x), Telescope)))", "all x. (CelestialObject(x) -> requires(DetailedObservation(x), Telescope))"]}
{"id": "entailmentbank_validation_97", "nl": "telescopes allow the detailed observation of celestial objects.", "fol": "", "prediction": ["all x. (Telescope(x) -> CanObserveWithDetail(x, CelestialObject))", "all x. (Telescope(x) -> CanObserveInDetail(x, CelestialObject))", "all t. (Telescope(t) -> all o. (CelestialObject(o) -> AllowsDetailedObservation(t, o)))", "FOL Translation:\nall x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> AllowsDetailedObservation(x, CelestialObjects))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "FOL Translation:\nall x. (Telescope(x) -> CanObserveDetail(x, CelestialObject))", "all x. (Telescope(x) -> canObserveInDetail(x, CelestialObject))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "FOL Translation:\nall x. (Telescope(x) -> AllowsDetailedObservationOf(x, CelestialObjects))", "all t. (Telescope(t) -> exists c. (CelestialObject(c) & AllowsDetailedObservation(t, c)))", "FOL Translation:\nall x. (Telescope(x) -> allowsDetailedObservation(x, CelestialObjects))", "all x. (Telescope(x) -> all y. (CelestialObject(y) -> AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> exists y. (CelestialObject(y) & AllowsDetailedObservation(x, y)))"]}
{"id": "entailmentbank_validation_98", "nl": "a planet is a kind of celestial object / celestial body.", "fol": "", "prediction": ["all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x) & CelestialBody(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))", "all x. (Planet(x) -> CelestialObject(x))"]}
{"id": "entailmentbank_validation_99", "nl": "telescopes allow the detailed observation of planets.", "fol": "", "prediction": ["FOL Translation:\nall x. (Telescope(x) -> exists y. (AllowsDetailedObservationOf(x, y) & Planet(y)))", "all x. (Telescope(x) -> CanObservePlanetsInDetail(x))", "all x. (Telescope(x) -> all y. (Planet(y) -> CanObserveInDetailWith(x, y)))", "all x. (Telescope(x) -> AllowsDetailedObservationOf(x, planets))", "all x. (Telescope(x) -> all y. (Planet(y) -> AllowDetailedObservation(x, y)))", "all x. (Telescope(x) -> all y. (Planet(y) -> AllowsDetailedObservation(x, y)))", "exists x. (Telescope(x) & all y. (Planet(y) -> AllowsDetailedObservation(x, y)))", "exists x. (Telescope(x) & all y. (Planet(y) -> AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> exists y. (Planet(y) & AllowsDetailedObservation(x, y)))", "all x. (Telescope(x) -> allowsDetailedObservationOfPlanets(x))", "exists x. (Telescope(x) & all y. (Planet(y) -> AllowsDetailedObservation(x, y)))", "all t. (Telescope(t) -> all p. (Planet(p) -> AllowsDetailedObservation(t, p)))", "all z. (Telescope(z) -> all x. (Planet(x) -> AllowsDetailedObservation(z, x)))", "all x. (Telescope(x) -> allowsDetailedObservationOfPlanets(x))", "exists t. (Telescope(t) & all p. (Planet(p) -> AllowsDetailedObservation(t, p)))", "all x. (Telescope(x) -> exists y. (Planet(y) & AllowsDetailedObservation(x, y)))"]}
{"id": "entailmentbank_validation_100", "nl": "gravity causes orbits.", "fol": "", "prediction": ["all x, y. (Causes(gravity, Orbits(x, y)))", "exists x exists y. (Gravity(x) & Orbit(y) & Causes(x, y))", "exists x exists y. (Gravity(x) & Orbits(y) -> Causes(x, y))", "all x y. (Gravity(x) & Orbit(y) -> Causes(x, y))", "all x. all y. (Orbits(x, y) -> Causes(gravity, Orbits(x, y)))", "all x y. (Gravity(x, y) -> Causes(x, Orbits(y)))", "exists x exists y. (Gravity(x) & OrbitRelationship(y) & Causes(x, y))", "all x, y. (Gravity(x, y) -> Causes(x, Orbits(y)))", "all x. all y. (Orbit(x, y) -> GravityCausesOrbit(x, y))", "all x y. (Gravity(x) & Orbit(y) -> Causes(x, y))", "all x. all y. (Orbits(x, y) -> CausedBy(Orbits(x, y), gravity))", "exists x exists y. (Gravity(x) & Orbit(y) -> Causes(x, y))", "exists x exists y. (Gravity(x) & Orbits(y) -> Causes(x, y))", "all x y. (Gravity(x) & Orbits(y) -> Causes(x, y))", "exists x exists y. (Causes(gravity, Orbits(x, y)))", "all x. all y. (Orbits(x, y) -> Causes(gravity, Orbits(x, y)))"]}
{"id": "entailmentbank_validation_101", "nl": "gravity causes the earth to revolve around the sun.", "fol": "", "prediction": ["Causes(gravity, RevolvesAround(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolvesAround(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, Revolve(earth, sun))", "Causes(gravity, RevolveAround(earth, sun))", "Exists x. Exists y. (Gravity(x) & Earth(y) & RevolveAround(y, sun) & Causes(x, y))"]}
{"id": "entailmentbank_validation_102", "nl": "the moon orbits the earth.", "fol": "", "prediction": ["Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)", "Orbits(moon, earth)"]}
{"id": "entailmentbank_validation_103", "nl": "gravity causes the moon to orbit the earth.", "fol": "", "prediction": ["Exists x. Exists y. (Gravity(x) & Moon(y) & Earth(z) & Orbits(y, z) & Causes(x, Orbits(y, z)))", "Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "Exists x. (Gravity(x) & Causes(x, Orbit(moon, earth)))", "GravityCausesOrbit(moon, earth)", "Causes(gravity, Orbit(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbit(moon, earth))", "`Causes(gravity, Orbits(moon, earth))`", "Exists g, m, e (Gravity(g) & Moon(m) & Earth(e) & Causes(g, Orbits(m, e)))", "Causes(Gravity, Orbits(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbits(moon, earth))", "Cause(gravity, Orbits(moon, earth))", "Causes(gravity, Orbit(moon, earth))"]}
{"id": "entailmentbank_validation_104", "nl": "gravity causes both the orbit of the earth around the sun and the orbit of the moon around the earth.", "fol": "", "prediction": ["Causes(gravity, Orbits(earth, sun)) & Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))", "Causes(gravity, Orbits(earth, sun) & Orbits(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))", "Causes(gravity, Orbit(earth, sun)) & Causes(gravity, Orbit(moon, earth))", "Causes(gravity, (Orbits(earth, sun) & Orbits(moon, earth)))", "Causes(gravity, Orbits(earth, sun)) & Causes(gravity, Orbits(moon, earth))", "Exists g, Earth, Sun, Moon. (Gravity(g) & Causes(g, Orbit(Earth, Sun)) & Causes(g, Orbit(Moon, Earth)))", "Causes(gravity, Orbit(earth, sun)) & Causes(gravity, Orbit(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))", "Causes(gravity, Orbit(earth, sun)) & Causes(gravity, Orbit(moon, earth))", "Causes(gravity, Orbit(earth, sun) & Orbit(moon, earth))", "Causes(gravity, Orbits(earth, sun)) & Causes(gravity, Orbits(moon, earth))", "Causes(gravity, Orbit(earth, sun)) & Causes(gravity, Orbit(moon, earth))", "Causes(gravity, Orbits(earth, sun)) & Causes(gravity, Orbits(moon, earth))"]}
{"id": "entailmentbank_validation_105", "nl": "spring tide is when the distance between high tide and low tide is the greatest.", "fol": "", "prediction": ["SpringTide(x) <-> GreatestTideDistance(x)", "SpringTide() <-> GreatestDistance(HighTide, LowTide)", "SpringTide(x) <-> (GreatestDistance(HighTide(x), LowTide(x)))", "SpringTide = GreatestDistanceBetweenHighTideAndLowTide", "SpringTide(spring_tide) <-> GreatestDistance(high_tide, low_tide)", "SpringTide(x) <-> (GreatestDistanceHighLowTide(x))", "SpringTide(t) <-> GreatestDistance(HighTide(t), LowTide(t))", "", "SpringTide(x) <-> GreatestDistance(HighTide(y), LowTide(z))", "SpringTide(t) <-> GreatestDistance(HighTide(t), LowTide(t))", "SpringTide(st) <-> GreatestDistanceBetweenHighTideAndLowTide(st)", "SpringTideWhen(all y. ((HighTide(y) & LowTide(y) & GreatestDistanceBetween(y)) -> SpringTide(y)))", "SpringTideOccurs <-> GreatestDistanceBetweenTides(highTide, lowTide)", "SpringTide(x) <-> GreatestDistanceBetweenHighLowTide(x)", "SpringTide(x) <-> (Event(x) & exists y. (HighTide(y) & DistanceBetween(y, LowTide(x)) = Greatest))", "SpringTide(spring_tide) <-> GreatestTidalDistance(spring_tide)"]}
{"id": "entailmentbank_validation_106", "nl": "spring tides occur during a full moon.", "fol": "", "prediction": ["all x. (FullMoon(x) -> Occurs(SpringTide, x))", "all x. (FullMoon(x) -> Occurs(spring_tide, x))", "all x. (FullMoon(x) -> Occurs(SpringTide, x))", "all x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "FOL Translation:\nall t. (FullMoon(t) -> OccursDuring(spring_tides, t))", "all x. (FullMoon(x) -> Occurs(spring_tides, x))", "all x. (FullMoon(x) -> Occurs(spring_tides, x))", "OccursDuring(spring_tides, full_moon)", "all x. (FullMoon(x) -> OccursDuring(spring_tide, x))", "all x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "all t. (SpringTide(t) -> exists m. (FullMoon(m) & OccurDuring(t, m)))", "all x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "all x. (SpringTide(x) <-> FullMoon(y) & OccursDuring(x, y))", "FOL Translation:\nall x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "FOL Translation:\nall x. (FullMoon(x) -> SpringTideOccurs(x))", "all x. (SpringTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))"]}
{"id": "entailmentbank_validation_107", "nl": "the highest tides occur during a full moon.", "fol": "", "prediction": ["OccursDuringHighestTides(full_moon)", "all x. (FullMoon(x) -> HighestTidesOccur(x))", "exists x. (HighestTide(x) & OccurDuring(x, FullMoon))", "all t. ((HighestTide(t) & OccursDuring(t, full_moon)))", "all x. ((Tide(x) & Highest(x)) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "FOL Translation:\nall x. (FullMoon(x) -> HighestTidesOccur(x))", "all x. (HighestTide(x) -> occursDuringPhase(x, full_moon))", "all x. (FullMoon(x) -> OccurHighestTides(x))", "exists x. (Tide(x) & Highest(x) & OccursDuringFullMoon(x))", "all x. (FullMoon(x) -> OccursHighestTides(x))", "FOL Translation:\nall x. (HighestTide(x) -> exists y. (FullMoon(y) & OccursDuring(x, y)))", "all t. (HighestTide(t) -> exists m. (FullMoon(m) & OccursDuring(t, m)))", "all x. ((HighestTide(x) & OccursDuring(x, full_moon)) -> FullMoon(full_moon))", "all t. ((Tide(t) & Highest(t)) -> exists m. (FullMoon(m) & OccursDuring(t, m)))", "exists x. (Tide(x) & Highest(x) & OccursDuringFullMoon(x))", "all x. (HighestTide(x) -> OccurDuring(x, FullMoon))"]}
{"id": "entailmentbank_validation_108", "nl": "marine fossils means fossils of marine animals.", "fol": "", "prediction": ["all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimalFossil(x))", "all x. (MarineFossil(x) <-> Fossil(x) & OfMarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & BelongsTo(x, y))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(y, x))", "all x. (MarineFossil(x) <-> Fossil(x) & OfMarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(x, y))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(x, y))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & FossilOf(x, y))", "all x. (MarineFossil(x) <-> FossilOfMarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimalFossil(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(y, x))", "all x. (MarineFossil(x) <-> Fossil(x) & FossilOfMarineAnimal(x))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(y) & Of(x, y))", "all x. (MarineFossil(x) <-> Fossil(x) & MarineAnimal(x))", "all x. (MarineFossil(x) <-> FossilOfMarineAnimal(x))"]}
{"id": "entailmentbank_validation_109", "nl": "marine animals are water animals.", "fol": "", "prediction": ["all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))", "all x. (MarineAnimal(x) -> WaterAnimal(x))"]}
{"id": "entailmentbank_validation_110", "nl": "marine fossils are fossils of water animals.", "fol": "", "prediction": ["all x. (MarineFossil(x) -> exists y. (Fossil(y) & WaterAnimal(y) & Of(x, y)))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> exists y. (Fossil(x, y) & WaterAnimal(y)))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all z. (MarineFossil(z) -> exists w. (FossilOf(z, w) & WaterAnimal(w)))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all z. (MarineFossil(z) -> exists w. (FossilOf(z, w) & WaterAnimal(w)))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all x. (MarineFossil(x) -> FossilOfWaterAnimal(x))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))", "all x. (MarineFossil(x) -> exists y. (FossilOf(x, y) & WaterAnimal(y)))"]}
{"id": "entailmentbank_validation_111", "nl": "marine fossils are found in mountains.", "fol": "", "prediction": ["all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountain(x))", "all x. (MarineFossil(x) -> FoundIn(x, mountains))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> exists y. (Mountain(y) & FoundIn(x, y)))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountains(x))", "all x. (MarineFossil(x) -> FoundInMountain(x))"]}
{"id": "entailmentbank_validation_112", "nl": "fossils of water animals are found in mountains.", "fol": "", "prediction": ["exists x. (Fossil(x) & OfWaterAnimal(x) & exists y. (Mountain(y) & FoundIn(x, y)))", "exists x. (Fossils(x) & OfWaterAnimal(x) & FoundInMountain(x))", "exists x. (Fossil(x) & WaterAnimal(y) & Of(x, y) & FoundInMountains(x))", "exists x. (Fossil(x) & WaterAnimalFossil(x) & FoundInMountain(x))", "exists x. (Fossil(x) & WaterAnimalFossil(x) & FoundInMountains(x))", "exists x. (Fossil(x) & WaterAnimal(y) & Of(x, y) & Mountain(z) & FoundIn(x, z))", "exists x. (Fossil(x) & WaterAnimalFossil(x) & exists y. (Mountain(y) & FoundIn(x, y)))", "exists x. (Fossil(x) & OfWaterAnimal(x) & FoundInMountains(x))", "exists x. (Fossil(x) & WaterAnimal(x) & FoundInMountains(x))", "exists x. (Fossil(x) & OfWaterAnimal(x) & FoundInMountains(x))", "exists x. (Fossil(x) & WaterAnimal(y) & From(z, y) & Mountain(z) & FoundIn(x, z))", "exists x. (Fossil(x) & WaterAnimal(y) & Of(x, y) & Mountain(z) & FoundIn(x, z))", "exists x. (Fossil(x) & WaterAnimal(y) & FoundIn(x, mountains) & BelongsTo(x, y))", "exists x. (Fossil(x) & WaterAnimal(y) & Of(x, y) & exists z. (Mountain(z) & FoundIn(x, z)))", "exists x. (Fossil(x) & OfWaterAnimal(x) & FoundIn(x, Mountains))", "exists x. (Fossil(x) & WaterAnimal(y) & Of(x, y) & FoundInMountains(x))"]}
{"id": "entailmentbank_validation_113", "nl": "if fossils of a water animal or plant are found in a place then that place used to be covered by water in the past.", "fol": "", "prediction": ["all x. all y. ((FossilOfWaterAnimalOrPlant(y) & FoundIn(y, x)) -> WasCoveredByWaterInPast(x))", "all x y. ((Fossil(x) & (WaterAnimal(x) | Plant(x)) & FoundIn(x, y)) -> UsedToBeCoveredByWater(y))", "all x. (exists y. ((FossilOf(y, WaterAnimal) | FossilOf(y, Plant)) & FoundInPlace(y, x)) -> CoveredByWaterInPast(x))", "all x. all y. (((Fossil(x) & (WaterAnimal(x) | Plant(x))) & FoundIn(x, y)) -> CoveredByWaterInThePast(y))", "all x y. ((FossilOfWaterAnimal(x) | FossilOfPlant(y)) & FoundIn(x, z) -> CoveredByWaterInPast(z))", "all x. ((exists y. ((Fossil(y) & (WaterAnimal(y) | Plant(y))) & FoundIn(y, x))) -> CoveredByWaterInThePast(x))", "all y. ((exists x. ((WaterAnimal(x) | Plant(x)) & FossilOf(x, y))) -> UsedToBeCoveredByWater(y))", "all x. ((exists y. ((WaterAnimalFossil(y) | PlantFossil(y)) & FoundIn(y, x))) -> CoveredByWaterInThePast(x))", "exists x y. ((Fossil(x) & (WaterAnimal(x) | Plant(x)) & FoundIn(x, y)) -> CoveredByWaterInThePast(y))", "all x. ( (exists y. (FossilOfWaterAnimal(y) | FossilOfPlant(y)) & FoundIn(y, x)) -> CoveredByWaterInPast(x) )", "all x. all p. ((Fossil(x) & (WaterAnimal(x) | Plant(x)) & FoundIn(x, p)) -> CoveredByWaterInPast(p))", "all x. (exists y. ((FossilOfWaterAnimal(y) | FossilOfPlant(y)) & FoundIn(x, y)) -> CoveredByWaterInThePast(x))", "all x. ((exists y. (Fossil(y) & (WaterAnimal(y) | Plant(y)) & FoundIn(y, x))) -> CoveredByWaterInPast(x))", "all x. all y. ((FossilOfWaterAnimalOrPlant(y) & FoundIn(y, x)) -> WasCoveredByWaterInPast(x))", "all x. (exists y. ((FossilOfWaterAnimal(y) | FossilOfPlant(y)) & FoundIn(y, x)) -> CoveredByWaterInPast(x))", "all x. ((exists y. (FossilOfWaterAnimal(y) | FossilOfWaterPlant(y)) & FoundIn(y, x)) -> CoveredByWaterInPast(x))"]}
{"id": "entailmentbank_validation_114", "nl": "the mountains used to be covered by water in the past.", "fol": "", "prediction": ["Exists x. (Mountain(x) & UsedToBeCoveredByWaterInPast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "Exists x. (Mountain(x) & UsedToBeCoveredByWater(x, past))", "exists x. (Mountain(x) & CoveredByWaterInPast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "exists x. (Mountain(x) & UsedToBeCoveredByWaterInThePast(x))", "exists x. (Mountain(x) -> CoveredByWaterInPast(x))", "FOL Translation:\nall x. (Mountain(x) -> CoveredByWaterInThePast(x))", "all x. (Mountain(x) -> WasCoveredByWaterInThePast(x))", "all x. (Mountain(x) -> CoveredByWaterInPast(x))", "exists x. (Mountain(x) & UsedToBeCoveredByWaterInThePast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "exists x. (Mountain(x) & CoveredByWaterInThePast(x))", "exists x. (Mountain(x) & CoveredByWaterInPast(x))", "exists x. (Mountain(x) & CoveredByWaterInPast(x))", "PastCoveredByWater(mountains)"]}
{"id": "entailmentbank_validation_115", "nl": "a mountain is a kind of environment.", "fol": "", "prediction": ["all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "Environment(mountain)", "Mountain(m) -> Environment(m)", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))", "all x. (Mountain(x) -> Environment(x))"]}
{"id": "entailmentbank_validation_116", "nl": "if something used to be in the past then that something has changed.", "fol": "", "prediction": ["all x. (UsedToBeInThePast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInThePast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInThePast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInThePast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> HasChanged(x))", "all x. (UsedToBeInPast(x) -> Changed(x))", "all x. (UsedToBeInThePast(x) -> HasChanged(x))", "all x. (UsedToBeInThePast(x) -> HasChanged(x))"]}
{"id": "entailmentbank_validation_117", "nl": "a body of water is a kind of environment.", "fol": "", "prediction": ["all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))", "all x. (BodyOfWater(x) -> Environment(x))"]}
{"id": "entailmentbank_validation_118", "nl": "the environment has changed from a body of water to mountains.", "fol": "", "prediction": ["Exists x. (Environment(x) & ChangedFromTo(x, body_of_water, mountains))", "FOL Translation:\nChanges(environment, body_of_water, mountains)", "ChangedFromTo(environment, body_of_water, mountains)", "Change(environment, body_of_water, mountains)", "ChangedFromTo(environment, body_of_water, mountains)", "Changed(environment, body_of_water, mountains)", "\\( Exists x, y, z. (Environment(x) \\& BodyOfWater(y) \\& Mountains(z) \\& ChangedFromTo(x, y, z)) \\)", "Exists e1, e2. (Environment(e1) & Environment(e2) & ChangedFromTo(e1, e2) & BodyOfWater(e1) & Mountains(e2))", "Changed(environment, body_of_water, mountains)", "Exists e. (Environment(e) & Changed(e, water, mountains))", "ChangedFromTo(environment, body_of_water, mountains)", "Exists e, w, m. (Environment(e) & BodyOfWater(w) & Mountains(m) & ChangedFromTo(e, w, m))", "Changed(environment, body_of_water, mountains)", "Exists e, w, m. (Environment(e) & BodyOfWater(w) & Mountains(m) & ChangedFromTo(e, w, m))", "ChangedFromTo(environment, body_of_water, mountains)", "Change(environment, bodyOfWater, mountains)"]}
{"id": "entailmentbank_validation_119", "nl": "environments are found on the crustal surface of earth.", "fol": "", "prediction": ["all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all e. (Environment(e) -> FoundOnCrustalSurfaceOfEarth(e))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOf(x, earth))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOn(x, crustal_surface_earth))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all e. (Environment(e) -> FoundOnCrustalSurfaceOfEarth(e))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOfEarth(x))", "all x. (Environment(x) -> FoundOnCrustalSurfaceOf(x, earth))"]}
{"id": "entailmentbank_validation_120", "nl": "the environments on the crustal surface of earth have changed from a body of water to mountains.", "fol": "", "prediction": ["exists x, y. (EnvironmentOnCrustalSurfaceOfEarth(x) & BodyOfWater(x) & EnvironmentOnCrustalSurfaceOfEarth(y) & Mountain(y) & ChangedFromTo(x, y))", "Exists x. (Environment(x) & OnCrustalSurfaceOf(earth, x) & ChangedFromTo(x, BodyOfWater, Mountains))", "exists e. (Environment(e) & OnCrustalSurface(e, earth) & ChangedFrom(e, water) & ChangedTo(e, mountains))", "Exists x. (Environment(x) & LocatedOnCrustalSurface(x, earth) & ChangedFrom(x, BodyOfWater) & ChangedTo(x, Mountains))", "Exists x. (Environment(x) & OnCrustalSurfaceOf(earth, x) & ChangedFrom(x, body_of_water) & ChangedTo(x, mountains))", "exists x, y. (CrustalSurface(x) & Environment(y) & OnSurface(y, x) & BodyOfWater(y) & ChangedTo(y, Mountains) & Earth(x))", "exists e, c, w, m. (EnvironmentOnCrustalSurface(e, earth) & BodyOfWater(w) & Mountains(m) & ChangedFromTo(e, w, m))", "all e. (Environment(e) & OnCrustalSurfaceOf(earth, e) & Was(e, BodyOfWater) -> ChangedTo(e, Mountains))", "```\nChanged(environment_on_crustal_surface_of_earth, body_of_water, mountains)\n```", "exists x. (Environment(x) & OnCrustalSurface(x, earth) & ChangedFromTo(x, body_of_water, mountains))", "Exists e1, e2. (CrustalSurfaceOf(earth) & IsEnvironmentOn(e1, CrustalSurfaceOf(earth)) & IsEnvironmentOn(e2, CrustalSurfaceOf(earth)) & HasChangedFromTo(e1, BodyOfWater, e2, Mountains))", "`Change(Environment(CrustalSurface(Earth)), BodyOfWater, Mountains)`", "To translate the sentence \"the environments on the crustal surface of earth have changed from a body of water to mountains\" into FOL, we can break it down as follows:\n\n- Let `EnvironmentsOnCrust(x)` represent environments on the crustal surface of Earth.\n- Let `ChangedFromWaterToMountains(x)` represent the change from a body of water to mountains.\n\nNow we can express the sentence in FOL:\n\nexists x. (EnvironmentsOnCrust(x) & ChangedFromWaterToMountains(x))", "exists e. (EnvironmentOnCrustalSurfaceOf(earth, e) & ChangedFrom(e, body_of_water) & ChangedTo(e, mountains))", "``` \nexists e1. exists e2. exists t1. exists t2. \n    (Environment(e1) & OnCrustalSurface(e1, earth) & IsBodyOfWater(e1, t1)) \n    & (Environment(e2) & OnCrustalSurface(e2, earth) & IsMountain(e2, t2) & After(t2, t1))\n```", "exists e1, e2. (EnvironmentOnCrustalSurfaceOf(earth, e1) & BodyOfWater(e1) & EnvironmentOnCrustalSurfaceOf(earth, e2) & Mountains(e2) & ChangedFromTo(e1, e2))"]}
{"id": "entailmentbank_validation_121", "nl": "organisms remains can be preserved in sedimentary rock.", "fol": "", "prediction": ["all x. (Remains(x) & Preserved(x) -> exists y. (Organism(x) & SedimentaryRock(y) & In(y, x)))", "exists x. exists y. (RemainsOfOrganism(x) & SedimentaryRock(y) & CanBePreservedIn(x, y))", "all x. (Remains(x) & Preserved(x) -> exists y. (Organism(y) & SedimentaryRock(z) & PreservedIn(x, z)))", "all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "all x. (RemainsOfOrganism(x) -> exists y. (SedimentaryRock(y) & PreservedIn(x, y)))", "all x. (RemainsOfOrganism(x) -> exists y. (SedimentaryRock(y) & PreservedIn(x, y)))", "all x. (RemainsOfOrganism(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "exists x. (OrganismRemains(x) & exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "FOL Translation:\nall x. (Remains(x) & Organism(x) -> exists y. (PreservedIn(x, y) & SedimentaryRock(y)))", "all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & PreservedIn(x, y)))", "all x. ((Organism(x) & PreservedRemains(x)) -> exists y. (SedimentaryRock(y) & PreservedIn(x, y)))", "all x. (Organism(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "all x. (OrganismRemains(x) -> exists y. (SedimentaryRock(y) & CanBePreservedIn(x, y)))", "Exists x. (OrganismRemains(x) & PreservedInSedimentaryRock(x))"]}
{"id": "entailmentbank_validation_122", "nl": "fossils are the remains of organisms or part of organisms.", "fol": "", "prediction": ["all x. (Fossil(x) -> (exists y. (RemainsOf(x, y) & Organism(y)) | exists z. (PartOf(x, z) & Organism(z))))", "all x. (Fossil(x) -> (exists y. (Organism(y) & RemainOf(x, y)) | exists z. (PartOfOrganism(z) & RemainOf(x, z))))", "all x. (Fossil(x) -> exists y. (Organism(y) & (RemainsOf(x, y) | PartOf(y, x))))", "all x. (Fossil(x) -> (exists y. (RemainsOf(x, y) & Organism(y)) | exists z. (PartOfOrganism(x, z))))", "all x. (Fossil(x) -> exists y. (RemainsOf(x, y) & (Organism(y) | PartOfOrganism(y))))", "all x. (Fossil(x) -> (exists y. (Organism(y) & RemainsOf(x, y)) | exists z. (PartOfOrganism(z) & RemainsOf(x, z))))", "all x. (Fossil(x) -> (exists y. (RemainsOf(x, y) & Organism(y)) | exists z. (PartOfOrganism(x, z) & Organism(z))))", "all x. (Fossil(x) -> (exists y. (Organism(y) & RemainsOf(x, y)) | exists z. (PartOfOrganism(z) & RemainsOf(x, z))))", "all x. (Fossil(x) -> (exists y. (Remains(x, y) & (Organism(y) | PartOfOrganism(y)))))", "all x. (Fossil(x) -> exists y. (Organism(y) & (RemainsOf(x, y) | PartOfOrganism(x, y))))", "all x. (Fossil(x) -> exists y. (RemainsOf(x, y) & (Organism(y) | PartOfOrganism(y))))", "all x. (Fossil(x) -> exists y. (Organism(y) & (RemainsOf(x, y) | PartOf(y, x))))", "all x. (Fossil(x) -> exists y. (RemainsOf(x, y) & (Organism(y) | PartOfOrganism(y))))", "all x. (Fossil(x) -> (exists y. (Organism(y) & RemainsOf(x, y)) | exists z. (PartOfOrganism(z) & RemainsOf(x, z))))", "all x. (Fossil(x) -> exists y. ((RemainsOf(x, y) & Organism(y)) | PartOfOrganism(x, y)))", "all x. (Fossil(x) -> exists y. (Organism(y) & (RemainsOf(x, y) | PartOfOrganism(x, y))))"]}
{"id": "entailmentbank_validation_123", "nl": "fossils are mostly found in sedimentary rock.", "fol": "", "prediction": ["all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> MostlyFoundIn(x, sedimentary_rock))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundInMostly(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundInMostly(x, y)))", "The sentence \"fossils are mostly found in sedimentary rock\" can be translated into first-order logic with a focus on the phrase \"mostly found.\" In FOL, \"mostly\" is not directly expressible, so we interpret it as \"typically\" or \"often,\" focusing on the relation \"found in sedimentary rock\" for fossils. The translation looks like:\n\nall x. (Fossil(x) -> OftenFoundIn(x, SedimentaryRock))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & MostlyFoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "exists y. (all x. (Fossil(x) -> FoundIn(x, y) & SedimentaryRock(y)))"]}
{"id": "entailmentbank_validation_124", "nl": "a mineral usually has a crystal structure.", "fol": "", "prediction": ["all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> Usually_HasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "FOL Translation:\nall x. (Mineral(x) -> Usually(CrystalStructure(x)))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "exists y. (Mineral(y) -> HasCrystalStructure(y))", "all x. (Mineral(x) -> HasCrystalStructure(x))", "exists x. (Mineral(x) & UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))", "all x. (Mineral(x) -> UsuallyHasCrystalStructure(x))"]}
{"id": "entailmentbank_validation_125", "nl": "a quartz is made of six-sided transparent crystals.", "fol": "", "prediction": ["all x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y)))", "all x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y)))", "all x. (Quartz(x) -> exists y. (SixSided(y) & Transparent(y) & Crystal(y) & MadeOf(x, y)))", "all x. (Quartz(x) -> exists y. (SixSidedCrystal(y) & Transparent(y) & MadeOf(x, y)))", "all x. (Quartz(x) -> exists y. (SixSided(y) & Transparent(y) & Crystal(y) & MadeOf(x, y)))", "Quartz(x) -> exists y. (MadeOf(x, y) & SixSided(y) & Transparent(y) & Crystal(y))", "all x. (Quartz(x) -> exists y. (Crystal(y) & MadeOf(x, y) & HasSixSides(y) & Transparent(y)))", "all z. (Quartz(z) -> exists x. (Crystal(x) & SixSided(x) & Transparent(x) & MadeOf(z, x)))", "Quartz(x) -> MadeOfSixSidedTransparentCrystals(x)", "exists x. (Quartz(x) & MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y))", "FOL Translation:\nall x. (Quartz(x) -> exists y. (MadeOf(x, y) & Crystal(y) & SixSided(y) & Transparent(y)))", "all x. (Quartz(x) -> exists y. (Crystal(y) & SixSided(y) & Transparent(y) & MadeOf(x, y)))", "exists x. (Quartz(x) -> exists y. (MadeOf(x, y) & SixSided(y) & Transparent(y) & Crystal(y)))", "all x. (Quartz(x) -> exists y. (MadeOf(x, y) & SixSided(y) & Transparent(y) & Crystal(y)))", "all x. (Quartz(x) -> exists y. (SixSided(y) & Transparent(y) & MadeOf(x, y) & Crystal(y)))", "exists x. (Quartz(x) & MadeOf(x, z) & all y. (PartOf(y, z) -> (SixSided(y) & Transparent(y) & Crystal(y))))"]}
{"id": "entailmentbank_validation_126", "nl": "quartz is a kind of mineral.", "fol": "", "prediction": ["Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "KindOf(quartz, mineral)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)", "Mineral(quartz)"]}
{"id": "entailmentbank_validation_127", "nl": "different classes of rocks are formed by different methods.", "fol": "", "prediction": ["all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all c. (RockClass(c) -> exists m. (FormationMethod(m) & FormedBy(c, m)))", "all x. (ClassOfRocks(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all c. all m. ((ClassOfRocks(c) & Method(m)) -> FormedBy(c, m))", "all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (ClassOfRock(x) -> exists y. (Method(y) & FormedBy(x, y)))", "all x. (RockClass(x) -> exists y. (FormationMethod(y) & FormedBy(x, y)))", "all x. (Rock(x) -> exists y. (ClassOfRock(x, y) & exists z. (Method(z) & FormedBy(x, z))))"]}
{"id": "entailmentbank_validation_128", "nl": "class is a measure of how a rock is formed.", "fol": "", "prediction": ["MeasureOf(class, FormationProcessOf(rock))", "MeasureOfFormation(class, rock)", "MeasureOfFormation(rock, class)", "MeasureOfFormation(class, rock)", "Measure(class, FormationMethod(rock))", "Measure(class, how_rock_formed)", "MeasureFormed(rock, class)", "Class(rock, measureOfFormation)", "Measure(class, FormationOfRock)", "MeasureOfFormation(class, rock)", "Measure(class, FormationMethod(rock))", "Measure(class, FormationProcess(rock))", "Measure(class, HowRockIsFormed)", "all x. (Rock(x) -> exists y. (Class(y) & MeasuresFormationOf(y, x)))", "MeasureOfFormation(class, rock)", "MeasureOfFormation(class, rock)"]}
{"id": "entailmentbank_validation_129", "nl": "the method by which a rock is formed can be used to classify rocks.", "fol": "", "prediction": ["all x. (Rock(x) & exists y. (MethodOfFormation(x, y) -> CanClassifyUsing(y, x)))", "all x. (Rock(x) & MethodOfFormation(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) -> exists y. (Method(y) & IsFormedBy(x, y) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & FormedByMethod(m) -> CanBeClassifiedByMethod(x, m))", "all x. (Rock(x) & MethodOfFormation(x, y) -> CanBeUsedToClassify(x))", "all x. (Rock(x) & FormedBy(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) -> exists y. (Method(y) & UsedToClassify(x, y) & Forms(x, y)))", "all x. (Rock(x) -> exists y. (MethodOfFormation(y, x) -> CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & FormedByMethod(x, y) -> CanUseToClassify(x, y))", "all x. (Rock(x) & MethodOfFormation(x, m) -> CanBeUsedToClassify(m, x))", "all x. (Rock(x) -> exists y. (MethodOfFormation(y, x) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & MethodOfFormation(x, y) -> CanBeUsedToClassify(x, y))", "all x. (Rock(x) -> exists y. (FormationMethod(x, y) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) -> exists y. (MethodOfFormation(x, y) & CanBeUsedToClassifyRocks(y)))", "all x. ((Rock(x) & FormedByMethod(x, y)) -> CanBeUsedToClassify(x, y))", "all x. (Rock(x) -> exists y. (MethodOfFormation(y) & CanBeUsedToClassify(y, x)))"]}
{"id": "entailmentbank_validation_130", "nl": "the origin of a rock means the method by which a rock is formed.", "fol": "", "prediction": ["all x. (Rock(x) -> (OriginOf(x) <-> MethodByWhichFormed(x)))", "all x. (Rock(x) -> (exists y. (OriginMethod(y, x) <-> FormedByMethod(x, y))))", "all x. (Rock(x) -> (Origin(x) <-> MethodFormation(x)))", "all x. (Rock(x) -> (Origin(x) <-> MethodByWhichFormed(x)))", "all x. (OriginOf(x, rock) <-> MethodByWhichFormed(x, rock))", "all x. (Rock(x) -> (Origin(x) <-> MethodOfFormation(x)))", "all x. (Rock(x) -> (Origin(x) <-> MethodOfFormation(x)))", "all x. (Rock(x) -> (Origin(x) <-> MethodByWhichFormed(x)))", "all x. (Rock(x) -> (OriginOf(x) <-> MethodOfFormation(x)))", "all x. (Rock(x) -> (exists y. (Origin(x, y) <-> MethodByWhichFormed(x, y))))", "all x. (Origin(x) & Rock(x) -> Method(x) & Formed(x))", "all x. (Rock(x) -> exists y. (Origin(y, x) <-> MethodOfFormation(y, x)))", "all x. (Rock(x) -> (OriginOf(x, m) <-> MethodOfFormation(x, m)))", "all x. (Rock(x) -> (Origin(x) <-> MethodOfFormation(x)))", "all x. (Rock(x) -> exists y. (Origin(x, y) <-> MethodOfFormation(y, x)))", "all x. (Rock(x) -> (exists y. (OriginOf(x, y) & Method(y) & Forms(x, y)) <-> Means(x, y)))"]}
{"id": "entailmentbank_validation_131", "nl": "the origin of rocks can be used to classify rocks.", "fol": "", "prediction": ["all x. (Rock(x) & OriginOf(x, y) -> CanBeUsedToClassify(x))", "all x. (Rock(x) -> exists y. (OriginOf(y, x) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & OriginOf(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) -> exists y. (Origin(y, x) & CanBeUsedToClassify(y, x)))", "all x. ((RockOrigin(x) & Rock(x)) -> CanBeUsedToClassify(x))", "all x. (Rock(x) & OriginOf(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) & Origin(x, y) -> CanBeUsedToClassify(x, y))", "all x. (Rock(x) & Origin(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) & OriginOf(x, y) -> CanBeUsedToClassify(y, x))", "all x. (Rock(x) -> exists y. (OriginOf(y, x) & CanBeUsedToClassify(y, x)))", "exists x. (OriginOf(x, rocks) & CanBeUsedToClassify(x, rocks))", "all x. (Rock(x) -> exists y. (OriginOf(y, x) & CanBeUsedToClassify(y, x)))", "all x. (Rock(x) & Origin(x, y) -> CanUseToClassify(x, y))", "all x. ((Rock(x) & OriginOf(x, y)) -> CanBeUsedToClassify(y, x))", "all x. (RockOrigin(x) -> CanBeUsedToClassify(x, Rock(x)))", "all x. (Rock(x) -> (exists y. (Origin(y) & IsOriginOf(y, x) & CanBeUsedToClassify(y, x))))"]}
{"id": "entailmentbank_validation_132", "nl": "rock formation can be used to study the history of rocks on earth.", "fol": "", "prediction": ["exists x. (RockFormation(x) & CanBeUsedToStudy(x, HistoryOf(Rock, earth)))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudy(x, HistoryOfRocksOnEarth))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistory(x, rocks, earth))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "exists x. (RockFormation(x) & CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "exists x. (RockFormation(x) & CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "all x. (RockFormation(x) -> CanBeUsedToStudyHistoryOfRocksOnEarth(x))", "exists x. (RockFormation(x) & CanBeUsedToStudy(x, HistoryOfRocksOnEarth))", "all x. (RockFormation(x) & OnEarth(x) -> CanBeUsedToStudyHistoryOfRocks(x))", "exists x. (RockFormation(x) & CanBeUsedToStudy(x, HistoryOfRocksOnEarth))"]}
{"id": "entailmentbank_validation_133", "nl": "the formation of something is a kind of process.", "fol": "", "prediction": ["all x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "all x. (FormationOf(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "exists x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))", "exists x. exists y. (FormationOf(x, y) -> KindOfProcess(x))", "exists x. exists y. (Formation(x) & Something(y) & KindOf(x, Process))", "exists x. (FormationOf(x) -> Process(x))", "all x. (FormationOf(x) -> KindOf(x, process))", "exists x. (Formation(x) -> Process(x))", "all x. (FormationOf(x) -> KindOfProcess(x))", "all x. (Formation(x) -> Process(x))", "all x. (Formation(x) -> Process(x))"]}
{"id": "entailmentbank_validation_134", "nl": "studying rock formations can mean studying the history and processes of earth.", "fol": "", "prediction": ["all x. (RockFormation(x) -> (CanMean(Studying(x), Studying(HistoryOfEarth)) & CanMean(Studying(x), Studying(EarthProcesses))))", "all x. (RockFormation(x) & Studying(x) -> (StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x)))", "all x. (RockFormation(x) & Studying(x) -> Studying(HistoryOfEarth) & Studying(ProcessesOfEarth))", "all x. (RockFormation(x) & Studies(x) -> StudiesHistoryOfEarth(x) & StudiesProcessesOfEarth(x))", "exists x. (Studying(x) & RockFormations(x) -> (StudiesHistoryOfEarth(x) & StudiesProcessesOfEarth(x)))", "exists x, y. (RockFormation(x) & Studying(x) & HistoryAndProcessesOfEarth(y) & Mean(Studying(x), Studying(y)))", "exists x. (Studying(x) & RockFormations(x) -> exists y. (Studying(y) & HistoryOfEarth(y) & ProcessesOfEarth(y)))", "FOL Translation:\nall x. (RockFormation(x) & Studying(x) -> StudyingHistory(x) & StudyingProcessesOfEarth(x))", "FOL Translation:\nall x. (Studying(x) & RockFormation(x) -> (Studying(x) & HistoryOfEarth(x) & ProcessesOfEarth(x)))", "all x. (RockFormation(x) -> (Studying(x) -> (exists y. (History(y) & OfEarth(y) & Studying(y)) & exists z. (Process(z) & OfEarth(z) & Studying(z)))))", "all x. (StudyingRockFormations(x) -> (MeansStudying(x, HistoryOfEarth) & MeansStudying(x, ProcessesOfEarth)))", "all x. (RockFormation(x) & Studying(x) -> StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x))", "all x. (RockFormation(x) & Studying(x) -> StudyingHistoryAndProcessesOfEarth(x))", "CanMean(StudyingRockFormations, StudyingHistoryAndProcessesOfEarth)", "exists x. (Studying(x) & RockFormation(x) -> (Studying(HistoryOfEarth) & Studying(ProcessesOfEarth)))", "exists x, y. (Studying(x) & RockFormation(y) & Means(x, Studying(history)) & Means(x, Studying(processesOfEarth)))"]}
{"id": "entailmentbank_validation_135", "nl": "structural geologists study rock formations.", "fol": "", "prediction": ["all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))", "all x. (StructuralGeologist(x) -> exists y. (RockFormation(y) & Studies(x, y)))"]}
{"id": "entailmentbank_validation_136", "nl": "structural geologists study the history and processes of earth.", "fol": "", "prediction": ["all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, historyAndProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, earth_history) & Studies(x, earth_processes))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, EarthHistory) & Studies(x, EarthProcesses))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (StructuralGeologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))"]}
{"id": "entailmentbank_validation_137", "nl": "how earth's environment changed is a part of the history of earth's environment.", "fol": "", "prediction": ["PartOf(ChangesInEnvironment(earth), HistoryOfEnvironment(earth))", "PartOf(HowChanged(earth_environment), History(earth_environment))", "PartOf(HowChangedEnvironment(earth), History(ChangeEnvironment(earth)))", "PartOf(HowChanged(earth_environment), History(earth_environment))", "PartOf(HowChanged(earth_environment), History(earth_environment))", "PartOf(HistoryOfChanges(earthEnvironment), HistoryOf(earthEnvironment))", "PartOf(HowChanged(environment_earth), History(environment_earth))", "PartOf(HowChanged(EarthEnvironment), History(EarthEnvironment))", "PartOf(ChangeOfEnvironment(earth), HistoryOfEnvironment(earth))", "PartOf(How(EarthEnvironmentChanged), HistoryOf(EarthEnvironment))", "PartOf(ChangeOfEnvironment(earth), HistoryOfEnvironment(earth))", "PartOf(HowChanged(earthEnvironment), History(earthEnvironment))", "PartOf(HowChanged(earth_env), HistoryOf(earth_env))", "FOL Translation:\nPartOf(HowEnvironmentChanged(earth), HistoryOfEnvironment(earth))", "PartOf(HowEnvironmentChanged(earth), HistoryOf(Environment(earth)))", "PartOf(HowChanged(EarthEnvironment), History(EarthEnvironment))"]}
{"id": "entailmentbank_validation_138", "nl": "fossils can be used to study the history of organisms and environments on earth.", "fol": "", "prediction": ["all x. (Fossil(x) -> CanBeUsedToStudy(x, HistoryOfOrganismsAndEnvironmentsOnEarth))", "all x. (Fossil(x) -> (CanBeUsedToStudyHistoryOfOrganisms(x) & CanBeUsedToStudyHistoryOfEnvironments(x)))", "exists x. (Fossil(x) -> CanBeUsedToStudy(x, HistoryOf(OrganismsOnEarth)) & CanBeUsedToStudy(x, HistoryOf(EnvironmentsOnEarth)))", "exists x. (Fossil(x) -> (CanBeUsedToStudy(x, HistoryOfOrganisms) & CanBeUsedToStudy(x, HistoryOfEnvironments) & OnEarth(x)))", "all x. (Fossil(x) -> (CanBeUsedToStudyHistory(x, organisms) & CanBeUsedToStudyHistory(x, environments) & OnEarth(x)))", "all x. (Fossil(x) -> CanBeUsedToStudy(x, History(Organisms)) & CanBeUsedToStudy(x, History(Environments)) & OnEarth)", "all x. (Fossil(x) -> CanBeUsedToStudyHistoryOf(x, organisms) & CanBeUsedToStudyHistoryOf(x, environments) & OnEarth(x))", "FOL Translation:\nall x. (Fossil(x) -> CanBeUsedToStudyHistoryOfOrganismsAndEnvironmentsOnEarth(x))", "exists x. (Fossil(x) & CanBeUsedToStudy(x, HistoryOfOrganisms) & CanBeUsedToStudy(x, HistoryOfEnvironments) & OnEarth(x))", "all x. (Fossil(x) -> CanBeUsedToStudyHistory(x, organisms) & CanBeUsedToStudyHistory(x, environments) & LocatedOn(x, earth))", "all x. (Fossil(x) -> (CanBeUsedToStudyHistoryOfOrganismsAndEnvironments(x) & OnEarth(x)))", "FOL Translation:\nall x. (Fossil(x) -> (CanBeUsedToStudyHistoryOfOrganisms(x) & CanBeUsedToStudyHistoryOfEnvironments(x) & OnEarth(x)))", "all x. (Fossil(x) -> CanBeUsedToStudy(x, HistoryOf(Organisms)) & CanBeUsedToStudy(x, HistoryOf(Environments)) & On(earth))", "all x. (Fossil(x) -> CanBeUsedToStudy(Fossil(x), HistoryOf(Organisms, Environments, Earth)))", "all x. (Fossil(x) -> (CanBeUsedToStudyHistoryOfOrganisms(x) & CanBeUsedToStudyHistoryOfEnvironments(x)))", "all x. (Fossil(x) -> CanBeUsedToStudy(x, HistoryOfOrganisms) & CanBeUsedToStudy(x, HistoryOfEnvironments) & On(x, Earth))"]}
{"id": "entailmentbank_validation_139", "nl": "studying fossils in rock formations can mean studying the history and processes of earth.", "fol": "", "prediction": ["all x. (StudyingFossilsInRockFormations(x) -> CanMean(x, StudyingHistoryAndProcessesOfEarth))", "exists x. (Studying(x) & Fossils(x) & InRockFormations(x) -> exists y. (Studying(y) & HistoryOfEarth(y) & ProcessesOfEarth(y)))", "exists x. (Fossils(x) & InRockFormations(x) -> Means(Study(x), Study(HistoryAndProcessesOfEarth)))", "exists x. (Fossil(x) & exists y. (RockFormation(y) & In(x, y))) -> CanMean(Studying(x, y), StudyingHistoryAndProcessesOfEarth)", "all x. ((Fossil(x) & InRockFormation(x)) -> CanMean(Studying(x), Studying(HistoryAndProcessesOfEarth)))", "exists x. (Studying(x) & FossilsInRockFormations(x) -> MeansStudying(x, HistoryAndProcessesOfEarth))", "all x. ((Studying(x) & Fossils(x) & InRockFormations(x)) -> (Studying(x) & HistoryOfEarth(x) & ProcessesOfEarth(x)))", "exists x. (Fossil(x) & exists y. (RockFormation(y) & StudiesIn(x, y))) -> StudiesHistoryAndProcessesOf(earth)", "exists x. (Fossil(x) & RockFormationContains(x) -> StudyHistoryAndProcessesOfEarth(x))", "exists x. exists y. (Studying(x, Fossils) & In(y, RockFormations) & Means(x, Studying(HistoryProcesses(Earth))))", "all x. ((Fossil(x) & InRockFormation(x)) -> Means(Studying(x), StudyingHistoryAndProcessesOfEarth))", "all x. ((StudyingFossilsInRockFormations(x)) -> (StudyingHistoryOfEarth(x) & StudyingProcessesOfEarth(x)))", "all x y. ((Fossil(x) & RockFormation(y) & In(x, y)) -> CanMean(Studying(x, y), Studying(HistoryOfEarth) & Studying(ProcessesOfEarth)))", "all x. ((Fossil(x) & InRockFormation(x) & Studying(x)) -> StudyingHistoryProcessesEarth(x))", "FOL Translation:\nall x. ((Fossil(x) & InRockFormation(x)) -> CanMeanStudyingHistoryAndProcessesOfEarth(x))", "all x. ((Fossils(x) & InRockFormations(x) & Studying(x)) -> StudyingHistoryAndProcessesOfEarth(x))"]}
{"id": "entailmentbank_validation_140", "nl": "paleontologists study fossils in rock formations.", "fol": "", "prediction": ["all x. (Paleontologist(x) -> exists y. exists z. (Fossil(y) & RockFormation(z) & Studies(x, y, z)))", "all x. (Paleontologist(x) -> exists y exists z. (Fossil(y) & RockFormation(z) & Studies(x, y, z)))", "all x. (Paleontologist(x) -> exists y. exists z. (Fossil(y) & RockFormation(z) & Studies(x, y) & In(y, z)))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & RockFormation(z) & In(y, z) & Studies(x, y)))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & In(y, z) & Studies(x, y))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & Studies(x, y, z))))", "all x. (Paleontologist(x) -> exists y. exists z. (Fossil(y) & InRockFormation(z) & Studies(x, y, z)))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & Studies(x, y) & In(y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & Studies(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))", "all x. (Paleontologist(x) -> exists y. (Fossil(y) & exists z. (RockFormation(z) & StudiesIn(x, y, z))))"]}
{"id": "entailmentbank_validation_141", "nl": "paleontologists study the history and processes of earth.", "fol": "", "prediction": ["all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, EarthProcesses))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, history_of_earth) & Studies(x, processes_of_earth))", "all x. (Paleontologist(x) -> Studies(x, HistoryEarth) & Studies(x, ProcessesEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, history_of_earth) & Studies(x, processes_of_earth))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, history_of_earth) & Studies(x, processes_of_earth))", "all x. (Paleontologist(x) -> Studies(x, EarthHistoryProcesses))", "all x. (Paleontologist(x) -> Studies(x, HistoryOfEarth) & Studies(x, ProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. (Paleontologist(x) -> Studies(x, history_of_earth) & Studies(x, processes_of_earth))"]}
{"id": "entailmentbank_validation_142", "nl": "structural geologists and paleontologists both study the history and processes of earth.", "fol": "", "prediction": ["all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryOfEarth(x) & StudiesProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, history_of_earth) & Studies(x, earth_processes))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, EarthHistory) & Studies(x, EarthProcesses))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, HistoryAndProcessesOfEarth))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> StudiesHistoryAndProcessesOfEarth(x))", "all x. ((StructuralGeologist(x) | Paleontologist(x)) -> Studies(x, HistoryProcessesOfEarth))"]}
{"id": "entailmentbank_validation_143", "nl": "metamorphic rocks do not contain fossils.", "fol": "", "prediction": ["all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossil(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))", "all x. (MetamorphicRock(x) -> -ContainsFossils(x))"]}
{"id": "entailmentbank_validation_144", "nl": "nearly all fossils are found in sedimentary rock.", "fol": "", "prediction": ["all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "all x. (Fossil(x) & FoundInSedimentaryRock(x))", "all x. (Fossil(x) -> exists y. (SedimentaryRock(y) & FoundIn(x, y)))", "all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "most x. (Fossil(x) -> FoundIn(x, sedimentary_rock))", "all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "all x. (Fossil(x) & -RarelyFound(x) -> FoundInSedimentaryRock(x))", "all x. ((Fossil(x) & FoundInSedimentaryRock(x)) | (Fossil(x) & -FoundInSedimentaryRock(x)))", "all x. (Fossil(x) & -FoundInSedimentaryRock(x) -> Rare(x))", "all x. (Fossil(x) -> FoundInSedimentaryRock(x)) & exists y. (Fossil(y) & -FoundInSedimentaryRock(y))", "To translate the sentence \"nearly all fossils are found in sedimentary rock\" into first-order logic, we note the use of \"nearly all,\" which suggests a majority without clear logical quantification in standard FOL. However, we'll represent the main logical relationship, focusing on the condition involving fossils and sedimentary rock:\n\nFOL Translation:\nall x. (Fossil(x) -> FoundInSedimentaryRock(x)) & exists y. (Fossil(y) & -FoundInSedimentaryRock(y))", "all x. (Fossil(x) -> FoundInSedimentaryRock(x))", "To express \"nearly all fossils are found in sedimentary rock\" in first-order logic, we can define predicates:\n\n- `Fossil(x)`: x is a fossil.\n- `FoundInSedimentaryRock(x)`: x is found in sedimentary rock.\n\nAlthough first-order logic does not handle \"nearly all\" directly, we can approximate it by asserting its meaning in natural language, using existential and universal quantifiers.\n\nFOL Translation:\n    \nall x. (Fossil(x) -> FoundInSedimentaryRock(x))", "To represent \"nearly all fossils are found in sedimentary rock\" in first-order logic, we first interpret \"nearly all\" as a case where for any given fossil, it is highly likely to be found in sedimentary rock. This involves representing \"being found in sedimentary rock\" as a predicate and does not conventionally fall into strict FOL due to the probabilistic nature of \"nearly all\", which is more accurately represented in probabilistic logic or natural language understanding frameworks.\n\nHowever, to stay within classical first-order logic, we make an approximation by implying it using universal quantification that closely aligns with the universal case:\n\nFOL Translation (approximation):\nall x. (Fossil(x) -> FoundInSedimentaryRock(x))\n\nThis reflects the idea that being found in sedimentary rock is a usual condition for fossils, although, technically, such expressions don't capture the probabilistic aspect of \"nearly all\".", "The sentence \"nearly all fossils are found in sedimentary rock\" implies that most, but not necessarily all, fossils are found in sedimentary rock. While first-order logic isn't inherently equipped to handle quantifiers like \"nearly all,\" it can be estimated using universally quantified implications for the predominant cases and recognizing exceptions or special cases.\n\nThis will be handled by a FOL approximation:\n\n`all x. (Fossil(x) & NotException(x) -> FoundInSedimentaryRock(x))`\n\nHere, `NotException(x)` represents the subset of fossils that do follow the generalization in the main assertion.", "all x. (Fossil(x) -> FoundIn(x, sedimentary_rock))"]}
{"id": "entailmentbank_validation_145", "nl": "fossils are lost / destroyed when sedimentary rock changes to metamorphic rock.", "fol": "", "prediction": ["all z. (Fossil(z) & ChangesToSedimentary(isPartOf(z, SedimentaryRock(z)), MetamorphicRock) -> Lost(z) | Destroyed(z))", "all x. (Fossil(x) & ChangesTo(SedimentaryRock(x), MetamorphicRock) -> (Lost(x) | Destroyed(x)))", "all x. (SedimentaryRock(x) & ChangesTo(x, MetamorphicRock) -> (exists y. (Fossil(y) & In(x, y)) -> (Lost(y) | Destroyed(y))))", "all x. (Fossil(x) & SedimentaryRock(y) & MetamorphicRock(z) & ChangesTo(y, z) -> LostOrDestroyed(x))", "all z. ((SedimentaryRock(z) & ChangesToMetamorphicRock(z)) -> -exists y. (Fossil(y) & Contains(z, y)))", "all x. (Fossil(x) & SedimentaryRock(y) & MetamorphicRock(z) & ChangesTo(y, z) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & ChangesTo(sedimentary_rock, metamorphic_rock) -> LostOrDestroyed(x))", "all x. ((Fossil(x) & SedimentaryRockChangesToMetamorphicRock) -> (Lost(x) | Destroyed(x)))", "all x. ((Fossil(x) & SedimentaryRock(x)) & ChangesTo(x, MetamorphicRock) -> (Lost(x) | Destroyed(x)))", "all x. ((Fossil(x) & SedimentaryRock(y) & MetamorphicRock(z) & ChangesTo(y, z)) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & ChangesToSedimentaryRock(x, y) & ChangesToMetamorphicRock(y) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & ChangesToSedimentaryRock(x, metamorphic_rock) -> LostOrDestroyed(x))", "all x. ((Fossil(x) & SedimentaryRockTransformsToMetamorphic(x)) -> (Lost(x) | Destroyed(x)))", "all x. ((Fossil(x) & SedimentaryRock(y) & Contains(y, x) & ChangesTo(y, MetamorphicRock)) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & SedimentaryRock(y) & ChangesTo(y, MetamorphicRock(z)) -> (Lost(x) | Destroyed(x)))", "all x. (Fossil(x) & SedimentaryRock(y) & MetamorphicRock(z) & ChangesTo(y, z) -> (Lost(x) | Destroyed(x)))"]}
{"id": "entailmentbank_validation_146", "nl": "if fossils are destroyed in rock transition, then there will be gaps in the fossil record.", "fol": "", "prediction": ["all x. (FossilsDestroyedInRockTransition(x) -> GapsInFossilRecord(x))", "all x. (FossilsDestroyedInRockTransition(x) -> GapsInFossilRecord(x))", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> exists y. (GapInFossilRecord(y)))", "all x. (FossilsDestroyedInRockTransition(x) -> GapsInFossilRecord)", "all x. (DestroyedInTransition(fossils, x) -> GapsInFossilRecord)", "all x. (DestroysFossilsInTransition(x) -> GapsInFossilRecord(x))", "all x. (DestroyedInRockTransition(x) -> GapInFossilRecord(x))", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapsInFossilRecord(x))", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapsInFossilRecord)", "all x. (DestroyedInRockTransition(fossil(x)) -> GapsInFossilRecord)", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapInFossilRecord)", "all x. (Fossil(x) & DestroyedInRockTransition(x) -> GapsInFossilRecord)", "all x. (DestroyedInRockTransition(x, Fossil(x)) -> GapsInFossilRecord)", "all x. (DestroyedInRockTransition(fossils(x)) -> GapsInFossilRecord(fossils(x)))", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapInFossilRecord)", "all x. ((Fossil(x) & DestroyedInRockTransition(x)) -> GapsInFossilRecord)"]}
{"id": "entailmentbank_validation_147", "nl": "sedimentary rock changing to metamorphic rock causes gaps in the fossil record.", "fol": "", "prediction": ["all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "exists x. (SedimentaryRock(x) & ChangesToMetamorphic(x) -> Causes(x, GapsInFossilRecord))", "FOL Translation:\nall x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "exists x exists y. (SedimentaryRock(x) & MetamorphicRock(y) & ChangesTo(x, y) -> CausesGapsInFossilRecord(x, y))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "exists x. exists y. (SedimentaryRock(x) & MetamorphicRock(y) & ChangesTo(x, y) -> CausesGapsInFossilRecord(y))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "all x. ((SedimentaryRock(x) & ChangesTo(x, MetamorphicRock)) -> Causes(GapInFossilRecord, x))", "exists x, y. (SedimentaryRock(x) & MetamorphicRock(y) & ChangesTo(x, y) -> CausesGapsInFossilRecord(x, y))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapInFossilRecord(x))", "all x. (SedimentaryRock(x) & ChangesToMetamorphicRock(x) -> CausesGapsInFossilRecord(x))", "FOL Translation:\nall x. (SedimentaryRock(x) & ChangesToMetamorphic(x) -> CausesGapsInFossilRecord(x))", "exists x, y. (SedimentaryRock(x) & ChangesTo(x, y) & MetamorphicRock(y) -> CausesGapsInFossilRecord(x))", "exists x, y. (SedimentaryRock(x) & MetamorphicRock(y) & ChangesTo(x, y) -> CausesGapsInFossilRecord(y))"]}
{"id": "entailmentbank_validation_148", "nl": "heat is a kind of energy.", "fol": "", "prediction": ["KindOf(heat, energy)", "Energy(heat)", "KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)", "Kind(heat, energy)", "Energy(heat)", "Kind(heat, energy)", "KindOf(heat, energy)", "Energy(heat)", "Kind(heat, energy)", "KindOf(heat, energy)", "KindOf(heat, energy)"]}
{"id": "entailmentbank_validation_149", "nl": "metamorphic rocks are formed by rocks being exposed to extreme heat and pressure.", "fol": "", "prediction": ["all x. (MetamorphicRock(x) -> exists y. (Rock(y) & FormedByExposureToExtremeHeat(y) & FormedByExposureToPressure(y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedFrom(y, x)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeatAndPressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedByExposure(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedFrom(y, x)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedFrom(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedFrom(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedBy(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedFrom(y, x)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToHeat(y) & ExposedToPressure(y) & Formed(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToPressure(y) & FormedByExposure(x, y)))", "all x. (MetamorphicRock(x) -> exists y. (Rock(y) & ExposedToExtremeHeat(y) & ExposedToExtremePressure(y) & FormedBy(x, y)))"]}
{"id": "entailmentbank_validation_150", "nl": "heat energy can change igneous rock into metamorphic rock.", "fol": "", "prediction": ["all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeInto(x, MetamorphicRock))", "all x. (IgneousRock(x) & HeatEnergy(e) -> CanChangeInto(x, MetamorphicRock(y)))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeTo(x, MetamorphicRock) & ChangesUsing(y, x))", "all x. (IgneousRock(x) & exists y. (HeatEnergy(y) & CanChange(y, x, MetamorphicRock)))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeInto(x, MetamorphicRock(z), y))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeTo(x, MetamorphicRock(x), y))", "all x. (IgneousRock(x) -> exists y. (HeatEnergy(y) & ChangesInto(y, x, MetamorphicRock(x))))", "all x. (IgneousRock(x) -> exists y. (HeatEnergy(y) & ChangesInto(y, x, MetamorphicRock(x))))", "exists x. (HeatEnergy(x) -> (exists y. (IgneousRock(y) & exists z. (MetamorphicRock(z) & Changes(x, y, z)))))", "all x. (IgneousRock(x) & Applies(heatEnergy, x) -> ChangesTo(x, MetamorphicRock))", "all x. (IgneousRock(x) -> exists y. (HeatEnergy(y) & CanChangeInto(y, x, MetamorphicRock(x))))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeInto(x, MetamorphicRock(z)))", "all x. (IgneousRock(x) & CanChangeByHeatEnergy(x) -> MetamorphicRock(x))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeToMetamorphicRock(x, y))", "all x. (IgneousRock(x) & HeatEnergy(y) -> CanChangeTo(metamorphicRock(x)))", "exists x. exists y. (IgneousRock(x) & MetamorphicRock(y) & CanTransform(heatEnergy, x, y))"]}
{"id": "entailmentbank_validation_151", "nl": "a tree is a kind of habitat.", "fol": "", "prediction": ["Habitat(tree)", "Habitat(tree)", "Tree(x) -> Habitat(x)", "Habitat(tree)", "Habitat(tree)", "Habitat(tree)", "Tree(x) -> Habitat(x)", "all x. (Tree(x) -> Habitat(x))", "Tree(x) -> Habitat(x)", "Tree(x) -> Habitat(x)", "Habitat(tree)", "Tree(tree) -> Habitat(tree)", "Habitat(tree)", "Tree(x) -> Habitat(x)", "Habitat(tree)", "Habitat(tree)"]}
{"id": "entailmentbank_validation_152", "nl": "cutting down trees in a forest causes the number of trees to decrease in that forest.", "fol": "", "prediction": ["all f. all t1. all t2. ((Forest(f) & CuttingDownTreesIn(t1, f) & TreesIn(t2, f) & t1 = t2) -> DecreaseInNumberOfTreesIn(f))", "all f. (Forest(f) -> (exists t. (Tree(t) & In(f, t) & CuttingDown(t)) -> Decreases(NumberOfTrees(f))))", "all f. (Forest(f) & exists t. (Tree(t) & In(f, t) & CuttingDownTree(t)) -> exists n. (NumberOfTrees(f, n) & Decreases(n)))", "all f. all t. ((Forest(f) & Tree(t) & InForest(t, f) & CuttingDown(t)) -> Decreases(NumberOfTreesIn(f)))", "all f. all t1. all t2. ((Tree(t1) & Tree(t2) & InForest(t1, f) & InForest(t2, f) & CuttingDown(t1, f)) -> (Exists(x. (InForest(x, f) & -(Tree(x)))) & NumberOfTreesDecreases(f)))", "all f, n. ((Forest(f) & CutsDownTreesIn(n, f)) -> DecreasesNumberOfTreesIn(f))", "all f. (Forest(f) & exists t. (Tree(t) & In(t, f) & CuttingDown(t)) -> Decreases(NumberOfTrees(f)))", "all f. (Forest(f) & exists y. (Tree(y) & In(f, y) & CuttingDown(y)) -> Decreases(NumberOfTrees(f)))", "all f. all x. ((Tree(x) & InForest(x, f) & CutDown(x)) -> Decreases(NumberOfTrees(f)))", "all x. (Forest(x) & exists y. (Tree(y) & In(x, y) & CutsDown(y)) -> Causes(Decrease(NumberOfTrees(x)), forest))", "all x. (Forest(x) & all y. (Tree(y) & In(x, y)) & CuttingDown(x) -> DecreaseNumberOfTrees(x))", "all f. all t. ((Forest(f) & Tree(t) & In(f, t) & CutsDown(t)) -> Decreases(NumberOfTrees(f)))", "all f. (Forest(f) -> (exists t. (Tree(t) & In(f, t) & CuttingDown(t)) -> Decrease(NumberOfTrees(f))))", "all f. all t. ((Forest(f) & Tree(t) & CuttingDown(t, f)) -> DecreasesNumberOfTrees(f))", "all f. all t. ((Forest(f) & Tree(t) & IsIn(t, f) & CuttingDown(t)) -> Decreases(NumberOfTrees(f)))", "all f. all x. ((Tree(x) & InForest(x, f) & CuttingDown(x)) -> Decreases(NumberOfTrees(f)))"]}
{"id": "entailmentbank_validation_153", "nl": "cutting down trees in a forest causes the number of habitat to decrease.", "fol": "", "prediction": ["all x. (Forest(x) & CuttingDownTreesIn(x) -> CausesDecreaseInHabitats(x))", "all x. ((Forest(x) & CuttingDownTrees(x)) -> DecreasesHabitatNumber(x))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> exists y. (Habitat(y) & InForest(y) & DecreasesNumber(y)))", "all x. (Tree(x) & InForest(x) -> Causes(CuttingDown(x), Decrease(NumberOf(Habitat))))", "all f. (Forest(f) & CuttingDownTrees(f) -> DecreasesNumberOfHabitat(f))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> Decreases(NumberOfHabitat))", "all x. (Forest(x) & CuttingDownTreesIn(x) -> CausesDecrease(NumberOfHabitat(x)))", "all x. ((Tree(x) & InForest(x)) -> Causes(CuttingDown(x), Decrease(NumberHabitat)))", "all x. ((Tree(x) & InForest(x) & CuttingDown(x)) -> Decreases(NumberOfHabitat))", "all x. (Forest(x) & CuttingDownTreesIn(x) -> CausesDecreaseInHabitatNumber(x))", "all x. all y. ((Tree(x) & Forest(y) & InForest(x, y)) -> Causes(CuttingDown(x), Decrease(HabitatCount(y))))", "all x. (Tree(x) & In(aForest(x)) & CuttingDown(x) -> Causes(Decrease(habitatNumber), forest))", "FOL Translation:\nall x. (Tree(x) & InForest(x) & CutsDown(x) -> Causes(Decrease(NumberOfHabitat), x))", "exists x. (Forest(x) & all y. (Tree(y) & In(x, y) -> (CutDown(y) -> DecreaseHabitat(x))))", "all x. (CuttingDownTreesInForest(x) -> Causes(NumberOfHabitatDecreases(x)))", "all x. (Forest(x) & CuttingDownTrees(x) -> Causes(Decrease(NumberOfHabitat(x))))"]}
{"id": "entailmentbank_validation_154", "nl": "an animal requires a habitat for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "FOL Translation:\nall x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))", "FOL Translation:\nall x. (Animal(x) -> exists y. (Habitat(y) & RequiresForSurvival(x, y)))"]}
{"id": "entailmentbank_validation_155", "nl": "cutting down trees in a forest causes the number of habitat required by animals for survival to decrease.", "fol": "", "prediction": ["all f, n. ((Forest(f) & TreesInForest(f, n) & CuttingDownTreesInForest(f)) -> Decreases(NumberOfHabitatsRequiredByAnimals(f)))", "all x. (Forest(x) & CuttingDownTrees(x) -> Decreases(HabitatRequiredForSurvival(x), Animals(y)))", "all f. (Forest(f) & CuttingDownTrees(f) -> Decreases(NumberOfHabitatRequiredByAnimalsForSurvival(f)))", "all x. (Forest(x) & CuttingDownTreesIn(x) -> Decreases(NumberOfHabitatRequiredByAnimalsForSurvival(x)))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> exists y. (Habitat(y) & RequiredByAnimalsForSurvival(y) & Decreases(y)))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> exists y. (Animal(y) & RequiresHabitat(y) & Decreases(HabitatCountFor(y), Survival(y))))", "exists x. (Forest(x) & all y. (Tree(y) & In(x, y) -> CuttingDown(y) -> Decreases(HabitatRequiredForSurvivalByAnimals, x)))", "all x. ((Forest(x) & Activity(CuttingDownTrees, x)) -> Causes(Decrease(NumberOf(HabitatRequiredForSurvivalByAnimals), x)))", "all x. ((Tree(x) & InForest(x) & CutDown(x)) -> exists y. (Habitat(y) & RequiredByAnimalsForSurvival(y) & Decrease(NumberOf(y))))", "all x. all y. ((Tree(x) & InForest(x, y) & CutDown(x)) -> Decreases(HabitatNumberRequiredByAnimals(y)))", "all x y. ((Tree(x) & Forest(y) & In(x, y) & CuttingDown(x)) -> Decreases(HabitatRequired(z), ForSurvivalByAnimals(z)))", "all x. (Tree(x) & PartOfForest(x) -> -all y. (Animal(y) -> Habitat(y, NecessaryForSurvival) & Decrease(Habitat(y, NecessaryForSurvival))))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> Decreases(NumberOfHabitatRequiredByAnimalsForSurvival))", "all x. all y. ((CuttingDownTrees(x) & Forest(x) & Habitat(y) & Requires(y, AnimalsForSurvival)) -> Decreases(Number(y)))", "all x. (Tree(x) & InForest(x) & CutDown(x) -> Decreases(HabitatNumber, RequiredByAnimalsForSurvival))", "FOL Translation:\nall f, t, a. ((Forest(f) & Tree(t) & Animal(a) & CuttingDown(t, f)) -> Decreases(NumberOfHabitatRequiredByAnimalsForSurvival(a, f)))"]}
{"id": "entailmentbank_validation_156", "nl": "humans changing ecosystems usually has a negative impact on an ecosystem / organisms living in an ecosystem.", "fol": "", "prediction": ["all x. (Human(x) & ChangesEcosystem(x) -> exists y. (Ecosystem(y) & NegativeImpactOn(y)))", "all x y. ((Human(x) & ChangesEcosystem(x, y)) -> usually(NegativeImpactOn(y) & (Ecosystem(y) | exists z. (Organism(z) & LivesIn(z, y)))))", "all x. (Ecosystem(x) & HumansChanging(x) -> NegativeImpact(x))", "all x. (Human(x) & ChangeEcosystem(x) -> Usually(NegativeImpactOn(y, z) & Ecosystem(z) & OrganismLivingIn(y, z)))", "all x. (Human(x) & ChangesEcosystem(x) -> all y. (Ecosystem(y) | Organism(z) & LivesIn(z, y) -> HasNegativeImpact(x, y) | HasNegativeImpact(x, z)))", "all h, e. ((Human(h) & ChangesEcosystem(h, e)) -> exists o. (Organism(o) & LivesIn(o, e) & NegativeImpact(e)))", "all x. ((Human(x) & ChangesEcosystem(x)) -> exists y. (Ecosystem(y) & OrganismsLivingInEcosystem(y) & NegativeImpact(x, y)))", "all x. ((Human(x) & ChangesEcosystem(x)) -> usually y. (Ecosystem(y) & OrganismLivingIn(y)) (NegativeImpactOn(y) | NegativeImpactOn(z)))", "all x. ((Human(x) & ChangesEcosystem(x)) -> exists y. ((Ecosystem(y) | OrganismLivingInEcosystem(y)) & NegativeImpact(x, y)))", "all x. all y. ((Human(x) & ChangesEcosystem(x, y) & Ecosystem(y)) -> NegativeImpact(y))", "all x. ((Human(x) & ChangesEcosystem(x, y)) & Ecosystem(y)) -> (exists z. ((Organism(z) & LivesIn(z, y)) -> NegativeImpact(y, z)))", "all x. ((Human(x) & ChangesEcosystem(x)) -> exists y. (Ecosystem(y) & HasNegativeImpact(x, y) & exists z. (Organism(z) & LivesIn(z, y))))", "all x. ((Ecosystem(x) & HumanChangesEcosystem(x)) -> exists y. (Organism(y) & LivesIn(y, x) & NegativeImpactOn(y, x)))", "all x. (Ecosystem(x) -> (exists y. (Human(y) & ChangesEcosystem(y, x)) -> NegativeImpact(x)))", "all x. ((Human(x) & ChangesEcosystem(x)) -> exists y. (Ecosystem(y) & OrganismsLivingIn(y) & NegativeImpact(x, y)))", "all x. (((Human(x) & ChangesEcosystem(x)) & UsuallyHasNegativeImpact(Ecosystem(e), Organism(o))) -> (Ecosystem(e) & LivesIn(o, e)))"]}
{"id": "entailmentbank_validation_157", "nl": "humans building homes in an ecosystem causes that ecosystem to change.", "fol": "", "prediction": ["exists e. (Ecosystem(e) & exists h. (Human(h) & BuildsHomeIn(h, e) -> CausesChangeInEcosystem(e)))", "exists x, y. ((Human(x) & Ecosystem(y) & BuildsHomeIn(x, y)) -> CausesChange(y))", "all x. all y. ((Human(x) & Home(y) & BuildsInEcosystem(x, y, z) & Ecosystem(z)) -> CausesChange(z))", "all x. all y. all z. ((Human(x) & Home(y) & BuildsIn(x, y, z) & Ecosystem(z)) -> Causes(Change(z)))", "all x. all y. ((Human(x) & BuildsHomeIn(x, y) & Ecosystem(y)) -> Causes(Change(y)))", "exists x. exists y. (Human(x) & Home(y) & Builds(x, y) & InEcosystem(y, z) -> CausesChange(z))", "exists x, y, z. (Human(x) & Home(y) & Ecosystem(z) & BuildsIn(x, y, z) -> CausesChange(x, y, z))", "all x. all y. (Human(x) & Ecosystem(y) & BuildsHomesIn(x, y) -> CausesChangeTo(x, y))", "exists x. (Ecosystem(x) & exists y. (Human(y) & BuildHomesIn(y, x)) -> Causes(Change(x)))", "all x y. ((Human(x) & Ecosystem(y) & BuildsIn(x, y)) -> Causes(Change(y)))", "exists x. (Ecosystem(x) & exists y. (Human(y) & BuildsHomeIn(y, x) -> CausesChange(x)))", "exists e. ((all h. (Human(h) & BuildsHomeIn(h, e))) -> Changes(e))", "exists e. (Ecosystem(e) & all x. (Human(x) & BuildsHomeIn(x, e) -> Causes(Change(e))))", "all x. (Ecosystem(x) & exists y. (Human(y) & BuildsHomeIn(y, x)) -> Causes(Change(x)))", "exists x. exists y. exists z. (Human(x) & Home(y) & Ecosystem(z) & BuildingIn(x, y, z) -> CausesChange(z))", "all x. all y. all z. ((Human(x) & Home(y) & Ecosystem(z) & BuildsIn(x, y, z)) -> Changes(z))"]}
{"id": "entailmentbank_validation_158", "nl": "humans building homes in an ecosystem has a negative impact on an ecosystem and organisms living in the ecosystem.", "fol": "", "prediction": ["exists e. (Ecosystem(e) & exists h. (Human(h) & BuildsHomesIn(h, e) & NegativeImpactOn(h, e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(h, o))))", "exists e. exists h. exists x. (Ecosystem(e) & HumansBuildingHomesIn(h, e) & Organism(x) & LivesIn(x, e) -> NegativeImpactOn(e) & NegativeImpactOn(x))", "exists e. (Ecosystem(e) & all h. ((Human(h) & BuildsHomeIn(h, e)) -> NegativeImpactOn(e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(o))))", "exists e. (Ecosystem(e) & all h. (Human(h) & BuildsHomeIn(h, e) -> NegativelyImpacts(h, e) & exists o. (Organism(o) & LivesIn(o, e) & NegativelyImpacts(h, o))))", "exists x, y, z. (Human(x) & Ecosystem(y) & Home(z) & BuildsIn(x, z, y) -> NegativeImpactOn(y, y) & NegativeImpactOn(y, OrganismsLivingIn(y)))", "exists e. (Ecosystem(e) & exists y. (Human(y) & BuildsHomes(y, e)) & NegativeImpact(y, e) & all o. ((Organism(o) & LivesIn(o, e)) -> NegativeImpact(y, o)))", "exists x, y, z. ((Human(x) & Ecosystem(y) & HomeBuildingIn(x, y) & LivesIn(z, y)) -> NegativeImpact(HomeBuildingIn(x, y), y) & NegativeImpact(HomeBuildingIn(x, y), z))", "all e. all h. all o. ((Ecosystem(e) & Human(h) & BuildHomesIn(h, e) & LivesIn(o, e)) -> (NegativeImpactOn(h, e) & NegativeImpactOn(h, o)))", "exists e. (Ecosystem(e) & exists x. (Home(x) & BuiltByHumans(x) & In(e, x) & exists o. (Organism(o) & LivesIn(o, e) & NegativeImpact(On(e, x) & On(e, o)))))", "all e. (Ecosystem(e) -> (all x. (Human(x) & BuildsHomeIn(x, e) -> NegativeImpactOn(x, e))) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(o, e))))", "all x. all y. (Human(x) & Ecosystem(y) & BuildsHomeIn(x, y) -> exists z. (Organism(z) & LivesIn(z, y) & NegativeImpact(BuildsHomeIn(x, y), y, z)))", "all e. (Ecosystem(e) -> (exists h. (Human(h) & BuildsHomeIn(h, e)) -> (NegativeImpactOn(e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(o)))))", "exists e. (Ecosystem(e) & exists h. (Human(h) & BuildsHomeIn(h, e) & NegativeImpactOn(h, e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOn(h, o))))", "exists e. (Ecosystem(e) & exists h. (Human(h) & BuildsHomeIn(h, e)) -> NegativeImpactOnEcosystem(e) & all o. (Organism(o) & LivesIn(o, e) -> NegativeImpactOnOrganism(o)))", "exists e. (Ecosystem(e) & all x. ((Human(x) & BuildsHomeIn(x, e)) -> (NegativeImpact(e) & exists o. (Organism(o) & LivesIn(o, e) -> NegativeImpact(o)))))", "exists e. (Ecosystem(e) & all h. (Human(h) & BuildsHomeIn(h, e) -> -PositiveImpactOn(h, e) & all o. (LivesIn(o, e) -> -PositiveImpactOn(h, o))))"]}
{"id": "entailmentbank_validation_159", "nl": "a wetland is a kind of ecosystem.", "fol": "", "prediction": ["all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))", "all x. (Wetland(x) -> Ecosystem(x))"]}
{"id": "entailmentbank_validation_160", "nl": "humans building homes in a wetland has a negative impact on a wetland and organisms living in the wetland.", "fol": "", "prediction": ["exists x, y. (Human(x) & Wetland(y) & BuildsHomesIn(x, y) -> NegativeImpactOn(y) & all z. (LivesIn(z, y) -> NegativeImpactOn(z)))", "exists x. (Wetland(x) & all y. ((Human(y) & BuildsHomeIn(y, x)) -> (NegativeImpactOn(x) & NegativeImpactOnOrganismsIn(x))))", "exists x y z. (Human(x) & Home(y) & Wetland(z) & BuildsIn(x, y, z) -> NegativeImpact(y, z) & NegativeImpact(y, OrganismsLivingIn(z)))", "exists y. (Wetland(y) & all z. ((Human(z) & BuildsHomeIn(z, y)) -> (NegativeImpactOn(y) & all w. (Organism(w) & LivesIn(w, y) -> NegativeImpactOn(w)))))", "\\( \\text{all } x. (\\text{Wetland}(x) \\& \\text{exists } y. (\\text{Human}(y) \\& \\text{BuildsHomeIn}(y, x)) \\rightarrow \\text{NegativeImpact}(x) \\& \\text{exists } z. (\\text{Organism}(z) \\& \\text{LivesIn}(z, x) \\rightarrow \\text{NegativeImpact}(z))) \\)", "exists h, w, o. (Human(h) & Home(h) & BuildsIn(h, w) & Wetland(w) & LivesIn(o, w) & Organism(o) -> NegativeImpact(BuildsIn(h, w), w) & NegativeImpact(BuildsIn(h, w), o))", "Exists w, h, o. (Wetland(w) & Human(h) & BuildsHomeIn(h, w) -> NegativeImpactOn(w) & NegativeImpactOn(o) & LivesIn(o, w))", "exists w. (Wetland(w) & exists h. (Human(h) & BuildsHomeIn(h, w)) -> negativeImpactOn(w) & exists o. (Organism(o) & LivesIn(o, w) & negativeImpactOn(o))))", "all x. ((Human(x) & BuildsHome(x, wetland) & Wetland(wetland)) -> (NegativeImpact(wetland) & all y. (Organism(y) & LivesIn(y, wetland) -> NegativeImpact(y))))", "exists x, y, z. (Human(x) & Home(y) & Wetland(z) & Builds(x, y) & In(z) & NegativeImpact(y, z) & all a. (Organism(a) & LivesIn(a, z) -> NegativeImpact(y, z)))", "exists h, w. (Humans(h) & Wetland(w) & BuildsIn(h, w) -> (NegativeImpactOn(h, w) & all o. (Organism(o) & LivesIn(o, w) -> NegativeImpactOn(h, o))))", "exists w. (Wetland(w) & exists h. (Human(h) & Builds(h, homes, w)) -> (NegativeImpact(Builds(h, homes, w), w) & all o. (Organism(o) & LivesIn(o, w) -> NegativeImpact(Builds(h, homes, w), o))))", "exists w. (Wetland(w) & exists x. (Human(x) & BuildsHomeIn(x, w)) -> NegativeImpactOn(w) & exists y. (LivesIn(y, w) -> NegativeImpactOn(y)))", "exists x. exists y. exists z. (Human(x) & Wetland(y) & Organism(z) & LivesIn(z, y) & BuildsIn(x, y) -> NegativeImpactOn(Building(x, y), y) & NegativeImpactOn(Building(x, y), z))", "exists x, y, z. (Human(x) & Home(y) & Wetland(z) & BuildsIn(x, y, z) -> NegativeImpactOn(y, z) & all w. (Organism(w) & LivesIn(w, z) -> NegativeImpactOn(y, w)))", "FOL Translation:\nall x. (Human(x) & BuildsHomeIn(x, wetland) -> (NegativeImpactOn(wetland) & all y. (Organism(y) & LivesIn(y, wetland) -> NegativeImpactOn(y))))"]}
{"id": "entailmentbank_validation_161", "nl": "if an animal eats other animals for food, then the animal will be the predator.", "fol": "", "prediction": ["all x. ((Animal(x) & exists y. (Animal(y) & EatsForFood(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & eatsOtherAnimalsForFood(x)) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))", "all x. ((Animal(x) & exists y. (Animal(y) & Eats(x, y))) -> Predator(x))"]}
{"id": "entailmentbank_validation_162", "nl": "tuna eat fish.", "fol": "", "prediction": ["all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "FOL Translation:\nall x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eat(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))", "all x. (Tuna(x) -> exists y. (Fish(y) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_163", "nl": "tuna is a kind of predator.", "fol": "", "prediction": ["Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)", "Predator(tuna)"]}
{"id": "entailmentbank_validation_164", "nl": "tuna is a kind of fish.", "fol": "", "prediction": ["Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)", "Fish(tuna)"]}
{"id": "entailmentbank_validation_165", "nl": "tuna is a kind of predatory fish.", "fol": "", "prediction": ["PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "Fish(tuna) & Predatory(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)", "PredatoryFish(tuna)"]}
{"id": "entailmentbank_validation_166", "nl": "commercial harvesting from the ocean has caused populations of large predatory fish to decrease.", "fol": "", "prediction": ["exists x. (CommercialHarvestingFromOcean(x) & causes(x, y) & Decrease(Population(y)) & LargePredatoryFish(y))", "exists x. ((CommercialHarvestingFromOcean(x) & all y. (LargePredatoryFish(y) -> DecreasePopulation(y))) -> Caused(x))", "exists x. (CommercialHarvesting(x) & From(ocean, x) -> exists y. (LargePredatoryFish(y) & PopulationDecrease(y)))", "exists x. (CommercialHarvestingFromOcean(x) & causes(x, exists y. (Population(y) & LargePredatoryFish(y) & Decrease(y))))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, y) & Population(y) & LargePredatoryFish(y) & Decrease(y))", "exists x exists y. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Population(y))) & LargePredatoryFish(y))", "exists x y. (CommercialHarvestingFromOcean(x) & Populations(y) & LargePredatoryFish(y) & DecreaseDueTo(x, y))", "exists x y. (CommercialHarvestingFromOcean(x) & Population(y) & LargePredatoryFish(y) -> Causes(x, Decrease(y)))", "FOL Translation:\nexists x. exists y. (CommercialHarvestingFromOcean(x) & LargePredatoryFish(y) & CausedDecrease(x, y))", "exists x. (CommercialHarvestingFromOcean(x) & exists y. (Population(y) & LargePredatoryFish(y) & CausedToDecrease(x, y)))", "exists x y. (CommercialHarvesting(x) & Ocean(x) & LargePredatoryFish(y) & DecreasesPopulation(x, y))", "exists x. exists y. (CommercialHarvestingFromOcean(x) & Causes(x, y) & DecreaseInPopulation(y) & LargePredatoryFish(y))", "exists x y. (CommercialHarvestingFromOcean(x) & PopulationOf(y, large_predatory_fish) & Decreases(y, x))", "exists x. (CommercialHarvestingFromOcean(x) & causesPopulationDecrease(x, LargePredatoryFish))", "exists x exists y. (CommercialHarvestingFromOcean(x) & LargePredatoryFish(y) & CausesDecreaseInPopulation(x, y))", "exists y. (CommercialHarvestingFromOcean(y) & causes(y, exists z. (LargePredatoryFish(z) & PopulationDecrease(z))))"]}
{"id": "entailmentbank_validation_167", "nl": "commercial harvesting from the ocean has caused the populations of tuna to decrease.", "fol": "", "prediction": ["exists x. (CommercialHarvestingFromOcean(x) & Causes(x, PopulationsDecrease(tuna)))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Population(tuna))))", "exists x. exists y. (CommercialHarvestingFromOcean(x) & Population(y) & Of(y, tuna) & Decrease(y) & Cause(x, Decrease(y)))", "exists x y. (CommercialHarvestingFromOcean(x) & Population(y) & Tuna(y) & DecreasesDueTo(y, x))", "exists x. (CommercialHarvesting(x) & FromOcean(x) & Causes(x, Decrease(Population(tuna))))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, exists y. (Population(y) & Tuna(y) & Decreasing(y))))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Population(tuna))))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Population(tuna))))", "exists x. (CommercialHarvestingInOcean(x) & Causes(x, PopulationsDecrease(tuna)))", "exists x. (CommercialHarvestingFromOcean(x) & all y. (Tuna(y) -> CausedToDecrease(x, y)))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, Decrease(Populations(tuna))))", "exists x. (CommercialHarvestingFromOcean(x) & CausesDecreaseInPopulation(x, tuna))", "exists x. (CommercialHarvestingFromOcean(x) & CausesDecreaseInPopulation(x, tuna))", "exists x. (CommercialHarvesting(x) & FromOcean(x) & Caused(x, DecreasePopulation(tuna)))", "exists x. (CommercialHarvestingFromOcean(x) & Causes(x, PopulationsDecrease(tuna)))", "exists x. (CommercialHarvestingFrom(x, ocean) & TunaPopulationDecrease(x))"]}
{"id": "entailmentbank_validation_168", "nl": "an organism becoming extinct causes a change in the organism's food web.", "fol": "", "prediction": ["all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChange(x, y)))", "exists x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChangeInFoodWeb(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChange(x, y)))", "exists x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & ChangeInFoodWebDueToExtinction(y, x)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & PartOf(x, y) & CausesChange(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & PartOf(x, y) & CausesChangeIn(FoodWeb, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (Change(y) & InFoodWeb(x, y)))", "FOL Translation:\nall x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & OrganismInFoodWeb(x, y) & CausesChange(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChangeIn(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (CausesChangeIn(x, FoodWeb(y)) & PartOf(x, FoodWeb(y))))", "exists x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChange(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChange(x, y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (Change(y) & Causes(ChangeInFoodWeb(x), y)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & ChangeInWeb(y, x)))", "all x. (Organism(x) & BecomesExtinct(x) -> exists y. (FoodWeb(y) & CausesChange(x, y)))", "exists x. (Organism(x) & BecomesExtinct(x) -> exists y. (Change(y) & InFoodWebOf(y, x)))"]}
{"id": "entailmentbank_validation_169", "nl": "a change in a food web can cause damage to an ecosystem.", "fol": "", "prediction": ["exists c. exists e. exists f. (ChangeInFoodWeb(c) & Ecosystem(e) & FoodWeb(f) & CausesDamageTo(c, e))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CanCauseDamage(x, y)))", "exists x y. (ChangeInFoodWeb(x) & Ecosystem(y) & CausesDamage(x, y))", "exists x exists y. (ChangeInFoodWeb(x) & Ecosystem(y) & CanCauseDamage(x, y))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x y. (ChangeInFoodWeb(x) & DamageToEcosystem(y) & Causes(x, y))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamageTo(x, y)))", "exists x y. (ChangeInFoodWeb(x) & Ecosystem(y) & CausesDamageTo(x, y))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamageTo(x, y)))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamageTo(x, y)))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x. (ChangeInFoodWeb(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y)))", "exists x y. (ChangeInFoodWeb(x) & CanCauseDamage(x, y) & Ecosystem(y))", "exists x. exists y. (ChangeInFoodWeb(x) & Ecosystem(y) & CanCauseDamage(x, y))"]}
{"id": "entailmentbank_validation_170", "nl": "extinctions of organisms can cause damage to an ecosystem by changing the food web.", "fol": "", "prediction": ["exists x. (Organism(x) & Extinction(x) -> exists y. (Ecosystem(y) & CausesDamageByChangingFoodWeb(x, y)))", "exists x. exists y. (Extinction(x) & Organism(x) & Ecosystem(y) & CausesDamageTo(x, y) & ChangesFoodWeb(x, y))", "exists x, y. (Organism(x) & Extinction(x) & Ecosystem(y) & CanCauseDamageToExtinction(x, y) & ChangeFoodWebExtinction(x, y))", "exists x. (Organism(x) & Extinction(x) -> exists y. (Ecosystem(y) & CanCauseDamage(x, y) & ChangesFoodWeb(x, y)))", "all x. (ExtinctionOfOrganism(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y) & ChangesFoodWeb(x, y)))", "exists x, y, z. (Extinction(x) & Organism(x) & CausesDamage(x, z) & Ecosystem(z) & ChangesFoodWeb(x, z))", "The translation of the sentence into first-order logic is:\n\nall x. (Organism(x) & Extinct(x) -> exists y. (Ecosystem(y) & CausesDamage(ChangeFoodWeb(x, y), y)))", "all x. (Organism(x) & Extinct(x) -> exists y. (Ecosystem(y) & CanCauseDamage(x, y) & ChangeFoodWeb(x, y)))", "all x. (OrganismExtinction(x) -> exists y. (Ecosystem(y) & CanCauseDamage(x, y) & ChangesFoodWeb(x, y)))", "exists x, y. (Extinction(x) & Organism(x) & Ecosystem(y) -> (CausesDamage(x, y) & ChangesFoodWeb(x, y)))", "exists x. (Extinction(x) & Organism(x) -> exists y. (Ecosystem(y) & CausesDamageTo(x, y) & ChangesFoodWeb(x, y)))", "exists x, y, z. (Extinction(x) & Organism(y) & Ecosystem(z) & CausesDamageTo(x, z) & Changes(x, FoodWeb(z)))", "exists x. (OrganismExtinction(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y) & ChangesFoodWeb(x, y)))", "all x. (Organism(x) & Extinction(x) -> exists y. (Ecosystem(y) & CausesDamageByChangingFoodWeb(x, y)))", "exists x. (Organism(x) & Extinction(x) -> exists y. (Ecosystem(y) & CausesDamage(x, y) & ChangesFoodWeb(x, y)))", "exists x. (Organism(x) & Extinction(x) -> exists y. (Ecosystem(y) & CanCauseDamageTo(x, y) & ChangesFoodWeb(x, y)))"]}
{"id": "entailmentbank_validation_171", "nl": "california is located on the boundary of two tectonic plates.", "fol": "", "prediction": ["LocatedOnBoundaryOfPlates(california) & TectonicPlate(x) & TectonicPlate(y) & PartOf(california, x) & PartOf(california, y) & x \u2260 y", "LocatedOnBoundary(california, tectonic_plate_1, tectonic_plate_2)", "Located(california, BoundaryOf(TectonicPlate1, TectonicPlate2))", "LocatedOnBoundaryOfPlates(california)", "Located(california, BoundaryOf(TectonicPlate(x), TectonicPlate(y)))", "LocatedOnBoundaryOf(california, tectonic_plate1, tectonic_plate2) & TectonicPlate(tectonic_plate1) & TectonicPlate(tectonic_plate2)", "LocatedOnBoundaryOfPlates(california)", "LocatedOnBoundaryOf(california, tectonic_plate_a, tectonic_plate_b)", "LocatedOnBoundaryOfPlates(california)", "LocatedOnBoundary(california, twoTectonicPlates)", "LocatedOnBoundary(california, tectonic_plate1, tectonic_plate2)", "LocatedOnBoundary(california, tectonicPlate1, tectonicPlate2) & TectonicPlate(tectonicPlate1) & TectonicPlate(tectonicPlate2)", "LocatedOnBoundary(california, twoTectonicPlates)", "LocatedOnBoundary(california, tectonic_plate1, tectonic_plate2) & TectonicPlate(tectonic_plate1) & TectonicPlate(tectonic_plate2)", "LocatedOnBoundary(california, tectonic_plate1, tectonic_plate2)", "LocatedOnBoundary(california, TectonicPlate1, TectonicPlate2)"]}
{"id": "entailmentbank_validation_172", "nl": "earthquakes are most common along tectonic plate boundaries.", "fol": "", "prediction": ["all x. (Earthquake(x) & MostCommonLoc(x, boundary)) -> TectonicPlateBoundary(boundary)", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundary))", "all x. (Earthquake(x) -> MostCommonAlongTectonicPlateBoundaries(x))", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlongTectonicPlateBoundaries(x))", "FOL Translation:\nall x. (Earthquake(x) -> MostCommonAlongBoundary(x, TectonicPlateBoundary))", "all x. (Earthquake(x) -> OccursMostCommonlyAlongBoundary(x, tectonic_plate))", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> CommonAlongTectonicPlateBoundaries(x))", "all x. (EarthquakeOccurAt(x) -> TectonicPlateBoundary(x))", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlongBoundaries(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlong(x, TectonicPlateBoundaries))", "all x. (Earthquake(x) -> MostCommonAlongPlateBoundary(x))", "all x. (Earthquake(x) -> CommonAlongTectonicPlateBoundaries(x))"]}
{"id": "entailmentbank_validation_173", "nl": "massachusetts is not located on the boundary of two tectonic plates.", "fol": "", "prediction": ["", "", "", "", "-LocatedOnBoundary(massachusetts, tectonic_plate1, tectonic_plate2)", "", "-Exists x. (TwoTectonicPlates(x) & LocatedOnBoundary(massachusetts, x))", "-LocatedOnBoundary(massachusetts, twoTectonicPlates)", "", "-LocatedOnBoundaryOfTectonicPlates(massachusetts)", "-LocatedOnBoundaryOfTectonicPlates(massachusetts)", "", "", "-LocatedOnBoundary(massachusetts, tectonic_plate1, tectonic_plate2)", "-LocatedOnBoundary(massachusetts, TwoTectonicPlates)", ""]}
{"id": "entailmentbank_validation_174", "nl": "earthquakes are more likely to occur in california than in massachusetts.", "fol": "", "prediction": ["all x. (Earthquake(x) -> (MoreLikelyToOccurIn(x, california) & -MoreLikelyToOccurIn(x, massachusetts)))", "FOL Translation:\nall x. (Earthquake(x) -> (MoreLikelyToOccurIn(x, california) > MoreLikelyToOccurIn(x, massachusetts)))", "Likelihood(Earthquake, california) > Likelihood(Earthquake, massachusetts)", "FOL Translation:\nLikelihood(Earthquake, california) > Likelihood(Earthquake, massachusetts)", "all x. (Earthquake(x) -> MoreLikelyToOccur(x, california, massachusetts))", "MoreLikelyToOccurIn(earthquakes, california, massachusetts)", "Likelihood(earthquakes, california) > Likelihood(earthquakes, massachusetts)", "exists x. (Earthquake(x) & Location(california) & Location(massachusetts) & MoreLikelyToOccur(x, california, massachusetts))", "all x. (Earthquake(x) -> (OccursIn(x, california) > OccursIn(x, massachusetts)))", "all x. (Earthquake(x) -> MoreLikelyToOccurIn(x, california, massachusetts))", "all x. (Earthquake(x) -> (MoreLikelyToOccurIn(x, california) & -MoreLikelyToOccurIn(x, massachusetts)))", "all x. (Earthquake(x) -> (MoreLikelyToOccurIn(x, california) & -MoreLikelyToOccurIn(x, massachusetts)))", "Existential and comparative concepts can be a challenge in first-order logic. However, a way to represent this might be to introduce a comparative predicate to denote relative likelihood. Here is a translation that tries to convey this idea within the FOL schema:\n\nexists l, m. (Region(california) & Region(massachusetts) & Likelihood(earthquake, l, california) & Likelihood(earthquake, m, massachusetts) & MoreLikely(l, m))", "MoreLikelyToOccur(earthquakes, california, massachusetts)", "exists x. (Earthquake(x) & MoreLikely(x, california, massachusetts))", "all x. (Earthquake(x) -> MoreLikely(OccurIn(x, california), OccurIn(x, massachusetts)))"]}
{"id": "entailmentbank_validation_175", "nl": "the oceanic plate is a kind of tectonic plate.", "fol": "", "prediction": ["KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "TectonicPlate(oceanic_plate)", "Kind(plate_oceanic, plate_tectonic)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)", "KindOf(oceanic_plate, tectonic_plate)"]}
{"id": "entailmentbank_validation_176", "nl": "the subduction of tectonic plates may cause magma to surface from underneath.", "fol": "", "prediction": ["exists x. exists y. (TectonicPlate(x) & TectonicPlate(y) & Subduction(x, y) -> exists z. (Magma(z) & MaySurfaceFromUnderneath(z)))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(SurfaceMagma, Underneath))", "exists x. (Subduction(x) & TectonicPlate(x) -> exists y. (Magma(y) & MayCauseToSurface(x, y)))", "exists x y. (TectonicPlate(x) & Subduction(x) & Magma(y) & MayCause(Subduction(x), Surface(y, Underneath)))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCauseToSurface(Magma, Underneath))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(Surface(magma)))", "exists x, y. (TectonicPlate(x) & TectonicPlate(y) & Subduction(x, y) -> exists z. (Magma(z) & MayCauseToSurface(z)))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(MagmaToSurface))", "exists x, y, z. (Subduction(x) & TectonicPlate(y) & TectonicPlate(z) & Causes(x, Surfacing(magma)))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(Surface(magma), Underneath(y)))", "exists x. exists y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(MagmaSurfacing, Underneath(x, y)))", "exists x, y. (TectonicPlate(x) & TectonicPlate(y) & Subduction(x, y) -> possibly exists z. (Magma(z) & SurfacesFromUnderneath(z)))", "exists x. (TectonicPlate(x) & Subduction(x) -> exists y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x exists y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(MagmaToSurfaceFromUnderneath))", "exists x, y. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) -> MayCause(x, z) & Surface(z) & Magma(z))", "exists x y z. (Subduction(x, y) & TectonicPlate(x) & TectonicPlate(y) & Magma(z) -> MayCauseToSurface(z, Underneath))"]}
{"id": "entailmentbank_validation_177", "nl": "the subduction of an oceanic plate may cause magma to surface from underneath.", "fol": "", "prediction": ["exists x exists y. (OceanicPlate(x) & Subduction(x, y) & Magma(y) & CanCause(y, SurfaceFromUnderneath(magma)))", "exists x. exists y. (OceanicPlate(x) & Subduction(x) & MayCauseToSurface(x, y) & Magma(y))", "exists x exists y. (Subduction(x, y) & OceanicPlate(x) & MayCause(x, exists z. (Magma(z) & SurfacesFromUnderneath(z))))", "exists x. exists y. (Subduction(oceanic_plate(x), y) -> MayCause(MagmaSurface(y)))", "exists x exists y. (OceanicPlate(x) & Subducts(x) & Magma(y) & MayCause(Subduction(x), SurfaceFromUnderneath(y)))", "exists x y. (OceanicPlate(x) & Subduction(x) & Magma(y) & Causes(Subduction(x), Surface(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & MayCauseToSurface(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x. exists y. (OceanicPlate(x) & Magma(y) & Subduction(x) & MayCause(Subduction(x), Surface(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> may y. (Magma(y) & SurfacesFromUnderneath(y)))", "exists x exists y. (OceanicPlate(x) & Subduction(x) & MayCause(x, y) & Magma(y) & SurfaceFromUnderneath(y))", "exists x exists y. (Subduction(x) & OceanicPlate(x) & Causes(x, y) & Magma(y) & SurfacesFromUnderneath(y))", "exists x y. (Subduction(x, y) & OceanicPlate(x) & MayCause(MagmaToSurface(y)))", "exists x exist y. (Subduction(x, y) & OceanicPlate(x) & Magma(y) -> MayCause(Surface(y, Underneath)))"]}
{"id": "entailmentbank_validation_178", "nl": "magma cools down when it comes to the surface from underneath.", "fol": "", "prediction": ["all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "exists x. (Magma(x) & all y. (Surface(y) & ComesTo(x, y) & Underneath(x) -> CoolsDown(x)))", "all m. (Magma(m) & ComesToSurface(m) -> CoolsDown(m))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurface(x)) -> CoolsDown(x))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all z. (Magma(z) & ComesToSurfaceFromUnderneath(z) -> CoolsDown(z))", "FOL Translation:\nall x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurfaceFromUnderneath(x)) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurfaceFromUnderneath(x)) -> CoolsDown(x))", "FOL Translation:\nall x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. (Magma(x) & ComesToSurfaceFromUnderneath(x) -> CoolsDown(x))", "all x. ((Magma(x) & ComesToSurface(x)) -> CoolsDown(x))"]}
{"id": "entailmentbank_validation_179", "nl": "the subduction of an oceanic plate will cause magma to surface and cool down.", "fol": "", "prediction": ["exists x, y. (Subduction(x) & OceanicPlate(x) & Causes(x, y) & Surfaces(magma, y) & CoolDown(magma, y))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolDown(y)))", "all x. (Subduction(oceanic_plate(x)) -> (exists y. (Magma(y) & Surfaces(y) & CoolsDown(y))))", "exists x. exists y. (OceanicPlate(x) & Subduction(x) & Causes(x, MagmaSurfacing(y) & CoolingDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exist x exist y. (Subduction(oceanic_plate(x)) & LeadsTo(x, Surfaces(magma(y)) & CoolsDown(y)))", "exists x. (Subduction(oceanic_plate, x) -> (exists y. (MagmaSurfaces(y) & CoolsDown(y))))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "FOL Translation:\nall x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "all x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (Magma(y) & Surfaces(y) & CoolsDown(y)))", "exists x, y. (OceanicPlate(x) & Subduction(x) & Causes(Subduction(x), MagmaSurfaces(y) & CoolsDown(y)))"]}
{"id": "entailmentbank_validation_180", "nl": "magma cooling can form volcanic mountains.", "fol": "", "prediction": ["exists x. (MagmaCooling(x) & CanForm(x, VolcanicMountains))", "exists x. (Magma(x) & Cooling(x) -> exists y. (VolcanicMountain(y) & Forms(y, x)))", "exists x. (Magma(x) & Cooling(x) & CanFormVolcanicMountains(x))", "exists x exists y. (Magma(x) & Cools(x) & Forms(x, y) & VolcanicMountain(y))", "exists x. (Magma(x) & Cooling(x) & formsVolcanicMountains(x))", "exists x. exists y. (Magma(x) & Cooling(x) & VolcanicMountain(y) & Forms(x, y))", "exists x exists y. (Magma(x) & Cooling(x) & VolcanicMountain(y) & CanForm(x, y))", "exists x. (MagmaCooling(x) -> CanFormVolcanicMountains(x))", "exists x. exists y. (MagmaCooling(x) & VolcanicMountain(y) & CanForm(x, y))", "all x. (MagmaCooling(x) -> CanFormVolcanicMountains(x))", "exists x. (Magma(x) & Cooling(x) & exists y. (VolcanicMountain(y) & Forms(x, y)))", "exists x, y. (Magma(x) & Cooling(x) & VolcanicMountain(y) & CanForm(x, y))", "exists x. ((Magma(x) & Cooling(x)) -> exists y. (VolcanicMountain(y) & Forms(x, y)))", "exists x. (MagmaCooling(x) -> CanFormVolcanicMountains(x))", "exists x. (Magma(x) & Cools(x) -> exists y. (VolcanicMountain(y) & FormsFrom(x, y)))", "exists x. (Magma(x) & Cools(x) -> CanFormVolcanicMountains(x))"]}
{"id": "entailmentbank_validation_181", "nl": "the subduction of an oceanic plate can form volcanic mountians.", "fol": "", "prediction": ["exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & FormedBy(x, y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> CanFormVolcanicMountains(x))", "exists x. (OceanicPlate(x) & CanSubduct(x) -> exists y. (VolcanicMountains(y) & Forms(y, x)))", "exists x1, x2. (Subduction(x1, x2) & OceanicPlate(x1) & CanFormVolcanicMountains(x1))", "exists x, y. (Subduction(x) & OceanicPlate(x) & VolcanicMountains(y) & CanForm(x, y))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(x, y)))", "exists x y z. (OceanicPlate(x) & Subduction(x, y) & VolcanicMountain(z) & Forms(y, z))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(x, y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(y, x)))", "exists x. (OceanicPlate(x) & CanFormVolcanicMountains(Subduction(x)))", "exists x. (OceanicPlate(x) & SubductionOf(x) -> CanFormVolcanicMountains(x))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountains(y) & FormedBy(x, y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountains(y) & Forms(x, y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Formation(y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(x, y)))", "exists x. (OceanicPlate(x) & Subduction(x) -> exists y. (VolcanicMountain(y) & Forms(x, y)))"]}
{"id": "entailmentbank_validation_182", "nl": "emitting sulfur dioxide causes acid rain.", "fol": "", "prediction": ["exists x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))", "exists x exists y. (Emits(x, sulfur_dioxide) & Causes(x, y) & AcidRain(y))", "all x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, acidRain))", "exists x. (Emits(x, sulfur_dioxide) -> Causes(x, acid_rain))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, acid_rain))", "all x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "exists x. exists y. (EmitsSulfurDioxide(x) & Causes(x, AcidRain(y)))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))", "all x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))", "FOL Translation:\nall x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))", "all x. (EmitsSulfurDioxide(x) -> CausesAcidRain(x))", "all x. (EmitsSulfurDioxide(x) -> Causes(x, AcidRain))"]}
{"id": "entailmentbank_validation_183", "nl": "volcanic ash in the atmosphere decreases the temperature by blocking the sun.", "fol": "", "prediction": ["exists x. (VolcanicAsh(x) & InAtmosphere(x) -> DecreasesTemperature(x) & Blocks(x, sun))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> DecreasesTemperature(x) & Blocks(x, sun))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> DecreasesTemperature(x) & Blocks(x, sun))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Temperature(y) & Decreases(x, y) & Blocks(x, sun)))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (TemperatureDecrease(y) & BlocksSun(x)))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Temperature(y) & Decreases(y) & exists z. (Sun(z) & Blocks(x, z))))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Temperature(y) & Decreases(y, x) & exists z. (Sun(z) & Blocks(x, z))))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Sun(y) & Blocks(x, y) & DecreasesTemperature(x)))", "exists x y. (VolcanicAshInAtmosphere(x) & Sun(y) & Blocks(x, y) -> DecreasesTemperature(x))", "exists x. (VolcanicAshInAtmosphere(x) & DecreasesTemperature(x) & Blocks(x, sun))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> exists y. (Temperature(y) & Decreases(x, y) & exists z. (Sun(z) & Blocks(x, z))))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) & DecreasesTemperature(x) & BlocksSun(x))", "exists x. (VolcanicAsh(x) & InAtmosphere(x) -> DecreasesTemperature(x) & Blocks(x, sun))", "exists x. (VolcanicAshInAtmosphere(x) -> exists y. (TemperatureDecreased(things) & Blocks(y, sun) & Sun(y)))", "exists x. (VolcanicAshInAtmosphere(x) & DecreasesTemperature(x) & Blocks(x, sun))", "exists x y. (VolcanicAsh(x) & InAtmosphere(x) & Blocks(x, sun) -> DecreasesTemperature(y))"]}
{"id": "entailmentbank_validation_184", "nl": "an erupting volcano releases sulfur gas and ash into the atmosphere.", "fol": "", "prediction": ["exists v. (EruptingVolcano(v) -> exists s, a. (Releases(v, s, atmosphere) & SulfurGas(s) & Releases(v, a, atmosphere) & Ash(a)))", "exists v. (EruptingVolcano(v) -> exists s, a. (SulfurGas(s) & Ash(a) & Releases(v, s) & Releases(v, a) & IntoAtmosphere(s) & IntoAtmosphere(a)))", "Erupting(volcano) -> (Releases(volcano, sulfur_gas, atmosphere) & Releases(volcano, ash, atmosphere))", "exists x. (Volcano(x) & Erupting(x) -> exists y z. (SulfurGas(y) & Ash(z) & ReleasesIntoAtmosphere(x, y) & ReleasesIntoAtmosphere(x, z)))", "exists z. (EruptingVolcano(z) -> (Releases(z, sulfur_gas) & Releases(z, ash) & IntoAtmosphere(sulfur_gas) & IntoAtmosphere(ash)))", "exists v. (EruptingVolcano(v) -> (ReleasesSulfurGas(v) & ReleasesAsh(v) & ReleasesToAtmosphere(v)))", "exists x. (EruptingVolcano(x) -> (Releases(x, sulfur_gas) & Releases(x, ash) & IntoAtmosphere(sulfur_gas) & IntoAtmosphere(ash)))", "Erupting(volcano) -> (Releases(volcano, sulfur_gas) & Releases(volcano, ash) & Into(volcano, atmosphere))", "exists v. (Volcano(v) & Erupting(v) -> exists g a. (SulfurGas(g) & Ash(a) & Releases(v, g) & Releases(v, a) & IntoAtmosphere(g) & IntoAtmosphere(a)))", "exists v. (EruptingVolcano(v) -> (exists g. (SulfurGas(g) & Releases(v, g, atmosphere))) & exists a. (Ash(a) & Releases(v, a, atmosphere)))", "exists v. (Volcano(v) & Erupting(v) -> exists s a. (SulfurGas(s) & Ash(a) & Releases(v, s) & Releases(v, a) & Into(s, atmosphere) & Into(a, atmosphere)))", "exists x. (Volcano(x) & Erupting(x) -> Releases(x, sulfur_gas) & Releases(x, ash) & IntoAtmosphere(sulfur_gas) & IntoAtmosphere(ash))", "exists v. (EruptingVolcano(v) -> exists g. (SulfurGas(g) & Releases(v, g) & exists a. (Ash(a) & Releases(v, a) & IntoAtmosphere(g, a))))", "Exists v. (Volcano(v) & Erupting(v) -> Exists g, a. (SulfurGas(g) & Ash(a) & Releases(v, g) & Releases(v, a) & Into(g, atmosphere) & Into(a, atmosphere)))", "exists v. (EruptingVolcano(v) -> (releases(v, sulfur_gas, atmosphere) & releases(v, ash, atmosphere)))", "exists x. (Volcano(x) & Erupting(x) -> (ReleasesSulfurGas(x, atmosphere) & ReleasesAsh(x, atmosphere)))"]}
{"id": "entailmentbank_validation_185", "nl": "a volcanic eruption can cause acid rain and decrease the temperature.", "fol": "", "prediction": ["exists e. (VolcanicEruption(e) -> (Causes(e, AcidRain) & Decreases(e, Temperature)))", "exists e. (VolcanicEruption(e) -> (Causes(e, acidRain) & Decreases(e, temperature)))", "exists x. (VolcanicEruption(x) -> (CausesAcidRain(x) & DecreasesTemperature(x)))", "exists x. (VolcanicEruption(x) -> (CausesAcidRain(x) & DecreasesTemperature(x)))", "exists e. (VolcanicEruption(e) -> (CanCauseAcidRain(e) & CanDecreaseTemperature(e)))", "exists e. (VolcanicEruption(e) -> (CanCause(e, acid_rain) & CanDecreaseTemperature(e)))", "exists x. (VolcanicEruption(x) -> (Causes(x, AcidRain) & DecreasesTemperature(x)))", "exists x, y. (VolcanicEruption(x) & AcidRain(y) & Causes(x, y) & DecreasesTemperature(x))", "exists x. (VolcanicEruption(x) -> (CanCause(x, AcidRain) & CanCause(x, DecreaseTemperature)))", "exists e. (VolcanicEruption(e) -> (CanCause(e, AcidRain) & CanDecreaseTemperature(e)))", "exists v, r, t. (VolcanicEruption(v) & Causes(v, r) & AcidRain(r) & Causes(v, t) & DecreasesTemperature(t))", "exists x. (VolcanicEruption(x) -> exists y. (Causes(x, AcidRain(y)) & Decreases(x, Temperature)))", "exists x. (VolcanicEruption(x) -> (Causes(x, AcidRain) & Causes(x, DecreaseTemperature)))", "exists e. (VolcanicEruption(e) -> (CanCause(e, AcidRain) & CanCause(e, DecreaseTemperature)))", "exists x. (VolcanicEruption(x) -> (Causes(x, AcidRain) & DecreasesTemperature(x)))", "exists x. (VolcanicEruption(x) -> (CanCause(x, AcidRain) & CanCause(x, DecreaseTemperature)))"]}
{"id": "entailmentbank_validation_186", "nl": "europe was unusally cold and had acid rain in 1783.", "fol": "", "prediction": ["UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "WasUnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "WasUnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "Cold(europe, 1783) & AcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)", "UnusuallyCold(europe, 1783) & HadAcidRain(europe, 1783)"]}
{"id": "entailmentbank_validation_187", "nl": "a volcanic eruption may have happened to cause the cold weather and acid rain.", "fol": "", "prediction": ["exists e. (VolcanicEruption(e) & Causes(e, ColdWeather) & Causes(e, AcidRain))", "exists e. (VolcanicEruption(e) & MayHaveHappened(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists e. (VolcanicEruption(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists e. (VolcanicEruption(e) & MayHaveHappened(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists e. (VolcanicEruption(e) & (Causes(e, cold_weather) | Causes(e, acid_rain)))", "exists e. (VolcanicEruption(e) & MayHaveCaused(e, ColdWeather) & MayHaveCaused(e, AcidRain))", "exists x. (VolcanicEruption(x) & MayHaveHappened(x) & Causes(x, ColdWeather) & Causes(x, AcidRain))", "exists x. (VolcanicEruption(x) & MayHaveHappened(x) & Causes(x, ColdWeather) & Causes(x, AcidRain))", "exists e. (VolcanicEruption(e) & (Causes(e, ColdWeather) | Causes(e, AcidRain)))", "exists z. (VolcanicEruption(z) & Causes(z, ColdWeather) & Causes(z, AcidRain))", "exists x. (VolcanicEruption(x) & Causes(x, ColdWeather) & Causes(x, AcidRain))", "exists e. (VolcanicEruption(e) & MayHaveHappened(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists e. (VolcanicEruption(e) & MayHaveHappened(e) & Causes(e, cold_weather) & Causes(e, acid_rain))", "exists x. (VolcanicEruption(x) & Cause(x, ColdWeather) & Cause(x, AcidRain))", "exists e. (VolcanicEruption(e) & MayHaveCaused(e, ColdWeather) & MayHaveCaused(e, AcidRain))", "exists x. (VolcanicEruption(x) & Happened(x) & Causes(x, ColdWeather) & Causes(x, AcidRain))"]}
{"id": "entailmentbank_validation_188", "nl": "the earth's atmosphere is made of 78 percent nitrogen by mass.", "fol": "", "prediction": ["MadeOfAtmosphere(earth, nitrogen, 78_percent_by_mass)", "MadeOfPercentage(earth_atmosphere, nitrogen, 78)", "MadeOfByMass(atmosphere(earth), nitrogen, 78_percent)", "MadeOf(earths_atmosphere, nitrogen, 78_percent_by_mass)", "MadeOfByMass(atmosphere, nitrogen, 78)", "MadeOfPercentage(earth_atmosphere, nitrogen, 78)", "MadeOf(earths_atmosphere, nitrogen, 0.78)", "MadeOf(earths_atmosphere, nitrogen, 78_percent)", "MadeOfByMass(atmosphere(earth), nitrogen, 78_percent)", "MadeOfByMass(earths_atmosphere, nitrogen, 78_percent)", "MadeOf(atmosphere_earth, nitrogen, 78_percent_mass)", "MadeOfByMass(atmosphere(earth), nitrogen, 78_percent)", "MadeOf(earths_atmosphere, nitrogen, 0.78)", "MadeOf(earths_atmosphere, nitrogen, 78_percent_by_mass)", "MadeOfByMass(earths_atmosphere, nitrogen, 0.78)", "MadeOf(earths_atmosphere, nitrogen, 0.78)"]}
{"id": "entailmentbank_validation_189", "nl": "most means over 50% of something.", "fol": "", "prediction": ["exists S. (Concept(S) & Most(S) <-> Over50Percent(S))", "all x. (Most(x) -> OverFiftyPercent(x))", "```markdown\nall x. (Most(x) -> GreaterThan50Percent(x))\n```", "all s. (Most(s) -> Over50Percent(s))", "The sentence \"most means over 50% of something\" involves defining the concept of \"most\" in terms of percentages related to a set of items or a property. To represent this in first-order logic, we will consider a general relationship where \"most\" implies that a certain property applies to more than 50% of elements within a set. In FOL, this can be abstractly represented as follows:\n\nLet PredicateToBeMost(y, z) be a placeholder predicate indicating application of \"most\" where y is the set and z is the property, and OverFiftyPercent(y, z) be another predicate indicating that the property z applies to over 50% of the set y.\n\nFor a generic set and property, the logic can be represented as:\n\nall y, z. (Most(y, z) <-> OverFiftyPercent(y, z))", "There is no standard way to express \"most\" in first-order logic as it's inherently a concept that involves quantification beyond what FOL can express. However, if you were to approximate this in terms of predicates related to the concept, it might look something like this:\n\nMost(x) <-> Over50Percent(x)\n\nThis expression is more symbolic, attempting to map the concept of \"most\" to \"over 50%,\" but it doesn't capture the full meaning of quantification as might be desired since FOL does not support generalized quantifiers like \"most.\"", "all x. (Most(x) -> Over50PercentOf(x, SomeThing))", "There isn't a direct equivalent of \"most\" in standard first-order logic since it's not straightforward to express \"over 50%\" without some form of counting or measure. However, we can define it informally by stating that if more than half of a domain satisfies a condition, it fits the definition of \"most\". \n\nFor the purpose of this exercise, a conceptual attempt would be:\n\nFOL Translation:\nFor the logic system that doesn't directly encode quantities with percentages, a specific translation isn't possible without additional assumptions or extensions like second-order logic. But we can approximate \"most\" with statements about proportions.\n\nUnfortunately, first-order logic lacks the expressive power to directly express \"most\" because it involves numerical comparison of quantities, but an extended logic system or an example involving a predefined set could potentially define it.", "all x. (Most(x) <-> Over50PercentOf(x, something))", "Note: Representing \"most\" in standard first-order logic is challenging, as FOL does not directly accommodate probabilistic or majority quantification. However, we can approach this conceptually by using existential and universal quantifiers to convey \"more than 50%\". \n\nFOL Translation:\nall z. (Most(z) -> Over50Percent(z))", "most(x) <-> Over50PercentOf(x)", "all x. (Most(x) -> OverFiftyPercentOf(x, something))", "all x. (OverFiftyPercent(x) <-> Most(x))", "all x. (Most(x) -> OverFiftyPercent(x))", "exists m. (Most(m) & Meaning(m, 'over 50% of something'))", "exists P. (Category(P) & all x. (x \u2208 P -> Thing(x)) & Over50Percent(y, P) -> Definition(y, 'most'))"]}
{"id": "entailmentbank_validation_190", "nl": "the earth's atmosphere is made of mostly nitrogen.", "fol": "", "prediction": ["FOL Translation:\nAtmosphere(earth, x) & MostlyContains(x, nitrogen)", "all x. (AtmosphereOf(x, earth) -> MostlyContains(x, nitrogen))", "Exists y. (EarthAtmosphere(y) & MadeOfMostly(y, nitrogen))", "exists y. (Atmosphere(earth, y) & ComposedMostlyOf(y, nitrogen))", "Exists x. (EarthsAtmosphere(x) & MadeMostlyOf(x, nitrogen))", "FOL Translation:\nAtmosphere(earth) & MadeOfMostly(earth, nitrogen)", "MadeMostlyOf(earth_atmosphere, nitrogen)", "Exists x. (Atmosphere(x) & Of(earth, x) & MadeMostlyOf(x, nitrogen))", "Atmosphere(earth) & MadeOfMostly(earth, nitrogen)", "Exists x. (EarthsAtmosphere(x) & MadeMostlyOf(x, nitrogen))", "Exists y. (Atmosphere(earth) & MadeMostlyOf(y, nitrogen))", "Exists y. (EarthAtmosphere(y) & MadeOfMostly(y, nitrogen))", "The sentence can be translated into first-order logic as follows:\n\nAtmosphere(earth, atmosphere) & MadeMostlyOf(atmosphere, nitrogen)", "Exists y. (EarthAtmosphere(y) & MadeOfMostly(y, nitrogen))", "MostlyMadeOf(atmosphere_earth, nitrogen)", "Exists y. (EarthsAtmosphere(y) & MostlyMadeOf(y, nitrogen))"]}
{"id": "entailmentbank_validation_191", "nl": "oceans cover 70% of the surface of the earth.", "fol": "", "prediction": ["Exists x. (Ocean(x) & Covers(x, earthSurface) & CoveragePercentage(x, 70))", "Exists x. (Ocean(x) & Covers(x, earth_surface) & PercentageCoverage(x, earth_surface, 70))", "Covers(oceans, surface_of_earth) & Percentage(70)", "Exists x. (Ocean(x) & Covers(x, surface_of_earth) & Amount(x, 0.70))", "FOL Translation:\nCovers(oceans, SurfaceOf(earth), 70%)", "Exists y. (Earth(y) & Surface(y, s) & OceansCover(s, 70))", "Exists x. (Ocean(x) & Covers(x, surfaceOf(earth)) & Percentage(Covers(x, surfaceOf(earth)), 70))", "Exists x. (Ocean(x) & Covers(x, surface_of_earth) & Percentage(x, 70))", "Cover(oceans, surface_of_earth) & Equals(Percentage_Coverage(oceans, surface_of_earth), 70)", "exists x. (Ocean(x) & Covers(x, surface_of_earth) & AreaCoveredBy(x, 70_percent))", "Covers(oceans, surface_of_earth, 70_percent)", "FOL Translation:\nCover(oceans, surface_of_earth) & Percentage(70)", "Existential quantification is likely better than universal here since 70% of a specified area hints at a specific subset. Therefore, translating the sentence to FOL might look like: \n\n  exists y. (Ocean(y) & Covers(y, surface_of_earth) & PercentageCovers(y, surface_of_earth, 70))", "Exists x. (Ocean(x) & Covers(x, earth_surface) & PercentageCovered(x, earth_surface, 70))", "Covers(oceans, surface_of_earth, 70_percent)", "Covers(oceans, 0.70, Surface(earth))"]}
{"id": "entailmentbank_validation_192", "nl": "oceans cover most of earth's surface.", "fol": "", "prediction": ["exists x. (Ocean(x) & CoversMostOfSurface(x, earth))", "exists y. (Earth(y) & Coverage(oceans, y, most))", "Cover(oceans, most_of_earth_surface)", "FOL Translation:\nCovers(oceans, surface_of_earth)", "Exists y. (Ocean(y) & CoversMostOfSurface(y, earth))", "exists x. (Ocean(x) & CoversMostOfEarthsSurface(x))", "exists x. (Ocean(x) & CoversMostOfSurface(x, earth))", "exists x. (Ocean(x) & CoversMostOfSurfaceOf(x, earth))", "`OceansCoverMostOfEarthSurface` is a specific statement about the relationship between oceans and Earth's surface, and this is more specific than any general quantifiers or variables we might employ. Therefore, it's best represented as a single predicate statement. In FOL, this can be translated as:\n\n`CoversMostOfSurface(oceans, earth)`", "exists x. (Ocean(x) & CoversMostOfEarthSurface(x))", "exists x. (Earth(x) & all y. (Ocean(y) -> CoversMostOfSurface(y, x)))", "exists x. (Ocean(x) & Covers(x, earth's_surface))", "exists y. (Ocean(y) & CoversMostOfEarthSurface(y))", "exists p. (Ocean(p) & Covers(p, earth_surface))", "exists x. (Ocean(x) & CoversMostOf(x, earth_surface))", "exists x. (Ocean(x) & CoversMostOfSurfaceOf(x, earth))"]}
{"id": "entailmentbank_validation_193", "nl": "an ocean is a kind of body of water.", "fol": "", "prediction": ["all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))", "all z. (Ocean(z) -> BodyOfWater(z))", "all x. (Ocean(x) -> BodyOfWater(x))", "all x. (Ocean(x) -> BodyOfWater(x))"]}
{"id": "entailmentbank_validation_194", "nl": "water covers most of earth's surface.", "fol": "", "prediction": ["exists x. (Water(x) & CoversMostOfEarthSurface(x))", "FOL Translation:\nCovers(water, mostSurface(earth))", "exists x. (Water(x) & CoversMostOfSurfaceOf(x, earth))", "exists x. (Water(x) & CoversMostOfSurface(x, earth))", "exists x. (Water(x) & CoversMostOfEarthSurface(x))", "exists x. (Water(x) & CoversMostOf(x, earth_surface))", "MostOfEarthSurfaceCoveredBy(water)", "exists x. (Water(x) & CoversMostOf(x, earth_surface))", "exists x. (Water(x) & CoversMostOfSurface(x, earth))", "exists x. (Water(x) & CoversMostOf(x, earth))", "`Covers(water, surface_of_earth)`", "`CoversMostOfSurface(water, earth)`", "exists x. (Water(x) & CoversMostOfEarthsSurface(x))", "exists x. (Water(x) & CoversMostOf(x, earth_surface))", "exists x. (Water(x) & CoversMostOfSurfaceOf(x, earth))", "exists x. (Water(x) & CoversMostOf(x, earth_surface))"]}
{"id": "entailmentbank_validation_195", "nl": "oceans contain most of earth's water.", "fol": "", "prediction": ["exists x. (Ocean(x) & ContainsMostOfEarthWater(x))", "exists y. (Ocean(y) & ContainsMostOfEarthsWater(y))", "exists x. (Ocean(x) & ContainsMostWaterOf(x, earth))", "exist y. (Ocean(y) & ContainsMostOfEarthsWater(y))", "Exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "FOL Translation:\nexists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "FOL Translation:\nContains(oceans, most_earth_water)", "FOL Translation:\nContains(oceans, most_earth_water)", "exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "exists x. (Ocean(x) & ContainsMostOfEarthsWater(x))", "all x. (Ocean(x) -> ContainsMostOfEarthsWater(x))", "exists y. (Ocean(y) & ContainsMostOfEarthsWater(y))", "all x. (Ocean(x) -> ContainsMostEarthWater(x))", "all x. (Ocean(x) -> ContainsMostOfEarthsWater(x))"]}
{"id": "entailmentbank_validation_196", "nl": "water is made of hydrogen and oxygen.", "fol": "", "prediction": ["MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "Exists w h o. (Water(w) & Hydrogen(h) & Oxygen(o) & MadeOf(w, h) & MadeOf(w, o))", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "Exists x. (Water(x) -> MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "MadeOf(water, hydrogen) & MadeOf(water, oxygen)"]}
{"id": "entailmentbank_validation_197", "nl": "ocean water is made of hydrogen and oxygen.", "fol": "", "prediction": ["Water(ocean) & MadeOf(ocean, hydrogen) & MadeOf(ocean, oxygen)", "all x. (OceanWater(x) -> MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "all x. (OceanWater(x) -> MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "Water(ocean) & MadeOf(ocean, hydrogen) & MadeOf(ocean, oxygen)", "FOL Translation:\nall x. (OceanWater(x) -> MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "MadeOf(ocean_water, hydrogen) & MadeOf(ocean_water, oxygen)", "Exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "MadeOf(ocean_water, hydrogen) & MadeOf(ocean_water, oxygen)", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "MadeOf(ocean_water, hydrogen) & MadeOf(ocean_water, oxygen)", "exists x. (OceanWater(x) -> (MadeOf(x, hydrogen) & MadeOf(x, oxygen)))", "exists x. (OceanWater(x) & MadeOf(x, hydrogen) & MadeOf(x, oxygen))", "Water(ocean) & MadeOf(ocean, hydrogen) & MadeOf(ocean, oxygen)", "all x. (OceanWater(x) -> MadeOf(x, hydrogen) & MadeOf(x, oxygen))"]}
{"id": "entailmentbank_validation_198", "nl": "oxygen is more common than hydrogen on earth.", "fol": "", "prediction": ["Exists natural language challenges with reducing context and logical complexity when such translations occur - for accuracy, each aspect of the comparison and conditions specified must be clearly represented in the logical formulation.\n\nHere is the FOL translation for the input sentence:\n\nexists x, y. (Oxygen(x) & Hydrogen(y) & OnEarth(x) & OnEarth(y) & MoreCommon(x, y))", "Exists x. (Oxygen(x) & MoreCommonOnEarth(x, hydrogen))", "Exists x. (Exists y. (CommonOnEarth(x) & CommonOnEarth(y) & Oxygen(x) & Hydrogen(y) & MoreCommon(x, y)))", "Common(oxygen, earth) -> Common(hydrogen, earth)", "MoreCommonThanOnEarth(oxygen, hydrogen)", "Exists x.(Planet(x) & Name(x, earth) & MoreCommon(oxygen, hydrogen, x))", "Existence(oxygen, earth, moreCommonThan(hydrogen))", "IsMoreCommonThan(oxygen, hydrogen, earth)", "MoreCommonThanOn(oxygen, hydrogen, earth)", "`MoreCommonOnEarth(oxygen, hydrogen)`", "MoreCommonThanOnEarth(oxygen, hydrogen)", "MoreCommonOnEarth(oxygen, hydrogen)", "Common(oxygen, hydrogen, earth)", "MoreCommonThanOn(oxygen, hydrogen, earth)", "`MoreCommonOnEarth(oxygen, hydrogen)`", "MoreCommon(oxygen, hydrogen, earth)"]}
{"id": "entailmentbank_validation_199", "nl": "oxygen is the most common element found in the compounds that make up ocean water.", "fol": "", "prediction": ["Exists x. (Compound(x) & MakesUp(ocean_water, x) & Exists y. (Element(y) & FoundIn(y, x) & MostCommonElement(y, x) & y = oxygen))", "exists x. (Oxygen(x) & all y. ((Compound(y) & MakesUpOceanWater(y)) -> ContainsMostCommonElement(y, x)))", "exists x. (Oxygen(x) & MostCommonElement(x, OceanWaterCompounds))", "exists x. (Compound(x) & MakesUpOceanWater(x) & all y. (Element(y) & FoundIn(y, x) -> y = oxygen)) & MostCommonElement(oxygen)", "exists x. (Element(x) & FoundIn(x, OceanWater) & all y. (Element(y) & FoundIn(y, OceanWater) -> Common(x))) & -exists z. (Element(z) & FoundIn(z, OceanWater) & MoreCommon(z, oxygen))", "exists x. (Element(x) & Oxygen(x) & forall y. (Compound(y) & MakesUp(y, ocean_water) & Contains(y, x)))", "exists x. (Oxygen(x) & all y. ((Compound(y) & MakesUp(y, ocean_water)) -> HasElement(y, x)) & MostCommonElement(x))", "exists x. (Element(x) & FoundInCompounds(x, ocean_water) & IsMostCommon(x, ocean_water)) & Oxygen(oxygen) & x = oxygen", "exists x. (Element(x) & IsMostCommon(x) & FoundInCompounds(x) & MakeUp(ocean_water, x) & Equals(x, oxygen))", "exists x. (Oxygen(x) & all y. ((Compound(y) & MakesUpOceanWater(y)) -> MostCommonElementIn(x, y)))", "exists x. (Compound(x) & MakesUpOceanWater(x) & Contains(x, oxygen) & all y. (Element(y) & FoundIn(y, x) -> MostCommonElement(y, x) = oxygen))", "exists z. (OceanWater(z) & all y. (Compound(y) & FoundIn(oxygen, y) & PartOf(y, z) -> CommonElement(oxygen, y)))", "exists x. (Compound(x) & MakesUpOceanWater(x) & ExistsInCommonElement(oxygen, x))", "exists x. (Element(x) & Common(x) & FoundInCompoundsThatMakeUp(ocean_water, x) & x = oxygen)", "exists z. (CommonElement(z) & FoundIn(z, OceanWaterCompounds) & Oxygen(z))", "exists z. (Oxygen(z) & MostCommonElement(z) & all y. (Compound(y) & MakesUp(y, ocean_water) -> FoundIn(z, y)))"]}
{"id": "entailmentbank_validation_200", "nl": "if something is permeable, then the water will flow through something easily.", "fol": "", "prediction": ["all x. (Permeable(x) -> exists y. (Water(w) & FlowThroughEasily(w, x)))", "all x. (Permeable(x) -> exists y. (WaterFlowsThroughEasily(water, x, y)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(w) & FlowsThrough(w, x) & Easily(w)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThrough(x, y) & Easily(y)))", "all x. (Permeable(x) -> FlowThrough(water, x, easily))", "all x. (Permeable(x) -> WaterFlowsThroughEasily(x))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> WaterFlowsThroughEasily(x))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))", "all x. (Permeable(x) -> exists y. (Water(y) & FlowsThroughEasily(y, x)))"]}
{"id": "entailmentbank_validation_201", "nl": "soil is permeable.", "fol": "", "prediction": ["Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)", "Permeable(soil)"]}
{"id": "entailmentbank_validation_202", "nl": "water will flow through soil easily.", "fol": "", "prediction": ["all x. (Water(x) & Soil(y) & FlowsThrough(x, y) -> Easily(FlowsThrough(x, y)))", "all x. ((Water(x) & Soil(y) & FlowsThrough(x, y)) -> EasyFlow(x, y))", "all x. (Water(x) & Soil(y) -> FlowsEasilyThrough(x, y))", "FOL Translation:\nall x. (Water(x) -> FlowsThroughSoilEasily(x))", "Exists x. (Water(x) & Soil(y) & FlowThroughEasily(x, y))", "`all x. (Soil(x) -> FlowsEasilyThrough(water, x))`", "FOL Translation:\nall x. (Water(x) & Soil(y) -> FlowsThroughEasily(x, y))", "FOL Translation:\nall x. (Water(x) & Soil(y) -> FlowsThroughEasily(x, y))", "all x. ((Water(x) & Soil(y)) -> FlowsThroughEasily(x, y))", "exists x. (Water(x) -> FlowsThroughSoilEasily(x))", "FOL Translation:\nall x. (Water(x) & Soil(y) -> FlowsThroughEasily(x, y))", "For the translation of \"water will flow through soil easily\", let's identify the main components:\n\n1. Water flows through soil: `FlowsThrough(water, soil)`\n2. Easily: we'll incorporate this conceptially within the predicate to reflect the manner of the process, such as `FlowsEasily`.\n\nThus, the translation would be:\n\n`FlowsEasilyThrough(water, soil)`", "exists x. (Water(x) & exists y. (Soil(y) & FlowsThroughEasily(x, y)))", "FOL Translation:\n\nall x. (Soil(x) -> FlowsThroughEasily(water, x))", "exists x. (Water(x) -> FlowsThrough(x, soil) & Easily(x))", "all x. (Water(x) -> FlowsThrough(x, soil) & Easily(FlowsThrough(x, soil)))"]}
{"id": "entailmentbank_validation_203", "nl": "color of the soil can be used to indicate the soil component.", "fol": "", "prediction": ["FOL Translation:\nall x. (SoilComponent(x) -> CanBeIndicatedByColor(x))", "exists x. (Soil(x) & exists y. (Color(y) & Indicates(y, SoilComponent(x))))", "exists x. (SoilComponent(x) -> CanBeIndicatedByColor(x))", "all x. (Soil(x) -> exists y. (ColorComponent(y) & Indicates(ColorOf(x), y)))", "exists x. (Soil(x) & exists y. (ColorOf(y, x) & CanBeUsedToIndicateSoilComponent(y, x)))", "exists x. exists y. (Soil(x) & SoilComponent(y) & CanBeUsedToIndicate(ColorOf(x), y))", "all x. (Soil(x) -> CanIndicateSoilComponent(Color(x)))", "all x. ((Soil(x) & ColorOf(x, y)) -> CanBeUsedToIndicate(y, SoilComponent(x)))", "all x. (Soil(x) -> (exists y. (Component(y) & CanIndicate(ColorOf(x), y))))", "all x. (Soil(x) -> exists y. (SoilComponent(y) & Indicates(ColorOf(x), y)))", "all x. (Soil(x) -> exists y. (ColorIndicatesComponent(ColorOf(x), y)))", "all x. (Soil(x) & Color(x, y) -> CanIndicateComponent(y, x))", "FOL Translation:\nall x. (Soil(x) -> exists y. (Color(x, y) & Indicates(y, Component(x))))", "all x. (Soil(x) -> exists y. (SoilComponent(y) & CanIndicate(ColorOf(x), y)))", "all x. (Soil(x) & Color(x, y) -> CanBeUsedToIndicate(y, SoilComponent(x)))", "FOL Translation:\nall x. (Soil(x) -> exists y. (Color(y) & UsedToIndicate(SoilComponent(x), y)))"]}
{"id": "entailmentbank_validation_204", "nl": "high humus content causes the soil to be brown.", "fol": "", "prediction": ["exists x. (Soil(x) & HighHumusContent(x) -> Brown(x))", "all x. (HighHumusContent(x) -> Causes(x, Brown(Soil(x))))", "all x. (HighHumusContent(x) -> Brown(Soil(x)))", "exists x. (Soil(x) & HighHumusContent(x) -> Brown(x))", "all x. (Soil(x) & HighHumusContent(x) -> Brown(x))", "exists x. (HighHumusContent(x) & Causes(x, Brown(Soil)))", "all x. (HighHumusContent(x) -> Causes(Brown(soil), x))", "all x. (HighHumusContent(x) -> Causes(BrownSoil(x)))", "exists x. (HighHumusContent(x) -> Causes(x, Brown(soil)))", "all x. (Soil(x) & HighHumusContent(x) -> Brown(x))", "all x. (HighHumusContent(x) -> CausesToBeBrown(Soil(x)))", "all x. (Soil(x) & HighHumusContent(x) -> Brown(x))", "all x. (HighHumusContent(x) -> Causes(x, BrownSoil(x)))", "exists x. (HighHumusContent(x) -> Causes(x, Brown(soil)))", "all x. (HighHumusContent(x) -> BrownSoil(x))", "exists x. (HighHumusContent(x) & Causes(x, y) & Soil(y) -> Brown(y))"]}
{"id": "entailmentbank_validation_205", "nl": "brown is a kind of color.", "fol": "", "prediction": ["KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "Type(brown, color)", "KindOf(brown, color)", "KindOfColor(brown)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)", "KindOf(brown, color)"]}
{"id": "entailmentbank_validation_206", "nl": "if the soil has high humus content, then the soil will be brown in color.", "fol": "", "prediction": ["all x. (Soil(x) & HighHumusContent(x) -> BrownInColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownInColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownInColor(x))", "all x. ((Soil(x) & HighHumusContent(x)) -> BrownInColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. ((Soil(x) & HighHumusContent(x)) -> BrownInColor(x))", "all x. ((Soil(x) & HighHumusContent(x)) -> BrownInColor(x))", "all x. (Soil(x) & HasHighHumusContent(x) -> BrownInColor(x))", "all x. ((Soil(x) & HasHighHumusContent(x)) -> BrownInColor(x))", "all x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "FOL Translation:\nall x. (Soil(x) & HighHumusContent(x) -> BrownColor(x))", "all x. ((Soil(x) & HighHumusContent(x)) -> BrownInColor(x))"]}
{"id": "entailmentbank_validation_207", "nl": "mountains can cause the water in the air mass to condense.", "fol": "", "prediction": ["all x. (Mountain(x) -> CanCauseCondensation(x))", "all x. (Mountain(x) -> CanCauseCondensation(x, WaterInAirMass))", "all x. (Mountain(x) -> CanCauseCondensationInAirMassWater(x))", "all x. (Mountain(x) -> CanCauseCondensationOnAirMass(x))", "all x. (Mountain(x) -> CanCauseCondensation(x, AirMassWater(x)))", "all x. (Mountain(x) -> CanCauseCondensation(x, WaterInAirMass))", "all x. (Mountain(x) -> CanCauseCondenseWaterInAirMass(x))", "all x. (Mountain(x) -> all y. (AirMass(y) -> CanCauseCondensation(x, y)))", "all x. (Mountain(x) -> all y. (AirMass(y) -> CanCauseCondense(x, y)))", "all x. (Mountain(x) -> exists y. (AirMass(y) & CausesCondense(x, y)))", "all x. (Mountain(x) -> exists y. (AirMass(y) & ContainsWater(y) -> CausesCondensation(x, y)))", "all x. (Mountain(x) -> exists y. (AirMass(y) & WaterIn(y, z) & Condense(z)))", "all x. (Mountain(x) -> CanCauseCondensation(x, AirMass(water)))", "all x. (Mountain(x) -> CausesCondensationInAirMass(x))", "all x. (Mountain(x) -> all y. (AirMass(y) -> CanCauseCondense(x, WaterIn(y))))", "all x. (Mountain(x) -> CanCauseCondensationInAirMass(x))"]}
{"id": "entailmentbank_validation_208", "nl": "mountain is a kind of geographic obstacles.", "fol": "", "prediction": ["all x. (Mountain(x) -> GeographicObstacle(x))", "all x. (Mountain(x) -> GeographicObstacle(x))", "all x. (Mountain(x) -> GeographicObstacle(x))", "all x. (Mountain(x) -> GeographicObstacle(x))", "all x. (Mountain(x) -> GeographicObstacle(x))", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)", "Mountain(mountain) & GeographicObstacle(mountain)", "KindOf(mountain, geographic_obstacles)", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)", "GeographicObstacle(mountain)", "Mountain(m) -> GeographicObstacle(m)", "GeographicObstacle(mountain)"]}
{"id": "entailmentbank_validation_209", "nl": "mountain is the geographic obstacle that can cause the water in the air mass to condense.", "fol": "", "prediction": ["exists x. (GeographicObstacle(x) & CanCauseCondensation(x, waterInAirMass) & Mountain(x))", "GeographicObstacle(mountain) & all x. ((AirMass(x) & ContainsWater(x)) -> CanCauseCondensation(mountain, x))", "Condense(water, airmass) & Mountain(x) & GeographicObstacle(x) -> CanCause(x, Condense(water, airmass))", "GeographicObstacle(mountain) & CanCauseCondensation(mountain, waterInAirMass)", "GeographicObstacle(mountain) & all x. (AirMass(x) & CausesCondensation(mountain, WaterIn(x)))", "GeographicObstacle(mountain) & all x. (AirMass(x) & ContainsWater(x) & PassesOver(x, mountain) -> CausesCondensation(mountain, x))", "CondenseWaterInAirMass(x) <- Mountain(x)", "GeographicObstacle(mountain) & all x. (AirMass(x) & hasWater(x) & encounters(mountain, x) -> CausesCondense(mountain, x))", "exists x. (Mountain(x) & GeographicObstacle(x) & CanCause(x, y) & WaterInAirMass(y) & Condense(y))", "all x. (Mountain(x) -> (GeographicObstacle(x) & CanCauseCondensation(x, AirMassWater)))", "all x. (GeographicObstacle(x) & Mountain(x) -> CanCauseCondensation(x, AirMassWater))", "all x. (GeographicObstacle(x) & Mountain(x) -> CanCauseCondense(AirMassWater(x)))", "exists x. (Mountain(x) & GeographicObstacle(x) & all y. (AirMass(y) & Water(y, y) & CanCondense(Water(y, y)) -> Causes(x, CanCondense(Water(y, y)))))", "all x. (Mountain(x) -> (GeographicObstacle(x) & CanCauseCondensation(x, AirMassWater)))", "exists x. (Mountain(x) & GeographicObstacle(x) & CanCauseCondensationOfWaterInAirMass(x))", "GeographicObstacle(mountain) & all x. ((AirMass(x) & ContainsWater(x) & InContactWith(x, mountain)) -> CausesToCondense(mountain, x))"]}
{"id": "entailmentbank_validation_210", "nl": "if something causes a process then that something is required for that process.", "fol": "", "prediction": ["all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x all y. (Causes(x, y) -> RequiredFor(x, y))", "all x all y. (Causes(x, y) -> RequiredFor(x, y))", "all x y. (Causes(x, y) & Process(y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))", "all x, y. (Causes(x, y) -> RequiredFor(x, y))", "all x, y. (Causes(x, y) -> RequiredFor(x, y))", "all x all y. (Causes(x, y) -> RequiredFor(x, y))", "all x y. (Causes(x, y) -> RequiredFor(x, y))", "all x y. (Causes(x, y) -> RequiredFor(x, y))", "all x, y. (Causes(x, y) -> RequiredFor(x, y))", "all x. all y. (Causes(x, y) -> RequiredFor(x, y))"]}
{"id": "entailmentbank_validation_211", "nl": "condensation causes clouds to form.", "fol": "", "prediction": ["all x. (Condensation(x) -> Causes(x, CloudFormation))", "all x. (Condensation(x) -> Causes(x, FormsClouds))", "all x. (Condensation(x) -> Causes(x, CloudFormation))", "all x. (Condensation(x) -> CausesToForm(x, Clouds))", "all x. (Condensation(x) -> Causes(x, Form(Clouds)))", "exists x. (Condensation(x) & Causes(x, form_clouds))", "all x. (Condensation(x) -> Causes(x, CloudFormation))", "all x. (Condensation(x) -> Causes(x, CloudsForm))", "all x. (Condensation(x) -> Causes(x, CloudsForm))", "all x. (Condensation(x) -> Causes(x, y) & Cloud(y))", "all x. (Condensation(x) -> Causes(x, FormationOfClouds))", "all x. (Condensation(x) -> Causes(x, CloudsToForm))", "To translate the sentence \"condensation causes clouds to form\" into first-order logic, we need to express the causal relationship between condensation and cloud formation. Here's one way to do this:\n\nFOL Translation:\nall x. (Condensation(x) -> Causes(x, FormClouds))", "all x. (Condensation(x) -> Causes(x, CloudFormation))", "all x. (Condensation(x) -> Causes(x, CloudFormation))", "all x. (Condensation(x) -> Causes(x, y) & Clouds(y))"]}
{"id": "entailmentbank_validation_212", "nl": "condensation is required for clouds to form.", "fol": "", "prediction": ["exists x. (CondensationRequiredForCloudFormation(x))", "exists x. (Cloud(x) -> RequiredCondensation(x))", "FOL Translation:\nall x. (Cloud(x) -> exists y. (Condensation(y) & RequiredFor(y, x)))", "all x. (CloudsForm(x) -> Requires(x, Condensation))", "exists x. (Condensation(x) -> RequiredFor(x, CloudFormation))", "exists x. (Condensation(x) -> all y. (Cloud(y) -> Requires(y, x)))", "Condensation(x) -> RequiredFor(CloudsToForm, x)", "all x. (Cloud(x) -> RequiresFormation(x, Condensation))", "all x. (Cloud(x) -> CondensationRequired(x))", "FOL Translation:\nall x. (CloudsForm(x) -> Required(condensation, x))", "CloudsForm(x) -> Requires(x, Condensation)", "FOL Translation:\nall x. (CloudsForm(x) -> RequiresCondensation(x))", "Exists c. (Cloud(c) -> CondensationRequiredForFormation(c))", "all x. (Cloud(x) -> exists y. (Condensation(y) & RequiredFor(y, CloudForming(x))))", "all x. (Cloud(x) -> exists y. (Condensation(y) & RequiredFor(y, x)))", "exists x. (Cloud(x) -> Requires(Condensation, Cloud(x)))"]}
{"id": "entailmentbank_validation_213", "nl": "erosion is when wind transports sediments from one place to another place for a long distance.", "fol": "", "prediction": ["Erosion(wind, sediments, from, to)", "Erosion(x) <-> (exists w, s, p1, p2. (Wind(w) & Sediment(s) & Place(p1) & Place(p2) & Transports(w, s, p1, p2) & LongDistance(p1, p2)))", "Erosion(x) <-> (exists y, z, p. (Wind(x) & Sediment(y) & Place(z) & Place(p) & Transports(x, y, z, p) & LongDistance(z, p)))", "Erosion occurs when wind moves sediments over long distances.\n\"\"\"\nFOL Translation:\nall e. (Erosion(e) <-> exists w, s, p1, p2. (Wind(w) & Transports(w, s, p1, p2) & Sediment(s) & LongDistance(p1, p2)))\n\"\"\"", "exists x exists y exists z. (Wind(x) & Transports(x, y, z) & Sediment(y) & LongDistance(z) -> Erosion(x, y, z))", "Erosion(wind, sediments) <-> (all x, y, z. (Place(x) & Place(y) & Sediments(z) & TransportByWind(wind, z, x, y) & LongDistance(x, y)))", "Erosion(x) <-> (WindTransports(x) & Sediment(x) & FromOnePlaceToAnotherLongDistance(x))", "Erosion occurs when wind transports sediments over long distances. As such, there will be three distinct components for the translation: erosion, wind\u2019s transportation of sediments, and the long distance aspect. Formulating the first-order logic requires creating predicates for each component.\n\nAssume the following predicates for clarity:\n- `Erosion(x)`: x is erosion.\n- `Wind(y)`: y is wind.\n- `Transports(y, z, a, b)`: Wind y transports sediments z from place a to place b.\n- `LongDistance(a, b)`: The distance between place a and place b is long.\n\nThe FOL translation then becomes:\n\nexists x, y, z, a, b. (Erosion(x) & Wind(y) & Transports(y, z, a, b) & LongDistance(a, b))", "Erosion is defined as the process involving specific conditions. Given the complexity of the statement, we will break it down using predicates that encapsulate the necessary components:\n\n1. **Erosion**: Representing the concept of erosion.\n2. **WindTransports**: Capturing the notion that wind is carrying sediments.\n3. **Sediments**: Identifying the objects involved in erosion.\n4. **From** and **To**: Denoting the initial and final locations.\n\nFOL Translation:\n```\nall w, s, p1, p2, d. (Erosion(w, s, p1, p2, d) <-> \n                      (WindTransports(w, s, p1, p2) & \n                       IsPlace(p1) & IsPlace(p2) & \n                       IsSediment(s) & LongDistance(d)))\n```\n\nIn this translation:\n- `w` stands for wind,\n- `s` stands for sediments,\n- `p1` and `p2` are predicates representing places (initial and final),\n- `d` represents distance, and is asserted to be long.\n\nThis translation captures the essence of erosion as defined in the sentence.", "Erosion(wind, sediments) <-> (exists x y z w. (Place(x) & Place(y) & Transports(wind, sediments, x, y) & LongDistance(z, x, y)))", "Erosion(wind) <-> (exists x, y. (Sediment(x) & Place(y) & Transports(wind, x, y) & ForLongDistance(y)))", "Erosion(x) <-> (exists y z. (Wind(y) & Transports(y, z, x) & Sediment(z) & From(x, one_place) & To(x, another_place) & LongDistance(x)))", "Erosion(is): all w, s, p1, p2, d. (Wind(w) & Sediments(s) & Place(p1) & Place(p2) & LongDistance(d) & Transports(w, s, p1, p2, d) -> Erosion).", "Erosion(x) <-> (WindTransports(y, x) & Sediments(x) & FromOnePlaceToAnother(x) & LongDistance(x))", "Erosion(wind, sediments) <-> (Transports(wind, sediments) & FromPlace(x) & ToPlace(y) & LongDistance(x, y))", "Erosion occurs when wind transports sediments from one place to another place for a long distance.\n\nFOL Translation:\nErosion(x) <-> (exists y, z. (Wind(y) & Sediment(z) & Transports(y, z, x) & From(x, p1) & To(x, p2) & LongDistance(p1, p2)))"]}
{"id": "entailmentbank_validation_214", "nl": "sand dunes / arches are formed by the wind transporting and depositing sand.", "fol": "", "prediction": ["all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand) & Forms(x, y)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, Sand) & Deposits(y, Sand) & Forms(x, Sand)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsWind(y, sand) & DepositsWind(y, sand) & Forms(x, sand)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, Sand(x)) & Deposits(y, Sand(x))))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDeposits(y, sand, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (WindTransportingSand(y) & DepositingSand(y) & Forms(x, y)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDeposits(y, sand, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand) & Forms(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & TransportsAndDepositsSand(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (WindTransportsAndDeposits(y, sand) & Forms(y, x)))", "all x. ((SandDune(x) | Arch(x)) -> exists y. (Wind(y) & Transports(y, sand) & Deposits(y, sand) & Forms(x, y)))"]}
{"id": "entailmentbank_validation_215", "nl": "wind erosion can form sand dunes and arches.", "fol": "", "prediction": ["exists x. (WindErosion(x) -> (CanForm(x, SandDunes) & CanForm(x, Arches)))", "all x. (WindErosion(x) -> (CanForm(x, sand_dunes) & CanForm(x, arches)))", "exists x. (WindErosion(x) -> (CanForm(x, SandDunes) & CanForm(x, Arches)))", "exists x. (WindErosion(x) -> (CanForm(x, SandDunes) & CanForm(x, Arches)))", "exists x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "exists x. ((SandDune(x) | Arch(x)) & FormedBy(x, WindErosion))", "exists x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "Translation:\nall x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "all x. ((WindErosion(x) -> (CanForm(x, SandDunes) & CanForm(x, Arches)))", "exists x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "exists x, y. (WindErosion(x) & (Forms(x, SandDunes(y)) & Forms(x, Arches(y))))", "exists x. (WindErosion(x) -> (CanForm(x, SandDunes) & CanForm(x, Arches)))", "exists x. ((WindErosion(x) & CanFormSandDunes(x)) & CanFormArches(x))", "FOL Translation:\nall x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "all x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))", "all x. (WindErosion(x) -> (CanFormSandDunes(x) & CanFormArches(x)))"]}
{"id": "entailmentbank_validation_216", "nl": "rain causes erosion.", "fol": "", "prediction": ["all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, erosion))", "all x. (Rain(x) -> Causes(x, erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> CausesErosion(x))", "all x. (Rain(x) -> CausesErosion(x))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> CausesErosion(x))", "all x. (Rain(x) -> Causes(x, Erosion))", "all x. (Rain(x) -> Causes(x, Erosion))"]}
{"id": "entailmentbank_validation_217", "nl": "erosion sometimes decreases the amount of nutrients in soil.", "fol": "", "prediction": ["exists x. (Erosion(x) & DecreasesSometimes(x, y) & Nutrients(y) & In(Soil, y))", "exists x. (Erosion(x) & SometimesDecreasesNutrientsInSoil(x))", "exists x. (Erosion(x) & DecreasesAmountOfNutrientsInSoil(x))", "exists x. (Erosion(x) & sometimes y. (Soil(y) & DecreasesAmountOfNutrientsIn(x, y)))", "exists x. (Erosion(x) & SometimesDecreasesAmountOfNutrientsInSoil(x))", "exists x. exists y. (Erosion(x) & DecreasesSometimes(x, y) & In(y, Soil) & Nutrient(y))", "FOL Translation:\nexists x. (Erosion(x) & sometimes(Decreases(x, nutrients, soil)))", "exists x. (Erosion(x) & Decreases(x, `amount_of_nutrients_soil`))", "exists x. (Erosion(x) & DecreasesSometimes(x, y) & AmountOfNutrients(y) & In(y, soil))", "exists x. (Erosion(x) & sometimes y. (DecreasesAmountOfNutrientsInSoil(x, y)))", "exists x. (Erosion(x) & sometimes(Decreases(x, NutrientsInSoil)))", "exists s. (Soil(s) & exists t. (Time(t) & DecreasesAtTime(Erosion, NutrientAmount(s), t)))", "exists x. (Erosion(x) & sometimes y. (Soil(y) & DecreasesNutrientsIn(x, y)))", "exists t. (Sometimes(t) & Decreases(t, Erosion, NutrientsAmount, Soil))", "exists x. (Erosion(x) & sometimes(x, y) & DecreasesAmountOf(y, Nutrients, Soil))", "exists x. (Erosion(x) & DecreasesAmountOfNutrientsInSoil(x))"]}
{"id": "entailmentbank_validation_218", "nl": "rain can decrease the amount of nutrients in soil.", "fol": "", "prediction": ["all s. (Soil(s) -> (exists r. (Rain(r) & CanDecreaseNutrientsIn(r, s))))", "FOL Translation:\nall x. (Rain(x) -> CanDecreaseNutrients(x, soil))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> exists y. (Soil(y) & DecreasesNutrients(x, y)))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> DecreasesAmountOfNutrientsInSoil(x))", "all x. (Soil(x) & Rains(x) -> CanDecreaseNutrients(x))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Soil(x) -> (Rains -> DecreasesNutrientsInSoil(x)))", "all x. (Rain(x) -> exists y. (Nutrient(y) & Soil(z) & Decreases(x, y, z)))", "FOL Translation:\nall x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all s. (Soil(s) -> (exists r. (Rain(r) & CanDecreaseNutrients(r, s))))", "all x. (Rain(x) -> exists y. (Soil(y) & DecreasesNutrients(x, y)))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))", "all x. (Rain(x) -> CanDecreaseNutrientsInSoil(x))"]}
{"id": "entailmentbank_validation_219", "nl": "as the availability of water decreases, the environment will become more dry.", "fol": "", "prediction": ["all e. (Decreases(AvailabilityOfWater, e) -> BecomesMoreDry(e, Environment))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all e, w. (AvailabilityOf(water, e, w) & Decreases(w) -> BecomesMoreDry(environment(e)))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all e. (DecreaseAvailabilityOfWater(e) -> BecomesMoreDry(e))", "all x. (Decreases(AvailabilityOfWater(x)) -> Becomes(Dry(Environment(x))))", "all x. (DecreaseAvailabilityOfWater(x) -> BecomeMoreDry(Environment(x)))", "all x. ((Decreases(AvailabilityOfWater(x))) -> BecomesMoreDry(Environment(x)))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all x. (Decreases(WaterAvailability(x)) -> BecomesMoreDry(Environment(x)))", "all s. (DecreaseAvailabilityOfWater(s) -> BecomesMoreDry(environment(s)))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all x. (Decreases(AvailabilityOfWater(x)) -> BecomesMoreDry(Environment(x)))", "all x. (DecreaseAvailabilityOfWater(x) -> BecomeMoreDry(environment))", "all t. (Decreases(AvailabilityOfWater, t) -> BecomesMoreDry(Environment, t))"]}
{"id": "entailmentbank_validation_220", "nl": "drought is when available water decreases in an environment.", "fol": "", "prediction": ["Drought(x) <-> (AvailableWater(x, y) & Environment(x) & Decreases(y))", "Drought(x) <-> (AvailableWaterDecreases(x) & InEnvironment(x))", "DroughtIs(x) <-> (AvailableWaterDecreasesInEnvironment(x))", "Drought(e) <-> exists e, x, y. (AvailableWater(e, x) & Environment(y) & Decreases(x, y))", "Drought(isCondition(drought)) <-> all e. (Environment(e) -> exists w. (Water(w) & Available(w, e) & Decreases(w, e)))", "Drought(x) <-> (exists y. (Environment(y) & Decreases(AvailableWater(y), y)))", "A common set of predicates to represent the relationship can be:\n\n- `Drought(e)`: Describes the situation of drought in environment `e`.\n- `AvailableWaterDecreases(e)`: Water availability decreases in environment `e`.\n\nHere is the translation into first-order logic:\n\nall e. (Drought(e) <-> AvailableWaterDecreases(e))", "Drought(e) <-> (exists w. (AvailableWater(w) & Environment(e) & DecreasesIn(w, e)))", "Drought(x) <-> exists y. (AvailableWater(y, x) & Environment(x) & Decreases(y))", "Drought(e) <-> exists w. (AvailableWater(w, e) & Decreases(w, e))", "all e. (Drought(e) <-> exists w. (AvailableWater(w, e) & Decreases(w, e)))", "Drought(x) <-> (all y. (Environment(y) & InEnvironment(y, x) -> Decreases(AvailableWater(y))))", "Drought(x) <-> (AvailableWater(y) & Environment(z) & DecreasesIn(y, z))", "Drought(x) <-> (exists y. (Environment(y) & Decreases(AvailableWater(y), y)))", "Drought(x) <-> (AvailableWater(y) & Environment(z) & Decreases(y, z))", "Drought(e) <-> (exists x. Environment(e) & AvailableWater(x, e) & Decreases(x, e))"]}
{"id": "entailmentbank_validation_221", "nl": "drought causes the environment to be dry.", "fol": "", "prediction": ["all x. (Drought(x) -> Causes(x, Dry(environment)))", "exists x. (Drought(x) -> Causes(x, DryEnvironment))", "exists z. (Drought(z) -> all y. (Environment(y) & AffectedBy(z, y) -> Dry(y)))", "all x. (Drought(x) -> Causes(x, DryEnvironment))", "exists x, y. (Drought(x) & Environment(y) -> Causes(x, Dry(y)))", "exists x. (Drought(x) -> Causes(x, Dry(environment)))", "exists x. (Drought(x) -> Causes(x, Dry(environment)))", "all x. (Drought(x) -> Causes(x, DryEnvironment))", "exists x. (Drought(x) -> Causes(x, results_in(Dry(Environment))))", "all x. (Drought(x) -> Causes(x, EnvironmentToBeDry))", "exists x. (Drought(x) -> all y. (Environment(y) & AffectedBy(x, y) -> Dry(y)))", "all x. (Drought(x) -> Causes(x, Dry(environment)))", "exists x. (Drought(x) -> all y. (Environment(y) -> Dry(y)))", "all x. (Drought(x) -> Causes(x, y) & Dry(y) & Environment(y))", "exist x. (Drought(x) -> Causes(x, Dry(environment)))", "exists x. (Drought(x) -> Causes(x, Dry(environment)))"]}
{"id": "entailmentbank_validation_222", "nl": "dry conditions can cause fire.", "fol": "", "prediction": ["all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "FOL Translation:\nall x. (DryConditions(x) -> CanCauseFire(x))", "all x. (DryConditions(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCause(x, fire))", "all x. (DryConditions(x) -> CanCause(x, fire))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryConditions(x) -> CanCauseFire(x))", "all x. (DryConditions(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCause(fire, x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "all x. (DryCondition(x) -> CanCauseFire(x))", "FOL Translation:\n\nall x. (DryConditions(x) -> CanCauseFire(x))"]}
{"id": "entailmentbank_validation_223", "nl": "drought may cause wildfires.", "fol": "", "prediction": ["exists x. (Drought(x) & exists y. (Wildfire(y) & MayCause(x, y)))", "exists x. (Drought(x) -> MayCauseWildfires(x))", "FOL Translation:\nall x. (Drought(x) -> MayCause(x, wildfire))", "exists x. exists y. (Drought(x) & Wildfire(y) & MightCause(x, y))", "exists x. (Drought(x) -> MayCause(x, Wildfire))", "exists x. exists y. (Drought(x) & MayCause(x, y) & Wildfire(y))", "exists x. exists y. (Drought(x) & Wildfire(y) & MayCause(x, y))", "exists x exists y. (Drought(x) & Wildfire(y) & CanCause(x, y))", "exists x exists y. (Drought(x) & Wildfire(y) & Causes(x, y))", "exists x. (Drought(x) & PossibleCauseOf(x, wildfire))", "exists x exists y. (Drought(x) & Wildfire(y) & MayCause(x, y))", "exists x. (Drought(x) -> MayCause(x, Wildfires))", "all x. (Drought(x) -> MayCause(x, wildfire))", "exists x. exists y. (Drought(x) & Wildfire(y) & MayCause(x, y))", "exists x. (Drought(x) & exists y. (Wildfire(y) & MayCause(x, y)))", "exists x. (Drought(x) -> MayCause(x, Wildfire))"]}
{"id": "entailmentbank_validation_224", "nl": "a prairie is a kind of ecosystem.", "fol": "", "prediction": ["all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "Prairie(x) -> Ecosystem(x)", "Prairie(p) -> Ecosystem(p)", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "all x. (Prairie(x) -> Ecosystem(x))", "Prairie(x) -> Ecosystem(x)", "all x. (Prairie(x) -> Ecosystem(x))"]}
{"id": "entailmentbank_validation_225", "nl": "drought may cause wildfires to a prairie.", "fol": "", "prediction": ["FOL Translation:\nexists x, y. (Drought(x) & Prairie(y) -> MayCauseWildfires(x, y))", "exists x. (Drought(x) & exists y. (Prairie(y) & MayCause(x, Wildfire(y))))", "exists p. (Prairie(p) & (Drought -> Causes(Wildfire, p)))", "exists x exists y. (Prairie(x) & Wildfire(y) & Drought(z) & CanCause(z, y, x))", "exists x y. (Drought(x) & Prairie(y) -> MayCause(x, Wildfire(y)))", "exists x, y. (Drought(x) & Prairie(y) & MayCauseTo(x, Wildfires(y)))", "exists x y z. (Drought(x) & Prairie(y) & Wildfire(z) & MayCause(x, z, y))", "exists x. (Drought(x) & exists y. (Wildfire(y) & Prairie(z) & Cause(x, y, z)))", "exists x. (Drought(x) -> exists y. (Prairie(y) & Causes(x, Wildfire(y))))", "exists x. (Drought(x) -> exists y. (Prairie(y) & MayCauseWildfire(x, y)))", "exists x exists y. (Drought(x) & Prairie(y) -> CanCauseWildfireTo(x, y))", "exists x. (Drought(x) & exists y. (Prairie(y) -> MayCauseWildfires(x, y)))", "exists x. (Prairie(x) -> (Drought(x) -> MayCause(Drought, Wildfires(x))))", "exists x. (Prairie(x) & Drought(y) -> MayCause(Drought(y), Wildfires(x)))", "exists x. (Drought(x) -> exists y. (Wildfires(y) & Causes(x, y) & ToPrairie(y)))", "exists x. exists y. (Drought(x) & Prairie(y) & MayCause(x, Wildfire(y)))"]}
{"id": "entailmentbank_validation_226", "nl": "a barometer is a kind of instrument.", "fol": "", "prediction": ["Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)", "Barometer(x) -> Instrument(x)", "Instrument(barometer)", "Instrument(barometer)", "Instrument(barometer)"]}
{"id": "entailmentbank_validation_227", "nl": "a barometer is used to measure air pressure.", "fol": "", "prediction": ["exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) -> UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedFor(x, AirPressureMeasurement))", "exists x. (Barometer(x) -> UsedToMeasure(x, AirPressure))", "exists x. (Barometer(x) -> UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) -> UsedFor(x, Measure(AirPressure)))", "exists x. (Barometer(x) -> UsedToMeasure(x, AirPressure))", "exists x. (Barometer(x) -> UsedToMeasure(x, AirPressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x. (Barometer(x) -> UsedToMeasure(x, airPressure))", "exists x. (Barometer(x) & UsedToMeasure(x, air_pressure))", "exists x y. (Barometer(x) & AirPressure(y) & UsedToMeasure(x, y))"]}
{"id": "entailmentbank_validation_228", "nl": "a barometer is an instrument used to measure air pressure.", "fol": "", "prediction": ["all x. (Barometer(x) -> Instrument(x) & UsedToMeasure(x, air_pressure))", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "Instrument(barometer) & Measures(barometer, air_pressure)", "exists x. (Barometer(x) -> (Instrument(x) & UsedToMeasure(x, air_pressure)))", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "all x. (Barometer(x) -> Instrument(x) & UsedToMeasure(x, air_pressure))", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "Instrument(barometer) & Measures(barometer, air_pressure)", "exists x. (Barometer(x) -> Instrument(x) & UsedToMeasure(x, air_pressure))", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "Instrument(barometer) & UsedToMeasure(barometer, air_pressure)", "all x. (Barometer(x) -> (Instrument(x) & UsedToMeasure(x, air_pressure)))", "all x. (Barometer(x) -> (Instrument(x) & UsedToMeasure(x, air_pressure)))", "Instrument(barometer) & Measures(barometer, air_pressure)", "Instrument(barometer) & Measures(barometer, air_pressure)"]}
{"id": "entailmentbank_validation_229", "nl": "a property is a kind of information.", "fol": "", "prediction": ["all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> KindOfInformation(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> KindOfInformation(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))", "all x. (Property(x) -> Information(x))"]}
{"id": "entailmentbank_validation_230", "nl": "temperature is a property of weather.", "fol": "", "prediction": ["FOL Translation:\nall x. (Weather(x) -> exists y. (Property(y) & Temperature(y, x)))", "all x. (Weather(x) -> HasProperty(x, temperature))", "exists x. (Temperature(x) & PropertyOf(x, weather))", "all x. (Weather(x) -> exists y. (Temperature(y) & PropertyOf(y, x)))", "exists x. (Temperature(x) & PropertyOf(x, weather))", "exists x. (Property(temperature, x) & Weather(x))", "exists y. (Temperature(y) & PropertyOf(y, weather))", "PropertyOf(temperature, weather)", "exists x. (Weather(x) & PropertyOf(temperature, x))", "all x. (Weather(x) -> exists y. (Temperature(y) & PropertyOf(y, x)))", "all x. (Weather(x) -> exists y. (PropertyOf(y, x) & Temperature(y)))", "exists x. exists y. (Temperature(x) & Weather(y) & PropertyOf(x, y))", "PropertyOf(temperature, weather)", "exists x y. (Temperature(x) & Weather(y) & PropertyOf(x, y))", "PropertyOf(temperature, weather)", "exists x. exists y. (Temperature(x) & Weather(y) & PropertyOf(x, y))"]}
{"id": "entailmentbank_validation_231", "nl": "temperature is a kindof information about weather.", "fol": "", "prediction": ["KindOf(temperature, InformationAboutWeather)", "all x. (Temperature(x) -> InformationAboutWeather(x))", "KindOf(temperature, InformationAbout(weather))", "all x. (Temperature(x) -> (Information(x) & About(x, weather)))", "FOL Translation:\nKindOf(temperature, InformationAboutWeather)", "KindOf(temperature, InformationAbout(weather))", "all x. (Temperature(x) -> InformationAboutWeather(x))", "KindOf(temperature, InformationAbout(weather))", "all x. (Temperature(x) -> InformationAboutWeather(x))", "KindOf(temperature, InformationAboutWeather)", "kindof(temperature, information_about_weather)", "KindOf(temperature, InformationAboutWeather)", "KindOf(temperature, InformationAboutWeather)", "KindOf(temperature, InformationAboutWeather)", "FOL Translation:\nall x. (Temperature(x) -> InformationAbout(x, weather))", "all x. (Temperature(x) -> (Information(x) & About(x, Weather)))"]}
{"id": "entailmentbank_validation_232", "nl": "a thermometer is used to measure temperature.", "fol": "", "prediction": ["exists x. exists y. (Thermometer(x) & Temperature(y) & UsedToMeasure(x, y))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) -> UsedToMeasure(x, temperature))", "exists x. Thermometer(x) -> UsedToMeasure(x, temperature)", "exists x. (Thermometer(x) -> UsedToMeasure(x, temperature))", "exists x. exists y. (Thermometer(x) & Temperature(y) & UsedToMeasure(x, y))", "exists x. (Thermometer(x) -> UsedToMeasure(x, Temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x exists y. (Thermometer(x) & Temperature(y) & UsedToMeasure(x, y))", "exists x. (Thermometer(x) -> UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature))"]}
{"id": "entailmentbank_validation_233", "nl": "a thermometer is used to measure the information about weather on temperature.", "fol": "", "prediction": ["exists x. (Thermometer(x) -> UsedToMeasureInformation(x, weather, temperature))", "exists x. (Thermometer(x) -> UsedToMeasure(x, information, weather, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature) & InformationAbout(weather, temperature))", "exists x. (Thermometer(x) -> UsedToMeasure(x, InformationAboutWeatherOnTemperature))", "all x. (Thermometer(x) -> UsedToMeasureInformation(x, weather, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, WeatherInformationOn(Temperature)))", "exists x. (Thermometer(x) -> UsedToMeasure(x, information, weather, temperature))", "exists x. (Thermometer(x) & UsedToMeasure(x, Information(Weather(Temperature))))", "exists x. exists y. exists z. (Thermometer(x) & Measure(x, y, z) & InformationAbout(y, Weather) & On(z, Temperature))", "all x. (Thermometer(x) -> UsedFor(x, MeasureInformation(Weather, Temperature)))", "exists x. (Thermometer(x) & UsedToMeasure(x, TemperatureInformationAbout(Weather)))", "exists x. (Thermometer(x) -> UsedToMeasure(x, TemperatureInformationAboutWeather))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature) & InformationAbout(x, Weather))", "all x. (Thermometer(x) -> UsedToMeasure(x, TemperatureInformation(Weather)))", "all x. (Thermometer(x) -> UsedToMeasure(x, InformationAbout(WeatherOnTemperature)))", "exists x. (Thermometer(x) & UsedToMeasure(x, Information(y, Weather, Temperature)))"]}
{"id": "entailmentbank_validation_234", "nl": "wind direction is a property of weather.", "fol": "", "prediction": ["exists x. (Weather(x) & PropertyOf(wind_direction, x))", "all x. (Weather(x) -> exists y. (WindDirection(y) & PropertyOf(y, x)))", "all x. (Weather(x) -> exists y. (Property(y) & WindDirection(y) & AssociatedWith(x, y)))", "exists x. (Weather(x) & PropertyOf(wind_direction, x))", "PropertyOf(wind_direction, weather)", "all x. (Weather(x) -> exists y. (WindDirection(y) & PropertyOf(y, x)))", "exists x. (WindDirection(x) & PropertyOf(x, Weather))", "all z. (Weather(z) -> exists a. (Property(a) & WindDirection(a)))", "all x. (Weather(x) -> exists y. (WindDirection(y) & PropertyOf(y, x)))", "all x. (Weather(x) -> exists y. (Property(y) & WindDirection(y) & BelongsTo(y, x)))", "all x. (WindDirection(x) -> PropertyOf(x, weather))", "PropertyOf(wind_direction, weather)", "exists x. (PropertyOf(wind_direction, x) & Weather(x))", "exists x. (Property(x, wind_direction) & Weather(y))", "all x. (Weather(x) -> exists y. (WindDirection(y) & PropertyOf(y, x)))", "all x. (WindDirection(x) -> PropertyOf(x, Weather))"]}
{"id": "entailmentbank_validation_235", "nl": "wind direction is a kind of information about weather.", "fol": "", "prediction": ["InformationAboutWeather(wind_direction)", "all x. (WindDirection(x) -> InformationAbout(x, Weather))", "KindOfInformation(wind_direction, weather)", "all x. (WindDirection(x) -> InformationAboutWeather(x))", "InformationAboutWeather(wind_direction)", "InformationAboutWeather(wind_direction)", "FOL Translation:\nall x. (WindDirection(x) -> InformationAbout(x, weather))", "KindOf(InformationAbout(wind_direction, weather), information)", "KindOf(wind_direction, information_about_weather)", "exists x. (WindDirection(x) & KindOfInformationAboutWeather(x))", "all x. (WindDirection(x) -> InformationAbout(x, Weather))", "KindOf(InformationAbout(wind_direction, weather))", "all x. (WindDirection(x) -> InformationAboutWeather(x))", "all x. (WindDirection(x) -> InformationAboutWeather(x))", "KindOf(wind_direction, InformationAbout(weather))", "KindOf(Information(Weather), WindDirection)"]}
{"id": "entailmentbank_validation_236", "nl": "a station model is used for displaying information about weather in a particular point and time.", "fol": "", "prediction": ["exists x. (StationModel(x) & UsedFor(x, DisplayInformation(Weather, ParticularPointAndTime)))", "exists x. (StationModel(x) & UsedForDisplayingWeatherInfo(x) & ParticularPointInTime(y) & In(y))", "Exists x. (StationModel(x) & UsedForDisplayingInformationAboutWeather(x) & Exists y. (ParticularPoint(y) & Time(y)))", "exists x. (StationModel(x) & UsedFor(x, DisplayingInformationAboutWeather(y)) & ParticularPointAndTime(y))", "exists x. (StationModel(x) & UsedForDisplayingWeatherInfo(x) & InAParticularPointAndTime(x))", "exists x. (StationModel(x) & UsedForDisplayingInformation(x, Weather, ParticularPointAndTime))", "exists x. (StationModel(x) & UsedForDisplayingInfo(x) & all y. (Weather(y) & ParticularPoint(y) & ParticularTime(y) -> DisplaysInfoAbout(x, y)))", "exists x y z. (StationModel(x) & WeatherInformation(y) & ParticularPoint(z) & ParticularTime(z) & UsedFor(x, Display(y, z)))", "FOL Translation:\nall x. (StationModel(x) -> UsedForDisplayingWeatherInfo(x))", "all x. (StationModel(x) -> UsedForDisplayingWeatherInfo(x))", "exists x, y, z. (StationModel(x) & DisplaysInformationAboutWeather(x, y, z) & Point(y) & Time(z))", "exists x. (StationModel(x) & UsedForDisplaying(x, InformationAboutWeather) & In(aParticularPointAndTime, x))", "exists x. (StationModel(x) & UsedFor(x, DisplayingInformationAboutWeather(y)) & ParticularPoint(p) & ParticularTime(t))", "exists x y z. (StationModel(x) & DisplayingInformation(x, y, z) & Weather(y) & ParticularPoint(z) & ParticularTime(z))", "exists x. (StationModel(x) & UsedForDisplayingInformation(x) & about(x, Weather) & about(x, ParticularPoint) & about(x, ParticularTime))", "exists x. (StationModel(x) -> UsedForDisplayingInformationAboutWeather(x))"]}
{"id": "entailmentbank_validation_237", "nl": "wind direction in a particular point and time is displayed in a station model.", "fol": "", "prediction": ["exists x. exists y. (ParticularPoint(x) & Time(y) -> DisplayedInStationModel(WindDirection(x, y)))", "exists x. exists y. exists z. (WindDirection(x, y, z) & DisplayedInStationModel(x, y, z))", "exists x, y, z. (PointInTime(x, y, z) & WindDirection(x, y, z, w) & DisplayedInStationModel(w))", "exists x. exists y. exists z. (ParticularPoint(x) & ParticularTime(y) & StationModel(z) & Displays(z, WindDirectionAt(x, y)))", "exists p, t, s. (ParticularPoint(p) & Time(t) & StationModel(s) -> DisplaysWindDirection(p, t, s))", "exists p, t, s. (Point(p) & Time(t) & StationModel(s) & Displays(s, WindDirection(p, t)))", "exists x, y, z, w, v. (ParticularPoint(x) & ParticularTime(y) & StationModel(z) & WindDirection(w, x, y) & Displays(z, w))", "all p, t. (Exists w. (WindDirection(w, p, t)) -> exists s. (StationModel(s) & Displays(s, w, p, t)))", "exists x, y, z. (WindDirection(x, y, z) & ParticularPoint(y) & ParticularTime(z) -> DisplayedInStationModel(x))", "exists p, t. (ParticularPoint(p) & ParticularTime(t) -> exists s. (StationModel(s) & Displays(s, WindDirection(p, t))))", "exists x, y, z. (ParticularPoint(x) & ParticularTime(y) & StationModel(z) & DisplaysWindDirectionIn(z, x, y))", "exists p, t, s. (ParticularPoint(p) & ParticularTime(t) & StationModel(s) & DisplaysWindDirection(s, p, t))", "exists x, y, z, w. (ParticularPoint(x) & Time(y) & WindDirection(z, x, y) & StationModel(w) & Displays(w, z))", "exists x, y, z. (ParticularPoint(x) & ParticularTime(y) & WindDirectionAt(x, y, z) & DisplayedInStationModel(z))", "exists p, t, s. (ParticularPoint(p) & ParticularTime(t) & StationModel(s) & Displays(s, WindDirection(p, t)))", "exists x, y, z. (PointInTime(x, y) & StationModel(z) & DisplaysWindDirection(z, x, y))"]}
{"id": "entailmentbank_validation_238", "nl": "sleet is a kind of precipitation.", "fol": "", "prediction": ["Precipitation(sleet)", "Precipitation(sleet)", "Precipitation(sleet)", "Precipitation(sleet)", "Precipitation(sleet)", "KindOf(sleet, precipitation)", "KindOf(sleet, precipitation)", "KindOf(sleet, precipitation)", "Precipitation(sleet)", "Precipitation(sleet)", "KindOf(sleet, precipitation)", "Precipitation(sleet)", "Precipitation(sleet)", "KindOf(sleet, precipitation)", "Precipitation(sleet)", "Precipitation(sleet)"]}
{"id": "entailmentbank_validation_239", "nl": "hail is a kind of precipitation.", "fol": "", "prediction": ["Precipitation(hail)", "Precipitation(hail)", "KindOf(hail, precipitation)", "Precipitation(hail)", "Precipitation(hail)", "Precipitation(hail)", "Precipitation(hail)", "Precipitation(hail)", "KindOf(hail, precipitation)", "Precipitation(hail)", "Precipitation(hail)", "KindOf(hail, precipitation)", "KindOf(hail, precipitation)", "Precipitation(hail)", "Precipitation(hail)", "Precipitation(hail)"]}
{"id": "entailmentbank_validation_240", "nl": "hail and sleet are different kinds of precipitation.", "fol": "", "prediction": ["Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & - (exists z. (Hail(z) & Sleet(z)))", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & -all z. (Hail(z) <-> Sleet(z))", "all x. ((Hail(x) -> Precipitation(x)) & (Sleet(x) -> Precipitation(x)) & - (x = y) -> (Hail(x) & Sleet(y)))", "DifferentKinds(Precipitation(hail), Precipitation(sleet))", "DifferentKindsOfPrecipitation(hail, sleet)", "Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & all z. (Hail(z) -> -Sleet(z))", "DifferentKindOfPrecipitation(hail, sleet)", "Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "Different(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "all x. ((Hail(x) | Sleet(x)) -> Precipitation(x)) & -exists z. (Hail(z) & Sleet(z))", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & all z. (Hail(z) -> -Sleet(z))", "DifferentKinds(hail, sleet) & Precipitation(hail) & Precipitation(sleet)", "all x. (Hail(x) -> Precipitation(x)) & all y. (Sleet(y) -> Precipitation(y)) & all z. ((Hail(z) | Sleet(z)) -> -(Hail(z) & Sleet(z)))", "Different(hail, sleet) & KindOfPrecipitation(hail) & KindOfPrecipitation(sleet)"]}
{"id": "entailmentbank_validation_241", "nl": "when one kind of energy changes into another kind of energy, the total amount of energy is constant.", "fol": "", "prediction": ["all x y z. ((EnergyKind(x) & EnergyKind(y) & ChangesInto(x, y)) -> TotalEnergyConstant(z))", "all x. all y. all z. ((Energy(x) & Energy(y) & ChangesInto(x, y)) -> ConstantTotalEnergy(z))", "all x y. ((EnergyKind(x) & EnergyKind(y) & ChangesInto(x, y)) -> Constant(TotalEnergy))", "all x, y. ((EnergyType(x) & EnergyType(y) & ChangesInto(x, y)) -> Constant(TotalAmountOfEnergy))", "all x y. ((KindOfEnergy(x) & KindOfEnergy(y) & ChangesInto(x, y)) -> TotalEnergyConstant())", "all x y. ((KindOfEnergy(x) & KindOfEnergy(y) & ChangesInto(x, y)) -> TotalEnergyConstant)", "all x y. ((IsEnergyKind(x) & IsEnergyKind(y) & ChangesInto(x, y)) -> Constant(TotalEnergy))", "FOL Translation:\nall e1, e2. ((EnergyType(e1) & EnergyType(e2) & ChangesInto(e1, e2)) -> TotalEnergyConstant())", "all x, y, z. ((Energy(x) & Energy(y) & ChangesInto(x, y, z)) -> Constant(TotalAmount(z)))", "all x, y. ((Energy(x) & Energy(y) & ChangesInto(x, y)) -> Constant(TotalAmountOfEnergy))", "all x, y. (EnergyKind(x) & EnergyKind(y) & ChangesInto(x, y) -> Constant(TotalAmountOfEnergy))", "all x y. (Energy(x) & Energy(y) & ChangesInto(x, y) -> TotalEnergyConstant())", "all x y. ((IsEnergy(x) & IsEnergy(y) & ChangesInto(x, y)) -> Constant(TotalAmountOfEnergy))", "all x y. ((EnergyType(x) & EnergyType(y) & ChangesInto(x, y)) -> TotalEnergyIsConstant)", "all x, y. ((EnergyType(x) & EnergyType(y) & ChangesInto(x, y)) -> TotalEnergyConstant())", "all x y. ((EnergyType(x) & EnergyType(y) & ChangesInto(x, y)) -> Constant(TotalAmountOfEnergy))"]}
{"id": "entailmentbank_validation_242", "nl": "energy transformation means one kind of energy changes into another kind of energy.", "fol": "", "prediction": ["all x. (EnergyTransformation(x) <-> exists y exists z. (EnergyKind(y) & EnergyKind(z) & ChangesInto(x, y, z)))", "all e1 e2. (Energy(e1) & Energy(e2) & TransformsInto(e1, e2) -> EnergyTransformation(e1, e2))", "Means(energy_transformation, all x. (Energy(x) -> exists y. (Energy(y) & ChangesInto(x, y))))", "all x. (EnergyTransformation(x) <-> exists y exists z. (KindOfEnergy(y) & KindOfEnergy(z) & ChangesInto(y, z)))", "all x. (EnergyTransformation(x) <-> exists y, exists z. (EnergyKind(y) & EnergyKind(z) & ChangesInto(x, y, z)))", "all x. (EnergyTransformation(x) -> exists y exists z. (KindOfEnergy(y) & KindOfEnergy(z) & ChangesInto(x, y, z)))", "all x. (EnergyTransformation(x) -> exists y exists z. (EnergyKind(y) & EnergyKind(z) & ChangesInto(y, z)))", "all x. (EnergyTransformation(x) <-> exists y exists z. (KindOfEnergy(y) & KindOfEnergy(z) & ChangesInto(x, y, z)))", "all x. (EnergyTransformation(x) -> exists y, z. (EnergyKind(y) & EnergyKind(z) & ChangesInto(y, z)))", "all x. (EnergyTransformation(x) <-> exists y exists z. (KindOfEnergy(y) & KindOfEnergy(z) & ChangesInto(y, z)))", "Means(EnergyTransformation, all e1, e2. (KindOfEnergy(e1) & KindOfEnergy(e2) & ChangesInto(e1, e2)))", "all e1. all e2. (EnergyTransformation(e1, e2) <-> (Energy(e1) & Energy(e2) & ChangesInto(e1, e2)))", "all x y. (EnergyTransformation(x, y) -> (EnergyKind(x) & EnergyKind(y) & ChangesInto(x, y)))", "Means(energy_transformation, exists x. (Energy(x) & exists y. (Energy(y) & ChangesInto(x, y))))", "all x. (EnergyTransformation(x) <-> exists y exists z. (IsKindOfEnergy(y) & IsKindOfEnergy(z) & ChangesInto(x, y, z)))", "all x. (EnergyTransformation(x) -> exists y, z. (IsEnergyKind(y) & IsEnergyKind(z) & ChangesInto(x, y, z)))"]}
{"id": "entailmentbank_validation_243", "nl": "when energy transformation happens, the total amount of energy is constant.", "fol": "", "prediction": ["all x. (EnergyTransformation(x) -> EnergyConstant(totalEnergy))", "all x. (EnergyTransformation(x) -> Constant(TotalAmountOfEnergy))", "all e. (EnergyTransformation(e) -> Constant(TotalEnergy(e)))", "all y. (EnergyTransformationHappens(y) -> TotalAmountOfEnergyConstant(y))", "all x. (EnergyTransformationHappens(x) -> TotalEnergyConstant(x))", "all t. (EnergyTransformation(t) -> Constant(TotalAmountOfEnergy))", "all t. (EnergyTransformationHappens(t) -> TotalEnergyConstant(t))", "all e. (EnergyTransformationHappens(e) -> ConstantTotalEnergy(e))", "all x. (EnergyTransformationHappens(x) -> TotalEnergyConstant(x))", "all e. (EnergyTransformation(e) -> TotalEnergyConstant(e))", "all x. (EnergyTransformationHappens(x) -> TotalAmountOfEnergyIsConstant(x))", "all x. (EnergyTransformationHappens(x) -> TotalEnergyConstant())", "all x. (EnergyTransformation(x) -> Constant(TotalAmountOfEnergy))", "all e. (EnergyTransformationOccurs(e) -> TotalEnergyIsConstant(e))", "all x. (EnergyTransformationHappens(x) -> all y. (TotalEnergyAmount(y) & Constant(y)))", "all t. (EnergyTransformationHappens(t) -> TotalEnergyConstant(t))"]}
{"id": "entailmentbank_validation_244", "nl": "energy transformation means energy conversion.", "fol": "", "prediction": ["all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) -> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))", "all x. (EnergyTransformation(x) <-> EnergyConversion(x))"]}
{"id": "entailmentbank_validation_245", "nl": "when energy conversion happens, the total amount of energy is constant.", "fol": "", "prediction": ["all e. (EnergyConversion(e) -> Constant(TotalAmountOfEnergy(e)))", "all x. (EnergyConversionHappens(x) -> EnergyConstant(TotalEnergy(x)))", "all x. (EnergyConversionHappens(x) -> TotalEnergyConstant(x))", "all x. (EnergyConversionHappens(x) -> Constant(TotalAmountOfEnergy))", "all e. (EnergyConversion(e) -> Constant(TotalAmountOfEnergy))", "all e. (EnergyConversion(e) -> Constant(TotalAmountOfEnergy))", "all x. (EnergyConversionHappens(x) -> TotalEnergyIsConstant(x))", "all x. (EnergyConversionHappens(x) -> TotalEnergyConstant(x))", "all e. (EnergyConversionHappens(e) -> IsConstant(TotalAmountOfEnergy()))", "all x. (EnergyConversionHappens(x) -> TotalEnergyIsConstant(x))", "all x. (EnergyConversionHappens(x) -> ConstantTotalEnergy(x))", "all e. (EnergyConversionOccurs(e) -> Constant(TotalAmountOfEnergy(e)))", "all x. (EnergyConversion(x) -> IsConstant(TotalAmountOfEnergy))", "all e. (EnergyConversion(e) -> Constant(TotalAmountOfEnergy(e)))", "all e. (EnergyConversion(e) -> forall t. (TotalEnergy(t, e) = Constant))", "all e. (EnergyConversion(e) -> Constant(TotalAmountOfEnergy))"]}
{"id": "entailmentbank_validation_246", "nl": "solid is a kind of state of matter.", "fol": "", "prediction": ["all x. (Solid(x) -> StateOfMatter(x))", "StateOfMatter(solid)", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "KindOf(solid, StateOfMatter)", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "KindOfStateOfMatter(solid)", "KindOfStateOfMatter(solid)", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "all x. (Solid(x) -> StateOfMatter(x))", "KindOf(solid, state_of_matter)", "Kind(solid, state_of_matter)"]}
{"id": "entailmentbank_validation_247", "nl": "heat energy can change the state of matter.", "fol": "", "prediction": ["exists x exists y. (HeatEnergy(x) & Matter(y) -> CanChangeStateOf(y, x))", "exists x. (HeatEnergy(x) & CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "all x. (HeatEnergy(x) -> exists y. (StateOfMatter(y) & CanChange(x, y)))", "all x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "all x. (Matter(x) -> (exists y. (HeatEnergy(y) & CanChangeStateOf(x, y))))", "all x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "all x. (HeatEnergy(x) -> exists y. (Matter(y) & CanChangeState(x, y)))", "all x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "all x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))", "exists x. (HeatEnergy(x) -> all y. (Matter(y) -> CanChangeState(x, y)))", "all x. (HeatEnergy(x) -> exists y. (StateOfMatter(y) & CanChange(x, y)))", "exists x. (HeatEnergy(x) -> CanChangeStateOfMatter(x))"]}
{"id": "entailmentbank_validation_248", "nl": "liquid is a kind of state of matter.", "fol": "", "prediction": ["all x. (Liquid(x) -> StateOfMatter(x))", "FOL Translation:\nall x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "KindOf(liquid, StateOfMatter)", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "all x. (Liquid(x) -> StateOfMatter(x))", "KindOf(liquid, StateOfMatter)", "StateOfMatter(liquid)"]}
{"id": "entailmentbank_validation_249", "nl": "heat can change a substance from a solid to liquid.", "fol": "", "prediction": ["exists x. (Substance(x) & Solid(x) & exists y. (Liquid(y) & CanChangeFromTo(heat, x, y)))", "exists s. (Substance(s) & Solid(s) -> HeatCanChangeToLiquid(s))", "exists x, y, z. (Substance(x) & Solid(x) & Liquid(y) & Heat(z) & ChangesTo(x, y, z))", "exists x. (Substance(x) & Solid(x) & exists y. (Heat(y) & ChangesFromSolidToLiquid(x, y)))", "exists x. (Substance(x) & all s, l. ((Solid(x, s) & Liquid(x, l)) -> HeatChangesStateTo(s, l)))", "exists x, y, z. (Substance(x) & Solid(x) & Heat(y) & Liquid(z) -> CanChange(y, x, z))", "exists x. (Substance(x) & Solid(x) & exists y. (Liquid(y) & CanChangeWithHeat(x, y)))", "all x. (Substance(x) -> (Heat(y) & CanChangeStateFromTo(y, x, solid, liquid)))", "all x. (Substance(x) & SolidForm(x) -> exists y. (LiquidForm(y) & CanChangeWithHeat(x, y)))", "exists x y. (Substance(x) & Solid(x) & Liquid(y) & CanChangeTo(x, y, heat))", "exists x, y. (Substance(x) & Solid(x) & Liquid(y) -> (Heat(h) & Changes(h, x, y)))", "exists x, y, z. (Solid(z) & Liquid(y) & Substance(x) & ChangesFromToBy(z, y, x, heat))", "exists x, y, z. (Substance(x) & Solid(x, y) & Liquid(x, z) & HeatCanChange(x, y, z))", "exists x. (Substance(x) & Solid(x) -> HeatCanChangeToLiquid(x))", "FOL Translation:\nall x. (Substance(x) -> (exists y. (Heat(y) & ChangesSolidToLiquid(x, y))))", "exists x. exists y. (Substance(x) & Solid(x) & Liquid(y) & CanChangeTo(x, y, heat))"]}
{"id": "entailmentbank_validation_250", "nl": "melting means a substance changes from a solid into a liquid by increasing heat energy.", "fol": "", "prediction": ["all x. (Melting(x) -> (Substance(x) & ChangesFromSolidToLiquid(x) & ByIncreasingHeatEnergy(x)))", "all s. (Melting(s) <-> (Substance(s) & ChangesState(s, solid, liquid) & IncreasesHeatEnergy(s)))", "all x. (Melting(x) <-> (Substance(x) & ChangesFrom(x, solid, liquid) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) <-> (Substance(x) & ChangesState(x, solid, liquid) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) -> (Substance(x) & ChangesFromSolidToLiquid(x) & ByIncreasingHeatEnergy(x)))", "all x. (Melting(x) <-> (Substance(x) & ChangesFromSolidToLiquid(x) & ByIncreasingHeatEnergy(x)))", "all s. ((Melting(s) & Solid(s) & IncreasingHeatEnergy(s)) -> Liquid(s))", "all x. (Substance(x) & Melting(x) -> exists y. (ChangeState(x, solid, liquid) & IncreasingHeatEnergy(x)))", "all x. (Melting(x) -> (Substance(x) & ChangesState(x, solid, liquid) & IncreasesHeatEnergy(x)))", "all x. (Substance(x) & Melting(x) -> ChangesToState(x, solid, liquid) & IncreasesHeatEnergy(x))", "all x. (Melting(x) <-> (Substance(x) & ChangesFromSolidToLiquid(x) & ByIncreasingHeatEnergy(x)))", "all x. (Substance(x) & Melting(x) -> (Solid(x) & ChangesTo(x, Liquid) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) -> (Substance(x) & ChangesState(x, solid, liquid) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) -> exists y. (SubstanceChanges(x, y) & Solid(y) & Liquid(y) & ByIncreasingHeatEnergy(x)))", "all x. (Melting(x) -> (Substance(x) & ChangesFromSolidToLiquid(x) & IncreasesHeatEnergy(x)))", "all x. (Melting(x) <-> (Substance(x) & ChangesFromSolidToLiquid(x) & ByIncreasingHeatEnergy(x)))"]}
{"id": "entailmentbank_validation_251", "nl": "heat can cause a solid substance to melt.", "fol": "", "prediction": ["all x. (SolidSubstance(x) & Heat(y) -> CanCause(y, Melts(x)))", "all x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (Solid(x) & Substance(x) -> exists y. (Heat(y) & Causes(y, Melt(x))))", "all x. all y. ((Heat(x) & SolidSubstance(y)) -> CanCauseToMelt(x, y))", "all x. (SolidSubstance(x) -> Heat(y) -> CanCause(y, Melts(x)))", "all x. (SolidSubstance(x) & Heat(y) -> CanCause(y, Melt(x)))", "FOL Translation:\nall x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "FOL Translation:\nall x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "FOL Translation:\nall x. (SolidSubstance(x) -> (Heat(y) -> CanCause(y, Melt(x))))", "FOL Translation:\nall x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))", "all s. (SolidSubstance(s) & Heat(h) -> CanCauseToMelt(h, s))", "exists x. (SolidSubstance(x) & HeatCanCauseToMelt(x))", "all x. (Solid(x) & Heat(y) -> CanCauseToMelt(y, x))", "all x. (SolidSubstance(x) & Heat(y) -> CanCauseToMelt(y, x))"]}
{"id": "entailmentbank_validation_252", "nl": "ice is a kind of solid.", "fol": "", "prediction": ["Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "Solid(ice)", "KindOf(ice, solid)", "Solid(ice)", "Solid(ice)", "Solid(ice)"]}
{"id": "entailmentbank_validation_253", "nl": "heat can cause ice to melt.", "fol": "", "prediction": ["exists h, i. (Heat(h) & Ice(i) -> CanCauseToMelt(h, i))", "exists x. (Heat(x) & exists y. (Ice(y) & CanCause(x, Melts(y))))", "exists x. (Heat(x) -> CanCauseMelting(ice, x))", "all x. (Heat(x) -> exists y. (Ice(y) & CausesToMelt(x, y)))", "exists x. (Heat(x) -> CanCauseToMelt(x, ice))", "all x. (Ice(x) -> exists y. (Heat(y) & CanCauseToMelt(y, x)))", "exists x, y. (Heat(x) & Ice(y) -> CanCauseToMelt(x, y))", "exists x. (Heat(x) -> exists y. (Ice(y) & CanCauseMelt(x, y)))", "all x. (Ice(x) -> (exists y. (Heat(y) & Causes(y, Melts(x)))))", "all x. (Heat(x) -> CanCauseToMelt(x, ice))", "all x. (Ice(x) & HeatCanCause(x) -> Melts(x))", "FOL Translation:\nall x. (Ice(x) & Heat(y) & CanCause(y, Melt(x)))", "exists x. (Heat(x) -> exists y. (Ice(y) -> Causes(x, Melts(y))))", "exists x. (Heat(x) -> exists y. (Ice(y) & CanCauseToMelt(x, y)))", "FOL Translation:\nall x. (Ice(x) & Heat(y) -> Causes(y, Melts(x)))", "all x. (Heat(x) -> exists y. (Ice(y) & Causes(x, Melt(y))))"]}
{"id": "entailmentbank_validation_254", "nl": "the sun is a source of radiation / heat called sunlight.", "fol": "", "prediction": ["SourceOf(sun, sunlight) & EmitsRadiation(sun, sunlight) & EmitsHeat(sun, sunlight)", "SourceOf(sun, radiation) & SourceOf(sun, heat) & Called(sun, sunlight)", "SourceOfRadiation(sun, sunlight)", "SourceOf(sun, sunlight) & Radiation(sunlight) & Heat(sunlight)", "SourceOf(sun, sunlight) & Emits(sun, radiation) & Emits(sun, heat)", "SourceOfRadiationHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight) & Name(sunlight, \"sunlight\")", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOf(sun, sunlight) & Radiation(sunlight) & Heat(sunlight)", "SourceOfRadiation(sun, sunlight) & SourceOfHeat(sun, sunlight)", "SourceOfRadiation(sun, sunlight)"]}
{"id": "entailmentbank_validation_255", "nl": "the heat energy from the sunlight cause ice to melt.", "fol": "", "prediction": ["exists e. (HeatEnergy(e) & From(e, sunlight) & all x. (Ice(x) -> Causes(e, Melts(x))))", "exists x. exists y. exists z. (HeatEnergyFromSunlight(x) & Ice(y) & Melts(y, z) & Causes(x, y))", "exists x exists y exists z. (HeatEnergy(x) & From(x, Sunlight) & Ice(y) & Causes(x, Melting(y)) & Melt(y, z))", "exists x. (HeatEnergyFromSunlight(x) & all y. (Ice(y) -> CausesToMelt(x, y)))", "exists x. exists y. ((HeatEnergy(x) & Sunlight(y) & Source(x, y)) -> Cause(x, Melts(ice)))", "exists x, y. (HeatEnergyFromSunlight(x) & Ice(y) -> CausesToMelt(x, y))", "exists x. exists y. (HeatEnergyFromSunlight(x) & Ice(y) -> Causes(x, Melt(y)))", "exists h, s, i. (HeatEnergyFrom(s, sunlight) & Ice(i) & Causes(h, i, Melts(i)))", "exists x. exists y. (HeatEnergyFromSunlight(x) & Ice(y) -> CausesToMelt(x, y))", "`all x. ((HeatEnergy(x) & From(x, sunlight) & Affects(x, ice)) -> CausesToMelt(x, ice))`", "exists x. (HeatEnergy(x) & From(x, sunlight) & exists y. (Ice(y) & Causes(x, Melt(y))))", "exists x exists y exists z. (HeatEnergyFrom(sunlight, x) & Ice(y) & Cause(x, Melt(y)))", "exists x. exists y. exists z. (HeatEnergy(x) & From(x, Sunlight(y)) & Ice(z) & Causes(x, Melt(z)))", "exists x, y, z. (HeatEnergyFromSunlight(x) & Ice(y) & Causes(x, Melt(y)))", "exists x. (HeatEnergyFromSunlight(x) & exists y. (Ice(y) & CausesToMelt(x, y)))", "exists x. exists y. (HeatEnergyFrom(sunlight, x) & Ice(y) & Causes(x, Melts(y)))"]}
{"id": "entailmentbank_validation_256", "nl": "a wagon is a kind of vehicle.", "fol": "", "prediction": ["Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "all x. (Wagon(x) -> Vehicle(x))", "Vehicle(wagon)", "Vehicle(wagon)", "all x. (Wagon(x) -> Vehicle(x))", "all x. (Wagon(x) -> Vehicle(x))", "Wagon(w) -> Vehicle(w)"]}
{"id": "entailmentbank_validation_257", "nl": "a vehicle is a kind of object.", "fol": "", "prediction": ["all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))", "all x. (Vehicle(x) -> Object(x))"]}
{"id": "entailmentbank_validation_258", "nl": "a wagon is a kind of object.", "fol": "", "prediction": ["Object(wagon)", "all x. (Wagon(x) -> Object(x))", "Object(wagon)", "Object(wagon)", "Object(wagon)", "all x. (Wagon(x) -> Object(x))", "all w. (Wagon(w) -> Object(w))", "all x. (Wagon(x) -> Object(x))", "all x. (Wagon(x) -> Object(x))", "Object(wagon)", "Object(wagon)", "Object(wagon)", "Object(wagon)", "all x. (Wagon(x) -> Object(x))", "all x. (Wagon(x) -> Object(x))", "Object(wagon)"]}
{"id": "entailmentbank_validation_259", "nl": "rolling is a kind of motion.", "fol": "", "prediction": ["KindOfMotion(rolling, motion)", "KindOf(rolling, motion)", "Motion(rolling)", "all x. (Rolling(x) -> Motion(x))", "Motion(rolling)", "Motion(rolling)", "KindOf(rolling, motion)", "Kinds(rolling, motion)", "Motion(rolling)", "KindOf(rolling, motion)", "all x. (Rolling(x) -> Motion(x))", "KindOf(rolling, motion)", "KindOf(rolling, motion)", "all x. (Rolling(x) -> Motion(x))", "Motion(rolling)", "KindOfMotion(rolling, motion)"]}
{"id": "entailmentbank_validation_260", "nl": "a wagon rolling is an example of an object in motion.", "fol": "", "prediction": ["exists x. (Wagon(x) & Rolling(x) & Object(x) & InMotion(x))", "exists x. (WagonRolling(x) & ExampleOf(x, ObjectInMotion))", "Exists x. (WagonRolling(x) & Example(x, ObjectInMotion))", "exists x. (WagonRolling(x) & ExampleOf(x, ObjectInMotion))", "exists x. (Wagon(x) & Rolling(x) & IsExampleOf(x, ObjectInMotion))", "exists x. (Wagon(x) & Rolling(x) -> ExampleOf(x, ObjectInMotion))", "Rolling(wagon) & Object(wagon) & InMotion(wagon)", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(ObjectInMotion, x))", "Exists x. (Wagon(x) & Rolling(x) & Object(x) & InMotion(x))", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(x, ObjectInMotion))", "exists x. (Wagon(x) & Rolling(x) & ObjectInMotion(x))", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(x, ObjectInMotion))", "ExampleOf(wagon_rolling, ObjectInMotion)", "exists x. (WagonRolling(x) & Example(x, ObjectInMotion))", "Example(rolling_wagon, object_in_motion)", "exists x. (Wagon(x) & Rolling(x) & ObjectInMotion(x))"]}
{"id": "entailmentbank_validation_261", "nl": "an example of mechanical energy is an object in motion.", "fol": "", "prediction": ["exists x. (MechanicalEnergy(x) & ExampleOf(x, ObjectInMotion))", "exists x. (MechanicalEnergyExample(x) & ObjectInMotion(x))", "exists x. (ExampleOf(mechanical_energy, x) & Object(x) & InMotion(x))", "exists x. (MechanicalEnergyExample(x) & ObjectInMotion(x))", "exists x. (ExampleOf(mechanical_energy, x) & Object(x) & InMotion(x))", "exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))", "exists x. (ExampleOf(mechanical_energy, x) & ObjectInMotion(x))", "exists x. (ExampleOf(mechanical_energy, x) & Object(x) & InMotion(x))", "exists x. (Example(mechanical_energy, x) & Object(x) & InMotion(x))", "exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))", "exists x. (ExampleOf(mechanical_energy, x) & ObjectInMotion(x))", "exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))", "exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))", "exists x y. (MechanicalEnergyExample(x) & Object(y) & InMotion(y) & ExampleOf(x, y))", "exists x. (MechanicalEnergyExample(x) & Object(x) & InMotion(x))", "exists x. (ExampleOfMechanicalEnergy(x) & ObjectInMotion(x))"]}
{"id": "entailmentbank_validation_262", "nl": "a wagon rolling is an example of mechanical energy.", "fol": "", "prediction": ["Rolling(wagon) -> ExampleOf(wagon, MechanicalEnergy)", "ExampleOfMechanicalEnergy(wagon_rolling)", "Exists x. (Wagon(x) & Rolling(x) & ExampleOf(x, MechanicalEnergy))", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(x, MechanicalEnergy))", "Example(wagon_rolling, mechanical_energy)", "Example(wagon_rolling, mechanical_energy)", "exists x. (Wagon(x) & Rolling(x) -> ExampleOf(x, MechanicalEnergy))", "exists x. (WagonRolling(x) & Example(x, MechanicalEnergy))", "exists x. (WagonRolling(x) & ExampleOf(x, MechanicalEnergy))", "ExampleOf(MechanicalEnergy, WagonRolling)", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(MechanicalEnergy, x))", "ExampleOf(WagonRolling, MechanicalEnergy)", "exists x. (WagonRolling(x) & ExampleOf(x, MechanicalEnergy))", "exists x. (Wagon(x) & Rolling(x) & ExampleOf(MechanicalEnergy, x))", "exists x. (WagonRolling(x) & ExampleOf(x, MechanicalEnergy))", "Example(wagon_rolling, mechanical_energy)"]}
{"id": "entailmentbank_validation_263", "nl": "loud means high in sound energy / sound intensity.", "fol": "", "prediction": ["all x. (Loud(x) -> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) -> HighInSoundEnergy(x) & HighInSoundIntensity(x))", "all x. (Loud(x) <-> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) -> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) <-> HighInSoundEnergy(x) & HighInSoundIntensity(x))", "For this particular sentence, we need to translate the idea that if something is loud, then it is high in sound energy or intensity.\n\nFOL Translation:\nall x. (Loud(x) -> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) <-> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) -> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) <-> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) <-> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) <-> HighSoundEnergy(x) | HighSoundIntensity(x))", "all x. (Loud(x) -> HighInSoundEnergy(x) | HighInSoundIntensity(x))", "all x. (Loud(x) <-> (HighInSoundEnergy(x) | HighInSoundIntensity(x)))", "all x. (Loud(x) <-> HighSoundEnergy(x) | HighSoundIntensity(x))", "all x. (Loud(x) -> HighSoundEnergy(x) | HighSoundIntensity(x))", "all x. (Loud(x) <-> HighInSoundEnergy(x) | HighInSoundIntensity(x))"]}
{"id": "entailmentbank_validation_264", "nl": "sound is a kind of energy.", "fol": "", "prediction": ["KindOf(sound, energy)", "Kind(sound, energy)", "Energy(sound)", "Energy(sound)", "Energy(sound)", "KindOf(sound, energy)", "KindOf(sound, energy)", "KindOf(sound, energy)", "Energy(sound)", "KindOf(sound, energy)", "KindOf(sound, energy)", "Energy(sound)", "KindOf(sound, energy)", "Energy(sound)", "Energy(sound)", "Energy(sound)"]}
{"id": "entailmentbank_validation_265", "nl": "a classroom is a kind of area.", "fol": "", "prediction": ["all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "Classroom is a subset of Area which means every instance of Classroom is an instance of Area. Thus, the FOL translation will be:\n\n`all x. (Classroom(x) -> Area(x))`", "Classroom(x) -> Area(x)", "Area(classroom)", "all x. (Classroom(x) -> Area(x))", "Classroom(x) -> Area(x)", "all x. (Classroom(x) -> Area(x))", "all x. (Classroom(x) -> Area(x))", "KindOf(classroom, area)", "Classroom(x) -> Area(x)"]}
{"id": "entailmentbank_validation_266", "nl": "the sound in a loud class room is an example of high sound energy.", "fol": "", "prediction": ["Exists x. (Sound(x) & InLoudClassroom(x) -> HighSoundEnergy(x))", "Let us denote `SoundInLoudClassroom` as the predicate for \"the sound in a loud classroom\" and `HighSoundEnergy` for \"an example of high sound energy.\"\n\nFOL Translation:\nHighSoundEnergy(SoundInLoudClassroom)", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InClassroom(x) & Loud(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOfHighSoundEnergy(x))", "Exists x. (Sound(x) & Loud(x) & ClassroomSound(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) -> ExampleOfHighSoundEnergy(x))", "Exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassRoom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "Exists x. (Sound(x) & InLoudClassroom(x) -> HighSoundEnergyExample(x))", "exists x. (Sound(x) & InLoudClassroom(x) & ExampleOf(x, HighSoundEnergy))", "exists x. (Sound(x) & InLoudClassroom(x) -> ExampleOfHighSoundEnergy(x))", "ExampleOf(sound_in_loud_class_room, high_sound_energy)"]}
{"id": "entailmentbank_validation_267", "nl": "if an object / something is in the sunlight then that object / that something will absorb solar energy.", "fol": "", "prediction": ["all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_268", "nl": "a sidewalk is located outside.", "fol": "", "prediction": ["all x. (Sidewalk(x) -> LocatedOutside(x))", "exists x. (Sidewalk(x) & LocatedOutside(x))", "Sidewalk(sidewalk) & LocatedOutside(sidewalk)", "Sidewalk(x) -> LocatedOutside(x)", "all x. (Sidewalk(x) -> LocatedOutside(x))", "SidewalkIsLocatedOutside(sidewalk)", "Sidewalk(x) -> LocatedOutside(x)", "exists x. (Sidewalk(x) & LocatedOutside(x))", "exists x. (Sidewalk(x) & LocatedOutside(x))", "all x. (Sidewalk(x) -> LocatedOutside(x))", "exists x. (Sidewalk(x) & LocatedOutside(x))", "Sidewalk(sidewalk) & LocatedOutside(sidewalk)", "all x. (Sidewalk(x) -> LocatedOutside(x))", "Sidewalk(x) -> LocatedOutside(x)", "all x. (Sidewalk(x) -> LocatedOutside(x))", "exists x. (Sidewalk(x) & LocatedOutside(x))"]}
{"id": "entailmentbank_validation_269", "nl": "a sidewalk located outside will absorb solar energy.", "fol": "", "prediction": ["exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "all x. ((Sidewalk(x) & LocatedOutside(x)) -> AbsorbsSolarEnergy(x))", "exists x. exists y. (Sidewalk(x) & LocatedOutside(x) & SolarEnergy(y) & Absorbs(x, y))", "exists x. exists y. (Sidewalk(x) & LocatedOutside(x) & SolarEnergy(y) & Absorbs(x, y))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x.(Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "all x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "Exists x (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_270", "nl": "absorbing sunlight causes objects to heat.", "fol": "", "prediction": ["all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> CausesHeating(x))", "all x. (AbsorbsSunlight(x) -> Causes(Heat(x)))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbsSunlight(x) -> Heats(x))", "all x. (AbsorbingSunlight(x) -> Causes(Heated(x)))", "all x. (AbsorbsSunlight(x) -> Heats(x))"]}
{"id": "entailmentbank_validation_271", "nl": "the sidewalk located outsie will heat.", "fol": "", "prediction": ["Outside(x) & Sidewalk(x) -> WillHeat(x)", "FOL Translation:\nexists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "Exists logic. \u0586 sidewalk(\u0444)  -->  LocatedOutside(\u0444)  & WillHeat(\u0444)", "Exists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "Exists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "Sidewalk(outsie) & LocatedOutside(outsie) -> WillHeat(outsie)", "Exists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))", "Exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))", "OutdoorSidewalk(sidewalk) & CanHeat(sidewalk)", "Exists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "Exists x. (Sidewalk(x) & LocatedOutside(x) & WillHeat(x))", "Sidewalk(outsie) & LocatedOutside(outsie) & WillHeat(outsie)", "exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> WillHeat(x))"]}
{"id": "entailmentbank_validation_272", "nl": "if something heat, it will feel hot.", "fol": "", "prediction": ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]}
{"id": "entailmentbank_validation_273", "nl": "the sidewalk located outside will feel hot.", "fol": "", "prediction": ["To represent the given sentence \"the sidewalk located outside will feel hot\" as a formula in first-order logic, we can define the following predicates:\n\n- `Sidewalk(x)`: `x` is a sidewalk.\n- `LocatedOutside(x)`: `x` is located outside.\n- `WillFeelHot(x)`: `x` will feel hot.\n\nHere's the translation in FOL:\n\nexists x. (Sidewalk(x) & LocatedOutside(x) & WillFeelHot(x))", "", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "", "", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "Exists s. (Sidewalk(s) & LocatedOutside(s) & WillFeelHot(s))", "", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))", "", "exists x. (Sidewalk(x) & LocatedOutside(x) -> FeelsHot(x))"]}
{"id": "entailmentbank_validation_274", "nl": "there is a person in a dark room looking out a window in the day.", "fol": "", "prediction": ["exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDaytime)", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & Daytime)", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & InDay(x))", "exists x. (Person(x) & InRoom(x) & DarkRoom(x) & LooksOutWindow(x) & Daytime)", "exists x. (Person(x) & In(x, dark_room) & LookingOutWindow(x) & In(daytime))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & DayTime())", "exists x. (Person(x) & InRoom(x) & DarkRoom(x) & LookingOutWindow(x) & InDaytime(x))", "exists x. (Person(x) & InDarkRoom(x) & LookingOutWindow(x) & Daytime)"]}
{"id": "entailmentbank_validation_275", "nl": "if something is in a dark place, then that something will not reflect enough light to be seen.", "fol": "", "prediction": ["all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "FOL Translation:\nall x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLight(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. ((InDarkPlace(x)) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectEnoughLightToBeSeen(x))", "all x. (DarkPlace(x) -> -ReflectEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectEnoughLightToBeSeen(x))", "all x. ((InDarkPlace(x)) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLightToBeSeen(x))", "all x. (InDarkPlace(x) -> -ReflectsEnoughLight(x))"]}
{"id": "entailmentbank_validation_276", "nl": "the person in the dark room will not reflect enough light to be seen.", "fol": "", "prediction": ["exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLight(x, Seen(x)))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "Existential quantifier should be used here as the person is not universally quantified, and the statement is specific to \"the person\".\n\nFOL Translation:\nexists x. (PersonInDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) & -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectsEnoughLightToBeSeen(x))", "exists x. (Person(x) & InDarkRoom(x) -> -ReflectEnoughLightToBeSeen(x))", "exists x. (PersonInDarkRoom(x) -> -ReflectEnoughLightToBeSeen(x))", "Let:\n\n- `Person(x)` signify that x is a person.\n- `InDarkRoom(x)` signify that x is in a dark room.\n- `ReflectsEnoughLight(x)` signify that x reflects enough light to be seen.\n- `Seen(x)` signify that x can be seen.\n\nThe sentence describes a specific situation and by using a universal assumption (for any person in a dark room), it would be structured as:\n\nall x. ((Person(x) & InDarkRoom(x)) -> -ReflectsEnoughLight(x) & -Seen(x))\n\nThis logic assumes that reflecting enough light is directly necessary for a person to be seen; thus, not reflecting enough light implies the person cannot be seen."]}
{"id": "entailmentbank_validation_277", "nl": "there is a person outside in the day looking into the dark room.", "fol": "", "prediction": ["exists x. (Person(x) & Outside(x) & DuringDay(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & InDaytime(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Daytime & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Daylight(x) & LookingInto(x, dark_room))", "exists x. (Person(x) & Outside(x) & InTheDay(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Daytime(x) & LookingIntoRoom(x) & DarkRoom(y))", "exists x. (Person(x) & Outside(x) & Daytime & LookingInto(x, dark_room))", "exists x. (Person(x) & Outside(x) & Daytime & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Daytime(y) & LooksInto(x, z) & DarkRoom(z))", "exists x. (Person(x) & Outside(x) & DuringDay(x) & LookingInto(x, dark_room))", "exists x. (Person(x) & OutsideInDay(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & OutsideInDay(x) & LookingIntoDarkRoom(x))", "exists x. (Person(x) & Outside(x) & Day(y) & LookingInto(x, dark_room))", "exists x. (Person(x) & Outside(x) & InDay(x) & LookingInto(x, dark_room))", "exists x. (Person(x) & Outside(x) & Day(time) & LookingInto(x, dark_room))", "exists x. (Person(x) & Outside(x) & InDaytime(x) & LookingIntoDarkRoom(x))"]}
{"id": "entailmentbank_validation_278", "nl": "the person outside cannot see the person in the dark room.", "fol": "", "prediction": ["exists x, y. (PersonOutside(x) & PersonInDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & IsOutside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Outside(x) & Person(y) & InDarkRoom(y) & -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & IsOutside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & IsOutside(x) & IsInDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & IsOutside(x) & IsInDarkRoom(y) -> -CanSee(x, y))", "exists x. (exists y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) & -CanSee(x, y)))", "exists x exists y. (Person(x) & Person(y) & IsOutside(x) & IsInDarkRoom(y) -> -CanSee(x, y))", "exists x exists y. (Person(x) & Person(y) & IsOutside(x) & IsInDarkRoom(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "Assuming the predicates `Outside(x)` for \"x is outside\", `InDarkRoom(y)` for \"y is in the dark room\", and `CanSee(x, y)` for \"x can see y\", the FOL translation is:\n\nexists x, y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) & -CanSee(x, y))", "exists x. exists y. (Outside(x) & InDarkRoom(y) & Person(x) & Person(y) -> -CanSee(x, y))", "exists x, y. (Person(x) & Person(y) & Outside(x) & InDarkRoom(y) -> -CanSee(x, y))", "Let us define some predicates:\n- `Person(x)`: to represent that `x` is a person.\n- `Outside(x)`: to represent that `x` is outside.\n- `DarkRoom(y)`: to represent that `y` is in the dark room.\n- `Sees(x, y)`: to represent that `x` can see `y`.\n\nFOL Translation:\nexists x. exists y. (Person(x) & Outside(x) & Person(y) & DarkRoom(y) & -Sees(x, y))"]}
{"id": "entailmentbank_validation_279", "nl": "a prism refracts light.", "fol": "", "prediction": ["exists x. exists y. (Prism(x) & Light(y) & Refracts(x, y))", "Refracts(prism, light)", "exists x. (Prism(x) & exists y. (Light(y) & Refracts(x, y)))", "exists x. (Prism(x) & exists y. (Light(y) & Refracts(x, y)))", "exists x. (Prism(x) -> exists y. (Light(y) & Refracts(x, y)))", "exists y. (Prism(y) & exists z. (Light(z) & Refracts(y, z)))", "exists x. (Prism(x) & exists y. (Light(y) & Refracts(x, y)))", "Refracts(prism, light)", "Refracts(prism, light)", "Refracts(prism, light)", "Prism(x) -> exists y. (Light(y) & Refracts(x, y))", "FOL Translation:\nall x. (Prism(x) -> exists y. (Light(y) & Refracts(x, y)))", "exists x. (Prism(x) & RefractsLight(x))", "exists x. exists y. (Prism(x) & Light(y) & Refracts(x, y))", "Prism(prism) & Refracts(prism, light)", "exists x, y. (Prism(x) & Light(y) & Refracts(x, y))"]}
{"id": "entailmentbank_validation_280", "nl": "refracting sunlight / light causes sunlight / light to split into different colors.", "fol": "", "prediction": ["exists x. exists y. (Refracting(x, y) & Causes(SplitIntoDifferentColors(y)))", "all x. ((Refracting(x, sunlight) | Refracting(x, light)) -> Causes(x, SplitIntoDifferentColors(sunlight)) | Causes(x, SplitIntoDifferentColors(light)))", "all x. ((Refracting(x) & Light(x)) -> Causes(x, SplitIntoDifferentColors(x)))", "all x. ((Refracting(x) & (Sunlight(x) | Light(x))) -> Causes(SplitIntoDifferentColors(x)))", "all x. ((Refracting(x, sunlight) | Refracting(x, light)) -> Causes(x, SplittingIntoDifferentColors(sunlight)) | Causes(x, SplittingIntoDifferentColors(light)))", "To translate the given sentence into first-order logic, we need to identify the key concepts and relations. The main elements are \"refracting,\" \"sunlight/light,\" \"causes,\" \"split,\" and \"different colors.\" \n\nHere's how these concepts can be translated into predicates:\n- `Refracts(light)`: A predicate indicating that something refracts light or sunlight.\n- `Causes(action, effect)`: A relation predicate indicating causation between an action and its effect.\n- `SplitIntoColors(light)`: A predicate indicating that light is split into different colors.\n\nNow, let's construct the FOL statement:\n\nexists x. (Refracts(x) & Causes(Refracts(x), SplitIntoColors(sunlight))) | exists x. (Refracts(x) & Causes(Refracts(x), SplitIntoColors(light)))", "all x. ((Refracting(x, sunlight) | Refracting(x, light)) -> Causes(x, SplitIntoDifferentColors(sunlight)) | Causes(x, SplitIntoDifferentColors(light)))", "FOL Translation:\nall x. (Light(x) & Refracted(x) -> SplitsIntoDifferentColors(x))", "exists x. exists y. ((Refracting(x) & LightOrSunlight(x)) & Causes(x, y) & SplitIntoDifferentColors(y))", "all x. (Refracting(x) & (Sunlight(x) | Light(x)) -> Causes(SplitIntoColors(x)))", "all x. ((Sunlight(x) | Light(x)) & Refracts(x) -> CausesToSplitIntoColors(x))", "all x. (Refracting(x) & (Sunlight(x) | Light(x)) -> Causes(x, SplitIntoDifferentColors(x)))", "all x. ((Refracting(x) & (Sunlight(x) | Light(x))) -> Causes(x, SplitIntoDifferentColors(x)))", "all x. (Refracting(x, sunlight) | Refracting(x, light) -> Causes(x, SplitIntoDifferentColors(x)))", "all x. (Refracting(x) & (Sunlight(x) | Light(x)) -> Causes(x, SplitIntoColors(x)))", "all x. (RefractsSunlight(x) -> CausesSplitIntoColors(x))"]}
{"id": "entailmentbank_validation_281", "nl": "a prism can refract light and split the light into different colors.", "fol": "", "prediction": ["exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoDifferentColors(x))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) & CanRefractLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoDifferentColors(x)))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) -> (CanRefractLight(x) & CanSplitLightIntoColors(x)))"]}
{"id": "entailmentbank_validation_282", "nl": "white light is made of all colors of visible light combined.", "fol": "", "prediction": ["all x. (VisibleLightColor(x) -> PartOf(x, white_light))", "FOL Translation:\nall x. (Color(x) & VisibleLight(x) -> PartOf(x, white_light))", "FOL Translation:\nall x. (Color(x) & VisibleLight(x) -> ComponentOf(x, whiteLight))", "FOL Translation:\nMadeOf(white_light, Combine(all y. (Color(y) & VisibleLight(y))))", "Combination(whitelight, all x. (Color(x) & VisibleLight(x)))", "all x. (ColorOfVisibleLight(x) -> PartOf(x, white_light)) & MadeOf(white_light, CombinedColorsOfVisibleLight)", "MadeOf(white_light, Combine(all x. (Color(x) & VisibleLight(x))))", "all x. (WhiteLight(x) -> exists y. (Color(y) & VisibleLight(y) & PartOf(y, x)))", "FOL Translation:\nWhiteLight(x) -> (MadeOf(x, all y. (Color(y) & VisibleLight(y))))", "MadeOf(white_light, Combined(all x. (Color(x) & VisibleLight(x))))", "all x. (WhiteLight(x) -> exists y. (VisibleLight(y) & CombinedColors(y, x)))", "all x. (WhiteLight(x) -> exists y. (VisibleLight(y) & MadeOf(x, y)))", "all x. (VisibleLightColor(x) -> PartOf(x, WhiteLight)) & Combined(WhiteLight)", "all x. (VisibleLight(x) & Color(x) -> PartOf(x, white_light))", "FOL Translation:\nMadeOf(white_light, all y. (ColorOfVisibleLight(y)))", "exists x. (WhiteLight(x) & all y. (Color(y) -> CombinedIn(x, y) & VisibleLight(y)))"]}
{"id": "entailmentbank_validation_283", "nl": "a prism can refract white light and split the light into all colors of visible light.", "fol": "", "prediction": ["exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLightIntoAllColors(x)))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoAllColors(x))", "exists x. (Prism(x) & CanRefract(x, white_light) & SplitIntoColors(x, white_light, all_colors_visible_light))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLightIntoAllColorsOfVisibleLight(x)))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLightIntoColors(x)))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & all y. (Color(y) & VisibleLight(y) -> SplitsInto(x, y)))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoAllVisibleColors(x))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoAllColorsOfVisibleLight(x))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLight(x)))", "exists z. (Prism(z) & CanRefractWhiteLight(z) & CanSplitIntoAllColorsOfVisibleLight(z))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoAllColors(x))", "exists x. (Prism(x) & CanRefractWhiteLight(x) & CanSplitLightIntoColors(x))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitLightIntoAllColorsOfVisibleLight(x)))", "exists x. (Prism(x) -> (CanRefractWhiteLight(x) & CanSplitIntoColorsOfVisibleLight(x)))"]}
{"id": "entailmentbank_validation_284", "nl": "a vacuum has no matter in it.", "fol": "", "prediction": ["all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "FOL Translation:\nVacuum(v) -> all x. (Matter(x) -> -In(v, x))", "all x. ((Vacuum(x)) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all v. (Vacuum(v) -> -exists m. (Matter(m) & In(v, m)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(y, x)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "`all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))`", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "\\-exists x. (Matter(x) & In(vacuum, x))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))", "FOL Translation:\nall x. (Vacuum(x) -> -exists y. (Matter(y) & Inside(y, x)))", "all x. (Vacuum(x) -> -exists y. (Matter(y) & In(x, y)))"]}
{"id": "entailmentbank_validation_285", "nl": "sound requires matter to travel.", "fol": "", "prediction": ["all x. (Sound(x) -> exists y. (Matter(y) & RequiresForTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & Requires(x, y) & CanTravelThrough(x, y)))", "all s. (Sound(s) -> exists m. (Matter(m) & Requires(s, m) & CanTravelThrough(s, m)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all s. (Sound(s) -> exists m. (Matter(m) & Requires(s, m) & CanTravelThrough(s, m)))", "all x. (Sound(x) -> exists y. (Matter(y) & Requires(x, y) & CanTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & Requires(x, y) & ToTravel(x)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravelThrough(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & Requires(x, y) & CanTravelIn(x, y)))", "FOL Translation:\nall x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))", "all x. (Sound(x) -> exists y. (Matter(y) & RequiresToTravel(x, y)))"]}
{"id": "entailmentbank_validation_286", "nl": "sound cannot travel through a vacuum.", "fol": "", "prediction": ["all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravel(sound, x))", "FOL Translation:\nall x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravel(sound, x))", "FOL Translation:\n-Vacuum(y) -> -exists x. (Sound(x) & CanTravelThrough(x, y))", "FOL Translation:\nall x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "FOL Translation:\nall x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (IsVacuum(x) -> -CanTravelThrough(sound, x))", "FOL Translation:\nall x. (Vacuum(x) -> -CanTravel(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "all x. (Vacuum(x) -> -CanTravel(sound, x))", "all x. (Vacuum(x) -> -CanTravelThrough(sound, x))", "For the sentence \"sound cannot travel through a vacuum,\" the logical translation involves saying that for all entities that are sounds, it is not possible to travel through a vacuum. \n\nFOL Translation:\nall x. (Sound(x) -> -CanTravelThroughVacuum(x))", "FOL Translation:\nall x. (Vacuum(x) -> -CanTravelThrough(sound, x))"]}
{"id": "entailmentbank_validation_287", "nl": "metal is a thermal / thermal energy conductor.", "fol": "", "prediction": ["Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "ThermalEnergyConductor(metal)", "Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "ThermalConductor(metal)", "Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)", "ThermalConductor(metal)", "Conductor(metal, thermal_energy)", "ThermalEnergyConductor(metal)", "ThermalEnergyConductor(metal)", "Conductor(metal, thermal_energy)", "Conductor(metal, thermal_energy)"]}
{"id": "entailmentbank_validation_288", "nl": "a spoon sometimes is made of metal.", "fol": "", "prediction": ["exists x. (Spoon(x) & SometimesMadeOf(x, metal))", "exists x. (Spoon(x) & SometimesMadeOf(x, metal))", "exists x. (Spoon(x) & MadeOf(x, metal))", "exists x. (Spoon(x) & MadeOf(x, metal))", "exists x. (Spoon(x) & MadeOfMetal(x))", "exists x. (Spoon(x) & MadeOfMetal(x))", "exists z. (Spoon(z) & MaterialSometimes(z, metal))", "exists x. (Spoon(x) & Material(x, metal))", "exists x. (Spoon(x) & Material(x, metal))", "exists x. (Spoon(x) & MadeOf(x, metal))", "exists x. (Spoon(x) & SometimesMadeOf(x, metal))", "exists x. (Spoon(x) & MadeOfMetal(x))", "exists x. (Spoon(x) & MadeOf(x, metal))", "exists x. (Spoon(x) & Sometimes(MadeOf(x, metal)))", "exists x. (Spoon(x) & (-Material(x, Metal) | Material(x, Metal)))", "exists x. (Spoon(x) & MadeOfMetal(x))"]}
{"id": "entailmentbank_validation_289", "nl": "a metal spoon is a thermal conductor.", "fol": "", "prediction": ["Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "MetalSpoonThermalConductor(x)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(x) & Spoon(x) -> ThermalConductor(x)", "Metal(spoon) & ThermalConductor(spoon)", "Metal(spoon) & ThermalConductor(spoon)", "ThermalConductor(metal_spoon)", "Metal(spoon) & Spoon(spoon) -> ThermalConductor(spoon)", "ThermalConductor(metal_spoon)"]}
{"id": "entailmentbank_validation_290", "nl": "a hot substance is a source of heat.", "fol": "", "prediction": ["all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))", "all x. (Hot(x) -> SourceOfHeat(x))", "all x. (HotSubstance(x) -> SourceOfHeat(x))"]}
{"id": "entailmentbank_validation_291", "nl": "a metal spoon is placed in a pot of hot soup.", "fol": "", "prediction": ["Exists x. Exists y. Exists z. (Metal(x) & Spoon(x) & PlacedIn(x, y) & Pot(y) & Hot(z) & Soup(z) & In(y, z))", "Exists x. (MetalSpoon(x) & Exists y. (Pot(y) & Contains(y, HotSoup) & PlacedIn(x,y)))", "exists x. (MetalSpoon(x) & exists y. (Pot(y) & Contains(y, HotSoup) & PlacedIn(x, y)))", "Exists x. Exists y. Exists z. (MetalSpoon(x) & PlacedIn(x, y) & Pot(y) & HotSoup(z) & In(y, z))", "Exists x. Exists y. (MetalSpoon(x) & Pot(y) & HasHotSoup(y) & PlacedIn(x, y))", "Exists x. Exists y. Exists z. (MetalSpoon(x) & Pot(y) & HotSoup(z) & PlacedIn(x, y) & In(y, z))", "PlacedIn(metal_spoon, pot_of_hot_soup)", "Exists x. Exists y. ((MetalSpoon(x) & PotOfHotSoup(y)) & PlacedIn(x, y))", "Exists x exists y. (MetalSpoon(x) & Pot(y) & PlacedIn(x, y) & HotSoup(y))", "Exists x. Exists y. (MetalSpoon(x) & Pot(y) & PlacedIn(x, y) & HotSoup(y))", "Exists x (Metal(x) & Spoon(x) & Exists y (Pot(y) & HotSoup(y) & PlacedIn(x, y)))", "Exists x. (MetalSpoon(x) & Exists y. (Pot(y) & Has(y, HotSoup) & PlacedIn(x, y)))", "Exists x. Exists y. Exists z. (Metal(x) & Spoon(x) & Pot(y) & Hot(z) & Soup(z) & In(y, z) & PlacedIn(x, y))", "exists x. exists y. (MetalSpoon(x) & Pot(y) & HotSoup(z) & PlacedIn(x, y) & Contains(y, z))", "PlacedIn(metal_spoon, pot_of_hot_soup)", "PlacedIn(metal_spoon, pot_of_hot_soup)"]}
{"id": "entailmentbank_validation_292", "nl": "the hot soup will be a source of heat for the metal spoon.", "fol": "", "prediction": ["exists x. exists y. (HotSoup(x) & MetalSpoon(y) -> SourceOfHeatFor(x, y))", "exists x exists y. (HotSoup(x) & MetalSpoon(y) & SourceOfHeatFor(x, y))", "exists x. exists y. (HotSoup(x) & MetalSpoon(y) -> SourceOfHeatFor(x, y))", "exists x. (Soup(x) & Hot(x) & exists y. (Spoon(y) & Metal(y) & SourceOfHeatFor(x, y)))", "exists x exists y. (HotSoup(x) & MetalSpoon(y) -> SourceOfHeatFor(x, y))", "exists s. (Soup(s) & Hot(s) & exists m. (Metal(m) & Spoon(m) & SourceOfHeatFor(s, m)))", "exists x. (Soup(x) & Hot(x)) -> exists y. (Spoon(y) & Metal(y) & SourceOfHeatFor(x, y))", "exists y. (HotSoup(y) & all z. (MetalSpoon(z) -> SourceOfHeatFor(y, z)))", "exists x. (Soup(x) & Hot(x) & exists y. (Spoon(y) & Metal(y) & SourceOfHeatFor(x, y)))", "SourceOfHeat(hot_soup, metal_spoon)", "exists x. (Soup(x) & Hot(x) & Spoon(y) & Metal(y) -> SourceOfHeatFor(x, y))", "exists x. exists y. (HotSoup(x) & MetalSpoon(y) & SourceOfHeatFor(x, y))", "exists x exists y. (HotSoup(x) & MetalSpoon(y) & SourceOfHeatFor(x, y))", "HOT(soup) & SOURCE_OF_HEAT(soup, spoon) & METAL(spoon)", "exists x. exists y. (HotSoup(x) & MetalSpoon(y) -> SourceOfHeat(x, y))", "exists x. (Soup(x) & Hot(x) -> exists y. (MetalSpoon(y) & SourceOfHeatFor(x, y)))"]}
{"id": "entailmentbank_validation_293", "nl": "if a thermal conductor is exposed to a source of heat, then thermal conduction will make the thermal conductor become hot.", "fol": "", "prediction": ["all x. (all y. ((ThermalConductor(x) & ExposedToHeatSource(x, y)) -> (ThermalConduction(x) & BecomesHot(x))))", "all x. all y. ((ThermalConductor(x) & ExposedToHeatSource(x, y)) -> (ThermalConductionMakesHot(x)))", "all x. ((ThermalConductor(x) & ExposedToHeatSource(x)) -> (ThermalConduction(x) -> BecomesHot(x)))", "all x. ((ThermalConductor(x) & ExposedToHeatSource(x)) -> (ThermalConduction(x) & BecomesHot(x)))", "all x. ((ThermalConductor(x) & ExposedToHeatSource(x)) -> (ThermalConduction(x) -> BecomesHot(x)))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> ThermalConduction(x) & BecomesHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> exists y. (ThermalConduction(y) & MakesHot(y, x)))", "all x. all y. ((ThermalConductor(x) & ExposedToHeatSource(x, y)) -> (ThermalConduction(x, y) -> BecomesHot(x)))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> BecomesHot(x))", "all x. ((ThermalConductor(x) & ExposedToHeatSource(x)) -> (ThermalConductionCauses(Hot(x))))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> exists y. (ThermalConduction(y) & MakesHot(y, x)))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> ThermalConductionCausesHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> exists y. (ThermalConduction(y) & MakesHot(y, x)))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> ThermalConduction(x) -> BecomesHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> BecomesHot(x))", "all x. (ThermalConductor(x) & ExposedToHeatSource(x) -> BecomesHot(x))"]}
{"id": "entailmentbank_validation_294", "nl": "the metal spoon will be heated up by thermal conduction.", "fol": "", "prediction": ["HeatedUpByThermalConduction(metal_spoon)", "`exists x. (MetalSpoon(x) -> HeatsUp(x) & HeatTransferByThermalConduction(x))`", "HeatedUpBy(metal_spoon, thermal_conduction)", "exists x. (MetalSpoon(x) & HeatedByThermalConduction(x))", "exists x. (MetalSpoon(x) -> HeatsUpByThermalConduction(x))", "Exists x. (MetalSpoon(x) -> HeatedUpByThermalConduction(x))", "exists x. (Spoon(x) & Metal(x) & WillBeHeatedBy(x, ThermalConduction))", "exists x. (MetalSpoon(x) -> WillBeHeatedByThermalConduction(x))", "exists x. (MetalSpoon(x) & HeatedByThermalConduction(x))", "exists x. (MetalSpoon(x) -> HeatedUpByThermalConduction(x))", "exists x. (MetalSpoon(x) & HeatsUp(x) & ByThermalConduction(x))", "exists x. (MetalSpoon(x) -> HeatedByThermalConduction(x))", "Exists x. (MetalSpoon(x) -> HeatedUpByThermalConduction(x))", "Exists x, y. (MetalSpoon(x) & Heating(y) & ThermalConduction(y, x))", "HeatedByThermalConduction(metal_spoon)", "Exists x. (Metal(x) & Spoon(x) & WillBeHeatedUpByThermalConduction(x))"]}
{"id": "entailmentbank_validation_295", "nl": "thermal conduction is when heat flows from warmer object to cooler object.", "fol": "", "prediction": ["ThermalConduction(x) <-> (exists y exists z. (HeatFlowsFromTo(y, z) & Warmer(y) & Cooler(z)))", "exists t. (ThermalConduction(t) & all x y. ((Warmer(x) & Cooler(y) & FlowsHeatFromTo(x, y, t)) <-> IsInstanceOf(t, ThermalConduction)))", "all x y. (Warmer(x) & Cooler(y) & HeatFlows(x, y) <-> ThermalConduction(HeatFlows(x, y)))", "all x, y. (Warmer(x) & Cooler(y) & HeatFlows(x, y) <-> ThermalConduction(x, y))", "all x y. (Warmer(x) & Cooler(y) -> ThermalConduction(x, y))", "all x y. ((Warmer(x) & Cooler(y) & HeatFlowsFromTo(x, y)) -> ThermalConduction(HeatFlowsFromTo(x, y)))", "FOL Translation:\nall x all y. (WarmerObject(x) & CoolerObject(y) & HeatFlowsFromTo(x, y) <-> ThermalConduction(x, y))", "ThermalConduction(x) <-> (exists y, z. (HeatFlow(y, z) & Warmer(y) & Cooler(z) & FlowFromTo(x, y, z)))", "all x y. ((WarmerObject(x) & CoolerObject(y) & FlowsHeatFromTo(x, y)) <-> ThermalConduction(x, y))", "all x, y. (WarmerObject(x) & CoolerObject(y) & HeatFlowsFromTo(x, y) -> ThermalConduction).", "all x y. (ThermalConduction(x, y) <-> (Heat(x) & HeatFlowFrom(x, y) & WarmerThan(x, y) & CoolerThan(y, x)))", "exists x, y. (WarmerObject(x) & CoolerObject(y) & ThermalConductionOccursWhen(HeatFlowsFromTo(x, y)))", "all a b. (Warmer(a) & Cooler(b) & HeatFlowsFromTo(a, b) -> ThermalConduction(HeatFlowsFromTo(a, b)))", "all x y. (ThermalConduction(x) & WarmerObject(y) & CoolerObject(z) -> HeatFlowsFromTo(y, z))", "all x y. (ThermalConductionOccurs(x, y) <-> (HeatFlowsFromTo(x, y) & Warmer(x) & Cooler(y)))", "all x y. (ThermalConduction(x, y) <-> (HeatFlowsFromTo(x, y) & WarmerObject(x) & CoolerObject(y)))"]}
{"id": "entailmentbank_validation_296", "nl": "thermal conduction is when materials conduct heat through those materials through collision of particles.", "fol": "", "prediction": ["ThermalConduction(x) <-> (Material(x) & ConductsHeatThroughParticlesCollision(x))", "ThermalConduction(x) <-> (Material(x) & ConductsHeat(x) & ThroughCollisionOfParticles(x))", "all x. (ThermalConduction(x) <-> (Material(x) & ConductsHeatThrough(x, CollisionOfParticles)))", "all x. (Material(x) & ConductsHeatByParticleCollision(x) -> ThermalConduction(x))", "ConductionThermal(x) <-> (Material(x) & ConductHeat(x) & Through(x, CollisionOfParticles))", "all x. (ThermalConduction(x) <-> (ConductsHeat(x) & exists y. (Material(y) & ConductsThrough(y, x) & CollisionOfParticles(x, y))))", "all x. (ThermalConduction(x) <-> (Material(x) & ConductsHeat(x) & Through(x, y) & CollisionOfParticles(y)))", "ThermalConduction(thermal_conduction) <-> all m. ((Material(m) & ConductsHeat(m)) <-> CollisionOfParticlesConductsHeat(m))", "InvolvesThermalConduction(materials, conductsHeat(materials), collisionOfParticles(materials))", "ThermalConduction(x) <-> (Material(x) & exists y. (Material(y) & ConductsHeat(x, y) & CollisionOfParticles(y)))", "ThermalConduction(x) <-> (Material(x) & ConductsHeatThroughCollisionOfParticles(x))", "ThermalConduction(is, all x. (Material(x) & ConductsHeat(x) & ThroughCollisionOfParticles(x)))", "all x. (ThermalConduction(x) <-> (Material(x) & exists y. (ConductHeat(x, y) & CollisionOfParticles(y, x))))", "ThermalConduction(x) <-> exists y. (Material(y) & ConductsHeatThroughCollision(y, x))", "ThermalConduction(x) <-> (Material(x) & ConductsHeatThroughCollisionsOfParticles(x))", "all x. (Material(x) & ConductsHeatThroughCollisionOfParticles(x) -> ThermalConduction(x))"]}
{"id": "entailmentbank_validation_297", "nl": "thermal conduction is a heat exchange process involving the collision of particles.", "fol": "", "prediction": ["Process(thermal_conduction) & HeatExchange(thermal_conduction) & all z. (Particle(z) -> InvolvesCollision(thermal_conduction, z))", "HeatExchangeProcess(thermal_conduction) & all x. (Particle(x) -> InvolvesCollision(thermal_conduction, x))", "HeatExchangeProcess(thermal_conduction) & all x. (CollisionOfParticles(x) -> Involves(thermal_conduction, x))", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, ParticleCollision)", "HeatExchangeProcess(thermal_conduction) & InvolvesCollisionOfParticles(thermal_conduction)", "HeatExchangeProcess(thermal_conduction) & all x. (Particle(x) -> InvolvesCollision(thermal_conduction, x))", "HeatExchangeProcess(thermal_conduction) & involves(thermal_conduction, CollisionOfParticles)", "HeatExchangeProcess(thermal_conduction) & all x. (Particle(x) -> InvolvesCollision(thermal_conduction, x))", "HeatExchangeProcess(thermal_conduction) & all x. (Involves(thermal_conduction, x) -> CollisionOfParticles(x))", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, CollisionOfParticles)", "HeatExchangeProcess(thermal_conduction) & all x. (Particle(x) & InvolvedInCollision(x, thermal_conduction))", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, CollisionOfParticles)", "HeatExchangeProcess(thermal_conduction) & Involves(thermal_conduction, ParticleCollision)", "HeatExchangeProcess(thermal_conduction) & all x. (Involves(thermal_conduction, x) -> CollisionOfParticles(x))", "ThermalConduction(thermal_conduction) & HeatExchangeProcess(thermal_conduction) & all x. (Particle(x) -> InvolvesCollision(thermal_conduction, x))", "HeatExchangeProcess(thermal_conduction) & all x. (CollisionOfParticles(x) -> Involves(thermal_conduction, x))"]}
{"id": "entailmentbank_validation_298", "nl": "longitudinal waves travel through pattern of compressions and rarefactions.", "fol": "", "prediction": ["all x. (LongitudinalWave(x) -> TravelsThrough(x, PatternOfCompressionsAndRarefactions))", "all x. (LongitudinalWave(x) -> TravelsThroughPatternOf(Compressions(x) & Rarefactions(x)))", "all x. (LongitudinalWave(x) -> TravelsThroughPatternOfCompressionsAndRarefactions(x))", "all x. (LongitudinalWave(x) -> exists p. (PatternOfCompressionsAndRarefactions(p) & TravelsThrough(x, p)))", "exists p, c, r. (LongitudinalWave(p) & TravelsThrough(p, c) & PatternOf(c, Compressions) & PatternOf(c, Rarefactions))", "all x. (LongitudinalWave(x) -> TravelsThrough(x, PatternOf(CompressionsAndRarefactions)))", "all x. (LongitudinalWave(x) -> TravelsThroughPatternOfCompressionsAndRarefactions(x))", "all x. (LongitudinalWave(x) -> TravelsThroughPatternOfCompressionsAndRarefactions(x))", "all x. (LongitudinalWave(x) -> (exists y. (CompressionPattern(y) & TravelThrough(x, y)) & exists z. (RarefactionPattern(z) & TravelThrough(x, z))))", "all z. (LongitudinalWave(z) -> Exists y. (Pattern(y) & TravelsThroughPatternOf(z, Compressions(y), Rarefactions(y))))", "exists x. (LongitudinalWave(x) & TravelsThrough(x, PatternOf(CompressionsAndRarefactions)))", "all x. (LongitudinalWave(x) -> TravelThrough(x, PatternOf(Compressions) & PatternOf(Rarefactions)))", "all x. (LongitudinalWave(x) -> TravelsThroughPattern(x, Compressions) & TravelsThroughPattern(x, Rarefactions))", "FOL Translation:\nall x. (LongitudinalWave(x) -> TravelThroughPattern(x, Compressions) & TravelThroughPattern(x, Rarefactions))", "all x. (LongitudinalWave(x) -> TravelThroughPattern(x, CompressionsAndRarefactions))", "FOL Translation:\nall x. (LongitudinalWave(x) -> (TravelsThrough(x, Compressions) & TravelsThrough(x, Rarefactions)))"]}
{"id": "entailmentbank_validation_299", "nl": "compression waves produces compressions and rarefactions.", "fol": "", "prediction": ["all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> Produces(x, Compressions) & Produces(x, Rarefactions))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compressions) & Produces(x, Rarefactions)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compressions) & Produces(x, Rarefactions)))", "all x. (CompressionWave(x) -> (ProducesCompressions(x) & ProducesRarefactions(x)))", "all x. (CompressionWave(x) -> (ProducesCompressions(x) & ProducesRarefactions(x)))", "all x. (CompressionWave(x) -> (ProducesCompressions(x) & ProducesRarefactions(x)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))", "all x. (CompressionWave(x) -> Produces(x, compressions) & Produces(x, rarefactions))", "all x. (CompressionWave(x) -> (Produces(x, Compression) & Produces(x, Rarefaction)))"]}
{"id": "entailmentbank_validation_300", "nl": "longitudinal waves are also called compression waves.", "fol": "", "prediction": ["all x. (LongitudinalWave(x) -> AlsoCalledCompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> AlsoCalled(x, CompressionWave))", "all x. (LongitudinalWave(x) -> AlsoCalled(x, CompressionWave))", "all x. (LongitudinalWave(x) -> AlsoCalled(x, CompressionWave))", "all x. (LongitudinalWave(x) -> CalledCompressionWave(x))", "all x. (LongitudinalWave(x) -> CalledCompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> Called(x, compression_wave))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CalledCompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))", "all x. (LongitudinalWave(x) -> CompressionWave(x))"]}
{"id": "entailmentbank_validation_301", "nl": "longitudinal waves cause object to move in the same direction of the wave.", "fol": "", "prediction": ["FOL Translation:\nall w, o. (LongitudinalWave(w) & ActsOn(w, o) -> MovesInSameDirectionAsWave(o, w))", "all x. (LongitudinalWave(x) -> exists y. (Object(y) & CausesToMoveInSameDirection(x, y)))", "all x. (LongitudinalWave(x) -> (exists y. (Object(y) & Causes(x, MoveInSameDirectionAsWave(y)))))", "all x. (LongitudinalWave(x) -> exists y. (CausesToMoveInDirectionOfWave(x, y)))", "all x y. (LongitudinalWave(x) & Object(y) & Causes(x, MoveInDirection(y, DirectionOfWave(x))))", "all x. (LongitudinalWave(x) -> all y. (Object(y) & CausedByMotionInDirection(y, x) -> MovesInSameDirectionAsWave(y, x)))", "all x y. (LongitudinalWave(x) & Object(y) & ActsInDirectionOf(x, y) -> CausesMovementInSameDirection(x, y))", "all x y. ((LongitudinalWave(x) & Causes(x, y)) -> MovesInSameDirectionAsWave(y, x))", "all x y. (LongitudinalWave(x) & Object(y) & Causes(x, Movement(y)) -> MovesInSameDirectionAsWave(y, x))", "all x. (LongitudinalWave(x) -> exists y. (Object(y) & CausesToMoveSameDirectionAsWave(x, y)))", "all x. (LongitudinalWave(x) -> exists y. (Object(y) & MovesInSameDirectionAsWave(y, x)))", "all w, o. (LongitudinalWave(w) & Affects(w, o) -> MovesInSameDirectionAs(o, w))", "all w, o. (LongitudinalWave(w) & Causes(w, o) -> MovesInSameDirectionAs(o, w))", "all x. (LongitudinalWave(x) -> exists y. (Object(y) & CausesToMoveInSameDirectionOfWave(x, y)))", "all x. (LongitudinalWave(x) -> exists y. (Object(y) & CausesToMoveInSameDirectionAsWave(x, y)))", "all x y. (LongitudinalWave(x) & Object(y) & Cause(x, y) -> MovesInSameDirectionAsWave(y, x))"]}
{"id": "entailmentbank_validation_302", "nl": "compression waves cause object to move in the same direction of the wave.", "fol": "", "prediction": ["all x. ((CompressionWave(x) & Affects(x, y) & Object(y)) -> MovesInSameDirection(y, x))", "all x, y. (CompressionWave(x) & Object(y) & Causes(x, MoveInSameDirectionAsWave(y)))", "all x. all y. (CompressionWave(x) & Object(y) & Causes(x, MoveInDirectionOfWave(y, x)))", "all x, y. (CompressionWave(x) & Object(y) & Causes(x, MoveInSameDirectionAsWave(y)))", "FOL Translation:\nall w, o. (CompressionWave(w) & Affects(w, o) -> MovesInSameDirectionAs(o, w))", "all x y. (CompressionWave(x) & Object(y) & Causes(x, y) -> MovesInDirectionOf(y, x))", "all x. all y. (CompressionWave(x) & Object(y) & MovesInDirectionOf(x, y) -> Causes(x, MoveInSameDirectionAsWave(y)))", "all x. (CompressionWave(x) & Object(y) & Causes(x, MoveInDirectionOfWave(y, x)))", "all x. (CompressionWave(x) -> exists y. (Object(y) & Causes(x, y) & MovesInSameDirectionAs(y, x)))", "all x. (CompressionWave(x) -> exists y. (Object(y) & CauseMoveInDirectionOfWave(x, y)))", "all x y. (CompressionWave(x) & Causes(x, y) & Object(y) -> MovesInSameDirectionAs(y, x))", "all x y. (CompressionWave(x) & Object(y) & CausedBy(Movement(y), x) -> MovesInSameDirectionAsWave(y, x))", "all x. (CompressionWave(x) -> exists y. (Object(y) & Causes(x, MoveInDirectionOfWave(y, x))))", "all x. (CompressionWave(x) -> exists y. (Object(y) & MovesInSameDirectionAs(x, y)))", "all x. all y. (CompressionWave(x) & CausedBy(y, x) -> MovesInDirectionOf(y, x))", "all x y. (CompressionWave(x) & Object(y) & Causes(x, MovesInDirectionOfWave(y, x)))"]}
{"id": "entailmentbank_validation_303", "nl": "a surface is a part of an object.", "fol": "", "prediction": ["all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))", "all x. (Surface(x) -> exists y. (Object(y) & PartOf(x, y)))"]}
{"id": "entailmentbank_validation_304", "nl": "friction occurs when two object's surfaces move against each other.", "fol": "", "prediction": ["exists x exists y. (Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y) -> FrictionOccurs(x, y))", "all x, y. ((Object(x) & Object(y) & MovesAgainst(x, y)) -> FrictionOccurs(x, y))", "exists x exists y (Object(x) & Object(y) & SurfaceOf(x, z) & SurfaceOf(y, w) & MovesAgainst(z, w) -> FrictionOccurs(z, w))", "all x, y. ((Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y)) -> FrictionOccurs(x, y))", "all x, y. ((Object(x) & Object(y) & Surface(x) & Surface(y) & MovesAgainst(x, y)) -> FrictionOccurs(x, y))", "all x, y. (Objects(x) & Objects(y) & MoveAgainstEachOther(SurfaceOf(x), SurfaceOf(y)) -> FrictionOccurs(SurfaceOf(x), SurfaceOf(y)))", "all x, y. (Object(x) & Object(y) & MoveAgainstEachOther(Surface(x), Surface(y)) -> FrictionOccurs(x, y))", "exists x, y. (Object(x) & Object(y) & MovesAgainstEachOtherSurface(x, y) -> FrictionOccurs(x, y))", "all x y. ((Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y)) -> FrictionOccurs(x, y))", "exists x, y. (Object(x) & Object(y) & MovesAgainst(x, y) -> FrictionOccurs(x, y))", "all x, y. ((Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y)) -> FrictionOccurs(x, y))", "all x y. ((Object(x) & Object(y) & MovesAgainst(x, y)) -> FrictionOccurs(x, y))", "all x, y. ((Object(x) & Object(y) & MovesAgainst(x, y)) -> FrictionOccurs(x, y))", "all x, y. (Object(x) & Object(y) & MovesAgainstEachOther(Surfaces(x), Surfaces(y)) -> FrictionOccurs(x, y))", "all x, y. ((Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y)) -> FrictionOccurs(x, y))", "all x y. ((Object(x) & Object(y) & SurfacesMoveAgainstEachOther(x, y)) -> FrictionOccurs(x, y))"]}
{"id": "entailmentbank_validation_305", "nl": "skidding is when the tire of a vehicle slides on the road without rotating.", "fol": "", "prediction": ["all x. (Skidding(x) <-> (Tire(x) & VehicleT(x) & SlidesOnRoad(x) & -Rotating(x)))", "all x. (Skidding(x) <-> (Tire(x) & Vehicle(y) & PartOf(x, y) & SlidesOn(x, road) & -Rotating(x)))", "all x. (Skidding(x) <-> exists y. (Tire(y) & Slides(y) & OnRoad(y) & Vehicle(z) & PartOf(y, z) & -Rotating(y)))", "all x. (Skidding(x) <-> (TireOfVehicle(x) & SlidesOnRoad(x) & -Rotating(x)))", "all x. (Skidding(x) <-> (exists y. (Tire(y) & OnVehicle(y, x) & Slides(y, road) & -Rotating(y))))", "all x. (Skidding(x) <-> (exists y. (Tire(y) & PartOf(y, Vehicle(z)) & SlidesOn(y, Road) & -Rotating(y))))", "all x. (Skidding(x) <-> (exists y. (Tire(y) & PartOf(y, x) & SlidesOn(y, Road) & -Rotates(y))))", "all t. (Tire(t) & Skidding(t) <-> SlidesOnRoad(t) & -Rotating(t))", "all x. (Skidding(x) <-> exists y. (Tire(y) & PartOf(y, x) & Vehicle(x) & SlidesOn(y, road) & -Rotates(y)))", "all x. all y. all z. (Skidding(x, y, z) <-> (Vehicle(y) & Tire(z) & PartOf(z, y) & SlidesOnRoad(z, x) & -Rotating(z)))", "all x. (Skidding(x) <-> exists y. (Tire(y) & Vehicle(z) & PartOf(y, z) & SlidesOn(y, road) & -Rotates(y)))", "all x. (Skidding(x) <-> exists y. (Tire(y) & Vehicle(z) & PartOf(y, z) & SlidesOnRoad(y) & -Rotating(y)))", "all x. (Skidding(x) <-> exists y. (Tire(y) & PartOf(y, x) & Vehicle(x) & SlidesOnRoad(y) & -Rotating(y)))", "all x. (Skid(x) <-> (exists y. (Tire(y) & PartOf(y, x) & Slides(y) & -Rotates(y) & On(y, road))))", "all x. (Skidding(x) <-> (exists y. (Tire(y) & Of(y, x) & Vehicle(x) & SlidesOn(y, road) & -Rotating(y))))", "all x. (Skidding(x) <-> (exists y. (Tire(y) & Vehicle(y) & PartOf(y, x) & SlidesOnRoad(y) & -Rotating(y))))"]}
{"id": "entailmentbank_validation_306", "nl": "a tire is a kind of object.", "fol": "", "prediction": ["all x. (Tire(x) -> Object(x))", "Object(tire)", "Object(tire)", "all x. (Tire(x) -> Object(x))", "all x. (Tire(x) -> Object(x))", "Object(tire)", "all x. (Tire(x) -> Object(x))", "all x. (Tire(x) -> Object(x))", "all x. (Tire(x) -> Object(x))", "all x. (Tire(x) -> Object(x))", "Object(tire)", "Object(tire)", "Object(tire)", "all x. (Tire(x) -> Object(x))", "Object(tire)", "all x. (Tire(x) -> Object(x))"]}
{"id": "entailmentbank_validation_307", "nl": "skidding causes friction between the tire and the road.", "fol": "", "prediction": ["exists x exists y. (Skidding(x) & Tire(y) & Road(z) & Causes(x, Friction(y, z)))", "exists x exists y. (Tire(x) & Road(y) & Skidding(x, y) -> CausesFriction(x, y))", "exists x exists y. (Tire(x) & Road(y) & Skidding(x) & Causes(Skidding(x), Friction(x, y)))", "exists x exists y. (Skidding(x) & Tire(y) & Road(x) & Causes(x, FrictionBetween(y, x)))", "exists x, y, z. (Skidding(x) & Tire(y) & Road(z) -> CausesFriction(x, y, z))", "exists x exists y. (Skidding(x) & Tire(y) & Road(z) & Causes(x, Friction(y, z)))", "exists x exists y. (Skidding(x) & Tire(x) & Road(y) & Causes(x, FrictionBetween(x, y)))", "exists x exists y. (Skidding(x) & Tire(x) & Road(y) & Causes(x, Friction(x, y)))", "exists x exists y. (Skidding(x) & Tire(x) & Road(y) -> Causes(FrictionBetween(x, y)))", "exists x exists y. (Skidding(x) & Tire(y) & Road(z) & Causes(x, Friction(y, z)))", "exists x exists y exists z. (Skidding(x) & Tire(y) & Road(z) & CausesFriction(x, y, z))", "exists x, y, z. (Skid(x) & Tire(y) & Road(z) & Causes(x, Friction(y, z)))", "exists x, y. (Skidding(x, y) & Tire(x) & Road(y) -> CausesFriction(x, y))", "exists x, y, z. (Skidding(x) & Tire(y) & Road(z) & CausesFrictionBetween(x, y, z))", "FOL Translation:\nall x y z. (Skidding(x, y, z) -> FrictionBetween(x, y, z))", "exists x exists y. (Tire(x) & Road(y) & Skidding(x, y) -> Causes(Friction(x, y), Skidding(x, y)))"]}
{"id": "entailmentbank_validation_308", "nl": "friction causes the temperature of an object to increase.", "fol": "", "prediction": ["`all x. (Object(x) & FrictionAffects(x) -> Causes(Friction, TemperatureIncreases(x)))`", "exists x, y. (Friction(x) & Object(y) & Causes(x, IncreasesTemperature(y)))", "all x. (Object(x) & FrictionAffects(x) -> Causes(Friction, IncreaseTemperature(x)))", "all x. (Object(x) -> (Friction(x) -> Causes(Friction(x), IncreaseTemperature(x))))", "all x. (Object(x) & FrictionCausesIncreaseInTemp(x))", "all x. (Object(x) & Friction(x) -> Causes(Friction(x), IncreaseTemperature(x)))", "all x. (Object(x) & FrictionCausesTemperatureIncrease(x) -> IncreasesTemperature(x))", "exists y. (Friction(y) & all x. (Object(x) & TemperatureIncreasesDueTo(x, y)))", "all x. (Object(x) & FrictionIncreasesTemperatureOf(x))", "all x. (Friction(x) -> exists y. (Object(y) & CausesIncreaseInTemperature(x, y)))", "all x. (Friction(x) -> Causes(x, TemperatureIncrease(object)))", "all x. (Object(x) & Friction(x) -> IncreasesTemperature(x))", "all x. (Object(x) & FrictionIncreasesTemperature(x))", "all x. (Object(x) & FrictionCauses(x) -> TemperatureIncreases(x))", "all x. (Object(x) & FrictionCausesTemperatureIncrease(x))", "FOL Translation:\nall x. (Object(x) & FrictionInvolved(x) -> IncreasesTemperature(x))"]}
{"id": "entailmentbank_validation_309", "nl": "friction causes the temperature of the tire to increase.", "fol": "", "prediction": ["exists x exists y. (Friction(x) & TemperatureOf(y) & Tire(y) & Causes(x, Increase(y)))", "exists x. exists y. (Friction(x) & Tire(y) & Causes(x, IncreasesTemperature(y)))", "exists x. (Friction(x) & causes(x, IncreaseTemperature(tire)))", "exists x, y. (Friction(x, y) & Tire(y) -> CausesIncreaseInTemperature(x, y))", "exists x. (Friction(x) & exists y. (Tire(y) & Causes(x, Increase(Temperature(y)))))", "exists x, y. (Friction(x) & Tire(y) & Causes(x, Increase(Temperature(y))))", "exists x. exists y. (Friction(x, y) & Tire(y) & Causes(x, IncreaseTemperature(y)))", "exists x. exists y. (Friction(x, y) & Tire(y) & Causes(x, TemperatureIncrease(y)))", "exists x. exists y. (Friction(x) & Tire(y) & Causes(x, IncreaseTemperature(y)))", "exists y. (Friction(y) & exists z. (Tire(z) & Causes(y, IncreaseTemperature(z))))", "exists x. (Friction(x) -> exists y. (Tire(y) & Causes(x, TemperatureIncrease(y))))", "exists x, y. (Friction(x, y) & Tire(y) -> CausesIncreaseInTemperature(x, y))", "FOL Translation:\nall x. (Tire(x) & FrictionAffects(x) -> TemperatureIncrease(x))", "exists x, y, z. (Friction(x) & Temperature(y) & Tire(z) & Causes(x, Increase(y, z)))", "exists x, y. (Friction(x) & Tire(y) & Causes(x, IncreaseTemperature(y)))", "exists x. (Friction(x) & all y. (Tire(y) -> Causes(x, Increase(Temperature(y)))))"]}
{"id": "entailmentbank_validation_310", "nl": "if the tire overheats, some chemical in the tire will vaporized.", "fol": "", "prediction": ["exists x. (Chemical(x) & InTire(x) -> if Overheats(tire) then WillVaporize(x))", "FOL Translation:\nall x. (Tire(x) & Overheats(x) -> exists y. (ChemicalInTire(x, y) & Vaporized(y)))", "exists x. (Tire(t) & ChemicalIn(t, x) & Overheats(t) -> Vaporizes(x))", "exists y. ((Overheats(tire) & ChemicalIn(tire, y)) -> Vaporized(y))", "exists y. (ChemicalIn(tire, y) & Overheats(tire) -> Vaporized(y))", "exists y. (Tire(t) & Overheats(t) -> (Chemical(y, t) & WillVaporize(y)))", "FOL Translation:\nall x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & In(x, y) & WillVaporize(y)))", "exists y. (ChemicalIn(y, tire) & Overheats(tire) -> Vaporizes(y))", "exists y. (TireOverheats(y) -> exists z. (ChemicalInTire(z, y) & Vaporizes(z)))", "exists x. (ChemicalInTire(x) & all y. (Overheats(tire) -> WillVaporized(x)))", "exists y. (Chemical(y, tire) & Overheats(tire) -> Vaporized(y))", "all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & In(x, y) & WillVaporize(y)))", "all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & In(x, y) & WillVaporize(y)))", "exists y. (Chemical(y) & InTire(y) & all x. (Tire(x) & Overheats(x) -> WillVaporize(y)))", "all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))", "all x. (Tire(x) & Overheats(x) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))"]}
{"id": "entailmentbank_validation_311", "nl": "if the temperature of the tire keeps increasing, the tire will overheat.", "fol": "", "prediction": ["all x. (Tire(x) & TemperatureIncreases(x) -> Overheats(x))", "all x. ((Tire(x) & TemperatureIncreasing(x)) -> Overheat(x))", "all x. (Tire(x) & TemperatureIncreases(x) -> Overheats(x))", "all x. ((Tire(x) & TemperatureIncreasing(x)) -> Overheat(x))", "all x. ((Tire(x) & TemperatureIncreases(x)) -> Overheat(x))", "all x. ((Tire(x) & TemperatureIncreases(x)) -> WillOverheat(x))", "all x. ((Tire(x) & TemperatureIncreasing(x)) -> Overheat(x))", "all x. (Tire(x) & IncreasingTemperature(x) -> WillOverheat(x))", "all x. ((Tire(x) & TemperatureIncreasing(x)) -> Overheats(x))", "all x. ((Tire(x) & TemperatureIncreases(x)) -> WillOverheat(x))", "all x. (Tire(x) & KeepsIncreasing(TemperatureOf(x)) -> Overheats(x))", "all x. (Tire(x) & TemperatureIncreasing(x) -> WillOverheat(x))", "all x. (Tire(x) & TemperatureIncreases(x) -> Overheats(x))", "exists x. (Tire(x) & all t. (IncreasingTemperature(x, t) -> Overheats(x)))", "all x. (Tire(x) & TemperatureIncreasing(x) -> Overheats(x))", "all x. (Tire(x) & IncreasingTemperature(x) -> WillOverheat(x))"]}
{"id": "entailmentbank_validation_312", "nl": "if the temperature of the tire keeps increasing, some chemical in the tire will be vaporized.", "fol": "", "prediction": ["all x. ((Tire(x) & IncreasingTemperature(x)) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))", "FOL Translation:\nall x. (Tire(x) & IncreasingTemperature(x) -> exists y. (ChemicalInTire(x, y) & WillBeVaporized(y)))", "all x. ((Tire(x) & IncreasingTemperature(x)) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))", "all x. (Tire(x) & Increases(Temperature(x)) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))", "all t. (Temperature(t) & Tire(t) & Increasing(t) -> exists c. (Chemical(c) & InTire(c, t) & WillBeVaporized(c)))", "all x. (Tire(x) & IncreasingTemperature(x) -> exists y. (Chemical(y) & InTire(y, x) & WillBeVaporized(y)))", "FOL Translation:\nall x. (Tire(x) & TemperatureIncreasing(x) -> exists y. (ChemicalIn(x, y) & WillBeVaporized(y)))", "all x. ((Tire(x) & TemperatureIncreases(x)) -> exists y. (ChemicalIn(x, y) & WillBeVaporized(y)))", "FOL Translation:\nall t. ((Tire(t) & TemperatureIncreases(t)) -> exists c. (ChemicalIn(t, c) & WillBeVaporized(c)))", "all t. ((Tire(t) & Increases(Temperature(t))) -> exists c. (Chemical(c) & InTire(c, t) & WillBeVaporized(c)))", "all t. (IncreasingTemperatureOf(t, tire) -> exists c. (ChemicalIn(c, tire) & WillBeVaporized(c)))", "all x. (Tire(x) & KeepsIncreasing(Temperature(x)) -> exists y. (Chemical(y) & InTire(y, x) & Vaporized(y)))", "all t. (Temperature(t) & Tire(t) & Increases(t) -> exists c. (Chemical(c) & InTire(c, t) & WillBeVaporized(c)))", "all x. (Tire(x) & IncreasingTemperature(x) -> exists y. (ChemicalInTire(y, x) & WillBeVaporized(y)))", "exists t. (Tire(t) & all x. (Temperature(t, x) & Increasing(x) -> exists c. (Chemical(c) & InTire(c, t) & WillBeVaporized(c))))", "all x. ((Tire(x) & all t. (TemperatureOf(x, t) & Increasing(t))) -> exists y. (Chemical(y) & In(x, y) & WillBeVaporized(y)))"]}
{"id": "entailmentbank_validation_313", "nl": "friction causes some chemicals in the tire to vaporize.", "fol": "", "prediction": ["exists x. (ChemicalInTire(x) & FrictionCausesVaporization(x))", "exists x. (Chemical(x) & InTire(x) & exists y. (Friction(y) & Causes(y, Vaporize(x))))", "exists x. (Chemical(x) & InTire(x) & Causes(friction, Vaporize(x)))", "exists x. (Chemical(x) & InTire(x) & exists y. (Friction(y) & Causes(y, Vaporize(x))))", "exists x. (ChemicalInTire(x) & FrictionCausesVaporization(x))", "exists x. (ChemicalInTire(x) & FrictionCausesVaporization(x))", "exists x. (Chemical(x) & InTire(x) & FrictionCausesVaporize(friction, x))", "exists x. (ChemicalInTire(x) & FrictionCausesVaporize(x))", "exists y. (ChemicalInTire(y) & all x. (Friction(x, y) -> Vaporizes(y)))", "FOL Translation:\nexists y. (Chemical(y) & InTire(y) & FrictionCausesVaporize(y))", "exists x. (Chemical(x) & InTire(x) & all y. (Friction(y) -> Causes(y, Vaporize(x))))", "exists x. (Chemical(x) & InTire(x) & exists y. (Friction(y) & Causes(y, Vaporize(x))))", "exists x. (Chemical(x) & InTire(x) & CausedToVaporizeBy(friction, x))", "exists z. (Chemical(z) & InTire(z) & all x. (Friction(x) -> Causes(x, Vaporize(z))))", "exists x. (Chemical(x) & InTire(x) & Causes(Friction, Vaporize(x)))", "exists x. (ChemicalInTire(x) & FrictionCausesVaporize(x))"]}
{"id": "entailmentbank_validation_314", "nl": "vaporizing a substance causes smoke.", "fol": "", "prediction": ["all x. (Substance(x) & Vaporizing(x) -> CausesSmoke(x))", "all x. (Substance(x) & Vaporized(x) -> CausesSmoke(x))", "all x. (Substance(x) & Vaporizes(x) -> CausesSmoke(x))", "all x. (Substance(x) & Vaporizing(x) -> CausesSmoke(x))", "all x. (SubstanceVaporized(x) -> Causes(Smoke, x))", "all x. (Substance(x) & Vaporizes(x) -> CausesSmoke(x))", "all x. (Vaporizes(x) -> CausesSmoke(x))", "exists x. exists y. (Vaporizes(x, y) -> CausesSmoke(x, y))", "all x. (Substance(x) & Vaporizing(x) -> Causes(Smoke, x))", "all x. (Substance(x) & Vaporizes(x) -> CausesSmoke(x))", "all x. (Vaporizes(x) -> CausesSmoke(x))", "all s. (Substance(s) & Vaporizing(s) -> CausesSmoke(s))", "all x. (Vaporizes(x) -> Causes(x, Smoke))", "all x. (Substance(x) -> (Vaporizing(x) -> Causes(Vaporizing(x), Smoke(x))))", "all x. (Vaporizing(x) -> Causes(Smoke, x))", "all x. (Substance(x) & Vaporizing(x) -> Causes(Smoke, x))"]}
{"id": "entailmentbank_validation_315", "nl": "friction causes the tire to produce smoke.", "fol": "", "prediction": ["exists x. exists y. (Friction(x) & Tire(y) & Causes(x, ProduceSmoke(y)))", "exists x. (Friction(x) & exists y. (Tire(y) & Causes(x, ProducesSmoke(y))))", "exists x exists y. (Friction(x) & Tire(y) & Causes(x, ProduceSmoke(y)))", "exists x. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produce(y, z)))", "FOL Translation:\nexists x. exists y. (FrictionCauses(x, y) & Tire(y) & ProducesSmoke(y))", "exists x exists y. (Friction(x) & Tire(y) & Causes(x, ProduceSmoke(y)))", "exists x. (FrictionCauses(x, tire) & ProduceSmoke(tire))", "exists x. exists y. exists z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produces(y, z)))", "exists x exists y. (Friction(x) & Tire(y) -> Causes(x, ProducesSmoke(y)))", "exists x, y, z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produces(y, z)))", "exists x. exists y. (Friction(x) & Tire(y) & Causes(x, ProducesSmoke(y)))", "exists x. exists y. (Friction(x) & Tire(y) & Causes(x, ProduceSmoke(y)))", "`exists x. (Friction(x) & exists y. (Tire(y) & Causes(x, ProduceSmoke(y))))`", "exists x exists y. (Friction(x, y) & Tire(y) -> ProducesSmoke(y))", "exists x. exists y. (Friction(x) & Tire(y) & Causes(x, ProduceSmoke(y)))", "exists x exists y exists z. (Friction(x) & Tire(y) & Smoke(z) & Causes(x, Produces(y, z)))"]}
{"id": "entailmentbank_validation_316", "nl": "as the friction increases, the resistance on the object to move will increase.", "fol": "", "prediction": ["all x. (Object(x) & Increases(Friction) -> Increases(ResistanceToMove(x)))", "all x. (Object(x) & FrictionIncreases(x) -> ResistanceToMoveIncreases(x))", "all x. (Object(x) -> (FrictionIncreases(x) -> ResistanceIncreases(x)))", "all x. (Object(x) & Increases(Friction) -> Increases(ResistanceToMove(x)))", "all x. all y. ((FrictionIncreases(x) & Object(y)) -> ResistanceToMoveIncreases(y))", "all x. (FrictionIncreases(x) -> ResistanceToMoveIncreases(x))", "all x. (Object(x) & Increase(Friction) -> Increase(ResistanceToMove(x)))", "all x. (FrictionIncreases(x) -> ResistanceIncreases(x))", "all x. (Object(x) -> (FrictionIncreases(x) -> ResistanceToMoveIncreases(x)))", "all x. (Object(x) & FrictionIncreases(x) -> ResistanceToMoveIncreases(x))", "all x y. ((Object(x) & FrictionIncreases(y) & IsActingOn(y, x)) -> ResistanceToMoveIncreases(x))", "all x. (Object(x) & Increases(Friction(x)) -> Increases(ResistanceToMove(x)))", "all x. (Object(x) -> (Increases(Friction) -> Increases(ResistanceToMove(x))))", "all x. (Object(x) & FrictionIncreases(x) -> ResistanceToMoveIncreases(x))", "all x. (FrictionIncreases(x) -> ResistanceIncreases(x))", "all x. (Object(x) -> (Increase(Friction) -> Increase(ResistanceToMove(x))))"]}
{"id": "entailmentbank_validation_317", "nl": "as roughness of a surface increases, friction will increase.", "fol": "", "prediction": ["all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) -> (Increases(Roughness(x)) -> Increases(Friction(x))))", "all x. ((Surface(x) & Increases(Roughness(x))) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. ((Surface(x) & Increases(Roughness(x))) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & IncreasesRoughness(x) -> IncreasesFriction(x))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))", "all x. (Surface(x) & Increases(Roughness(x)) -> Increases(Friction(x)))"]}
{"id": "entailmentbank_validation_318", "nl": "as the roughness of a surface increases, the resistance on the object to move will increase.", "fol": "", "prediction": ["all x all y. (Surface(x) & Object(y) & RoughnessIncreases(x) -> ResistanceToMoveIncreases(y, x))", "all x. all y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y, x)))", "all x y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y)))", "all x. (Surface(x) & RoughnessIncreases(x) -> ResistanceToMoveIncreases(x))", "all x. all y. ((Surface(x) & Object(y) & RoughnessIncreases(x) & On(x, y)) -> ResistanceIncreases(y))", "all s, o. (Surface(s) & Object(o) & Increases(Roughness(s)) -> Increases(ResistanceToMove(o, s)))", "all x. (Surface(x) -> all y. (Object(y) & InContactWith(y, x) -> (Increases(Roughness(x)) -> Increases(ResistanceToMove(y)))))", "all x, y. ((Surface(x) & Object(y) & RoughnessIncreases(x)) -> ResistanceToMoveIncreases(y))", "all x y. (Surface(x) & Object(y) & Increases(Roughness(x)) -> Increases(ResistanceToMove(y)))", "all x, y. (Surface(x) & Object(y) & RoughnessIncreases(x) -> ResistanceToMoveIncreases(y, x))", "all x y. ((Surface(x) & Object(y) & Increases(Roughness(x))) -> Increases(ResistanceToMove(y)))", "all x y. ((Surface(x) & Object(y) & RoughnessIncreases(x)) -> ResistanceIncreases(y, x))", "all x. all y. (Surface(x) & Object(y) & RoughnessIncreases(x) -> ResistanceToMoveIncreases(y, x))", "all s. all o. ((Surface(s) & Object(o) & Increases(Roughness(s))) -> Increases(ResistanceToMove(o, s)))", "all x, y. (Surface(x) & Object(y) & Increases(Roughness(x)) -> Increases(ResistanceToMove(y, x)))", "all x y. ((Surface(x) & Object(y) & RoughnessIncreases(x) & On(y, x)) -> ResistanceIncreases(y))"]}
{"id": "entailmentbank_validation_319", "nl": "carpet has a rough surface.", "fol": "", "prediction": ["RoughSurface(carpet)", "HasRoughSurface(carpet)", "exists x. (Carpet(x) & HasRoughSurface(x))", "exists x. (Carpet(x) & RoughSurface(x))", "RoughSurface(carpet)", "RoughSurface(carpet)", "SurfaceType(carpet, rough)", "SurfaceType(carpet, rough)", "exists y. (Carpet(y) & HasRoughSurface(y))", "Surface(carpet, rough)", "exists x. (Carpet(x) & RoughSurface(x))", "exists x. (Carpet(x) & HasRoughSurface(x))", "RoughSurface(carpet)", "RoughSurface(carpet)", "Surface(carpet, rough)", "RoughSurface(carpet)"]}
{"id": "entailmentbank_validation_320", "nl": "wood has a smooth surface.", "fol": "", "prediction": ["SmoothSurface(wood)", "SmoothSurface(wood)", "SmoothSurface(wood)", "HasSmoothSurface(wood)", "Exists x. (Wood(x) & HasSmoothSurface(x))", "SmoothSurface(wood)", "SmoothSurface(wood)", "SmoothSurface(wood)", "SmoothSurface(wood)", "SmoothSurface(wood)", "HasSmoothSurface(wood)", "exists x. (Wood(x) & SmoothSurface(x))", "SmoothSurface(wood)", "HasSmoothSurface(wood)", "SmoothSurface(wood)", "SmoothSurface(wood)"]}
{"id": "entailmentbank_validation_321", "nl": "the resistance on the object to move on the carpet will be larger than on the wood.", "fol": "", "prediction": ["exists x. exists y. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))", "exists x. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x. exists y. exists z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))", "all x. (Object(x) -> (ResistanceToMoveOn(x, carpet) > ResistanceToMoveOn(x, wood)))", "exists o. (Object(o) -> (Resistance(o, carpet) > Resistance(o, wood)))", "exists x. exists y. exists z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))", "exists x. (Object(x) & Carpet(c) & Wood(w) & ResistanceToMoveOn(x, c) > ResistanceToMoveOn(x, w))", "exists x, y, z. (Resistance(x, y, carpet) & Resistance(x, y, wood) & Larger(Resistance(x, y, carpet), Resistance(x, y, wood)))", "exists obj, carpet, wood. (Object(obj) & Carpet(carpet) & Wood(wood) & LargerResistance(obj, carpet, wood))", "exists x. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x, y, z. (Object(x) & Carpet(y) & Wood(z) -> ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x. exists y. exists z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))", "exists x, y, z, w. (Object(x) & Carpet(y) & Wood(z) & Larger(ResistanceToMove(x, y), ResistanceToMove(x, z)))", "exists x, y, z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x, y. (Object(x) & Carpet(y) & Wood(z) -> LargerThan(ResistanceToMoveOn(x, y), ResistanceToMoveOn(x, z)))", "exists x, y, z. (Object(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))"]}
{"id": "entailmentbank_validation_322", "nl": "a toy car is a kind of object.", "fol": "", "prediction": ["ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "Object(toy_car)", "ToyCar(t) -> Object(t)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "Object(toy_car)", "ToyCar(toycar) -> Object(toycar)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)", "ToyCar(x) -> Object(x)"]}
{"id": "entailmentbank_validation_323", "nl": "the resistance on the toy car to move on the carpet is larger than on the wood.", "fol": "", "prediction": ["The translation of the given sentence into FOL is:\n\nResistance(toy_car, carpet) > Resistance(toy_car, wood)", "exists x. (ToyCar(x) & exists y. (Carpet(y) & exists z. (Wood(z) & Larger(ResistanceToMove(x, y), ResistanceToMove(x, z)))))", "Resistance(toy_car, carpet) > Resistance(toy_car, wood)", "LargerResistance(toy_car, carpet, wood)", "LargerResistanceOnCarpet(toy_car) & Resistance(toy_car, carpet) > Resistance(toy_car, wood)", "Exists x. (ToyCar(x) & Exists y. (Carpet(y) & Exists z. (Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))))", "exists t, c, w. (ToyCar(t) & Carpet(c) & Wood(w) & ResistanceToMove(t, c, r1) & ResistanceToMove(t, w, r2) & r1 > r2)", "Resistance(toy_car, move, carpet) > Resistance(toy_car, move, wood)", "LargerResistance(resistance_on_toy_car_on_carpet, resistance_on_toy_car_on_wood)", "exists x, y, z. (Resistance(x, toy_car, carpet) & Resistance(y, toy_car, wood) & LargerThan(x, y))", "LargerResistanceOnCarpet(toy_car, carpet, wood)", "exists x y z. (ToyCar(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "exists x. exists y. exists z. exists w. (ToyCar(x) & Carpet(y) & Wood(z) & ResistanceOn(x, y, r1) & ResistanceOn(x, z, r2) & Larger(r1, r2))", "Exists x. (ToyCar(x) & Carpet(y) & Wood(z) & ResistanceToMove(x, y) > ResistanceToMove(x, z))", "`Resistance(toy_car, carpet) > Resistance(toy_car, wood)`", "exists x. exists y. exists z. (ToyCar(x) & Carpet(y) & Wood(z) & ResistanceToMoveOn(x, y) > ResistanceToMoveOn(x, z))"]}
{"id": "entailmentbank_validation_324", "nl": "as the resistance on the object to move increase, the object will move slower.", "fol": "", "prediction": ["all x. all y. ((ResistanceToMove(y, x) & Increases(y)) -> MovesSlower(x))", "all x. ((Object(x) & Increases(ResistanceToMove(x))) -> MovesSlower(x))", "all x. (Object(x) & Increase(ResistanceToMove(x)) -> MoveSlower(x))", "all x. (Object(x) & IncreaseResistanceToMove(x) -> MoveSlower(x))", "all x. (Object(x) & IncreasesResistanceToMove(x) -> MovesSlower(x))", "all x. (Object(x) & ResistanceToMoveIncreases(x) -> MovesSlower(x))", "all x. (Object(x) & ResistanceIncrease(x) -> MovesSlower(x))", "To translate the sentence into first-order logic, we need to identify the conditions and implications expressed in it. Specifically, the sentence describes a relationship between the resistance to an object's movement and its speed. Here is one way to represent that relationship in FOL:\n\nall x. (Object(x) & IncreaseResistanceToMove(x) -> MoveSlower(x))", "FOL Translation:\nall x, y. (Object(x) & ResistanceIncrease(x, y) -> MoveSlower(x))", "all x. (Object(x) & IncreaseResistanceToMove(x) -> MoveSlower(x))", "all x. (Object(x) & IncreasedResistanceToMove(x) -> MovesSlower(x))", "all x. (Object(x) & IncreaseResistanceToMove(x) -> MoveSlower(x))", "all x. ((Object(x) & Increase(ResistanceToMove(x))) -> MovesSlower(x))", "all x. all y. ((Object(x) & ResistanceToMoveIncrease(y, x)) -> MoveSlower(x))", "all x. (Increase(Resistance(x)) -> MoveSlower(x))", "all x. (Object(x) & IncreaseResistanceToMove(x) -> MoveSlower(x))"]}
{"id": "entailmentbank_validation_325", "nl": "the toy car will move slower on the carpet than on the wood.", "fol": "", "prediction": ["exists c, w. (Carpet(c) & Wood(w) & ToyCar(toycar) -> MovesSlower(toycar, c, w))", "exists x. (ToyCar(x) -> exists y, z. (Carpet(y) & Wood(z) & MovesSlowerOn(x, y, z)))", "MoveSlowerOn(toy_car, carpet, wood)", "exists x. exists y. (ToyCar(x) & Carpet(y) & Wood(z) & MovesSlowerOn(x, y, z))", "Exists x. Exists y. Exists z. (ToyCar(x) & Carpet(y) & Wood(z) & MovesSlowerOn(x, y, z))", "FOL Translation:\nexists x y z. (ToyCar(x) & Carpet(y) & Wood(z) & MovesSlowerOn(x, y, z))", "Translate the following sentence into FOL:\n\nFOL Translation:\nMoveSlower(toy_car, carpet, wood)", "exists x. exists y. exists z. ((ToyCar(x) & Carpet(y) & Wood(z)) -> MovesSlowerOn(x, y, z))", "`SlowerOnSurface(toy_car, carpet, wood)`", "exists x exists y exists z. (ToyCar(x) & Carpet(y) & Wood(z) & MovesSlowerOn(x, y, z))", "exists x, y, z. (ToyCar(x) & Carpet(y) & Wood(z) & WillMoveSlowerOn(x, y, z))", "MoveSlowerOn(the_toy_car, carpet, wood)", "MoveSlowerOnSurface(toy_car, carpet, wood)", "exists x. (ToyCar(x) & exists y. (Carpet(y) & exists z. (Wood(z) & MovesSlowerOn(x, y, z))))", "exists x. (ToyCar(x) & exists y. (Carpet(y) & exists z. (Wood(z) & MovesSlowerOn(x, y, z))))", "Let the constants be `toyCar`, `carpet`, and `wood`, and let the predicates be `MovesSlowerOn(x, y, z)`, representing \"x moves slower on y than on z\".\n\nFOL Translation:\nMovesSlowerOn(toyCar, carpet, wood)"]}
{"id": "entailmentbank_validation_326", "nl": "a glider is a kind of object.", "fol": "", "prediction": ["Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Object(glider)", "Glider(g) -> Object(g)", "Object(glider)", "Glider(x) -> Object(x)", "Object(glider)"]}
{"id": "entailmentbank_validation_327", "nl": "flying an object requires lift to oppose the object's weight.", "fol": "", "prediction": ["all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & OpposesWeight(y, x))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. (Object(x) -> (exists y. (Flying(x, y) -> RequiresLiftToOpposeWeight(x))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. (Object(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Object(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Object(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Object(x) -> (Flying(x) -> requires(Lift(x), Oppose(Weight(x)))))", "FOL Translation:\nall x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all o. (Object(o) & Flying(o) -> exists l. (Lift(l) & Opposes(l, Weight(o))))", "all x. (Object(x) -> (Flying(x) -> RequiresLift(x) & Opposes(Lift(x), Weight(x))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. (Object(x) & Flying(x) -> requires(Lift, Oppose(Weight(x))))", "all x. (Object(x) -> (requires(Flying(x), exists y. (Lift(y) & Oppose(y, WeightOf(x))))))", "all x. (Object(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))"]}
{"id": "entailmentbank_validation_328", "nl": "flying a glider requires lift to oppose the weight of the glider.", "fol": "", "prediction": ["all x. (FlyingGlider(x) -> exists y. (Lift(y) & OpposesWeight(y, x)))", "all x. (Glider(x) -> (exists y. (Lift(y) & Opposes(y, Weight(x))) -> Flying(x)))", "all x. (Glider(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Flying(x) & Glider(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (FlyingGlider(x) -> exists y. (Lift(y) & OpposesWeightOf(y, x)))", "all x. (Flying(x) & Glider(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Glider(x) -> (Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x)))))", "all x. ((Glider(x) & Flies(x)) -> exists y. (Lift(y) & OpposesWeightOf(y, x)))", "all x. (Glider(x) -> (exists y. (Fly(y, x) & Requires(y, LiftToOpposeWeight(x)))))", "all x. (FlyingGlider(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "FOL Translation:\nall x. (Glider(x) -> (Requires(Flying(x), Lift(x)) & Opposes(Lift(x), Weight(x))))", "all x. (Glider(x) & Flying(x) -> exists y. (Lift(y) & Opposes(y, Weight(x))))", "all x. (Glider(x) -> (exists y. (Flying(x, y) & Lift(y) & Opposes(y, Weight(x)))))", "all g. (Glider(g) -> (exists l. (Lift(l) & Opposes(l, Weight(g))) -> Requires(Fly(g), l)))", "all x. (Glider(x) & Flying(x) -> exists y. (LiftOpposesWeightOf(y, x) & Lift(y) & WeightOf(x)))", "all x. ((Glider(x) & Fly(x)) -> exists y. (Lift(y) & Opposes(y, Weight(x))))"]}
{"id": "entailmentbank_validation_329", "nl": "pedals are part of a bicycle for pedalling.", "fol": "", "prediction": ["all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all z. (Pedal(z) -> exists x. (Bicycle(x) & PartOf(z, x) & ForPedaling(z)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & FunctionFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (PartOf(x, y) & Bicycle(y) & ForPedalling(x)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & UsedFor(x, Pedalling)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & ForPedalling(x)))"]}
{"id": "entailmentbank_validation_330", "nl": "pedalling a bicycle requires moving the pedals in a circular motion.", "fol": "", "prediction": ["all x. (PedalBicycle(x) -> Requires(MovePedalsCircularly(x)))", "all x. (Bicycle(x) -> (Pedalling(x) -> Requires(MovingPedalsInCircularMotion(x))))", "all x. (Pedalling(bicycle, x) -> Requires(x, MovingInCircularMotion(pedals)))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsCircularly))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (PedallingBicycle(x) -> Requires(x, all y. (Pedal(y) & Bicycle(x) & PartOf(y, x)) -> MovesInCircularMotion(y)))", "all x. (PedallingBicycle(x) -> Requires(x, exists y. (Pedal(y) & MovesInCircularMotion(y))))", "all x. (Bicycle(x) -> (Pedalling(x) -> exists y. (Pedal(y) & PartOf(y, x) & MovesInCircularMotion(y))))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion(x)))", "all x. (Bicycle(x) -> (Pedalling(x) -> Requires(MoveInCircularMotion(pedals(x)))))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (Pedalling(x, bicycle) -> Requires(MovingPedalsInCircularMotion(x)))", "all x. (PedallingBicycle(x) -> Requires(x, MovingPedalsInCircularMotion))", "all x. (Pedalling(x) & Bicycle(x) -> Requires(x, MovingPedalsInCircularMotion(x)))"]}
{"id": "entailmentbank_validation_331", "nl": "the pedals are the part of a bicycle that moves in circular motion.", "fol": "", "prediction": ["all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & MovesInCircularMotion(x)))", "all x. ((Pedal(x) & PartOf(x, bicycle)) -> MovesInCircularMotion(x))", "all x. (Bicycle(x) -> exists y. (PartOf(y, x) & Pedals(y) & MovesInCircularMotion(y)))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "all x. (Pedal(x) -> (PartOf(x, bicycle) & MovesInCircularMotion(x)))", "all p. (Pedal(p) & PartOf(p, bicycle) -> MovesInCircularMotion(p))", "all x. ((Pedal(x) & PartOf(x, bicycle)) -> MovesInCircularMotion(x))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))", "exists x. (Bicycle(x) & all y. ((Pedal(y) & PartOf(y, x)) -> MovesInCircularMotion(y)))", "all x. (Pedal(x) -> exists y. (Bicycle(y) & PartOf(x, y) & MovesInCircularMotion(x)))", "all x. (Pedal(x) & PartOf(x, bicycle) -> MovesInCircularMotion(x))"]}
{"id": "entailmentbank_validation_332", "nl": "north / northward is a kind of direction.", "fol": "", "prediction": ["Direction(north)", "Direction(north)", "KindOf(north, direction)", "Direction(north)", "Direction(north)", "Direction(north)", "all x. (North(x) -> Direction(x))", "Direction(north)", "Direction(north)", "Direction(north)", "all x. (North(x) -> Direction(x))", "Direction(north)", "Direction(north)", "Direction(north)", "Direction(north)", "Direction(north)"]}
{"id": "entailmentbank_validation_333", "nl": "velocity is a measure of a speed in a direction.", "fol": "", "prediction": ["Measure(velocity, SpeedInDirection)", "Measure(velocity, exists x. (Speed(x) & Direction(x)))", "Measure(velocity, SpeedInDirection)", "Measure(velocity, SpeedInDirection)", "Measure(velocity, SpeedInDirection)", "Measure(velocity, SpeedDirection)", "Measure(velocity, SpeedAndDirection)", "Measure(velocity, SpeedInDirection)", "MeasureOf(velocity, SpeedWithDirection)", "MeasureOf(velocity, speed) & InDirection(velocity, direction)", "all x. (Velocity(x) -> exists y exists z. (MeasureOf(x, y) & Speed(y) & Direction(z)))", "Measure(velocity, SpeedInDirection)", "Measure(velocity, SpeedAndDirection(speed, direction))", "MeasureOf(velocity, SpeedInDirection)", "Measure(velocity, Speed-And-Direction)", "Measure(velocity, Speed(x) & Direction(x))"]}
{"id": "entailmentbank_validation_334", "nl": "40 m/s describes the speed of an object.", "fol": "", "prediction": ["exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40m/s))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & SpeedOf(x, 40))", "exists x. (Object(x) & Speed(x, 40_m/s))", "exists x. (Object(x) & SpeedOf(x) = 40)", "exists x. (SpeedOf(x, 40_m_per_s))", "exists x. (SpeedOf(x) = 40_m_per_s)", "exists x. (Object(x) & SpeedOf(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40))", "exists x. (Object(x) & Speed(x, 40_m_per_s))", "exists x. (Object(x) & Speed(x, 40))"]}
{"id": "entailmentbank_validation_335", "nl": "40 m/s north describes the velocity of an object.", "fol": "", "prediction": ["exists x. (Object(x) & Velocity(x, 40, north))", "exists x. (Object(x) & Velocity(x, 40, m/s, north))", "exists x. (Object(x) & DescribesVelocity(x, 40, north))", "exists x. (Object(x) & Describes(velocity_40ms_north, x))", "exists x. (Object(x) & Velocity(x, 40, m/s, north))", "exists x. (VelocityOf(x, 40ms_north))", "exists x. (Object(x) & DescribesVelocity(forty_m_per_s_north, x))", "exists x. (Object(x) & Velocity(x, \"40 m/s north\"))", "exists x. (Object(x) & DescribesVelocity(x, \"40 m/s north\"))", "exists x. (Object(x) & Velocity(x, '40 m/s north'))", "exists x. (Object(x) & Velocity(x, 40, 'north'))", "exists x. (Object(x) & Describes(Velocity(40, m/s, north), x))", "exists x. (Object(x) & Velocity(x, '40 m/s north'))", "exists z. (Velocity(z) & Describes(z, object) & Magnitude(z, 40) & Direction(z, north))", "exists x. (Object(x) & Velocity(x, 40, north))", "exists x. (Object(x) & Velocity(x, '40 m/s north'))"]}
{"id": "entailmentbank_validation_336", "nl": "inherited characteristics can deterimne the structure of an organism's anatomy.", "fol": "", "prediction": ["all x. (InheritedCharacteristics(x) -> Determine(x, AnatomyStructure(Organism(x))))", "all x. (InheritedCharacteristic(x) -> exists y. (Organism(y) & Determines(x, StructureOfAnatomy(y))))", "all x. (InheritedCharacteristic(x) -> exists y. (Determines(x, y) & StructureOfOrganism(y) & Anatomy(y)))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructure(x, Anatomy(x)))", "FOL Translation:\nall x. (InheritedCharacteristics(x) -> CanDetermineStructureOfAnatomy(x))", "all x. (InheritedCharacteristic(x) -> exists y. (Organism(y) & Determines(x, AnatomyStructure(y))))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructureOfAnatomy(x))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructureAnatomy(x, Organism(y)))", "all x. (InheritedCharacteristics(x) -> CanDetermineStructure(x, Anatomy(y)))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructure(x, AnatomyOfOrganism))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructure(x, OrganismAnatomy))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructureOfAnatomy(x))", "exists x. (InheritedCharacteristic(x) -> Determines(x, StructureOfAnatomy(y)))", "all x. (InheritedCharacteristic(x) -> CanDetermineStructureOfAnatomy(x))", "all x. ((InheritedCharacteristic(x)) -> CanDetermineStructureOfAnatomy(x))", "all x y. (InheritedCharacteristic(x) & Organism(y) -> CanDetermineStructureOfAnatomy(x, y))"]}
{"id": "entailmentbank_validation_337", "nl": "the structure of an organism's anatomy is used to classify the organism into the appropriate taxonomic rank.", "fol": "", "prediction": ["all x. (Organism(x) -> exists y. (AnatomyStructure(y) & UsesForClassification(y, x)))", "all x. (Organism(x) -> exists y. (Structure(y) & Anatomy(y, x) & UsedToClassify(y, x)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, y, AppropriateTaxonomicRank(x))))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(y, x)))", "all x. (Organism(x) -> exists s. (StructureOfAnatomy(x, s) & UsedToClassify(x, s) & resultsInTaxonomicRank(x)))", "all x. (Organism(x) & exists y. (AnatomyStructure(y) & IsStructureOf(y, x)) -> exists z. (TaxonomicRank(z) & ClassifiesBasedOn(y, z)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, y) & ClassifyIntoTaxonomicRank(x)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(y, x) & UsedToClassifyStructure(y, x)))", "all x. all y. (Organism(x) & AnatomyStructure(y, x) -> UsedForClassification(y, x, AppropriateTaxonomicRank(x)))", "all x. (Organism(x) -> exists y. (Structure(y) & PartOf(y, Anatomy(x)) & UsedToClassify(x, TaxonomicRank)))", "all x. (Organism(x) -> exists y. (AnatomyStructure(y, x) & UsedToClassify(y, x) & AppropriateTaxonomicRank(x)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, AppropriateTaxonomicRank(x))))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, y, AppropriateTaxonomicRank(x))))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, AppropriateTaxonomicRank(x))))", "all x. (Organism(x) -> exists y. (AnatomyStructure(y) & UsedToClassify(x, y) & AppropriateTaxonomicRank(y)))", "all x. (Organism(x) -> exists y. (StructureOfAnatomy(x, y) & UsedToClassify(x, y)))"]}
{"id": "entailmentbank_validation_338", "nl": "inherited characteristics can be used to classify an oganism into the apropriate taxonomic rank.", "fol": "", "prediction": ["all x. (Organism(x) & InheritedCharacteristic(x) -> exists y. (TaxonomicRank(y) & UsedForClassification(x, y)))", "all x. (Organism(x) & InheritedCharacteristic(x) -> exists y. (AppropriateTaxonomicRank(y) & Classify(x, y)))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & CanClassifyInto(x, y)))", "all x. (Organism(x) & InheritedCharacteristics(x, c) -> exists y. (TaxonomicRank(y) & Classifies(x, c, y)))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & UsedToClassify(x, y)))", "all x. (Organism(x) & HasInheritedCharacteristics(x) -> CanBeClassifiedIntoTaxonomicRank(x))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & CanBeClassifiedInto(x, y)))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & Classifies(x, y)))", "all x. ((Organism(x) & InheritedCharacteristic(x, y)) -> CanBeUsedToClassify(x, y, AppropriateTaxonomicRank(y)))", "all o. (Organism(o) & exists c. (InheritedCharacteristic(c, o) -> canBeUsedToClassify(o, c)))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & ClassifyInto(x, y)))", "all x y. (InheritedCharacteristic(x) & Organism(y) & UsedToClassify(x, y) -> CanClassifyIntoTaxonomicRank(y))", "all x. (InheritedCharacteristics(x) -> exists y. (Organism(x) & TaxonomicRank(y) & UsedToClassify(x, y)))", "all x. (InheritedCharacteristics(x) -> exists y. (Organism(y) & ClassifyUsing(x, y) & AppropriateTaxonomicRank(y)))", "all x. (Organism(x) & InheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & ClassifiesInto(x, y)))", "all x. (Organism(x) & HasInheritedCharacteristics(x) -> exists y. (TaxonomicRank(y) & ClassifiesInto(x, y)))"]}
{"id": "entailmentbank_validation_339", "nl": "genes are able to determine the inherited characteristics of a living thing.", "fol": "", "prediction": ["all x. (Gene(x) -> exists y. (LivingThing(y) & Determines(x, InheritedCharacteristics(y))))", "all x. (Gene(x) -> CanDetermine(x, InheritedCharacteristics(y)) & InheritedCharacteristics(y) & LivingThing(y))", "all x. (Gene(x) -> exists y. (Determines(x, y) & InheritedCharacteristic(y) & LivingThing(y)))", "all x. (Gene(x) -> exists y. (Determines(x, y) & InheritedCharacteristic(y) & LivingThing(z)))", "all x. ((Gene(x) & LivingThing(y) & InheritedCharacteristic(z, y)) -> CanDetermine(x, z))", "all x. (Gene(x) -> exists y. (LivingThing(y) & Determines(x, InheritedCharacteristics(y))))", "all x. (Gene(x) -> exists y. (LivingThing(y) & DeterminesInheritedCharacteristics(x, y)))", "all x. (Gene(x) -> CanDetermineInheritedCharacteristics(x, LivingThing(y)))", "all x. (Gene(x) -> exists y. (LivingThing(y) & Determines(x, InheritedCharacteristics(y))))", "all x. (Gene(x) -> exists y. (LivingThing(y) & Determines(x, InheritedCharacteristics(y))))", "all x. (Gene(x) -> CanDetermineInheritedCharacteristics(x, y) & LivingThing(y))", "all x. (Gene(x) -> CanDetermineInheritedCharacteristics(x, y) & LivingThing(y))", "all x. ((Gene(x) & InLivingThing(x)) -> CanDetermineInheritedCharacteristics(x))", "all x. (Gene(x) -> CanDetermineInheritedCharacteristics(x, LivingThing(x)))", "all x. (Gene(x) -> CanDetermine(x, CharacteristicsOf(y)) & Inherited(y) & LivingThing(y))", "all x. (Gene(x) -> exists y. (LivingThing(y) & DeterminesInheritedCharacteristics(x, y)))"]}
{"id": "entailmentbank_validation_340", "nl": "genes can be used for classifying organisms.", "fol": "", "prediction": ["all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "exists x. (Gene(x) & CanBeUsedForClassifying(x))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "FOL Translation:\nall g. (Gene(g) -> CanBeUsedForClassifyingOrganisms(g))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, organism))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, Organism))", "all g. (Gene(g) -> CanBeUsedForClassifying(g, organism))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, Organism))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, Organism))", "all x. (Gene(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Gene(x) -> CanBeUsedForClassifying(x, Organism))"]}
{"id": "entailmentbank_validation_341", "nl": "genes are made of dna.", "fol": "", "prediction": ["all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOfDNA(x))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all g. (Gene(g) -> MadeOf(g, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))", "all x. (Gene(x) -> MadeOf(x, dna))"]}
{"id": "entailmentbank_validation_342", "nl": "dna can be used for classifying organisms.", "fol": "", "prediction": ["all x. (DNA(x) -> CanBeUsedForClassifying(x, Organisms))", "all x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "FOL Translation:\nall x. (Organism(x) -> CanBeUsedForClassifying(dna, x))", "FOL Translation:\nall x. (DNA(x) -> CanBeUsedForClassifying(x, organisms))", "all x. (DNA(x) -> CanBeUsedForClassifying(x, Organisms))", "FOL Translation:\nall x. (DNA(x) -> CanBeUsedForClassifying(x, organisms))", "FOL Translation:\nall x. (DNA(x) -> CanBeUsedForClassifying(x, organism))", "all x. (DNA(x) -> CanBeUsedForClassifying(x, Organism))", "all x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (Organism(x) -> CanBeUsedForClassifying(dna, x))", "FOL Translation:\nall x. (DNA(x) -> CanBeUsedForClassifying(x, organisms))", "exists x. (DNA(x) & CanBeUsedForClassifyingOrganisms(x))", "exists x. (DNA(x) & CanBeUsedForClassifyingOrganisms(x))", "FOL Translation:\nall x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "all x. (DNA(x) -> CanBeUsedForClassifyingOrganisms(x))", "FOL Translation:\nall x. (Organism(x) -> CanBeUsedForClassifying(dna, x))"]}
{"id": "entailmentbank_validation_343", "nl": "dna is a kind of molecule.", "fol": "", "prediction": ["Molecule(dna)", "Molecule(dna)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "Kind(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "Kind(dna, molecule)", "Kind(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "Kind(dna, molecule)", "KindOf(dna, molecule)", "KindOf(dna, molecule)", "Kind(dna, molecule)"]}
{"id": "entailmentbank_validation_344", "nl": "molecules are used for classifying organisms.", "fol": "", "prediction": ["all x. (Molecule(x) -> UsedForClassifying(x, Organism))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifying(x, organisms))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifying(Organisms, x))", "all x. (Molecule(x) -> UsedForClassifying(x, organisms))", "all z. (Molecule(z) -> UsedForClassifyingOrganisms(z))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifying(x, Organisms))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))", "all x. (Molecule(x) -> UsedForClassifyingOrganisms(x))"]}
{"id": "entailmentbank_validation_345", "nl": "a frog is a kind of amphibian.", "fol": "", "prediction": ["FOL Translation:\nall x. (Frog(x) -> Amphibian(x))", "Frog(f) -> Amphibian(f)", "Frog(x) -> Amphibian(x)", "Frog(x) -> Amphibian(x)", "Frog(f) -> Amphibian(f)", "Frog(x) -> Amphibian(x)", "Frog(x) -> Amphibian(x)", "FOL Translation:\nall x. (Frog(x) -> Amphibian(x))", "Frog(x) -> Amphibian(x)", "FOL Translation:\nFrog(x) -> Amphibian(x)", "Amphibian(frog)", "Frog(x) -> Amphibian(x)", "FOL Translation:\nall x. (Frog(x) -> Amphibian(x))", "Frog(f) -> Amphibian(f)", "FOL Translation:\nall x. (Frog(x) -> Amphibian(x))", "Frog(x) -> Amphibian(x)"]}
{"id": "entailmentbank_validation_346", "nl": "a tadpole is a kind of young / baby frog.", "fol": "", "prediction": ["Frog(tadpole) & Young(tadpole)", "Tadpole(x) -> YoungFrog(x)", "Tadpole(x) -> YoungFrog(x)", "Tadpole(x) -> YoungFrog(x)", "Tadpole(x) -> YoungFrog(x)", "Frog(tadpole) & Young(tadpole)", "all x. (Tadpole(x) -> YoungFrog(x))", "YoungTadpole(babyFrog)", "Tadpole(x) -> YoungFrog(x)", "all x. (Tadpole(x) -> YoungFrog(x))", "Tadpole(x) -> YoungFrog(x)", "Tadpole(x) -> YoungFrog(x)", "YoungTadpole(x) <-> Frog(x)", "all x. (Tadpole(x) -> YoungFrog(x))", "Frog(tadpole) & Young(tadpole)", "all x. (Tadpole(x) -> YoungFrog(x))"]}
{"id": "entailmentbank_validation_347", "nl": "a tadpole is a kind of young amphibian.", "fol": "", "prediction": ["Tadpole(x) -> YoungAmphibian(x)", "exists x. (Tadpole(x) & YoungAmphibian(x))", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(t) -> YoungAmphibian(t)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(t) -> YoungAmphibian(t)", "Tadpole(x) -> YoungAmphibian(x)", "Tadpole(t) -> YoungAmphibian(t)", "Tadpole(x) -> YoungAmphibian(x)"]}
{"id": "entailmentbank_validation_348", "nl": "metamorphosis is when an amphibian changes from an immature form to an adult form.", "fol": "", "prediction": ["all x. (Metamorphosis(x) <-> (Amphibian(y) & ChangesFromImmatureToAdult(x, y)))", "all x. (Metamorphosis(x) <-> (Amphibian(x) & ImmatureForm(x) & ChangesTo(x, AdultForm(x))))", "all x. (Metamorphosis(x) <-> (Amphibian(x) & ChangesFromImmatureFormToAdultForm(x)))", "Metamorphosis(all x. (Amphibian(x) & ImmatureForm(x) -> AdultForm(x)))", "all x. (Amphibian(x) & ImmatureForm(x) & ChangesTo(x, AdultForm(x)) -> Metamorphosis(x))", "all x. (Amphibian(x) & Undergoes(x, metamorphosis) -> ChangesFromImmatureToAdult(x))", "all x. (Amphibian(x) & ImmatureForm(x) & AdultForm(x) -> Metamorphosis(x))", "all x. (Metamorphosis(x) -> (exists y. (Amphibian(y) & ChangesFromImmatureToAdult(y))))", "all x. ((Amphibian(x) & UndergoesMetamorphosis(x)) -> ChangesFromImmatureToAdult(x))", "Metamorphosis(amphibian, immatureForm, adultForm) <-> (Amphibian(amphibian) & Changes(amphibian, immatureForm, adultForm) & ImmatureForm(immatureForm) & AdultForm(adultForm))", "all x. (Amphibian(x) & ImmatureForm(x) & ChangesTo(x, AdultForm(x)) -> Metamorphosis(x))", "all x. (Amphibian(x) & ChangesToAdultForm(x) -> Metamorphosis(x))", "all x. (Amphibian(x) & ChangesToImmatureForm(x) & ChangesToAdultForm(x) -> Metamorphosis(x))", "all x. (Amphibian(x) & ImmatureForm(x) & ChangesTo(x, AdultForm(x)) -> Metamorphosis(x))", "Metamorphosis(x) <-> (Amphibian(x) & Changes(x, immature_form, adult_form))", "all x. (Amphibian(x) & ChangesFromImmatureToAdultForm(x) -> Metamorphosis(x))"]}
{"id": "entailmentbank_validation_349", "nl": "an example of metamorphosis is when a tadpole changes from a an immature form to and adult form.", "fol": "", "prediction": ["exists x, y, z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesFromImmatureToAdultForm(x))", "Metamorphosis(tadpole) & ChangesFrom(tadpole, ImmatureForm) & ChangesTo(tadpole, AdultForm)", "exists x, y, z. (ExampleOf(x, Metamorphosis) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z) & PartOf(y, x) & PartOf(z, x))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesFromTo(x, ImmatureForm, AdultForm))", "exists x y z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z, x))", "exists x, y, z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z))", "exists x. (Metamorphosis(x) & Example(x, Change(tadpole, immatureForm, adultForm)))", "exists x y z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z) & Represents(x, y, z))", "exists x, y, z. (MetamorphosisExample(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & Changes(y, z))", "exists x. (MetamorphosisExample(x) & Tadpole(x) & ChangesFromImmatureToAdult(x))", "exists x, y, z. (ExampleOfMetamorphosis(x) & Tadpole(y) & ImmatureForm(y) & AdultForm(z) & ChangesFromTo(y, z))", "exists x. exists y. (MetamorphosisExample(x) & Tadpole(y) & ChangesFromImmatureToAdultForm(y, x))", "exists x. (MetamorphosisExample(x) & Tadpole(x) & ChangesFromTo(x, ImmatureForm, AdultForm))", "exists x. (Metamorphosis(x) & TadpoleChanges(x) & ImmatureFormToAdultFormChange(x))", "exists x. (ExampleOf(x, Metamorphosis) & When(TadpoleChangesToAdultForm, x))"]}
{"id": "entailmentbank_validation_350", "nl": "the immature form of a frog is called a tadpole.", "fol": "", "prediction": ["all x. (ImmatureFormOf(x, frog) -> Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) & Called(x, tadpole))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) -> Called(x, tadpole))", "exists x. (ImmatureForm(x, frog) & Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) & Called(x, tadpole))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole))", "all x. (ImmatureFormOfFrog(x) -> Called(x, tadpole))", "exists x. (ImmatureFormOfFrog(x) & Called(x, tadpole))", "exists x. (ImmatureForm(x) & Of(x, frog) & Called(x, tadpole))", "all x. (ImmatureFrogForm(x) -> Called(x, tadpole))", "exists x. (ImmatureForm(x) & Of(x, frog) & Called(x, tadpole))", "all x. (ImmatureFormOfFrog(x) -> Called(x, tadpole))", "all z. (ImmatureFormOfFrog(z) -> Called(z, tadpole))", "exists x. (ImmatureFormOf(frog, x) & Called(x, tadpole))", "all x. (ImmatureFormOfFrog(x) -> Called(x, tadpole))"]}
{"id": "entailmentbank_validation_351", "nl": "the adult form of a tadpole is called a frog.", "fol": "", "prediction": ["all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultFormOfTadpole(x) -> Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultForm(x, tadpole) -> Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "exists x. (TadpoleAdultForm(x) & Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "all x. (AdultFormOf(x, tadpole) -> Called(x, frog))", "exists x. (Tadpole(x) & AdultForm(x, y) & Called(y, frog))", "exists x. (TadpoleAdultForm(x) & Frog(x))", "all x. (Tadpole(x) & AdultForm(x, y) -> Frog(y) & IsCalled(y, frog))"]}
{"id": "entailmentbank_validation_352", "nl": "the imature form of a frog is called a tadpole and the adult form of a tadpole is called a frog.", "fol": "", "prediction": ["exists x. (ImatureForm(x) & Frog(x) & Called(x, tadpole)) & exists y. (AdultForm(y) & Tadpole(y) & Called(y, frog))", "exists x, y. ((ImmatureForm(x, frog) -> Called(x, tadpole)) & (AdultForm(y, tadpole) -> Called(y, frog)))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole)) & exists y. (AdultFormOf(y, tadpole) & Called(y, frog))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole)) & all y. (AdultFormOf(y, tadpole) -> Called(y, frog))", "exists x. (ImmatureForm(x, frog) & Called(x, tadpole)) & all y. (AdultForm(y, tadpole) -> Called(y, frog))", "exists x, y. (ImmatureForm(x, frog) & Called(x, tadpole) & AdultForm(y, tadpole) & Called(y, frog))", "exists x. (ImmatureForm(x) & Frog(x) & Called(x, tadpole)) & exists y. (AdultForm(y) & Tadpole(y) & Called(y, frog))", "exists x, y. (ImmatureForm(x, frog) & Tadpole(x) & AdultForm(y, x) & Frog(y))", "exists x. (ImmatureForm(x) & Frog(x) & Called(x, tadpole)) & exists y. (AdultForm(y) & Tadpole(y) & Called(y, frog))", "exists x. (ImatureForm(x) & Frog(x) & Called(x, tadpole)) & exists y. (AdultForm(y) & Tadpole(y) & Called(y, frog))", "1. Using constants for specific terms:\n   - `immature_form`\n   - `adult_form`\n   - `frog`\n   - `tadpole`\n\n2. Predicates to represent relationships and properties:\n   - `Called(x, y)`: denotes that `x` is called `y`\n\n3. Sentences:\n   - \"The immature form of a frog is called a tadpole\":\n     `Called(immature_form(frog), tadpole)`\n\n   - \"The adult form of a tadpole is called a frog\":\n     `Called(adult_form(tadpole), frog)`\n\nComplete FOL translation:\n(Called(immature_form(frog), tadpole) & Called(adult_form(tadpole), frog))", "exists x. (ImmatureFrog(x) & Called(x, tadpole)) & all y. (AdultTadpole(y) -> Called(y, frog))", "exists x. (ImmatureFormOf(x, frog) & Called(x, tadpole)) & all y. ((AdultFormOf(y, tadpole) & Called(y, frog)))", "FOL Translation:\nall x. ((ImmatureForm(x) & Frog(x) -> Called(x, tadpole)) & (AdultForm(x) & Tadpole(x) -> Called(x, frog)))", "exists x, y, z. (ImmatureFormOf(frog, x) & Called(x, tadpole) & AdultFormOf(y, z) & y = tadpole & z = frog)", "exists x. (ImmatureForm(x) & Frog(x) & Called(x, tadpole)) & exists y. (AdultForm(y) & Tadpole(y) & Called(y, frog))"]}
{"id": "entailmentbank_validation_353", "nl": "an example of metamorphosis is when a tadpole changes from a tadpole into a frog.", "fol": "", "prediction": ["exists x. (MetamorphosisExample(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & Changes(x, tadpole, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & Changes(x, tadpole, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesFromInto(x, tadpole, frog))", "exists x, y. (Tadpole(x) & Frog(y) & ChangesInto(x, y) & MetamorphosisExample(x, y))", "Exists x. (MetamorphosisExample(x) & Tadpole(x) & ChangesInto(x, Frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & ChangesFrom(x, tadpole, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesFromTadpoleToFrog(x))", "exists e. (ExampleOfMetamorphosis(e) & Tadpole(e) & ChangesInto(e, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (ExampleOfMetamorphosis(x) & Tadpole(x) & ChangesInto(x, frog))", "exists x. (MetamorphosisExample(x) & TadpoleChangesIntoFrog(x))"]}
{"id": "entailmentbank_validation_354", "nl": "reproduction occurs during adulthood.", "fol": "", "prediction": ["all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> OccursDuring(Reproduction(x), x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> OccursReproduction(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> OccursDuring(Reproduction(x), Adulthood(x)))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> CanReproduce(x))", "all x. (Adulthood(x) -> Occurs(reproduction, x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))", "all x. (Adulthood(x) -> ReproductionOccurs(x))"]}
{"id": "entailmentbank_validation_355", "nl": "an example of reproduction is laying eggs.", "fol": "", "prediction": ["exists x. (Reproduction(x) & ExampleOf(x, LayingEggs))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (ExampleOfReproduction(x) & LaysEggs(x))", "exists x. (ExampleOfReproduction(x) & LayingEggs(x))", "exists x exists y. (ExampleOfReproduction(x, y) & LayingEggs(y))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "Exists x. (ReproductionExample(x) & LaysEggs(x))", "exists x. (ReproductionExample(x, LayEggs))", "Exists x y. (ReproductionExample(x) & LaysEggs(y) & ExampleOf(x, y))", "exists x. (Reproduction(x) & ExampleOf(x, LayingEggs))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (ExampleOfReproduction(x) & LayingEggs(x))", "exists x. (ReproductionExample(x) & LayingEggs(x))", "exists x. (ExampleOfReproduction(x) & LayingEggs(x))", "exists x. (ExampleOfReproduction(x) & LayingEggs(x))"]}
{"id": "entailmentbank_validation_356", "nl": "laying eggs occurs during adulthood.", "fol": "", "prediction": ["all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> OccursDuring(LayingEggs, x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "", "all x. (Adulthood(x) -> LayingEggsOccursDuring(x))", "all x. (EggLayingDuring(x, adulthood))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", "all x. (Adulthood(x) -> CanLayEggs(x))", "all x. (Adulthood(x) -> LayingEggsOccurs(x))", ""]}
{"id": "entailmentbank_validation_357", "nl": "adulthood is a stage in the life cycle process.", "fol": "", "prediction": ["StageInLifeCycle(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "StageInLifeCycle(adulthood)", "Stage(adulthood) & PartOf(adulthood, life_cycle_process)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & LifeCycleProcess(adulthood)", "Stage(adulthood) & LifeCycleProcess(life_cycle_process) & PartOf(adulthood, life_cycle_process)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & InLifeCycleProcess(adulthood)", "Stage(adulthood) & PartOf(adulthood, life_cycle_process)", "Stage(adulthood) & InLifeCycleProcess(adulthood)"]}
{"id": "entailmentbank_validation_358", "nl": "laying eggs occurs during the adult stage in the life cycle.", "fol": "", "prediction": ["all x. (AdultStage(x) -> OccursDuring(LayingEggs, x))", "all x. (LayingEggsOccursDuring(x, adult_stage))", "all x. (AdultStage(x) -> LayingEggsOccurs(x))", "all x. (AdultStage(x) -> Occurs(LayingEggs, x))", "all x. ((LaysEggs(x) & AdultStage(x)) -> OccursDuringLifeCycle(x))", "all x. (LayingEggs(x) -> OccursDuring(x, AdultStage))", "all x. (LayingEggs(x) -> OccursDuringStage(x, AdultStage))", "all x. (LayingEggsOccurs(x) -> During(x, AdultStage) & InLifeCycle(x))", "all z. (LayingEggs(z) <-> OccursDuring(z, AdultStage(z)))", "all x. (LayingEggs(x) -> OccursDuring(x, AdultStage))", "all x. (LayingEggsOccursDuring(x, adult_stage) -> InLifeCycle(x, adult_stage))", "all x. (LayingEggsOccurs(x) -> DuringAdultStage(x))", "all x. (LayingEggsOccursDuring(x, LifeCycleStageAdult(x)))", "all x. (LayingEggs(x) -> OccursDuring(x, AdultStage))", "all x. (LayingEggsOccurs(x) -> DuringStage(x, adult))", "all x. (LayingEggs(x) -> OccursDuring(x, AdultStage))"]}
{"id": "entailmentbank_validation_359", "nl": "a female insect lays eggs.", "fol": "", "prediction": ["exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Female(x) & Insect(x) & LaysEggs(x))", "exists x. (Female(x) & Insect(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Female(x) & Insect(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (FemaleInsect(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))", "exists x. (Insect(x) & Female(x) & LaysEggs(x))"]}
{"id": "entailmentbank_validation_360", "nl": "a female insect lays eggs during the adult stage of an insect's life cycle.", "fol": "", "prediction": ["exists x. (Insect(x) & Female(x) & exists y. (Egg(y) & Lays(x, y) & DuringAdultStage(x)))", "exists x. (FemaleInsect(x) & LaysEggsDuringAdultStage(x, x))", "exists x. (Insect(x) & Female(x) & exists y. (Egg(y) & Lays(x, y) & During(AdultStage(x), LifeCycle(x))))", "exists x. (Insect(x) & Female(x) & exists y. (Eggs(y) & Lays(x, y) & DuringStage(y, AdultStage(x))))", "exists x. (FemaleInsect(x) & LaysEggsDuring(x, AdultStage))", "exists x. (FemaleInsect(x) & exists y. (InsectLifeCycleStage(y) & AdultStage(y) & LaysEggs(x, y)))", "exists x. (Female(x) & Insect(x) & LaysEggsDuring(x, AdultStage(y)) & Insect(y))", "exists x. (FemaleInsect(x) -> exists y. (LaysEggsDuringStage(x, y) & AdultStage(y) & InsectLifeCycle(y)))", "exists x. (FemaleInsect(x) & LaysEggsDuringStage(x, AdultStage))", "exists x. (Female(x) & Insect(x) & exists y. (Eggs(y) & Lays(x, y) & During(y, AdultStage(x))))", "exists x. (FemaleInsect(x) & exists y. (LaysEggs(x, y) & AdultStage(y) & PartOfLifeCycle(y, x)))", "exists x. (Insect(x) & Female(x) -> LaysEggsDuringAdultStage(x))", "exists x. (FemaleInsect(x) -> exists y. (Eggs(y) & Lays(x, y) & AdultStage(x)))", "exists x. (FemaleInsect(x) & exists y. (Egg(y) & Lays(x, y) & DuringStage(y, AdultStage)))", "exists x. (Insect(x) & Female(x) & DuringAdultStage(x) -> LaysEggs(x))", "exists x. (FemaleInsect(x) -> exists y. (AdultStage(y) & LaysEggsDuringStage(x, y)))"]}
{"id": "entailmentbank_validation_361", "nl": "a cat is a kind of mammal.", "fol": "", "prediction": ["all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "Cat(x) -> Mammal(x)", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))", "all x. (Cat(x) -> Mammal(x))"]}
{"id": "entailmentbank_validation_362", "nl": "mammals give birth to live young.", "fol": "", "prediction": ["all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GiveBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))", "all x. (Mammal(x) -> GivesBirthToLiveYoung(x))"]}
{"id": "entailmentbank_validation_363", "nl": "a cat gives birth to live young.", "fol": "", "prediction": ["all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> exists y. (LiveYoung(y) & GivesBirthTo(x, y)))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))", "all x. (Cat(x) -> GivesBirthToLiveYoung(x))"]}
{"id": "entailmentbank_validation_364", "nl": "to give birth to live young means to undergo live birth.", "fol": "", "prediction": ["all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GiveBirthToLiveYoung(x) <-> UndergoLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "FOL Translation:\nall x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))", "all x. (GivesBirthToLiveYoung(x) <-> UndergoesLiveBirth(x))"]}
{"id": "entailmentbank_validation_365", "nl": "a cat undergoes live birth.", "fol": "", "prediction": ["exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))", "exists x. (Cat(x) & UndergoesLiveBirth(x))"]}
{"id": "entailmentbank_validation_366", "nl": "live birth means developing inside the mother instead of an egg.", "fol": "", "prediction": ["all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) -> DevelopInsideMother(x) & -DevelopInEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -InsideEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInsideEgg(x)))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> (DevelopsInsideMother(x) & -DevelopsInEgg(x)))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))", "all x. (LiveBirth(x) <-> DevelopsInsideMother(x) & -DevelopsInEgg(x))"]}
{"id": "entailmentbank_validation_367", "nl": "a cat develops inside its mother.", "fol": "", "prediction": ["exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x. (Cat(x) -> DevelopsInside(x, MotherOf(x)))", "exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))", "all x. (Cat(x) -> exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x. (Cat(x) -> DevelopsInside(x, Mother(x)))", "exists x, y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x, y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x, y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x. (Cat(x) & exists y. (Mother(y, x) & DevelopsInside(x, y)))", "all x. (Cat(x) -> exists y. (Mother(y, x) & DevelopsInside(x, y)))", "exists x y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x, y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x. exists y. (Cat(x) & Mother(y, x) & DevelopsInside(x, y))", "exists x. (Cat(x) & exists y. (MotherOf(y, x) & DevelopsInside(x, y)))"]}
{"id": "entailmentbank_validation_368", "nl": "the opposite of the same is different.", "fol": "", "prediction": ["all x. (Opposite(x, x) <-> Different(x, x))", "all x. (Same(x, x) -> Different(x, x))", "`all x. Opposite(Same(x)) = Different(x)`", "all x. (Same(x, x) -> Different(x, x))", "all x. (Same(x) <-> Different(-x))", "all x. all y. (Opposite(x, x) = y -> Different(y, y))", "all x. (Same(x, x) -> Different(x, x))", "all x. (all y. (Same(x, y) -> Opposite(x, z) & Different(y, z)))", "all x. (Opposite(x, x) <-> Different(x, x))", "all x. (Opposite(x, x) -> Different(x, x))", "Same(x) -> Different(Opposite(x))", "all x. (Opposite(x, x) -> Different(x, x))", "all x. (Opposite(y, y) -> Different(y, x))", "all x. (Same(x, x) <-> -Different(x, x))", "all x. (Opposite(x, x) <-> Different(x, x))", "all x. (Same(x, x) -> Different(x, x))"]}
{"id": "entailmentbank_validation_369", "nl": "two birds are not in the same taxonomic family.", "fol": "", "prediction": ["exists x exists y. (Bird(x) & Bird(y) & -(x = y) & -SameFamily(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & -(x = y) & -(InSameFamily(x, y)))", "exists x, y. (Bird(x) & Bird(y) & -(x = y) & -SameTaxonomicFamily(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & -(x = y) & all f. (TaxonomicFamily(x, f) & TaxonomicFamily(y, f) -> -(x = y)))", "exists x exists y. (Bird(x) & Bird(y) & -(x = y) & -(SameTaxonomicFamily(x, y)))", "exists a, b. (Bird(a) & Bird(b) & a \u2260 b & -SameFamily(a, b))", "exists x, y. (Bird(x) & Bird(y) & -(x = y) & exists f, g. (TaxonomicFamily(f) & TaxonomicFamily(g) & InFamily(x, f) & InFamily(y, g) & -(f = g)))", "exists x exists y. (Bird(x) & Bird(y) & -(x = y) & all z. (TaxonomicFamily(x, z) -> -TaxonomicFamily(y, z)))", "exists x, y. (Bird(x) & Bird(y) & -(x = y) & -SameTaxonomicFamily(x, y))", "exists x, y. (Bird(x) & Bird(y) & -SameTaxonomicFamily(x, y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & -SameFamily(x, y))", "exists x, y. (Bird(x) & Bird(y) & -SameTaxonomicFamily(x, y))", "exists x, y. (Bird(x) & Bird(y) & -SameTaxonomicFamily(x, y))", "exists x exists y. (Bird(x) & Bird(y) & -(x = y) & -(SameTaxonomicFamily(x, y)))", "exists x y. (Bird(x) & Bird(y) & -(x = y) & -SameTaxonomicFamily(x, y))", "exists x, y. (Bird(x) & Bird(y) & x != y & -SameTaxonomicFamily(x, y))"]}
{"id": "entailmentbank_validation_370", "nl": "two birds are in different taxonomic families.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & InDifferentFamilies(x, y))", "exists x, y. (Bird(x) & Bird(y) & InDifferentFamilies(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & x \u2260 y)", "exists x exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & -(x = y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & TaxonomicFamily(x, f1) & TaxonomicFamily(y, f2) & f1 \u2260 f2)", "exists x, y. (Bird(x) & Bird(y) & DifferentFamilies(x, y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & InDifferentTaxonomicFamilies(x, y))", "exists x, y. (Bird(x) & Bird(y) & InDifferentTaxonomicFamilies(x, y))", "exists x, y. (Bird(x) & Bird(y) & InDifferentFamilies(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists f1. exists f2. (TaxonomicFamily(x, f1) & TaxonomicFamily(y, f2) & f1 \u2260 f2))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & InDifferentFamilies(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists f1. exists f2. (TaxonomicFamily(f1) & TaxonomicFamily(f2) & InFamily(x, f1) & InFamily(y, f2) & f1 \u2260 f2))", "exists x. exists y. (Bird(x) & Bird(y) & InDifferentFamilies(x, y) & x \u2260 y)"]}
{"id": "entailmentbank_validation_371", "nl": "environments with similar characteristics place similar environmental pressures on the organisms in them.", "fol": "", "prediction": ["all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(o, e1)) -> (SimilarPressures(e1, e2) & PressureOn(e1, o)))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & InEnvironment(o, e1)) -> (EnvironmentalPressure(e1, o) = EnvironmentalPressure(e2, o)))", "all e. (Environment(e) & SimilarCharacteristics(e) -> all x. (OrganismIn(x, e) -> SimilarEnvironmentalPressures(x, e)))", "all e, c. ((Environment(e) & CharacteristicsSimilar(e, c)) -> all o. (InOrganism(o, e) -> EnvironmentalPressure(e, o)))", "all e. (Environment(e) & SimilarCharacteristics(e) -> all o. (OrganismInEnvironment(o, e) -> SimilarEnvironmentalPressures(e, o)))", "all e. (Environment(e) & SimilarCharacteristics(e, cs) -> all o. (Organism(o) & InEnvironment(o, e) -> SimilarPressures(cs, o)))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(e2, o)) -> PlaceSimilarEnvironmentalPressures(e1, o))", "all e1, e2. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2)) -> all o1, o2. (ContainedIn(o1, e1) & ContainedIn(o2, e2) -> SimilarEnvironmentalPressures(o1, o2)))", "all x. (Environment(x) & SimilarCharacteristics(x) -> all y. (Organism(y) & In(x, y) -> SimilarEnvironmentalPressure(y)))", "all e1, e2. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2)) -> all o1, o2. ((OrganismIn(e1, o1) & OrganismIn(e2, o2)) -> (SimilarEnvironmentalPressures(e1, o1) & SimilarEnvironmentalPressures(e2, o2))))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & LocatedIn(o, e1)) -> PlacesPressure(e1, o) & SimilarPressure(e1, e2, o))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(o, e1)) -> (EnvironmentalPressure(e1, o) & EnvironmentalPressure(e2, o)))", "all e1 e2. (Environment(e1) & Environment(e2) & HasSimilarCharacteristics(e1, e2) -> all o. (OrganismIn(o, e1) <-> OrganismIn(o, e2) -> SimilarEnvironmentalPressures(e1, o) = SimilarEnvironmentalPressures(e2, o)))", "all e1 e2. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2)) -> (all o. (In(e1, o) -> (exists p. (EnvironmentalPressure(p, o) & SimilarEnvironmentalPressures(e2, o, p))))))", "all e1 e2. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2)) -> all o. (Organism(o) & In(e1, o) -> SimilarEnvironmentalPressures(e1, e2, o)))", "all e1, e2, o. ((Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & In(e1, o)) -> (PlacesEnvironmentalPressure(e1, o) <-> PlacesEnvironmentalPressure(e2, o)))"]}
{"id": "entailmentbank_validation_372", "nl": "two birds live in environments with similar characteristics.", "fol": "", "prediction": ["exists x, y, e1, e2. (Bird(x) & Bird(y) & SimilarCharacteristics(e1, e2) & LivesIn(x, e1) & LivesIn(y, e2) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & exists env1, env2. (LivesIn(x, env1) & LivesIn(y, env2) & SimilarCharacteristics(env1, env2)))", "exists bird1, bird2, char. (Bird(bird1) & Bird(bird2) & bird1 != bird2 & Environment(e1, bird1) & Environment(e2, bird2) & HasCharacteristic(e1, char) & HasCharacteristic(e2, char))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & exists e1, e2. (LivesIn(x, e1) & LivesIn(y, e2) & SimilarCharacteristics(e1, e2)))", "exists a exists b. (Bird(a) & Bird(b) & LivesInEnvironment(a, env1) & LivesInEnvironment(b, env2) & SimilarCharacteristics(env1, env2))", "exists b1. exists b2. (Bird(b1) & Bird(b2) & b1 \u2260 b2 & exists e1. exists e2. (Environment(e1) & Environment(e2) & SimilarCharacteristics(e1, e2) & LivesIn(b1, e1) & LivesIn(b2, e2)))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists z. exists w. (Environment(z) & Environment(w) & Similar(z, w) & LivesIn(x, z) & LivesIn(y, w)))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & exists z exists w. (Environment(z) & Environment(w) & LiveIn(x, z) & LiveIn(y, w) & SimilarCharacteristics(z, w)))", "exists x, y. (Bird(x) & Bird(y) & LivesIn(x, Environment(z)) & LivesIn(y, Environment(w)) & SimilarCharacteristics(Environment(z), Environment(w)))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & exists e1, e2. (Environment(e1) & Environment(e2) & LivesIn(x, e1) & LivesIn(y, e2) & SimilarCharacteristics(e1, e2)))", "exists x, y. (Bird(x) & Bird(y) & LivesInEnvironmentWithSimilarCharacteristics(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists e1. exists e2. (Environment(e1) & Environment(e2) & LivesIn(x, e1) & LivesIn(y, e2) & SimilarCharacteristics(e1, e2)))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & exists z. (Environment(z) & LivesIn(x, z) & LivesIn(y, z) & Similar(EnvironmentCharacteristics(z))))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & livesIn(x, e1) & livesIn(y, e2) & SimilarCharacteristics(e1, e2))", "exists x exists y. (Bird(x) & Bird(y) & LivesInSimilarEnvironment(x, y))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & exists z (Environment(z) & LivesIn(x, z) & LivesIn(y, z) & SimilarCharacteristics(z)))"]}
{"id": "entailmentbank_validation_373", "nl": "two birds developed under similar environmental pressures.", "fol": "", "prediction": ["exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x exists y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x exists y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarPressures(x, y))", "exists x y. (Bird(x) & Bird(y) & DevelopedUnderSimilarPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y) & x \u2260 y)", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists a, b. (Bird(a) & Bird(b) & DevelopedUnderSimilarPressures(a, b))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarPressures(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarEnvironmentalPressures(x, y))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedUnderSimilarPressures(x, y))"]}
{"id": "entailmentbank_validation_374", "nl": "two birds developed thousands of miles apart.", "fol": "", "prediction": ["exists x exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & x != y & DevelopedThousandsOfMilesApart(x, y))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedThousandsOfMilesApart(x, y))", "exists x exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y) & x \u2260 y)", "To translate the sentence \"two birds developed thousands of miles apart\" into first-order logic, we need to capture the idea that there exist two separate entities (birds) that each developed (an inferred predicate given by context) and that there's a significant distance between their places of development.\n\nFOL Translation:\nexists x exists y. (Bird(x) & Bird(y) & Developed(x) & Developed(y) & x \u2260 y & ThousandsOfMilesApart(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))", "exists x exists y. (Bird(x) & Bird(y) & DevelopedApartByMiles(x, y, thousands))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedThousandsOfMilesApart(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & Developed(x, y) & ThousandsOfMilesApart(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))", "exists x exists y. (Bird(x) & Bird(y) & DevelopedApart(x, y) & DistanceBetween(x, y, thousands_of_miles))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedThousandsOfMilesApart(x, y))"]}
{"id": "entailmentbank_validation_375", "nl": "if two things are thousands of miles apart then those two things are separate from each other.", "fol": "", "prediction": ["all x, y. (ThousandsOfMilesApart(x, y) -> SeparateFromEachOther(x, y))", "all x, y. ((ThousandsOfMilesApart(x, y)) -> Separate(x, y))", "all x. all y. ((ThousandsOfMilesApart(x, y)) -> Separate(x, y))", "all x, y. (ThousandsOfMilesApart(x, y) -> Separate(x, y))", "all x, y. (ThousandsOfMilesApart(x, y) -> SeparateFromEachOther(x, y))", "all x, y. ((ThousandsOfMilesApart(x, y) -> SeparateFromEachOther(x, y)))", "all x y. ((AreThousandsOfMilesApart(x, y)) -> Separate(x, y))", "all x, y. ((AreThousandsOfMilesApart(x, y)) -> SeparateFromEachOther(x, y))", "all x. all y. (ThousandsOfMilesApart(x, y) -> Separate(x, y))", "all x y. ((ThousandsOfMilesApart(x, y)) -> SeparateFromEachOther(x, y))", "all x, y. (ThousandsOfMilesApart(x, y) -> SeparateFromEachOther(x, y))", "all x, y. ((ThousandsOfMilesApart(x, y)) -> Separate(x, y))", "all x y. ((AreThousandsOfMilesApart(x, y)) -> SeparateFromEachOther(x, y))", "all x y. (ThousandsOfMilesApart(x, y) -> Separate(x, y))", "all x, y. ((ThousandsOfMilesApart(x, y)) -> SeparateFromEachOther(x, y))", "all x. all y. (ThousandsOfMilesApart(x, y) -> Separate(x, y))"]}
{"id": "entailmentbank_validation_376", "nl": "two birds developed separate from each other.", "fol": "", "prediction": ["exists x exists y. (Bird(x) & Bird(y) & DevelopedSeparateFromEachOther(x, y) & x \u2260 y)", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparately(x, y))", "exists x exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparately(x, y))", "exists b1. exists b2. (Bird(b1) & Bird(b2) & DevelopedSeparately(b1, b2) & b1 \u2260 b2)", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparateFromEachOther(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & SeparateDevelopment(x, y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparateFromEachOther(x, y))", "exists x exists y. (Bird(x) & Bird(y) & -Equal(x, y) & DevelopedSeparate(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & Separate(x, y) & Developed(x) & Developed(y) & x \u2260 y)", "exists x, y. (Bird(x) & Bird(y) & DevelopedSeparate(x, y) & x \u2260 y)", "exists b1. exists b2. (Bird(b1) & Bird(b2) & SeparateDevelopment(b1, b2) & -(b1 = b2))", "Assuming the context is about two distinct individual birds that developed independently, we can introduce constants to represent these birds and use the predicate `DevelopedSeparately` for clarity:\n\nFOL Translation:\nexists x exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparately(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparateFromEachOther(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparate(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedSeparate(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedSeparate(x, y))"]}
{"id": "entailmentbank_validation_377", "nl": "two birds developed in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x. exists y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x) & UnderSimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists b1, b2, e1, e2, p. (Bird(b1) & Bird(b2) & DevelopedIn(b1, e1) & DevelopedIn(b2, e2) & Separate(e1, e2) & EnvironmentalPressure(p) & Similar(e1, p) & Similar(e2, p))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & Developed(x) & Developed(y) & InSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x, y))", "exists b1. exists b2. (Bird(b1) & Bird(b2) & DevelopedInSeparateEnvironments(b1, b2) & SimilarEnvironmentalPressures(b1, b2))", "exists x. exists y. (Bird(x) & Bird(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & x \u2260 y & DevelopedInSeparateEnvironments(x, y) & Exists z. (EnvironmentalPressures(z) & Similar(z) & UnderPressures(x, z) & UnderPressures(y, z)))"]}
{"id": "entailmentbank_validation_378", "nl": "two birds from different taxonomic families developed in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & TaxonomicFamily(a, x) & TaxonomicFamily(b, y) & Different(a, b) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(a, b))", "exists x, y. (Bird(x) & Bird(y) & DifferentFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))", "exists b1, b2, f1, f2, e1, e2. (Bird(b1) & Bird(b2) & TaxonomicFamily(f1) & TaxonomicFamily(f2) & Environment(e1) & Environment(e2) & DifferentTaxonomicFamily(b1, b2, f1, f2) & DevelopedIn(b1, e1) & DevelopedIn(b2, e2) & Different(e1, e2) & SimilarEnvironmentalPressures(e1, e2))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))", "exists a, b. (Bird(a) & Bird(b) & DifferentFamilies(a, b) & DevelopedSeparateEnvironments(a, b) & SimilarEnvironmentalPressures(a) & SimilarEnvironmentalPressures(b))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x) & UnderSimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & DifferentFamilialTaxonomy(x, y) & DevelopedInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x) & UnderSimilarEnvironmentalPressures(y))", "exists b1, b2, f1, f2, e1, e2. (Bird(b1) & Bird(b2) & TaxonomicFamily(b1, f1) & TaxonomicFamily(b2, f2) & f1 \u2260 f2 & Environment(e1, b1) & Environment(e2, b2) & e1 \u2260 e2 & SimilarEnvironmentalPressures(e1, e2) & Developed(b1) & Developed(b2))", "exists bird1. exists bird2. exists family1. exists family2. exists env1. exists env2. (Bird(bird1) & Bird(bird2) & DifferentFamilies(family1, family2) & FromFamily(bird1, family1) & FromFamily(bird2, family2) & SeparateEnvironments(env1, env2) & DevelopedIn(bird1, env1) & DevelopedIn(bird2, env2) & SimilarEnvironmentalPressures(env1, env2))", "exists x exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x. exists y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x) & SimilarEnvironmentalPressures(y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "There exists two entities, `x` and `y`, such that they are birds, are from different taxonomic families, and developed in separate environments under similar environmental pressures.\n\nFOL Translation:\n```\nexists x, y. (Bird(x) & Bird(y) & TaxonomicFamily(x) != TaxonomicFamily(y) & DevelopedInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))\n```", "exists x, y, z, w. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & Environment(z) & Environment(w) & DifferentEnvironments(z, w) & DevelopedIn(x, z) & DevelopedIn(y, w) & SimilarEnvironmentalPressures(z, w))"]}
{"id": "entailmentbank_validation_379", "nl": "convergent evolution is when two species in different taxonomic families develop in different places under similar environmental pressures.", "fol": "", "prediction": ["ConvergentEvolution(convergent_evolution) <-> exists x, y. (Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y))", "ConvergentEvolution(x) <-> exists y exists z. (DifferentTaxonomicFamilies(y, z) & Species(y) & Species(z) & DevelopInDifferentPlaces(y, z) & SimilarEnvironmentalPressures(y, z))", "exists x y. (ConvergentEvolution(x, y) <-> (Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlaces(x, y) & UnderSimilarEnvironmentalPressures(x, y)))", "ConvergentEvolution(ce) <-> exists s1, s2, f1, f2, p1, p2, ep. (Species(s1) & Species(s2) & TaxonomicFamily(f1) & TaxonomicFamily(f2) & InFamily(s1, f1) & InFamily(s2, f2) & Different(f1, f2) & Different(p1, p2) & DevelopIn(s1, p1) & DevelopIn(s2, p2) & SimilarEnvironmentalPressures(ep, p1) & SimilarEnvironmentalPressures(ep, p2) & UnderPressures(s1, ep) & UnderPressures(s2, ep))", "all x y. ((Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)) -> ConvergentEvolution(x, y))", "all x y. ((ConvergentEvolution(x) & Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopsInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)) -> ConvergentWith(x, y))", "exists w. (ConvergentEvolution(w) & all x y. ((Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopsInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)) -> Occurs(w, x, y)))", "ConvergentEvolution(x) <-> (exists y exists z. (Species(y) & Species(z) & DifferentTaxonomicFamilies(y, z) & DevelopInDifferentPlaces(y, z) & SimilarEnvironmentalPressures(y, z)))", "ConvergentEvolution(F) <-> exists s1, s2, p1, p2, e. (Species(s1) & Species(s2) & DifferentTaxonomicFamilies(s1, s2) & DevelopIn(s1, p1) & DevelopIn(s2, p2) & p1 != p2 & SimilarEnvironmentalPressures(e, p1) & SimilarEnvironmentalPressures(e, p2))", "ConvergentEvolution(x, y) <-> (exists z. (Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DifferentPlaces(x, y) & SimilarEnvironmentalPressures(z) & DevelopUnder(z, x) & DevelopUnder(z, y)))", "exists x, y. ((Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)) -> ConvergentEvolution(x, y))", "exists e. (ConvergentEvolution(e) & all x y. ((Species(x) & Species(y) & InDifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlacesUnderSimilarEnvironmentalPressures(x, y)) -> Represents(e, x, y)))", "exists x, y. (ConvergentEvolution(x, y) & Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y))", "all x, y. ((Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DifferentPlaces(x, y) & SimilarEnvironmentalPressures(x, y)) -> ConvergentEvolution(x, y))", "Exists a. (ConvergentEvolution(a) & all x. all y. ((Species(x) & Species(y) & DifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlacesUnderSimilarEnvironmentalPressures(x, y)) -> Occurs(a, x, y)))", "exists e. (ConvergentEvolution(e) & all x. all y. (Species(x) & Species(y) & InDifferentTaxonomicFamilies(x, y) & DevelopInDifferentPlaces(x, y) & SimilarEnvironmentalPressures(e, x) & SimilarEnvironmentalPressures(e, y)))"]}
{"id": "entailmentbank_validation_380", "nl": "an example of convergent evolution is two birds from different taxonomic families developing in separate environments under similar environmental pressures.", "fol": "", "prediction": ["exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopsInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) & ExampleOfConvergentEvolution(x, y))", "exists x exists y. (ExampleOfConvergentEvolution(x, y) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y, z, a, b. (Bird(x) & Bird(y) & TaxonomicFamily(x, z) & TaxonomicFamily(y, a) & z != a & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) & ConvergentEvolutionExample(x, y))", "exists x. exists y. (ConvergentEvolutionExample(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopsInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x exists y exists z exists w. (ConvergentEvolutionExample(z) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(w) & under(z, x, y, w))", "exists x, y. (Bird(x) & Bird(y) & FromDifferentFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & UnderSimilarEnvironmentalPressures(x) & UnderSimilarEnvironmentalPressures(y) & ConvergentEvolutionExample(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & SeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) & ConvergentEvolutionExample(x, y))", "exists x, y. (ConvergentEvolutionExample(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & SeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y, z. (ConvergentEvolution(x) & Bird(y) & Bird(z) & DifferentTaxonomicFamilies(y, z) & SeparateEnvironments(y, z) & SimilarEnvironmentalPressures(y, z) & DevelopsUnder(z, y))", "ConvergentEvolution(example1) & exists x. (Bird(x) & TaxonomicFamily(family1) & BelongsTo(x, family1) & Environment(env1) & DevelopsIn(x, env1)) & exists y. (Bird(y) & TaxonomicFamily(family2) & BelongsTo(y, family2) & Environment(env2) & DevelopsIn(y, env2) & SimilarEnvironmentalPressures(env1, env2) & family1 \u2260 family2)", "exists x, y. (ConvergentEvolutionExample(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopsUnderSimilarPressures(x) & DevelopsUnderSimilarPressures(y) & SeparateEnvironments(x, y) & ConvergentEvolutionExample(x, y))", "exists x, y. (ExampleOfConvergentEvolution(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & SeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))", "exists x y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & DevelopInSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) -> ConvergentEvolutionExample(x, y))", "exists x, y. (Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & ExistsSeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y) & ExampleOfConvergentEvolution(x, y))", "exists x y. (ExampleOfConvergentEvolution(x) & Bird(x) & Bird(y) & DifferentTaxonomicFamilies(x, y) & SeparateEnvironments(x, y) & SimilarEnvironmentalPressures(x, y))"]}
{"id": "entailmentbank_validation_381", "nl": "winter is a kind of season.", "fol": "", "prediction": ["Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "KindOf(winter, season)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)", "Season(winter)"]}
{"id": "entailmentbank_validation_382", "nl": "seasons cause change to the environment.", "fol": "", "prediction": ["all s. (Season(s) -> exists c. (Change(c) & Causes(s, c) & ChangeAffectsEnvironment(c)))", "all s. (Season(s) -> exists e. (Environment(e) & Causes(s, ChangeTo(e))))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "FOL Translation:\nall x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all s. (Season(s) -> exists e. (Environment(e) & CausesChangeTo(s, e)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all s. (Season(s) -> exists e. (Environment(e) & CausesChange(s, e)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "exists x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all x. (Season(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "all s. (Season(s) -> exists e. (Environment(e) & CausesChange(s, e)))"]}
{"id": "entailmentbank_validation_383", "nl": "the winter season can cause change to the environment.", "fol": "", "prediction": ["exists x. (WinterSeason(x) & CanCauseChangeTo(x, environment))", "exists x. (WinterSeason(x) & CanCauseChangeToEnvironment(x))", "all x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))", "exists s. (WinterSeason(s) -> exists e. (Environment(e) & CausesChange(s, e)))", "exists x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))", "exists y. (WinterSeason(y) -> exists z. (Environment(z) & CanCauseChange(y, z)))", "FOL Translation:\nall x. (WinterSeason(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "exists x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))", "exists x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))", "exists x. (WinterSeason(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "exists x. (WinterSeason(x) -> exists y. (Environment(y) & CanCauseChangeTo(x, y)))", "exists x. (WinterSeason(x) -> exists y. (Environment(y) & CausesChangeTo(x, y)))", "exists x. (Winter(x) & CanCauseChangeToEnvironment(x))", "exists w. (WinterSeason(w) & all e. (Environment(e) -> CanCauseChangeTo(w, e)))", "exists y. (WinterSeason(y) & CanCauseChangeToEnvironment(y))", "FOL Translation:\nall x. (WinterSeason(x) -> CanCauseChangeToEnvironment(x))"]}
{"id": "entailmentbank_validation_384", "nl": "usually plants die or become dormant during the winter.", "fol": "", "prediction": ["The given sentence suggests a general tendency rather than an absolute rule, which is not directly expressed in classical first-order logic. However, we can approximate this by using an existential quantifier to indicate that there are some plants that die or become dormant during winter:\n\nFOL Translation:\nall x. (Plant(x) & Winter(winter) -> (Dies(x) | BecomesDormant(x)))", "Since \"usually\" is a notion that might not be directly translated into first-order logic, we will interpret it as indicating a common tendency, rather than an absolute rule.\n\nFOL Translation:\nall x. (Plant(x) -> (Winter -> (Die(x) | Dormant(x))))", "Translating the sentence into FOL requires insights into handling \"usually,\" which is a probabilistic or typical statement not directly expressible in standard FOL syntax. However, we can represent it approximately using a universal statement to express a tendency:\n\nall x. (Plant(x) & Winter -> (Dies(x) | BecomesDormant(x)))", "all x. (Plant(x) -> (UsuallyDies(x, winter) | BecomesDormant(x, winter)))", "all x. (Plant(x) -> (Season(winter) -> (Die(x) | BecomeDormant(x))))", "all x. (Plant(x) & Winter -> (Dies(x) | BecomesDormant(x)))", "To translate 'usually plants die or become dormant during the winter' into first-order logic, we need to handle the notion of \"usually\". In FOL, this might not be straightforward, but we can express it in a generic way by acknowledging that it applies to many plants, though not necessarily all, using a predicate such as `Usually`.\n\nFOL Translation:\n`all x. (Plant(x) & Winter(y) -> (Usually(Die(x) | BecomeDormant(x))))`\n\nNote: In classical first-order logic, there is no direct way to express \"usually\" without specific domain knowledge or a probabilistic logic extension. Here, we introduce a predicate `Usually` to conceptually encapsulate this notion.", "In translating 'usually plants die or become dormant during the winter' into first-order logic, it is important to convey that this is a general trend rather than an absolute universal statement. FOL does not directly capture probabilistic or typicality aspects, so we typically translate \"usually\" with a universal quantifier assuming normal conditions. Here's a reasonable representation while acknowledging this limitation:\n\nFOL Translation:\nall x. (Plant(x) -> (Winter -> (Dies(x) | Dormant(x))))", "all x. (Plant(x) -> Usually(Die(x) | BecomeDormant(x), During(winter)))", "To translate the sentence 'usually plants die or become dormant during the winter' into first-order logic (FOL), we represent the concept of 'usually' using an implication with a qualifying condition or additional predicate to imply a non-universal frequency. The translation will look like:\n\nFOL Translation:\nall x. (Plant(x) & Winter -> (Die(x) | BecomeDormant(x)))", "all x. (Plant(x) -> (Usually(Winter) -> (Dies(x) | BecomesDormant(x))))", "all x. (Plant(x) -> (Winter(w) -> (Die(x) | BecomeDormant(x))))", "all x. (Plant(x) & Winter -> Dies(x) | BecomesDormant(x))", "Translate the natural language sentence into first-order logic (FOL):\n\nSentence: Usually plants die or become dormant during the winter.\n\nFOL Translation:\nall x. (Plant(x) & Winter -> Dies(x) | Dormant(x))", "all x. (Plant(x) -> (Usually(Die(x)) | Usually(BecomeDormant(x))))", "The statement \"usually plants die or become dormant during the winter\" indicates a general tendency rather than an absolute rule. However, in first-order logic, we can't directly express probabilistic or \"usual\" statements. Here, I will represent it using a general conditional implication, implying that if it's winter, then plants tend to die or become dormant.\n\nFOL Translation:\nall x. (Plant(x) -> (Winter -> (Dies(x) | BecomesDormant(x))))"]}
{"id": "entailmentbank_validation_385", "nl": "an example of a seasonal change is plants dying or becoming dormant in the winter.", "fol": "", "prediction": ["exists x. (SeasonalChange(x) & ExampleOf(x, (all y. ((Plant(y) & (Dying(y, winter) | Dormant(y, winter)))))))", "exists x. (SeasonalChange(x) & Example(x, (exists y. ((PlantsDyingInWinter(y) | PlantsDormantInWinter(y))))))", "exists x. (SeasonalChange(x) & (x = DyingOrDormantPlantsInWinter))", "exists x. (SeasonalChange(x) & ExampleOf(x, y) & (all y. (Plant(y) -> (DyingInWinter(y) | BecomesDormantInWinter(y)))))", "exists x. (ExampleOfSeasonalChange(x) & (Winter(y) & (PlantsDying(x, y) | PlantsBecomingDormant(x, y))))", "exists x. (SeasonalChangeExample(x) & (all y. ((Plant(y) & (DiesInWinter(y) | BecomesDormantInWinter(y))) -> x = y)))", "exists x. (SeasonalChange(x) & ExampleOf(x, y) & (PlantsDyingInWinter(y) | PlantsBecomingDormantInWinter(y)))", "exists x. (SeasonalChange(x) & (ExampleOf(x, PlantsDyingInWinter) | ExampleOf(x, PlantsBecomingDormantInWinter)))", "exists x. (SeasonalChange(x) & ExampleOf(x, plants_dying_or_becoming_dormant_in_winter))", "exists x. (SeasonalChange(x) & (ExampleOf(x, PlantsDyingInWinter) | ExampleOf(x, PlantsBecomingDormantInWinter)))", "exists e. (ExampleOfSeasonalChange(e) & (exists p. (Plant(p) & (DiesInWinter(p) | BecomesDormantInWinter(p)))))", "exists x. (SeasonalChange(x) & ExampleOf(x, y) & (PlantsDyingInWinter(y) | BecomingDormantInWinter(y)))", "exists x. (SeasonalChange(x) & ExampleOf(x, (exists y. ((PlantsDying(y) & InWinter(y)) | (PlantsBecomingDormant(y) & InWinter(y))))))", "exists x. (SeasonalChange(x) & ExampleOf(x, y)) & all y. ((PlantsDyingInWinter(y) | BecomingDormantInWinter(y)) -> ExampleOf(x, y))", "exists x. (SeasonalChangeExample(x) & (DyingPlantsInWinter(x) | DormantPlantsInWinter(x)))", "exists x. (SeasonalChange(x) & Example(x, y) & (all y. ((Plant(y) & (Dies(y, winter) | BecomesDormant(y, winter))) -> Example(x, y))))"]}
{"id": "entailmentbank_validation_386", "nl": "an animal requires enough nutrients to survive.", "fol": "", "prediction": ["all x. (Animal(x) -> (exists y. (Nutrient(y) & Requires(x, y) & Enough(y, x)) -> CanSurvive(x)))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y) -> Survive(x)))", "all a. (Animal(a) -> exists n. (Nutrients(n) & Enough(n) & Requires(a, n) & Survive(a)))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y) -> CanSurvive(x)))", "all x. (Animal(x) -> (exists y. (Nutrients(y) & Requires(x, y) & Enough(y, x)) -> Survive(x)))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y, Survive(x))))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y) & ToSurvive(x, y)))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y, x) & CanSurvive(x)))", "all x. (Animal(x) -> (exists y. (Nutrients(y) & Enough(y, x)) -> Survive(x)))", "all x. (Animal(x) -> (exists y. (Nutrient(y) & Requires(x, y)) & Enough(x, y) -> Survive(x)))", "all x. (Animal(x) -> (RequiresEnoughNutrients(x) -> Survive(x)))", "all x. (Animal(x) -> exists y. (EnoughNutrients(y) & Requires(x, y) & Survive(x)))", "all x. (Animal(x) -> (RequiresEnoughNutrientsToSurvive(x)))", "all a. (Animal(a) -> (exists n. (Nutrients(n) & Enough(n, a) & Requires(a, n) & CanSurvive(a))))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y) & Survive(x)))", "all x. (Animal(x) -> exists y. (Nutrients(y) & Requires(x, y) & Enough(y, x) & Survive(x)))"]}
{"id": "entailmentbank_validation_387", "nl": "eating food is used to get nutrients by animals.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Food(y) & GetsNutrientsByEating(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedFor(Eating(y), GetNutrients(x))))", "all x. (Animal(x) -> exists y. (Food(y) & Eating(x, y) & UsedToGetNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & Eating(y, x) & UsedToGetNutrients(y, x)))", "all x. (Animal(x) -> exists y. (Food(y) & Eating(x, y) -> GetsNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToEat(x, y) & GetNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(x, y) & Eats(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrientsBy(Eating(x, y), x)))", "all x. ((Animal(x) & EatingFood(x)) -> UsedToGetNutrients(x))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eating(y), x)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eating(y, x))))", "all x. (Animal(x) -> exists y. (Food(y) & UsesToGetNutrients(x, y) & Eats(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & Eating(y, x) & UsedToGetNutrients(Eating(y, x))))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrientsBy(Eating(y), x)))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eating(y, x))))", "all x. (Animal(x) -> exists y. (Food(y) & UsedToGetNutrients(Eating(x, y))))"]}
{"id": "entailmentbank_validation_388", "nl": "an animal needs to eat food for nutrients.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> (exists y. (Food(y) & ProvidesNutrients(y)) -> NeedsToEat(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & ProvidesNutrients(y) & NeedsToEat(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> (exists y. (Food(y) & NeedsToEatForNutrients(x, y))))", "all x. (Animal(x) -> exists y. (Food(y) & ProvidesNutrients(y) & NeedsToEat(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & ForNutrients(x, y) & NeedsToEat(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & ProvidesNutrients(y) & NeedsToEat(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & NeedsToEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & ProvidesNutrients(y) & NeedsToEat(x, y)))"]}
{"id": "entailmentbank_validation_389", "nl": "plants are a source of food for animals.", "fol": "", "prediction": ["all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & SourceOfFoodFor(y, x)))", "all x. (Plant(x) -> exists y. (Animal(y) & SourceOfFoodFor(x, y)))"]}
{"id": "entailmentbank_validation_390", "nl": "an animal can eat plants for nutrients.", "fol": "", "prediction": ["all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> CanEatPlantsForNutrients(x))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> (exists y. (Plant(y) & CanEatForNutrients(x, y))))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "FOL Translation:\nall x. (Animal(x) -> exists y. (Plant(y) & EatForNutrients(x, y)))", "all x. (Animal(x) -> CanEatPlantsForNutrients(x))", "all x. (Animal(x) -> CanEatPlantsForNutrients(x))", "all x. (Animal(x) -> CanEatForNutrients(x, plants))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> (exists y. (Plant(y) & CanEatForNutrients(x, y))))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))", "all x. (Animal(x) -> exists y. (Plant(y) & CanEatForNutrients(x, y)))"]}
{"id": "entailmentbank_validation_391", "nl": "an example of seasonal change is some animals' food dying in the winter.", "fol": "", "prediction": ["exists x. (SeasonalChange(example, x) & exists y. (Animal(y) & FoodOf(y, x) & Dies(x, winter)))", "exists y. (SeasonalChange(y) & ExampleOf(y, some z. (Animal(z) & FoodOf(z, w) & Dies(w, winter))))", "exists x. (SeasonalChange(x) & ExampleOf(x, FoodDyingInWinter))", "exists x. (SeasonalChangeExample(x) & FoodOfSomeAnimalsDiesInWinter(x))", "exists y. (SeasonalChangeExample(y) & ExampleOf(y, exists x. (Animal(x) & FoodOf(x) = y & DiesIn(y, winter))))", "exists x. (SeasonalChangeExample(x) & AnimalFood(y) & DiesInWinter(y) & PartOf(y, x))", "exists e, a. (SeasonalChangeExample(e) & Animal(a) & FoodDyingInWinter(a, e))", "exists x. (ExampleOfSeasonalChange(x) & Food(x) & exists y. (Animal(y) & FoodOf(y, x) & DyingInWinter(x)))", "exists x. (ExampleOfSeasonalChange(x) & exists y. (Animal(y) & forall z. (Food(z, y) & Dies(z, winter))))", "exists y. (SeasonalChange(y) & ExampleOf(y, exists x. (AnimalFood(x) & DiesInWinter(x))))", "exists x. (SeasonalChange(x) & ExampleOf(x, FoodDyingInWinter))", "exists x. (ExampleOf(x, SeasonalChange) & exists y. (Animal(y) & FoodOf(y, x) & DiesInWinter(x)))", "exists z. (SeasonalChangeExample(z) & ExampleOf(z, exists y. (AnimalFood(y) & DiesIn(y, winter))))", "exists x. (SeasonalChange(x) & ExampleOf(x, y) & exists y. (Die(z) & FoodOfAnimals(z) & OccursInWinter(z)))", "exists x. (SeasonalChange(x) & Example(x, exists y. (Animal(y) & FoodOf(y, z) & DiesInWinter(z))))", "exists x. (SeasonalChange(x) & exampleOf(x, exists y. (Animal(y) & exists z. (Food(z) & DiesInWinter(z)))))"]}
{"id": "entailmentbank_validation_392", "nl": "an example of preparing is storing something for use later.", "fol": "", "prediction": ["exists x. (Example(x) & Preparing(x) & exists y. (Storing(y) & ForUseLater(y)))", "exists x exists y. (Example(x) & Preparing(y) & Storing(y, x) & ForUseLater(y, x))", "exists x y. (Example(x) & Preparing(y) & Storing(y) & ForUseLater(y))", "exists x. (Preparing(x) & exists y. (Store(y) & UseLater(y, x)))", "exists x. exists y. (Example(x, Preparing) & Storing(x, y) & ForUseLater(y))", "exists x. (ExampleOf(x, Preparing) -> exists y. (Storing(y) & ForUseLater(y, x)))", "exists x. (ExampleOfPreparing(x) -> exists y. (Storing(y) & ForUseLater(y)))", "exists x, y. (Example(x) & Preparing(x) & Storing(y, x) & ForUseLater(y))", "exists x. (ExampleOf(x, Preparing) & Storing(x, y) & UseLater(y))", "exists x. (ExampleOfPreparing(x) & Storing(x) & ForUseLater(x))", "exists x. exists y. (Example(x) & Preparing(y) & Storing(x, y) & UseLater(y))", "exists x y. (ExampleOf(x, Preparing) & Storing(x, y) & UseLater(y))", "exists x. (ExampleOfPreparing(x) & exists y. (Stores(x, y) & ForUseLater(y)))", "exists x. (Preparing(x) & Storing(x) & ForUseLater(x))", "exists x y. (Example(x) & Preparing(x) & Storing(y, x) & ForUseLater(y))", "exists x. (ExampleOfPreparing(x) & exists y. (Storing(y) & ForUseLater(y)))"]}
{"id": "entailmentbank_validation_393", "nl": "if an animal relies on plants for food then that animal must store enough food to last through the winter.", "fol": "", "prediction": ["all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreEnoughFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))", "all x. ((Animal(x) & ReliesOnPlantsForFood(x)) -> MustStoreFoodForWinter(x))"]}
{"id": "entailmentbank_validation_394", "nl": "an example of preparing is an animal storing food to last through the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparing(x) & AnimalStoringFood(x, winter))", "exists x. (ExampleOfPreparing(x) & Animal(x) & StoringFoodToLastThroughWinter(x))", "exists x. (ExampleOfPreparing(x) & Animal(x) & StoresFoodToLastThroughWinter(x))", "Exists e. (ExampleOfPreparing(e) & exists a. (Animal(a) & StoresFood(a) & LastsThroughWinter(a)))", "exists x. (Example(x) & Preparing(x) & exists y. (Animal(y) & StoresFood(y) & LastsThroughWinter(y)))", "exists x. (Animal(x) & StoringFoodToLastThroughWinter(x) & ExampleOfPreparing(x))", "exists x. (ExampleOfPreparing(x) & Animal(x) & StoresFoodForWinter(x))", "exists x, y. (ExampleOfPreparing(x) & Animal(y) & StoresFood(y) & LastsThroughWinter(y))", "exists x. (ExampleOfPreparing(x) & Animal(x) & StoringFoodForWinter(x))", "exists x, y, z. (ExamplePreparing(x) & Animal(y) & StoresFood(y, z) & LastsThroughWinter(z))", "exists x. exists y. (ExampleOfPreparing(x) & Animal(y) & StoresFoodToLastThroughWinter(y) & x = y)", "exists x. (ExampleOfPreparing(x) & StoringFoodToLastThroughWinter(x) & Animal(x))", "exists x. (ExampleOfPreparing(x) & y & z. (Animal(y) & StoringFood(y, z) & LastsThroughWinter(z, y)))", "An example of this sentence in FOL is:\n\nexists x. (Animal(x) & StoresFood(x, winter) -> ExampleOfPreparing(x))", "all x. (ExampleOfPreparing(x) <-> (Animal(y) & StoresFood(y) & ToLastThroughWinter(y)))", "exists x. (ExampleOfPreparing(x) & exists y. (Animal(y) & StoresFood(y) & LastsThroughWinter(food)))"]}
{"id": "entailmentbank_validation_395", "nl": "an example of preparing for seasonal change is an animal storing food for the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodForWinter(y) & x = y))", "FOL Translation:\nexists y. (ExampleOfPreparingForSeasonalChange(y) & AnimalStoresFoodForWinter(y))", "exists x, y. (Animal(x) & StoresFoodForWinter(x) & ExampleOf(y, PreparingForSeasonalChange) & y = StoresFoodForWinter(x))", "exists x, y. (ExampleOf(x, PreparingForSeasonalChange) & Animal(y) & StoresFoodForWinter(y) & Instance(x, y))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodForWinter(y) & x = StoresFoodExample(y)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Animal(a) & StoresFoodForWinter(a) & Example(x, a))", "exists e. (ExampleOfPreparingForSeasonalChange(e) & exists a. (Animal(a) & StoringFoodForWinter(a) & IsExampleOf(a, e)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodFor(y, winter) & Example(x, y)))", "exists x y. (ExampleOfPreparingForSeasonalChange(x) & Animal(y) & StoresFoodForWinter(y) & x = StoresFoodForWinter(y))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Animal(x) & StoresFoodFor(x, winter))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodForWinter(y) & ExampleIs(x, StoresFoodForWinter(y))))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodForWinter(y) & Example(x, y)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Animal(y) & StoresFoodForWinter(y) & x = StoringFoodForWinter(y))", "exists x. (ExampleOf(x, PreparingForSeasonalChange) & exists y. (Animal(y) & StoresFoodFor(x, y, winter)))", "exists y. (Example(y) & PreparingForSeasonalChange(y) & exists z. (Animal(z) & StoresFoodForWinter(z) & IsExampleOf(z, y)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Animal(y) & StoresFoodForWinter(y)))"]}
{"id": "entailmentbank_validation_396", "nl": "a squirrel is a kind of animal.", "fol": "", "prediction": ["Animal(squirrel)", "Squirrel(x) -> Animal(x)", "Animal(squirrel)", "Squirrel(x) -> Animal(x)", "Animal(squirrel)", "Animal(squirrel)", "Animal(squirrel)", "Animal(squirrel)", "Squirrel(squirrel) -> Animal(squirrel)", "Animal(squirrel)", "Animal(squirrel)", "Squirrel(x) -> Animal(x)", "Squirrel(x) -> Animal(x)", "Animal(squirrel)", "Animal(squirrel)", "Animal(squirrel)"]}
{"id": "entailmentbank_validation_397", "nl": "an example of preparing for seasonal change is a squirrel storing food for the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFoodForWinter(y) & x = y)", "exists x. (PreparationForSeasonalChange(x) & ExampleOf(x, StoringFood(squirrel, winter)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFoodForWinter(y) & x = StoringFoodForWinterBy(y))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFoodFor(y, winter) & y = x)", "exists e. (ExampleOf(e, PreparingForSeasonalChange) & \n            exists s. (Squirrel(s) & \n            exists f. (Food(f) & StoresFor(s, f, Winter))) & \n            IsExample(e, s))", "exists e. (ExampleOfPreparingForSeasonalChange(e) & exists s. (Squirrel(s) & StoresFoodFor(s, winter) & InstanceOf(e, StoringFoodForWinter)))", "exists x. (Example(x) & PreparingForSeasonalChange(x) & exists y. (Squirrel(y) & StoresFoodForWinter(y) & ExampleOf(x, y)))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFoodForWinter(y) & InstanceOf(x, y))", "Exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoreFoodForWinter(y) & x = y)", "Exists e. (ExampleOf(e, PreparingForSeasonalChange) & Exists s. (Squirrel(s) & StoresFoodFor(s, Winter)))", "ExampleOf(PreparingForSeasonalChange, StoringFoodForWinter(squirrel))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoreFoodForWinter(y) & Instance(y, x))", "ExampleOfPreparingForSeasonalChange(squirrel, StoringFoodForWinter(squirrel))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(x) & StoresFoodForWinter(x))", "exists x. (ExampleOf(x, PreparingForSeasonalChange) & Squirrel(y) & StoresFoodFor(z, Winter) & x = (y, z))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(s) & StoresFoodForWinter(s, x))"]}
{"id": "entailmentbank_validation_398", "nl": "nut is a kind of food.", "fol": "", "prediction": ["Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "KindOfFood(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "Food(nut)", "KindOf(nut, food)", "Food(nut)"]}
{"id": "entailmentbank_validation_399", "nl": "an example of preparing for seasonal change is an squirrel storing nuts for the winter.", "fol": "", "prediction": ["exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(x) & StoresForWinter(x, nuts))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresNutsForWinter(y) & x = y)", "Exists x, y. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresNutsForWinter(y))", "exists x. (ExampleOfPreparingForSeasonChange(x) & exists y. (Squirrel(y) & StoresForWinter(y, nuts) & PartOfExample(y, x)))", "Exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoreNutsForWinter(y, x))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFor(y, nuts, winter) & x = StoresFor(y, nuts, winter))", "exists x exists y exists z. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & Nuts(z) & StoringForWinter(y, z) & x = StoringForWinter(y, z))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresFor(x, y, nuts, winter))", "Existential quantification should be used to express the existence of an example of \"preparing for seasonal change,\" which is exemplified by a specific behavior of a squirrel.\n\nFOL Translation:\nexists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresNutsForWinter(y))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & exists y. (Squirrel(y) & StoresNutsForWinter(y) & Example(x, y)))", "ExampleOfPreparingForSeasonalChange(squirrel, StoringNutsForWinter(squirrel))", "Exists x, y. (ExampleofPreparingForSeasonalChange(x) & Squirrel(y) & StoresForWinter(y, x))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & ExampleIs(x, squirrelStoringNutsForWinter))", "exists x. (ExampleOfPreparingForSeasonalChange(x) & Squirrel(y) & StoresForWinter(y, nuts) & Example(x, y))", "ExampleOfPreparingForSeasonalChange(squirrel_storing_nuts_for_winter)", "ExampleOfPreparingForSeasonalChange(storingNutsForWinter(squirrel))"]}
{"id": "entailmentbank_validation_400", "nl": "an animal requires warmth for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "FOL Translation:\nall x. (Animal(x) -> RequiresForSurvival(x, Warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))"]}
{"id": "entailmentbank_validation_401", "nl": "winter has cold temperatures / weather.", "fol": "", "prediction": ["Winter(w) -> ColdTemperatures(w)", "Winter(w) -> Cold(w)", "ColdTemperature(winter)", "ColdTemperature(winter)", "Winter(w) -> HasColdTemperatures(w)", "Winter has cold temperatures / weather.\n\nFOL Translation:\nCold(temperature(winter)) & Cold(weather(winter))", "Winter(w) & HasColdTemperatures(w)", "Cold(winter)", "Winter(w) & ColdTemperatures(w)", "all x. (Winter(x) -> ColdTemperaturesOrWeather(x))", "Cold(winter)", "ColdTemperatures(winter)", "Winter(winter) -> ColdTemperature(winter)", "Cold(winter)", "ColdWeather(winter)", "FOL Translation:\nWinter(w) -> Cold(w)"]}
{"id": "entailmentbank_validation_402", "nl": "some animals must move to warmer climates in the winter.", "fol": "", "prediction": ["exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimates(x, winter))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimateInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))", "exists x. (Animal(x) & MustMoveToWarmerClimatesInWinter(x))"]}
{"id": "entailmentbank_validation_403", "nl": "migration is when animals move themselves from a cooler climate to a warmer climate for the winter.", "fol": "", "prediction": ["exists x. (Migration(x) & all y. (Animal(y) & Moves(y, CoolerClimate, WarmerClimate, Winter) -> PartOf(x, y)))", "Migration(is(x)) <-> (exists y, exists z, exists a, exists b. (Animal(y) & MovesSelf(y, z, a, b) & FromCoolerClimate(z) & ToWarmerClimate(a) & ForWinter(b)))", "exists x. (Migration(x) & all y. (Animal(y) & MovesTo(y, WarmerClimate) & IsFor(x, Winter)))", "all x. (Migration(x) <-> (Animal(x) & Moves(x, CoolerClimate, WarmerClimate) & ForWinter(x)))", "Migration(x) <-> (exists y. (Animal(y) & MovesItselfFromTo(y, CoolerClimate, WarmerClimate) & ForSeason(y, Winter)))", "exists m. (Migration(m) & all x. (Animal(x) -> (MovesFromToFor(x, cooler_climate, warmer_climate, winter) <-> PartOf(x, m))))", "MigrationIsWhenAnimalsMoveForWinter -> all x, y, z. (Migration(x) & Animal(y) & CoolerClimate(y) & WarmerClimate(z) & Winter(w) -> MoveForWinter(y, x, z, w))", "Migration is defined as the behavior where animals relocate from cooler to warmer climates for the winter. Therefore, capturing this relationship involves utilizing conditional and existential logic to denote the concept. The translation into first-order logic would look like:\n\nMigration(m) <-> all a. ((Animal(a) & CoolerClimate(c) & WarmerClimate(w) & Winter(wt)) -> exists m. (Move(a, c, w, m) & ForSeason(m, wt)))", "Migration(x) <-> (all a. (Animal(a) & MovesFromTo(a, CoolerClimate, WarmerClimate) & During(a, Winter) -> Migration(a)))", "`all x. (Migration(x) <-> (Animal(x) & MoveFromToFor(x, CoolerClimate, WarmerClimate, Winter)))`", "Migration(x) <-> (Animal(x) & MoveToWarmerClimateForWinter(x))", "all x. (Migration(x) <-> exists y. (Animal(y) & Move(y, CoolerClimate, WarmerClimate) & Winter))", "all x. (Migration(x) <-> (Animal(x) & MovesFromTo(x, CoolerClimate, WarmerClimate) & ForSeason(x, winter)))", "all x. (Migration(x) <-> (AnimalMoveAccordanceWithSeason(x) & CoolerToWarmerClimate(x) & ForWinter(x)))", "all x. (Animal(x) & MovesFromTo(x, cooler_climate, warmer_climate, winter) <-> Migration(x))", "Migration(x) <-> (exists a, b, y. (Animal(y) & Move(y, y, a, b) & CoolerClimate(a) & WarmerClimate(b) & ForSeason(y, winter)))"]}
{"id": "entailmentbank_validation_404", "nl": "an example of migration is moving to a warmer climate in the winter.", "fol": "", "prediction": ["exists x. (ExampleOfMigration(x) & MovesToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovesToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovesToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovesToWarmerClimateInWinter(x))", "exists x. (MigrationExample(x) & MovesToWarmerClimateInWinter(x))", "exists x. (MigrationExample(x) & MovesToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovingToWarmerClimateInWinter(x))", "exists x. (MigrationExample(x) & MovesToWarmerClimateInWinter(x))", "exists x. (MigrationExample(x) & MoveToWarmerClimateInWinter(x))", "exists x, y, z. (ExampleOf(x, Migration) & MovingTo(x, y, z) & WarmerClimate(y) & Winter(z))", "exists x. (Migration(x) & ExampleOf(x, moving_to_warmer_climate_in_winter))", "exists x. (ExampleOfMigration(x) & ExistsMovementToWarmerClimateInWinter(x))", "exists x, y, z. (ExampleOf(x, Migration) & MovesTo(y, z) & WarmerClimate(z) & InWinter(y) & x = y)", "exists x. (ExampleOfMigration(x) & MoveToWarmerClimateInWinter(x))", "exists x. (MigrationExample(x) & MovesToWarmerClimateInWinter(x))", "exists x. (ExampleOfMigration(x) & MovingToWarmerClimateInWinter(x))"]}
{"id": "entailmentbank_validation_405", "nl": "some birds fly south for the winter.", "fol": "", "prediction": ["exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FlySouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))", "exists x. (Bird(x) & FliesSouthForWinter(x))"]}
{"id": "entailmentbank_validation_406", "nl": "an example of migration is birds flying south in the winter.", "fol": "", "prediction": ["ExampleOfMigration(birds_flying_south_in_winter)", "exists x. (ExampleOfMigration(x) & BirdsFlyingSouthInWinter(x))", "exists x. (ExampleOfMigration(x) & Bird(y) & FlySouthInWinter(y) & x = y)", "Exists x. (ExampleOfMigration(x) & BirdsFlyingSouthInWinter(x))", "MigrationExample(birds_flying_south_in_winter)", "exists x, y. (ExampleOfMigration(x) & Birds(y) & FlySouthInWinter(y) & x = y)", "Exists x, y. (MigrationExample(x, BirdsFlyingSouthInWinter) & ExampleOf(y, Migration) & ExampleOf(x, y))", "exists x. (ExampleOfMigration(x) & x = BirdsFlyingSouthInWinter)", "ExampleOf(migration, exists x. (Bird(x) & FliesSouthInWinter(x)))", "exists x y. (MigrationExample(x) & ExampleOf(x, y) & BirdsFlyingSouthInWinter(y))", "ExampleOfMigration(birds_flying_south_in_winter)", "Exists x. (ExampleOfMigration(x) & BirdsFlyingSouthInWinter(x))", "exists x. (MigrationExample(x) & IsExampleOf(x, Migration) & ExampleDescription(x, \"birds flying south in the winter\"))", "Example(migration, BirdsFlySouthInWinter)", "ExampleOfMigration(birdsFlyingSouthInWinter)", "exists x. (MigrationExample(x) & BirdsFlyingSouthInWinter(x))"]}
{"id": "entailmentbank_validation_407", "nl": "migration is a kind of adaptation.", "fol": "", "prediction": ["KindOf(migration, adaptation)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "KindOf(migration, adaptation)", "KindOf(migration, adaptation)", "Adaptation(migration)", "KindOfAdaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)", "Adaptation(migration)"]}
{"id": "entailmentbank_validation_408", "nl": "an example of an adaptation is birds migrating south in the winter.", "fol": "", "prediction": ["exists x. (AdaptationExample(x) & BirdsMigratingSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (Adaptation(x) & ExampleOf(x, BirdsMigratingSouthInWinter))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigratingSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (AdaptationExample(x) & Migration(x) & all y. (Bird(y) & MigratesSouthInWinter(y) -> Examples(x, y)))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))", "exists x. (ExampleOfAdaptation(x) & BirdsMigrateSouthInWinter(x))", "exists x. (AdaptationExample(x) & Migration(birds, south, winter))", "exists x. (ExampleOfAdaptation(x) & BirdsMigratingSouthInWinter(x))", "exists e. (Example(e) & Adaptation(e) & exists b. (Bird(b) & MigrationSouthInWinter(b, e)))", "exists x. (ExampleOfAdaptation(x) & BirdsMigratingSouthInWinter(x))", "exists x. exists y. (AdaptationExample(x, y) & BirdsMigrateSouthInWinter(y))", "exists x. (AdaptationExample(x) & BirdsMigrateSouthInWinter(x))"]}
{"id": "entailmentbank_validation_409", "nl": "wasp's stinger contains poison.", "fol": "", "prediction": ["", "Contains(stinger(wasp), poison)", "", "Exists x. (WaspStinger(x) & Contains(x, poison))", "Exists x. (Wasp(x) & ContainsStinger(x, y) & Stinger(y) & Contains(y, z) & Poison(z))", "Exists x. (Wasp(x) & Contains(Stinger(x), Poison))", "exists x. (Stinger(x) & PartOf(x, wasp) & Contains(x, poison))", "Exists y. (Wasp(y) & Stinger(z) & Contains(z, y) & Contains(poison, z))", "exists x. (WaspStinger(x) & Contains(x, poison))", "exists x. (Wasp(x) & exists y. (Stinger(x, y) & Contains(y, poison)))", "exists x. (Wasp(x) & StingerOf(x, s) & Contains(s, poison))", "exists x. (WaspStinger(x) & Contains(x, poison))", "exists x. (WaspStinger(x) & Contains(x, poison))", "", "FOL Translation:\nexists z. (Wasp(z) & exists x. (Stinger(x) & Contains(x, poison) & PartOf(x, z)))", "Exists x. (Wasp(x) -> Exists y. (StingerOf(x, y) & Contains(y, poison)))"]}
{"id": "entailmentbank_validation_410", "nl": "poison causes harm to living things.", "fol": "", "prediction": ["all x. (LivingThing(x) & Poison(p) -> CausesHarmTo(p, x))", "FOL Translation:  \nall x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarm(y, x))))", "all x. ((LivingThing(x) & Poison(p)) -> CausesHarmTo(p, x))", "all x. (LivingThing(x) -> exists y. (Poison(y) & CausesHarm(y, x)))", "all x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarm(y, x))))", "all x. (LivingThing(x) & Poison(y) & Causes(y, x) -> Harm(x))", "all x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarmTo(y, x))))", "FOL Translation:\nall x. (LivingThing(x) -> (Poison(y) & CausesHarm(y, x)))", "all x. (LivingThing(x) & Poison(y) -> CausesHarm(y, x))", "all x. (LivingThing(x) -> exists y. (Poison(y) & CausesHarmTo(y, x)))", "", "all x. (LivingThing(x) & Poison(y) & Causes(y, x) -> Harm(x))", "all x. (LivingThing(x) -> exists y. (Poison(y) & CausesHarmTo(y, x)))", "all x. (LivingThing(x) -> (exists y. (Poison(y) & CausesHarmTo(y, x))))", "all x. (LivingThing(x) & Poison(y) & Causes(y, Harm, x) -> Harm(x))", "all x. (LivingThing(x) & Poison(y) & Causes(y, Harm, x) -> Harm(x))"]}
{"id": "entailmentbank_validation_411", "nl": "a wasp's stinger can be used to cause harm to living things.", "fol": "", "prediction": ["exists x. (Wasp(x) & exists y. (StingerOf(x, y) & all z. (LivingThing(z) -> CanCauseHarmTo(y, z))))", "exists x. (Wasp(x) & Stinger(x) & CanBeUsedToCauseHarm(Stinger(x), y) & LivingThing(y))", "exists x. (WaspStinger(x) -> CanBeUsedToCauseHarm(x, y) & LivingThing(y))", "exists x. (WaspStinger(x) -> CanBeUsedToCauseHarmToLivingThings(x))", "FOL Translation:\nall x. (Wasp(x) -> exists y. (Stinger(x, y) & CanBeUsedToCauseHarmToLivingThings(y)))", "all x. (WaspStinger(x) -> exists y. (LivingThing(y) & CanCauseHarm(x, y)))", "exists x. (WaspStinger(x) & exists y. (LivingThing(y) & CanBeUsedToCauseHarm(x, y)))", "exists x. (Wasp(x) & exists y. (StingerOf(x, y) & CanBeUsedToCauseHarm(y, z) & LivingThing(z)))", "exists x. (WaspStinger(x) -> CanCauseHarmTo(x, y) & LivingThing(y))", "exists x. (Wasp(x) & StingerOf(x, s) & exists y. (LivingThing(y) & CanCauseHarm(s, y)))", "exists x. (WaspStinger(x) -> CanCauseHarm(x, y) & all y. (LivingThing(y)))", "exists x. (Wasp(x) & exists y. (Stinger(y) & Owns(x, y) & all z. (LivingThing(z) -> CanCauseHarm(y, z))))", "exists x. (Wasp(x) & HasStinger(x) & all y. (LivingThing(y) -> CanCauseHarmTo(x, y)))", "exists x. (Wasp(x) -> exists y. (StingerOf(x, y) & CanBeUsedToCauseHarmTo(y, z) & LivingThing(z)))", "exists x. (Wasp(x) & exists y. (StingerOf(x, y) & CanCauseHarm(y, LivingThing)))", "exists x. (WaspStinger(x) & CanBeUsedToCauseHarm(x, y) & exists y. (LivingThing(y)))"]}
{"id": "entailmentbank_validation_412", "nl": "harming is a kind of defense.", "fol": "", "prediction": ["Defense(harming)", "all x. (Harming(x) -> Defense(x))", "KindOf(harming, defense)", "Harming(x) -> Defense(x)", "KindOf(harming, defense)", "all x. (Harming(x) -> Defense(x))", "KindOf(harming, defense)", "all x. (Harming(x) -> Defense(x))", "Defense(harming)", "all x. (Harming(x) -> Defense(x))", "all x. (Harming(x) -> Defense(x))", "all x. (Harming(x) -> Defense(x))", "Defense(harming)", "all x. (Harming(x) -> Defense(x))", "KindOf(harming, defense)", "Defense(harming)"]}
{"id": "entailmentbank_validation_413", "nl": "a stinger is used for defense by a wasp.", "fol": "", "prediction": ["exists x. (Wasp(x) & exists y. (Stinger(y) & UsedForDefenseBy(y, x)))", "exists x. (Stinger(x) & UsedForDefenseBy(x, wasp))", "exists x, y. (Stinger(x) & Wasp(y) & UsedForDefenseBy(x, y))", "exists x. (Wasp(x) & exists y. (Stinger(y) & UsedForDefenseBy(y, x)))", "exists x. (Wasp(x) & exists y. (Stinger(y) & UsedForDefenseBy(y, x)))", "exists y. (Wasp(y) & exists x. (Stinger(x) & UsedFor(x, Defense, y)))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. (Wasp(x) & exists y. (Stinger(y) & UsedForDefenseBy(y, x)))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. (Wasp(x) & exists y. (Stinger(y) & UsedForDefenseBy(y, x)))", "exists x. (Stinger(x) & exists y. (Wasp(y) & UsedForDefenseBy(x, y)))", "exists x. exists y. (Stinger(x) & Wasp(y) & UsedForDefenseBy(x, y))", "exists x. (Stinger(x) & Wasp(y) & UsedForDefenseBy(x, y))", "exists x. (Stinger(x) & Wasp(y) & UsedForDefenseBy(x, y))"]}
{"id": "entailmentbank_validation_414", "nl": "color is a property of an organism that describes what it looks like.", "fol": "", "prediction": ["all x. (Organism(x) -> exists y. (Property(color, y) & Describes(y, Appearance(x))))", "all x. (Organism(x) -> exists c. (Color(c) & PropertyOf(c, x) & Describes(c, x)))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & Color(y)))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & Color(y)))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & LooksLike(x, y)))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & Color(y)))", "all x. (Organism(x) -> exists y. (PropertyOf(y, x) & Describes(y, LooksLike(x)) & Color(y)))", "all x. (Organism(x) -> exists y. (Property(y) & DescribesWhatLooksLike(y, x) & Equals(y, color)))", "all x. (Organism(x) -> exists y. (Color(y) & PropertyOf(y, x) & Describes(y, LooksLike(x))))", "all x. (Organism(x) -> exists y. (Property(y) & Color(y) & Describes(y, LooksLike(x))))", "all x. (Organism(x) -> exists y. (Property(y) & Color(y) & Describes(y, x)))", "all x. (Organism(x) -> exists y. (PropertyOf(y, x) & Describes(y, x) & Color(y) & LooksLike(x)))", "all x. (Organism(x) -> exists y. (Color(y) & PropertyOf(y, x) & Describes(y, AppearanceOf(x))))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & Color(y)))", "all x. (Organism(x) -> exists y. (Property(y) & Describes(y, x) & Color(y)))", "all x. (Organism(x) -> exists y. (PropertyOf(y, x) & DescribesColor(y, x)))"]}
{"id": "entailmentbank_validation_415", "nl": "an example of camouflage is an organism looking like its environment.", "fol": "", "prediction": ["exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLikeEnvironment(y)))", "exists x. (CamouflageExample(x) & LooksLikeEnvironment(x))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLike(y, Environment(y))))", "exists x. (ExampleOf(camouflage, x) & LooksLikeEnvironment(x))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLike(y, ItsEnvironment(y))))", "exists x, y. (ExampleOf(x, Camouflage) & Organism(x) & LooksLike(x, y) & Environment(y))", "exists x. (ExampleOfCamouflage(x) & Organism(x) & LooksLike(x, Environment(x)))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLikeEnvironment(y) & x = y))", "exists x. (ExampleOf(x, Camouflage) & LooksLike(x, Environment))", "exists x. exists y. (CamouflageExample(x) & Organism(x) & Environment(y) & LooksLike(x, y))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLikeEnvironment(y)))", "exists x. (ExampleCamouflage(x) & exists y. (Organism(y) & LooksLikeEnvironment(y)))", "exists x y. (ExampleOfCamouflage(x) & Organism(x) & Environment(y) & LooksLike(x, y))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLike(y, EnvironmentOf(y))))", "exists x. (ExampleOfCamouflage(x) & Organism(x) & LooksLikeEnvironment(x))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & LooksLike(y, Environment(y))))"]}
{"id": "entailmentbank_validation_416", "nl": "an example of camouflage is organism having the same color as its environment.", "fol": "", "prediction": ["exists x. exists y. (ExampleOfCamouflage(x) & OrganismHasColorAsEnvironment(y) & x = y)", "exists x, y. (ExampleOfCamouflage(x) & Organism(y) & HasSameColorAsEnvironment(y) -> Example(x, y))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & SameColorAsEnvironment(y)))", "exists x. (ExampleOfCamouflage(x) & all y. (Organism(y) & SameColorAsEnvironment(y) -> HasProperty(x, y)))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y)))", "exists x. (ExampleOfCamouflage(x) & Organism(x) & HasSameColorAsEnvironment(x))", "exists x. exists y. (CamouflageExample(x) & Organism(x) & Environment(y) & HasSameColorAs(x, y))", "exists x. exists y. (ExampleOfCamouflage(x) & Organism(x) & MatchesColor(x, y) & Environment(y))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y)))", "exists x. (ExampleOfCamouflage(x) & HasColorAsEnvironment(x))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & SameColorAsEnvironment(y)))", "exists x. (CamouflageExample(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y) & ExampleOf(y, x)))", "exists x. (CamouflageExample(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y, x)))", "exists x, y. (ExampleOfCamouflage(x) & Organism(y) & HasSameColorAsEnvironment(y) & Example(x, y))", "exists x. (ExampleOfCamouflage(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y)))", "exists x. (CamouflageExample(x) & exists y. (Organism(y) & HasSameColorAsEnvironment(y)))"]}
{"id": "entailmentbank_validation_417", "nl": "if an animal's skin is a certain color then that animal is that color.", "fol": "", "prediction": ["all x. (exists c. (SkinColor(x, c)) -> Color(x, c))", "all x. all c. (Animal(x) & SkinColor(x, c) -> Color(x, c))", "all x, c. (Animal(x) & SkinColor(x, c) -> HasColor(x, c))", "all x. all c. (Animal(x) & SkinColor(x, c) -> Color(x, c))", "all x. all c. (Animal(x) & Color(c) & SkinColor(x, c) -> IsColor(x, c))", "all x. all c. (Animal(x) & SkinColor(x, c) -> IsColor(x, c))", "all x all y. (Animal(x) & HasSkinColor(x, y) -> IsColor(x, y))", "all x. all c. (Animal(x) & SkinColor(x, c) -> Color(x, c))", "all x. (Animal(x) & exists c. (SkinColor(x, c) & Color(c)) -> IsColor(x, c))", "all x. all c. (SkinColor(x, c) -> IsColor(x, c))", "all x. all c. (Animal(x) & SkinColor(x, c) -> HasColor(x, c))", "all x. all c. (HasSkinColor(x, c) -> IsColor(x, c))", "all x. (Animal(x) & exists c. (SkinColor(x, c) -> HasColor(x, c)))", "all x. all c. ((Animal(x) & SkinColor(x, c)) -> IsColor(x, c))", "all x. all c. ((Animal(x) & SkinColor(x, c)) -> IsColor(x, c))", "all x. all c. (Animal(x) & SkinColor(x, c) -> IsColor(x, c))"]}
{"id": "entailmentbank_validation_418", "nl": "an example of camouflage is an animal's skin having the same color as its environment.", "fol": "", "prediction": ["exists x, y. (CamouflageExample(x) & Animal(y) & HasColorSameAsEnvironment(y) & ExampleOf(y, x))", "exists x, y. (ExampleOfCamouflage(x) & Animal(y) & HasColor(Skin(y), Environment(y)) & SameColorAs(Skin(y), Environment(y)) & ExampleOf(x, HasColor(Skin(y), Environment(y))))", "exists x, y. (ExampleOfCamouflage(x) & Animal(y) & SkinOf(y, z) & HasSameColor(z, EnvironmentOf(y)))", "exists x. exists y. (ExampleOfCamouflage(x) & Animal(y) & Skin(y) & HasSameColorAs(Environment(y), Skin(y)))", "exists x, y. (ExampleOf(x, Camouflage) & Animal(y) & SkinOf(y, z) & HasColor(z, c) & Environment(y, e) & HasColor(e, c))", "exists x. (ExampleOfCamouflage(x) & AnimalSkin(x) & sameColor(x, Environment(x)))", "exists x, y. (ExampleOfCamouflage(x) & Animal(y) & SkinOf(y, z) & ColorOf(z) & EnvironmentOf(y, w) & ColorOf(w) & (ColorOf(z) = ColorOf(w)))", "exists x, y. (Camouflage(x) & ExampleOf(x, y) & SkinColor(y) = EnvironmentColor(y) & Animal(y))", "exists x, y. (CamouflageExample(x) & Animal(y) & SkinColor(y, EnvironmentColor(y)) = x)", "exists x. exists y. (ExampleOfCamouflage(x) & Animal(y) & sameColor(Skin(y), Environment(y)) & Example(x, sameColor(Skin(y), Environment(y))))", "exists x. exists y. (CamouflageExample(x) & Animal(y) & Skin(y) = EnvironmentColor(y) & PartOf(x, Skin(y)))", "exists x, y. (CamouflageExample(x) & Animal(y) & Skin(y, x) & ColorEquals(Skin(y), Environment(y)))", "exists x, y. (CamouflageExample(x) & AnimalSkin(y) & HasSameColor(y, EnvironmentOfAnimal(y)))", "CamouflageExample(skinOf(animal), environment)", "exists x, y, z. (ExampleOf(x, Camouflage) & Animal(y) & HasSkin(y, z) & SameColor(z, Environment(y)))", "exists x. exists y. (CamouflageExample(x) & Animal(y) & HasSkin(y, x) & sameColor(x, Environment(y)))"]}
{"id": "entailmentbank_validation_419", "nl": "camouflage is a kind of adaptation for hiding in an environment.", "fol": "", "prediction": ["KindOf(camouflage, Adaptation) & For(camouflage, HidingInEnvironment)", "KindOf(camouflage, Adaptation) & Purpose(camouflage, Hiding) & InEnvironment(camouflage)", "Adaptation(camo) & KindOf(camo, Hiding) & Environment(env) & HidingIn(camo, env)", "Adaptation(camouflage) & KindOf(camouflage, HidingInEnvironment)", "KindOf(camouflage, adaptation) & Hiding(camouflage, environment)", "KindOf(camouflage, adaptation) & Function(camouflage, hiding) & Purpose(hiding, environment)", "Adaptation(camouflage) & all x. (Environment(x) -> CanHide(camouflage, x))", "Adaptation(camouflage) & all e. (Environment(e) -> HidingIn(camouflage, e))", "all x. (Camouflage(x) -> (Adaptation(x) & Purpose(x, HidingInEnvironment)))", "Adaptation(camouflage) & KindOf(camouflage, ForHidingInEnvironment)", "Adaptation(camouflage) & HidingInEnvironment(camouflage)", "KindOf(camouflage, adaptation) & Function(camouflage, HidingInEnvironment)", "Kind(camouflage, adaptation) & all x. (Environment(x) -> HelpsToHide(camouflage, x))", "all x. (Camouflage(x) -> (Adaptation(x) & ForHiding(x, environment)))", "Adaptation(camouflage) & all x. (Environment(x) -> CanHideIn(camouflage, x))", "KindOf(camouflage, adaptation) & Purpose(camouflage, HidingInEnvironment)"]}
{"id": "entailmentbank_validation_420", "nl": "an animal having the same skin color as its environment is an adaptation for hiding in an environment.", "fol": "", "prediction": ["all x. all y. ((Animal(x) & Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (SkinColor(x, y) & Environment(z) & HasSameColor(y, z)) -> AdaptationForHiding(x, z))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> Adaptation(HideIn, y))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHiding(x, y))", "all x y. ((Animal(x) & Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHiding(x, y))", "all x. ((Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y))) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & Environment(y) & HasSameSkinColorAs(x, y) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAsEnvironment(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. all y. (Animal(x) & Environment(y) & SameSkinColorAsEnvironment(x, y) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. (Animal(x) & exists y. (SkinColor(x, y) & Environment(x, y) & SameColor(y, Environment(x))) -> AdaptationForHidingInEnvironment(x))", "all x. (Animal(x) & exists y. (SkinColor(x) = Color(y) & Environment(y)) -> AdaptationForHidingInEnvironment(x))", "all x. (Animal(x) & exists y. (Environment(y) & HasSameSkinColorAsEnvironment(x, y)) -> AdaptationForHidingInEnvironment(x, y))", "all x. all y. all z. ((Animal(x) & Environment(y) & HasSkinColor(x, z) & SameColor(z, y)) -> AdaptationForHiding(x, y))"]}
{"id": "entailmentbank_validation_421", "nl": "predators usually must see their prey in order to catch them.", "fol": "", "prediction": ["exists y. (Predator(y) -> all z. (Prey(z) -> (MustSee(y, z) & InOrderTo(Catch(y, z)))))", "Usually statements in natural language do not translate directly to strict logical forms. However, one can interpret them based on context and intent. Below is one way to formalize the given sentence:\n\nall x. (Predator(x) -> (Usually(See(x, Prey(x)) & Catch(x, Prey(x))))) \n\nDue to the inherent vagueness of \"usually,\" a direct translation in strict first-order logic lacks preciseness. Instead, the translation attempts to capture that there is a tendency for predators to usually see their prey to catch them. In a less precise interpretation, it might be represented as a general rule with some exceptions.", "all x. (Predator(x) -> Usually(MustSeePrey(x) -> CanCatchPrey(x)))", "all x. (Predator(x) -> Usually(MustSee(x, PreyOf(x)) -> CanCatch(x, PreyOf(x))))", "all x. (Predator(x) -> (UsuallyMustSeePrey(x) & all y. (Prey(y) -> (See(x, y) -> Catch(x, y)))))", "all x. (Predator(x) -> (usually y. (Prey(y) & Catch(x, y) -> MustSee(x, y))))", "all p, q. (Predator(p) & Prey(q) & UsuallyMustSee(p, q) -> (Caught(p, q) -> Sees(p, q)))", "", "all x. (Predator(x) -> (Usually(MustSeePrey(x)) -> CanCatchPrey(x)))", "all x. (Predator(x) -> (Usually(See(x, Prey(x))) -> CanCatch(x, Prey(x))))", "To translate the given sentence into first-order logic, we will need to break it down into its components. The sentence implies a typical scenario but not an absolute rule, so we can represent it in a more generic form without strict quantification over \"usually.\" We will focus on the logical conditions specified (seeing prey and catching prey).\n\nLet's define our predicates:\n- `Predator(x)`: x is a predator\n- `Prey(y)`: y is a prey\n- `Sees(z, y)`: z sees y\n- `Catches(z, y)`: z catches y\n\nThe sentence states that predators typically must see the prey to catch them. We can interpret this as meaning \"if a predator catches prey, then it usually sees its prey.\"\n\nThus, we arrive at a representation like:\nall z, y. ((Predator(z) & Prey(y) & Catches(z, y)) -> Sees(z, y))", "To translate the sentence 'predators usually must see their prey in order to catch them' into first-order logic, we need to break it down into parts. The sentence suggests that generally a predator needs to see its prey in order to catch it. While FOL does not handle probabilistic concepts like \"usually,\" we can represent the requirement part directly. \n\nAssuming:\n- `Predator(x)` means x is a predator.\n- `Prey(y)` means y is a prey.\n- `Sees(x, y)` means x sees y.\n- `Catches(x, y)` means x catches y.\n\nThe sentence implies that if x is a predator and y is its prey, then x must see y to catch y. While FOL can't express \"usually,\" the necessary condition can be captured as follows:\n\nall x, y. ((Predator(x) & Prey(y) & Catches(x, y)) -> Sees(x, y))", "all x. (Predator(x) -> (Usually & MustSeePreyToCatch(x)))", "all x. (Predator(x) -> (usually(See(x, Prey(x)) -> CanCatch(x, Prey(x)))))", "all x. ((Predator(x) & Prey(y) & Catches(x, y)) -> Sees(x, y))", "all p. (Predator(p) -> Usually(MustSeePreyToCatch(p)))"]}
{"id": "entailmentbank_validation_422", "nl": "hiding means visibility / ability to be seen decreases for camouflage.", "fol": "", "prediction": ["all x. (Hiding(x) -> (Camouflage(x) & Decreases(Visibility(x))))", "all x. (Hiding(x) -> (VisibilityDecreases(x) & AbilityToBeSeenDecreasesForCamouflage(x)))", "all x. (Hiding(x) -> Decreases(Visibility(x), Camouflage))", "all x. (Hiding(x) -> VisibilityDecreasesForCamouflage(x))", "all x. (Hiding(x) -> DecreasesVisibility(x) & Camouflage(x))", "all x. (Hiding(x) -> (Visibility(x) & CanBeSeen(x)) -> DecreasesForCamouflage(x))", "all x. (Hiding(x) -> (Visibility(x) -> DecreasesForCamouflage(x)))", "all x. (Hiding(x) -> Decreases(Visibility(x), Camouflage(x)))", "all x. (Hiding(x) -> (Visibility(x) & AbilityToBeSeen(x) -> DecreasesForCamouflage(x)))", "all x. ((Hiding(x) & Camouflage(x)) -> Decreases(Visibility(x)))", "all x. (Hiding(x) -> (Decreases(Visibility(x)) & ForCamouflage(x)))", "all x. (Hiding(x) -> (Decreases(Visibility(x)) & Decreases(AbilityToBeSeen(x)) & Camouflage(x)))", "all x. (Hiding(x) -> (VisibilityDecreases(x) & CanBeSeenLess(x) & Camouflage(x)))", "all x. (Hiding(x) -> (Visibility(x, Decreases) & AbilityToBeSeen(x, Decreases) & ForCamouflage(x)))", "all x. (Hiding(x) -> (Visibility(x) & AbilityToBeSeen(x) -> DecreasesDueToCamouflage(x)))", "all x. (Hiding(x) -> DecreasesVisibility(x) & DecreasesAbilityToBeSeen(x) & Camouflage(x))"]}
{"id": "entailmentbank_validation_423", "nl": "hiding can be used to avoid being seen by predators.", "fol": "", "prediction": ["FOL Translation:\nall u. (Hiding(u) -> CanBeUsedToAvoidBeingSeenByPredators(u))", "FOL Translation:\nall x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenBy(x, Predators))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "FOL Translation:\nall x. (Hiding(x) -> CanAvoid(x, SeenBy(y, Predator(y))))", "all x y. (Predator(y) & Hide(x) -> AvoidBeingSeen(x, y))", "FOL Translation:\nall x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "FOL Translation:\nall x. (ExistsW(x) & UsedToAvoid(Hiding(x), SeenBy(x, Predators)))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all p. (Predator(p) -> exists x. (UseHidingToAvoidBeingSeen(x, p)))", "all x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x y. (Hiding(x) & Predator(y) -> CanUseToAvoidBeingSeenBy(x, y))", "all x y. (Hiding(x) & Predator(y) -> CanBeUsedToAvoidBeingSeenBy(x, y))", "FOL Translation:\nall x. (Hiding(x) -> CanBeUsedToAvoidBeingSeenByPredators(x))", "all x. (Hiding(x) -> exists y. (Predator(y) & AvoidBeingSeenBy(x, y)))"]}
{"id": "entailmentbank_validation_424", "nl": "not being seen by predators is a kind of protection against predators.", "fol": "", "prediction": ["", "", "all x. (ProtectionAgainstPredators(x) & NotSeenByPredators(x) -> KindOf(ProtectionAgainstPredators(x), x))", "all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "ProtectionAgainstPredators(x) <-> NotSeenByPredators(x)", "all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "Protection(pr, pe) -> -SeenBy(pr, pe)", "all x. (ProtectionAgainstPredators(x) <-> NotSeenByPredators(x))", "all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "ProtectionType(notBeingSeenByPredators, protectionAgainstPredators)", "all x. (ProtectionAgainstPredators(x, NotSeenByPredators(x)))", "all x. (NotSeenByPredators(x) -> ProtectionAgainstPredators(x))", "", "exists x. (KindOf(x, ProtectionAgainstPredators) & NotSeenByPredators(x))", "all x. ((NotSeenByPredators(x) & Predator(x)) -> ProtectionAgainstPredators(x))", "all x. (ProtectionAgainstPredators(x) <-> NotSeenByPredators(x))"]}
{"id": "entailmentbank_validation_425", "nl": "hiding is a kind of protection against predators.", "fol": "", "prediction": ["all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> TypeOfProtection(x, AgainstPredators))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "FOL Translation:\nall x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))", "all x. (Hiding(x) -> ProtectionAgainstPredators(x))"]}
{"id": "entailmentbank_validation_426", "nl": "an animal having the same skin color as its environment is a kind of protection against predators.", "fol": "", "prediction": ["all x. (Animal(x) & Exists y. (SkinColor(x, y) & EnvironmentColor(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & HasSkinColor(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (SkinColor(x) = Color(y) & Environment(y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAsEnvironment(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> ProtectionAgainstPredators(x))", "all x. ((Animal(x) & exists y. (Environment(y) & HasSkinColor(x, z) & HasSkinColor(y, z))) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAsEnvironment(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Color(x) = Color(y) & Environment(y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColor(x, y)) -> ProtectionAgainstPredators(x))", "all x. ((Animal(x) & exists y. (Environment(y) & HasSkinColor(x, SkinColor(y)))) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAsEnvironment(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (SkinColor(x, y) & EnvironmentColor(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (SkinColor(x, y) & EnvironmentColorMatch(x, y)) -> KindOfProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> ProtectionAgainstPredators(x))", "all x. (Animal(x) & exists y. (Environment(y) & SameSkinColorAs(x, y)) -> KindOfProtectionAgainstPredators(x))"]}
{"id": "entailmentbank_validation_427", "nl": "hiding means ability to be seen decreases for camouflage.", "fol": "", "prediction": ["all x. (Hiding(x) -> (AbilityToBeSeen(x) decreases ForCamouflage(x)))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> (AbilityToBeSeen(x) & DecreasesForCamouflage(x)))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreases(x) & ForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreases(x) & Camouflage(x))", "all x. (Hiding(x) -> DecreasesAbilityToBeSeenForCamouflage(x))", "all x. (Hiding(x) -> (AbilityToBeSeenDecreases(x) & ForCamouflage(x)))", "all x. (Hiding(x) -> AbilityToBeSeenDecreases(x) & Camouflage(x))", "all x. (Hiding(x) -> AbilityToBeSeenDecreasesForCamouflage(x))", "Hiding(x) -> (AbilityToBeSeenDecreasesForCamouflage(x))", "all x. (Hiding(x) -> (AbilityToBeSeen(x) Decreases & ForCamouflage(x)))", "all x. (Hiding(x) -> (exists y. (AbilityToBeSeenDecreases(x, y) & Camouflage(y))))", "all x. (Hiding(x) -> AbilityToBeSeenDecreases(x) & Camouflage(x))"]}
{"id": "entailmentbank_validation_428", "nl": "to blend into something means ability to be seen decreases when around that something.", "fol": "", "prediction": ["all x y. (BlendsInto(x, y) -> (AbilityToBeSeenDecreases(x) & IsAround(x, y)))", "all x y. (BlendInto(x, y) -> (AbilityToBeSeenDecreases(x, y) & Around(x, y)))", "all x, y. (BlendInto(x, y) -> (AbilityToBeSeenDecreases(x) & Around(x, y)))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x, y))", "all x y. (BlendInto(x, y) -> AbilityToBeSeenDecreases(x, y))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x) & IsAround(x, y))", "all x y. (BlendsInto(x, y) -> (AbilityToBeSeen(x) > AbilityToBeSeenAround(x, y)))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x, y))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x, y))", "all x y. (BlendsInto(x, y) -> (AbilityToBeSeenDecreases(x, y) & Around(x, y)))", "all x y. (ToBlendInto(x, y) -> (Around(x, y) -> AbilityToBeSeenDecreases(x)))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x, Around(x, y)))", "all x y. (BlendsInto(x, y) -> AbilityToBeSeenDecreasesAround(x, y))", "all x y. (BlendInto(x, y) -> AbilityToBeSeenDecreases(x, y))", "all x y. (BlendInto(x, y) -> AbilityToBeSeenDecreasesWhenAround(x, y))", "all x, y. (BlendsInto(x, y) -> AbilityToBeSeenDecreases(x, y))"]}
{"id": "entailmentbank_validation_429", "nl": "to blend into something means to hide in something.", "fol": "", "prediction": ["all x. all y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendsInto(x, y) <-> HidesIn(x, y))", "all x all y. (MeansToBlendInto(x, y) <-> MeansToHideIn(x, y))", "all x. all y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (ToBlendInto(x, y) <-> ToHideIn(x, y))", "all x. all y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (ToBlendInto(x, y) <-> HideIn(x, y))", "all x. all y. (BlendsInto(x, y) <-> HidesIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))", "all x. all y. (BlendsInto(x, y) <-> HidesIn(x, y))", "all x. all y. (ToBlendInto(x, y) -> ToHideIn(x, y))", "all x all y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))", "all x y. (BlendInto(x, y) <-> HideIn(x, y))"]}
{"id": "entailmentbank_validation_430", "nl": "white fur blends into snow.", "fol": "", "prediction": ["BlendsInto(white_fur, snow)", "all x. (WhiteFur(x) -> BlendsInto(x, snow))", "all x. (WhiteFur(x) & Snow(y) -> BlendsInto(x, y))", "all x. (WhiteFur(x) -> BlendsInto(x, snow))", "FOL Translation:\nall x. (WhiteFur(x) -> BlendsIntoSnow(x))", "all x. (WhiteFur(x) & Snow(s) -> BlendsInto(x, s))", "all x. (WhiteFur(x) -> BlendsInto(x, snow))", "all x. (WhiteFur(x) & Snow(y) -> BlendsInto(x, y))", "all x. (WhiteFur(x) -> BlendsInto(x, snow))", "all x. (WhiteFur(x) & Snow(y) -> BlendsInto(x, y))", "all x. (WhiteFur(x) -> BlendsIntoSnow(x))", "all y. (HasWhiteFur(y) -> BlendsInto(y, snow))", "all x. (WhiteFur(x) & ExistsSnow(y) -> BlendsInto(x, y))", "all x. (HasWhiteFur(x) -> BlendsIntoSnow(x))", "all x. (WhiteFur(x) -> BlendsInto(x, snow))", "all x. (HasWhiteFur(x) & InSnow(x) -> BlendsInto(x, snow))"]}
{"id": "entailmentbank_validation_431", "nl": "an example of hiding is white fur blending in with snow.", "fol": "", "prediction": ["exists x. (ExampleOfHiding(x) & Blends(x, white_fur, snow))", "exists x. (ExampleOfHiding(x) & BlendingInWith(x, WhiteFur, Snow))", "exists x. (HidingExample(x) & Fur(x) & Color(x, white) & BlendsWith(x, snow))", "exists x. (HidingExample(x) & HasProperty(x, white_fur_blending_with_snow))", "exists x. (HidingExample(x) & WhiteFur(\"fur\") & BlendsInWith(\"fur\", \"snow\"))", "exists x. exists y. exists z. (ExampleOf(x, Hiding) & WhiteFur(y) & Snow(z) & BlendsInWith(y, z))", "exists x. (ExampleOfHiding(x) & BlendingIn(WhiteFur, Snow))", "exists x. (ExampleOf(x, Hiding) & BlendingIn(WhiteFur, Snow))", "exists x. (ExampleOfHiding(x) & WhiteFur(x) & BlendsInWith(x, snow))", "exists x y. (ExampleOfHiding(x) & WhiteFur(y) & BlendsInWith(y, snow) & PartOfExample(y, x))", "exists x. (ExampleOfHiding(x) & WhiteFurBlendingInWithSnow(x))", "exists x. (ExampleOfHiding(x) & Exists y. (WhiteFur(y) & BlendsInWith(y, snow) & x = y))", "exists x. (ExampleOfHiding(x) & WhiteFur(x) & BlendsInWith(x, snow))", "exists x y z. (Example(x) & Hiding(x) & WhiteFur(y) & BlendsInWith(y, Snow(z)))", "exists x exists y exists z. (ExampleOf(x, Hiding) & Fur(x) & White(x) & FurBlendsInWith(y, z) & Snow(z))", "exists x y z. (ExampleOf(z, Hiding) & Fur(x) & White(x) & Snow(y) & BlendingInWith(x, y) & ExampleOf(z, BlendingInWith(x, y)))"]}
{"id": "entailmentbank_validation_432", "nl": "an example of camouflage is white fur blending in with snow.", "fol": "", "prediction": ["exists x y z. (Example(x) & Camouflage(x) & WhiteFur(y) & Snow(z) & BlendsIn(y, z))", "CamouflageExample(white_fur_blending_in_with_snow)", "exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsInWith(x, snow))", "Exists x. (ExampleOfCamouflage(x) & WhiteFurBlendsWithSnow(x))", "exists x. (ExampleOfCamouflage(x) & BlendingWhiteFurWithSnow(x))", "Exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsInWith(x, snow))", "exists x. (ExampleOfCamouflage(x) & BlendsIn(x, snow) & WhiteFur(x))", "exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsWith(x, snow))", "ExampleOfCamouflage(white_fur_blending_in_with_snow)", "Exists x. (ExampleOfCamouflage(x) & BlendsIn(white_fur, snow, x))", "Exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsIn(x, snow))", "Exists e. (ExampleOfCamouflage(e) & WhiteFurBlendsWithSnow(e))", "exists x. (ExampleOfCamouflage(x) & Camouflage(x, white_fur, snow, BlendingIn(white_fur, snow)))", "exists x. (CamouflageExample(x) & ExampleOf(x, WhiteFurBlendingInWithSnow))", "exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsInWith(x, snow))", "Exists x. (ExampleOfCamouflage(x) & WhiteFur(x) & BlendsInWith(x, snow))"]}
{"id": "entailmentbank_validation_433", "nl": "some leaves have a speckled brown color.", "fol": "", "prediction": ["exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & HasSpeckledBrownColor(x))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & HasSpeckledBrownColor(x))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & HasColor(x, speckled_brown))", "exists x. (Leaf(x) & SpeckledBrownColor(x))", "exists x. (Leaf(x) & HasSpeckledBrownColor(x))"]}
{"id": "entailmentbank_validation_434", "nl": "some birds have a speckled brown color.", "fol": "", "prediction": ["exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & HasColor(x, speckled_brown))", "exists x. (Bird(x) & HasSpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & HasSpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & HasSpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrown(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))", "exists x. (Bird(x) & HasColor(x, speckled_brown))", "exists x. (Bird(x) & HasSpeckledBrownColor(x))", "exists x. (Bird(x) & SpeckledBrownColor(x))"]}
{"id": "entailmentbank_validation_435", "nl": "some birds look like leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & LooksLikeLeaves(x))", "FOL Translation:\nexists x. (Bird(x) & LooksLikeLeaf(x))", "exists x. (Bird(x) & LooksLike(x, leaves))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLike(x, leaves))", "exists x. (Bird(x) & LooksLikeLeaf(x))", "exists x. (Bird(x) & LooksLikeLeaf(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaves(x))", "exists x. (Bird(x) & LooksLikeLeaf(x))"]}
{"id": "entailmentbank_validation_436", "nl": "something that looks like another thing is difficult to distinguish from that thing.", "fol": "", "prediction": ["exists x exists y. ((LooksLike(x, y)) -> DifficultToDistinguishFrom(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguishFrom(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguishFrom(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguishFrom(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x exists y. ((LooksLike(x, y) & Thing(x) & Thing(y)) -> DifficultToDistinguishFrom(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x, y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x, y. (LooksLike(x, y) -> DifficultToDistinguishFrom(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x, y. (LooksLike(x, y) -> DifficultToDistinguish(x, y))", "exists x. exists y. (LooksLike(x, y) -> DifficultToDistinguishFrom(x, y))"]}
{"id": "entailmentbank_validation_437", "nl": "some birds are difficult to distinguish from leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "FOL Translation:\nexists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguish(x, y)))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguish(x, y)))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguishFrom(x, y)))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToDistinguish(x, y)))", "exists x. (Bird(x) & DifficultToDistinguishFromLeaves(x))"]}
{"id": "entailmentbank_validation_438", "nl": "difficult to distinguish can mean difficult to see in something else.", "fol": "", "prediction": ["exists x exists y. (DifficultToDistinguish(x) & DifficultToSeeIn(y, x))", "exists x, y. (DifficultToDistinguish(x) & Means(x, y) & DifficultToSee(y))", "exists x, y. (DifficultToDistinguish(x) & Means(DifficultToSeeIn(x, y), y))", "all x. (DifficultToDistinguish(x) -> exists y. (Mean(x, y) & DifficultToSeeIn(y)))", "Translate the following sentence into first-order logic:\n\nLet `Distinguish(x, y)` denote that \"x is distinguished from y\" and `Difficult(x)` denote that \"x is difficult\", and `Mean(x, y)` denote that \"x means y\", `SeeIn(x, y)` denote that \"x is seen in y\".\n\nAssuming `x` refers to \"difficult to distinguish\" and `y` refers to \"difficult to see in something else\", the FOL translation would be:\n\nMean(Difficult(Distinguish(x, y)), Difficult(SeeIn(x, y)))", "all x. (DifficultToDistinguish(x) -> exists y. (DifficultToSeeIn(x, y)))", "exists x exists y. (DifficultToDistinguish(x, y) -> DifficultToSeeIn(x, y))", "exists x, y. (DifficultToDistinguish(x) & DifficultToSee(x, y) & Mean(x, y))", "all x. (DifficultToDistinguish(x) -> exists y. (DifficultToSeeIn(x, y)))", "exists x. exists y. ((DifficultToDistinguish(x, y) -> DifficultToSeeIn(x, y)))", "FOL Translation:\nall x. (DifficultToDistinguish(x) -> exists y. (DifficultToSeeIn(x, y)))", "exists x y. (DifficultToDistinguish(x) & DifficultToSeeIn(y, x))", "exists x, y. (DifficultToDistinguish(x) & Mean(DifficultToSee(y), In(x, y)))", "exists x, y. (Distinguish(x) & Difficult(x) & Mean(DifficultToSee(x), In(y)))", "exists x, y. (DistinguishDifficult(x) & Mean(DistinguishDifficult(x), DifficultToSeeIn(y)))", "exists x exists y. (DifficultToDistinguish(x) & CanMean(x, y) & DifficultToSeeIn(y))"]}
{"id": "entailmentbank_validation_439", "nl": "some birds are difficult to see in leaves.", "fol": "", "prediction": ["exists x. (Bird(x) & IsDifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & exists y. (Leaf(y) & DifficultToSeeIn(x, y)))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))", "exists x. (Bird(x) & DifficultToSeeInLeaves(x))"]}
{"id": "entailmentbank_validation_440", "nl": "an example of camouflage is a bird looking like leaves.", "fol": "", "prediction": ["exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))", "exists x. (CamouflageExample(x) & Bird(x) & LooksLike(x, leaves))", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))", "exists x y. (ExampleOfCamouflage(x) & Bird(y) & LooksLike(y, leaves) & x = y)", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))", "exists x. exists y. (CamouflageExample(x) & Bird(x) & LooksLike(x, y) & Leaves(y))", "exists x. (ExampleOfCamouflage(x) & Bird(y) & LooksLike(y, leaves))", "exists x. (CamouflageExample(x) & Bird(x) & LooksLikeLeaves(x))", "exists x. (CamouflageExample(x) & Bird(x) & LooksLikeLeaves(x))", "exists x y. (CamouflageExample(x) & Bird(y) & LooksLike(y, leaves) & ExampleOf(x, LooksLike(y, leaves)))", "exists x. (CamouflageExample(x) & Bird(x) & LooksLike(x, leaves))", "exists x y. (CamouflageExample(x) & Bird(y) & LooksLike(y, leaves) & ExampleOfCamouflage(y, x))", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLikeLeaves(x))", "exists x. (CamouflageExample(x) & Bird(x) & LooksLikeLeaves(x))", "exists x. (CamouflageExample(x) & BirdLikeLeaves(x))", "exists x. (ExampleOfCamouflage(x) & Bird(x) & LooksLike(x, leaves))"]}
{"id": "entailmentbank_validation_441", "nl": "camouflage is used for hiding by animals from predators.", "fol": "", "prediction": ["all x. (Animal(x) & Predator(y) -> UsesForHiding(camouflage, x, y))", "all x. all y. if (Animal(x) & Predator(y) & UsesForHidingFrom(x, camouflage, y))", "all x. (Animal(x) -> exists y. (Predator(y) & UsesCamouflageForHiding(x, y)))", "all a. all p. all c. (Animal(a) & Predator(p) & Camouflage(c) & UsedForHidingBy(c, a, p) -> ProtectsFrom(a, p))", "exists x. (Animal(x) & exists y. (Predator(y) & UsesForHiding(camo, x, y)))", "all x. all y. all z. ((Animal(x) & Predator(y) & UsedForHidingBy(x, z) & Camouflage(z)) -> HideFrom(x, y))", "all x. (Animal(x) -> exists y. (Predator(y) & UsesForHiding(camouflage, x, y)))", "exists x. (Animal(x) & exists y. (Predator(y) & UsesFor(x, camouflage, HidingFrom(y))))", "all x. all y. all z. ((Animal(x) & Predator(y) & UsesFor(x, z, Hiding) & Camouflage(z)) -> HidesFrom(x, y))", "exists x. (Camouflage(x) & UsedFor(x, Hiding) & exists y. (Animal(y) & Uses(y, x) & exists z. (Predator(z) & HidesFrom(y, z))))", "all a. (Animal(a) -> exists c. (Camouflage(c) & UsesForHiding(a, c) & from(a, Predators)))", "all x. (Animal(x) & exists y. (Predator(y) & UsesForHiding(x, camouflage, y)))", "all a. (Animal(a) -> exists c, p. (Camouflage(c) & Predator(p) & UsedForHidingBy(c, a, p)))", "exists x. (Camouflage(x) & exists y. (Animal(y) & exists z. (Predator(z) & UsedForHidingBy(x, y, z))))", "all x. (Animal(x) -> exists y. (Predator(y) & UsesForHiding(x, camouflage, y)))", "all a. (Animal(a) -> exists p. (Predator(p) & UsesCamouflageToHideFrom(a, p)))"]}
{"id": "entailmentbank_validation_442", "nl": "looking like leaves can be used by birds for hiding from predators.", "fol": "", "prediction": ["all x. (LooksLikeLeaves(x) -> CanBeUsedByBirdsForHidingFromPredators(x))", "all x. (Bird(x) & LookLikeLeaves(x) -> CanUseForHidingFromPredators(x))", "all x. (Bird(x) & LooksLikeLeaves(x) -> CanUseForHiding(x))", "exists x. (LooksLikeLeaves(x) & CanBeUsedByBirdsForHiding(x) & FromPredators(x))", "all x. (LooksLikeLeaves(x) -> CanBeUsedBy(x, birds, ForHidingFrom(predators)))", "all x. ((LooksLikeLeaves(x) & Bird(x)) -> CanBeUsedForHidingFromPredators(x))", "all x. (Bird(x) & LookLikeLeaves(x) -> CanUseForHidingFromPredators(x))", "exists y. (all x. (Bird(x) & Predator(y, x)) -> CanHideUsingLeaves(x))", "exists x. (LooksLikeLeaf(x) & usableByBirds(x, HidingFromPredators))", "all x. (LookingLikeLeaves(x) & BirdUsesForHidingFromPredators(x))", "exists x. (LooksLikeLeaves(x) & canBeUsedByBirds(x, HidingFromPredators))", "all x. (LookingLikeLeaves(x) -> exists y. (Bird(y) & CanUseForHidingFromPredators(y, x)))", "all x. (LeafLikeAppearance(x) & Bird(y) & HidingFromPredators(y) -> CanUseFor(x, y))", "all x. (LooksLikeLeaf(x) -> exists y. (Bird(y) & UsesForHidingFromPredators(y, x)))", "all x. (LooksLikeLeaves(x) & BirdUsesForHiding(x) -> HidingFromPredators(x))", "exists x. (LooksLikeLeaves(x) & CanBeUsedBy(x, y) & Bird(y) & ForHidingFrom(x, z) & Predator(z))"]}
{"id": "entailmentbank_validation_443", "nl": "hiding can be used to avoid something.", "fol": "", "prediction": ["all x. (Hiding(x) -> exists y. (Avoid(x, y)))", "all x y. (Hiding(x) & Avoids(y, x) -> CanBeUsedToAvoid(x, y))", "all x. (Hiding(x) -> exists y. (Avoids(x, y)))", "all x. (Hiding(x) -> exists y. (Avoids(x, y)))", "all x. (Hiding(x) -> CanBeUsedToAvoid(x, y))", "all x. (Hiding(x) -> exists y. (Avoid(x, y)))", "exists x exists y. (Hiding(x) & Avoid(y) & UsedTo(x, y))", "exists x. exists y. (Hiding(x) & UsedForAvoiding(x, y))", "exists x. exists y. (Hiding(x) & Avoid(y) & UsedFor(x, y))", "exists x y. (Hiding(x) & UsedToAvoid(x, y))", "all x. (Hiding(x) -> exists y. (Avoids(x, y)))", "exists x. exists y. (Hiding(x) & Avoids(y, x))", "exists x exists y. (Hiding(x) & Avoid(y) & CanBeUsedFor(x, y))", "all x. (Hiding(x) -> exists y. (Avoids(x, y)))", "all x. (Hiding(x) -> exists y. (Avoid(y) & UsedFor(x, y)))", "exists x exists y. (Hiding(x) & Something(y) & CanBeUsedToAvoid(x, y))"]}
{"id": "entailmentbank_validation_444", "nl": "looking like leaves can be used by birds for avoiding predators.", "fol": "", "prediction": ["exists x. (LooksLikeLeaves(x) & CanBeUsedByBirdsForAvoidingPredators(x))", "exists x. (LooksLikeLeaves(x) & UsedBy(birds, x, AvoidingPredators))", "FOL Translation:\nall x. (Bird(x) & Uses(x, looks_like_leaves, AvoidPredators))", "all x. (LooksLikeLeaves(x) -> exists y. (Bird(y) & CanUseForAvoidingPredators(y, x)))", "exists x. (LookingLikeLeaves(x) & UsedBy(x, birds, AvoidingPredators(birds)))", "exists x. (LookingLikeLeaves(x) & UsedBy(x, Birds, AvoidingPredators))", "exists x. (LooksLikeLeaf(x) & usedBy(x, birds) & ForAvoidingPredators(x, birds))", "exists x. exists y. (LooksLikeLeaves(x) & Bird(y) & UsedForAvoidingPredators(x, y))", "exists x. (Bird(x) & UsesToAvoidPredators(x, LooksLikeLeaves))", "exists x. (LooksLikeLeaves(x) & CanBeUsedByBirds(x, AvoidPredators))", "exists x. (LooksLikeLeaves(x) & CanBeUsedBy(x, birds) & ForAvoidingPredators(x))", "all x. (Bird(x) & LooksLikeLeaves(x) -> CanUseToAvoidPredators(x))", "exists x. (LooksLikeLeaves(x) & CanBeUsedBy(birds, x, AvoidingPredators))", "exists x. (Bird(x) & UseForAvoidingPredators(x, LooksLikeLeaves))", "exists x. (Bird(x) & CanUseLookingLikeLeaves(x) & ForAvoidingPredators(x))", "exists x. (LookingLikeLeaves(x) & exists y. (Bird(y) & UsedForAvoidingPredatorsBy(y, x)))"]}
{"id": "entailmentbank_validation_445", "nl": "keeping warm is the opposite of becoming cold.", "fol": "", "prediction": ["Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepsWarm, BecomesCold)", "Opposite(KeepingWarm, BecomingCold)", "all x. (KeepingWarm(x) <-> -BecomingCold(x))", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)", "Opposite(KeepingWarm, BecomingCold)"]}
{"id": "entailmentbank_validation_446", "nl": "if a living thing becomes too cold then that living thing will die.", "fol": "", "prediction": ["", "all x. ((LivingThing(x) & BecomesTooCold(x)) -> Dies(x))", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]}
{"id": "entailmentbank_validation_447", "nl": "an animal usually requires warmth for survival.", "fol": "", "prediction": ["Translate the word \u201cusually.\u201d In the context of first-order logic, this could be interpreted as \u201cmost,\u201d \u201coften,\u201d or \u201ctypically.\u201d Since FOL does not naturally handle probabilistic concepts, we must acknowledge that such a translation may not be perfect. However, I can provide a structural transformation focusing on an equivalent statement:\n\n```FOL\nall x. (Animal(x) -> RequiresWarmthForSurvival(x))\n```\n\nThis generalizes the statement in a way compatible for FOL, assuming typicality as universal within the logic framework.", "all a. (Animal(a) -> RequiresWarmthForSurvival(a))", "all x. (Animal(x) -> RequiresWarmthForSurvivalUsually(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "exists x. (Animal(x) & RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> UsuallyRequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresForSurvival(x, warmth))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "all x. (Animal(x) -> RequiresWarmthForSurvival(x))", "FOL Translation:\nall x. (Animal(x) -> RequiresWarmthForSurvival(x))"]}
{"id": "entailmentbank_validation_448", "nl": "if the environmental temperature is too cold then an animal in that environment may become cold.", "fol": "", "prediction": ["all e. all a. ((Environment(e) & Animal(a) & TooCold(Temperature(e))) -> MayBecomeCold(a, e))", "all e. (EnvironmentalTemperature(e) & TooCold(e) -> exists a. (AnimalInEnvironment(a, e) & MayBecomeCold(a)))", "all e. all a. ((Environment(e) & Animal(a) & In(a, e) & TooCold(e)) -> MayBecomeCold(a))", "all x y. ((EnvironmentalTemperature(x) & TooCold(x) & Animal(y) & InEnvironment(y, x)) -> MayBecomeCold(y))", "all e. all a. ((Environment(e) & Animal(a) & InEnvironment(a, e) & TooCold(e)) -> MayBecomeCold(a))", "exists env. (Temperature(env) & TooCold(env) -> exists x. (AnimalInEnvironment(x, env) -> MayBecomeCold(x)))", "all x y. ((EnvironmentalTemperatureTooCold(x) & AnimalInEnvironment(y, x)) -> MayBecomeCold(y))", "all e. (EnvironmentalTemperature(e) & TooCold(e) -> exists a. (AnimalInEnvironment(a, e) & MayBecomeCold(a)))", "all x. ((EnvironmentalTemperatureTooCold(x)) -> exists y. (AnimalInEnvironment(y, x) & MayBecomeCold(y)))", "all x y. ((Environment(x) & Animal(y) & In(x, y) & TooColdTemperature(x)) -> MayBecomeCold(y))", "all e. (Environment(e) & Temperature(e, cold) -> exists a. (Animal(a) & InEnvironment(a, e) & MayBecomeCold(a)))", "all x. all y. ((Environment(y) & Temperature(y, cold) & In(animal(x), y)) -> MayBecomeCold(x))", "all x. (Animal(x) -> (TooCold(Environment(x)) -> MayBecomeCold(x)))", "all e. (Environment(e) & TemperatureTooCold(e) -> exists a. (Animal(a) & InEnvironment(a, e) & MayBecomeCold(a)))", "all e. (EnvironmentalTemperatureTooCold(e) -> exists a. (AnimalInEnvironment(a, e) & MayBecomeCold(a)))", "all e. (Environment(e) & TooCold(e) -> exists a. (Animal(a) & InEnvironment(a, e) & MayBecomeCold(a)))"]}
{"id": "entailmentbank_validation_449", "nl": "an animal requires warmth in cold temperatures.", "fol": "", "prediction": ["all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all z. (Animal(z) & ColdTemperature() -> RequiresWarmth(z))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature(y) -> RequiresWarmth(x, y))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "FOL Translation:\nall x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) -> all t. (ColdTemperature(t) -> RequiresWarmth(x, t)))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperature -> RequiresWarmth(x))", "all x. (Animal(x) & ColdTemperatures(x) -> RequiresWarmth(x))"]}
{"id": "entailmentbank_validation_450", "nl": "thick fur can be used for keeping warm.", "fol": "", "prediction": ["all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "exists x. (ThickFur(x) & CanBeUsedFor(x, KeepingWarm))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "exists x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedToKeepWarm(x))", "exists x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "exists x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "FOL Translation:\nall x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "all x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))", "exists x. (ThickFur(x) & UsedFor(x, KeepingWarm))", "exists x. (ThickFur(x) -> CanBeUsedForKeepingWarm(x))"]}
{"id": "entailmentbank_validation_451", "nl": "thick fur can be used by animals for survival in cold temperatures.", "fol": "", "prediction": ["all x. (Animal(x) & HasThickFur(x) & ColdTemperature(y) -> CanUseForSurvival(x, y))", "FOL Translation:\nall x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalInCold(x))", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalInCold(x))", "all x. (Animal(x) & HasThickFur(x) -> UsedForSurvivalInCold(x))", "", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalInCold(x))", "all x. (Animal(x) & HasThickFur(x) & ColdTemperature(y) -> CanUseForSurvival(x, y))", "all x. (Animal(x) & HasThickFur(x) & ColdTemperature -> CanUseForSurvival(x, ThickFur))", "all x. (Animal(x) & UsesForSurvival(x, ThickFur, ColdTemperatures))", "all x. (Animal(x) & HasThickFur(x) -> CanBeUsedForSurvivalInCold(x))", "all x. ((Animal(x) & HasThickFur(x)) -> CanUseForSurvivalInColdTemperatures(x))", "all x. ((Animal(x) & HasThickFur(x)) -> UsedForSurvivalInCold(x))", "FOL Translation:\nall x. (Animal(x) & HasThickFur(x) & ColdTemperatures(t) -> UsedForSurvivalIn(t, x))", "all x. ((Animal(x) & HasThickFur(x)) -> CanUseForSurvivalInCold(x))", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalInCold(x))", "all x. (Animal(x) & UsesForSurvival(x, thick_fur, cold_temperatures))"]}
{"id": "entailmentbank_validation_452", "nl": "winter has cold temperatures.", "fol": "", "prediction": ["Winter(winter) -> HasColdTemperatures(winter)", "ColdTemperature(winter)", "Winter(w) & HasColdTemperatures(w)", "ColdTemperatures(winter)", "HasColdTemperatures(winter)", "Winter(w) & ColdTemperatures(t) & Has(w, t)", "ColdTemperatures(winter)", "HasColdTemperatures(winter)", "ColdTemperature(winter)", "Cold(temperatures, winter)", "HasColdTemperatures(winter)", "Cold(winter)", "HasColdTemperatures(winter)", "ColdTemperature(winter)", "Cold(temperature, winter)", "ColdTemperatures(winter)"]}
{"id": "entailmentbank_validation_453", "nl": "thick fur can be used by animals for survival survival during winter.", "fol": "", "prediction": ["all x. (Animal(x) & HasThickFur(x) & Winter(y) -> CanUseForSurvival(x, y))", "all x. (Animal(x) & HasThickFur(x) -> UsedForSurvivalDuringWinter(x, ThickFur))", "FOL Translation:\nall x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "all x. ((Animal(x) & UsesForSurvivalDuringWinter(x, thick_fur)) -> CanSurviveWinter(x))", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "FOL Translation:\nall x. (Animal(x) & HasThickFur(x) -> CanBeUsedForSurvivalDuringWinter(x))", "", "exists x. (Animal(x) & UsesForSurvival(x, thick_fur) & During(winter))", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "exists x. (Animal(x) & HasThickFur(x) & UsedForSurvivalDuringWinter(ThickFur(x), x))", "all x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "all x. (Animal(x) & CanUseForSurvivalDuringWinter(x, thick_fur))", "all x. (Animal(x) & ThickFur(x) & Winter(y) -> CanUseForSurvival(x, y))", "exists x. (Animal(x) & HasThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "exists x. (Animal(x) & HasThickFur(x) & CanUseThickFurForSurvivalDuringWinter(x))", "exists x. (Animal(x) & ThickFur(x) -> UsedFor(x, SurvivalDuringWinter))"]}
{"id": "entailmentbank_validation_454", "nl": "a bear is a kind of animal.", "fol": "", "prediction": ["Bear(b) -> Animal(b)", "Bear(b) -> Animal(b)", "Animal(bear)", "Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Bear(b) -> Animal(b)", "Bear(b) -> Animal(b)", "Bear(x) -> Animal(x)", "Bear(b) -> Animal(b)", "Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Bear(x) -> Animal(x)", "Bear(b) -> Animal(b)", "Animal(bear)", "Bear(x) -> Animal(x)"]}
{"id": "entailmentbank_validation_455", "nl": "thick fur can be used by bears for survival during winter.", "fol": "", "prediction": ["exists x. (Bear(x) & ThickFur(x) & UsedForSurvivalDuringWinter(x))", "exists x. (ThickFur(x) & all y. (Bear(y) & UsesForSurvival(y, x, winter)))", "exists x. (Bear(x) & ThickFurCanBeUsedForSurvival(x, winter))", "all x. ((Bear(x) & HasThickFur(x)) -> UsedForSurvivalDuringWinter(x))", "FOL Translation:\nall x. (Bear(x) & HasThickFur(x) -> UsedForSurvivalDuringWinter(x))", "all x. (Bear(x) & HasThickFur(x) -> UsedForSurvivalDuringWinter(x))", "exists x. (ThickFur(x) & UsedBy(x, bears) & SurvivalDuringWinter(x))", "exists x. (Bear(x) & ThickFurCanBeUsedForSurvivalDuringWinter(x))", "Exists x. (Bear(x) & HasThickFur(x) & UsedForSurvivalDuringWinter(x))", "Translate the sentence into FOL:\n\nFOL Translation:\nall x. (Bear(x) & ThickFur(x) -> UsedForSurvivalDuringWinter(x))", "all x. (Bear(x) & ThickFur(y) -> CanBeUsedForSurvivalDuringWinter(y, x))", "all x. (Bear(x) & HasThickFur(x) -> CanUseForWinterSurvival(x))", "exists x. (Bear(x) & ThickFur(x) & CanBeUsedForSurvivalDuringWinter(x))", "FOL Translation:\nall x. (Bear(x) & HasThickFur(x) -> UsedForSurvivalInWinter(x))", "all x. (Bear(x) & ThickFur(x) -> CanUseForSurvivalDuringWinter(x))", "exists x. (Bear(x) & ThickFur(x) -> UsedForSurvivalDuringWinter(x))"]}
{"id": "entailmentbank_validation_456", "nl": "hunting is a kind of method for obtaining food.", "fol": "", "prediction": ["all x. (HuntingMethod(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> KindOfMethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (HuntingIsMethod(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "all x. (Hunting(x) -> MethodForObtainingFood(x))", "KindOf(hunting, MethodForObtainingFood)"]}
{"id": "entailmentbank_validation_457", "nl": "animals require food for survival.", "fol": "", "prediction": ["all x. (Animal(x) -> requires(x, food, survival))", "all x. (Animal(x) -> exists y. (Food(y) & Requires(x, y) & ForSurvival(x)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "FOL Translation:\nall x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all z. (Animal(z) -> RequiresFoodForSurvival(z))", "FOL Translation:\nall x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> requires(x, food, survival))", "all x. (Animal(x) -> requiresForSurvival(x, food))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> exists y. (Food(y) & RequiresForSurvival(x, y)))", "all x. (Animal(x) -> requires(x, food, survival))"]}
{"id": "entailmentbank_validation_458", "nl": "some animals must hunt to survive.", "fol": "", "prediction": ["exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))", "exists x. (Animal(x) & MustHuntToSurvive(x))"]}
{"id": "entailmentbank_validation_459", "nl": "hunting requires sensing prey.", "fol": "", "prediction": ["all x. (Hunting(x) -> exists y. (Prey(y) & Sensing(x, y)))", "all x. (Hunting(x) -> Requires(x, SensingPrey))", "all x. (Hunting(x) -> exists y. (Prey(y) & Sensing(x, y)))", "all x. (Hunting(x) -> exists y. (Sensing(x, y) & Prey(y)))", "all x. (Hunting(x) -> exists y. (Sensing(x, y) & Prey(y)))", "all x. (Hunting(x) -> exists y. (Prey(y) & Senses(x, y)))", "all x. (Hunting(x) -> exists y. (Prey(y) & RequiresSensing(x, y)))", "all x. (Hunting(x) -> exists y. (Prey(y) & Sensing(x, y)))", "all x. (Hunting(x) -> exists y. (Sensing(x, y) & Prey(y)))", "all x. (Hunting(x) -> RequiresSensingPrey(x))", "all x. (Hunting(x) -> Requires(x, SensingPrey))", "all x. (Hunting(x) -> exists y. (Prey(y) & Sensing(x, y)))", "all x. (Hunting(x) -> Requires(x, y) & Sensing(y) & Prey(y))", "all x. (Hunting(x) -> exists y. (Prey(y) & RequiresSensing(x, y)))", "all x. (Hunting(x) -> exists y. (SensesPrey(x, y)))", "all x. (Hunting(x) -> Requires(x, SensingPrey))"]}
{"id": "entailmentbank_validation_460", "nl": "better senses have a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. ((Animal(x) & BetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. (BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. (BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & BetterSenses(x)) -> PositiveImpactOnSurvival(x))", "FOL Translation:\nall x. (Animal(x) & HasBetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & BetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & HasBetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & HasBetterSenses(x)) -> PositiveImpactOnSurvival(x))", "all x. (BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterSenses(x) -> PositiveImpact(Survival(x)))", "all x. (Animal(x) & BetterSenses(x) -> PositiveImpactOnSurvival(x))", "all a. (Animal(a) & BetterSenses(a) -> PositiveImpactOnSurvival(a))", "all x. (Animal(x) & HasBetterSenses(x) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_461", "nl": "hearing is used for sensing sound by animals.", "fol": "", "prediction": ["all x. (Animal(x) -> Uses(x, Hearing, SensingSound))", "all x. (Animal(x) -> UsesForSensing(x, hearing, sound))", "all x. (Animal(x) -> UsesForSensingSound(x, Hearing))", "all x. (Animal(x) -> SensesSound(x, Hearing))", "all x. (Animal(x) -> exists y. (Sound(y) & UsesForSensing(x, hearing, y)))", "all x. (Animal(x) -> (exists y. (Sound(y) & UsesForHearing(x, y))))", "all x. (Animal(x) -> UsesFor(Hearing, SoundSensing(x)))", "all x. (Animal(x) -> UsesForSensingSound(x, Hearing))", "FOL Translation:\nall x. (Animal(x) -> SensesSoundWith(x, Hearing))", "all x. (Animal(x) -> UsesForSensing(x, hearing, sound))", "all x. (Animal(x) -> UsesFor(Hearing(x), SensingSound(x)))", "all x. (Animal(x) -> (exists y. (Hearing(y) & SensingSound(x, y))))", "all a. (Animal(a) -> exists s. (Sound(s) & HearingUsedForSensing(a, s)))", "all x. (Animal(x) -> UsesForSensingSound(x, Hearing))", "all x. (Animal(x) -> UsesForSensing(x, Hearing, Sound))", "all x. (Animal(x) -> UsedFor(Hearing, SensingSound, x))"]}
{"id": "entailmentbank_validation_462", "nl": "better hearing has a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & HasBetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & BetterHearing(x)) -> PositiveImpactOnSurvival(x))", "all a. (Animal(a) & HasBetterHearing(a) -> PositiveImpactOnSurvival(a))", "all x. (Animal(x) & BetterHearing(x) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_463", "nl": "senses are passed down from parent to offspring.", "fol": "", "prediction": ["all p, o. ((Parent(p) & Offspring(o, p)) -> (exists s. (Sense(s) & PassedDown(s, p, o))))", "all x. (Parent(x) -> exists y. (Offspring(y, x) & PassDownSenses(x, y)))", "all x all y all z. ((Parent(x, y) & Offspring(y, z)) -> PassesDownSenses(x, y, z))", "all x. (all y. (Parent(x, y) -> PassesDownSenses(x, y)))", "all s. (Sense(s) -> all p. (Parent(p) -> exists o. (Offspring(o, p) & PassedDown(s, p, o))))", "all x. ((Parent(y, z) & Offspring(z, x) & HasSenses(x)) -> HasSenses(z))", "all x. (Parent(x) -> all y. (Offspring(y, x) -> PassesDownSenses(x, y)))", "all x. all y. ((Parent(x, y) & Senses(x)) -> Senses(y))", "all x. all y. all z. ((Parent(x, y) & Offspring(y, z)) -> PassesDownSenses(x, z))", "all x. (Parent(x) -> all y. (Offspring(y, x) -> PassesDownSenses(x, y)))", "all s, p, o. (Parent(p, o) -> PassesDown(s, p, o))", "all x. all y. all z. ((Parent(x, y) & Offspring(y, z)) -> PassesDownSenses(x, z))", "all x. all y. all z. ((Parent(x, y) & Offspring(z, y) & Senses(x)) -> PassedDown(y, z))", "FOL Translation:\nall x. all y. all z. (Sense(x) & Parent(y, z) & PassesDown(y, x, z) -> Has(z, x))", "all x. ((Parent(x) & HasOffspring(x, y)) -> PassedDown(senses, x, y))", "all x y z. ((Parent(x, y) & Offspring(y, z)) -> PassesDownSenses(y, z))"]}
{"id": "entailmentbank_validation_464", "nl": "inheriting is when an inherited characteristic is passed from parent to offspring by genetics / dna.", "fol": "", "prediction": ["all x. (Inheriting(x) <-> exists y exists p exists o. (InheritedCharacteristic(y) & PassedFromToBy(y, p, o, GeneticsOrDNA)))", "all x. (InheritedCharacteristic(x) -> all y. (all z. (Parent(y, z) & Offspring(z, y) & PassedByGeneticsOrDNA(x, y, z) <-> Inherited(x, y, z))))", "all c, p, o. (InheritedCharacteristic(c) & InheritsByGeneticsOrDNA(c, p, o) & Parent(p) & Offspring(o) -> Inheriting(c, p, o))", "all x y. ((InheritedCharacteristic(x) & Parent(y) & Offspring(z) & PassedByGeneticsOrDNA(x, y, z)) -> Inheriting(x, y, z))", "all x. (Inheritance(x) <-> (exists y, z. (InheritedCharacteristic(y) & Parent(z) & Offspring(w) & PassedByGeneticsOrDNA(y, z, w))))", "all c. (InheritedCharacteristic(c) -> exists p, o. (Parent(p) & Offspring(o) & PassedByGenetics(c, p, o)))", "all x, y. ((InheritedCharacteristic(x) & Parent(y) & Offspring(z) & PassedByGeneticsOrDNA(x, y, z)) <-> Inheriting(x, y, z))", "all x. (Inheriting(x) <-> exists y exists z (Characteristic(y) & Parent(z) & Offspring(x) & PassedFromTo(y, z, x) & ByGenetics(y)))", "all c. ((InheritedCharacteristic(c) & PassedFromParentToOffspringByGenetics(c)) <-> Inheriting(c))", "all x. (Inheriting(x) <-> (exists y, z. (InheritedCharacteristic(y) & Parent(z) & Offspring(x) & PassedByGenetics(y, z, x))))", "all x. (InheritedCharacteristic(x) -> exists y exists z (Parent(y) & Offspring(z) & PassedByGeneticsOrDNA(y, z, x)))", "all c. (InheritedCharacteristic(c) -> exists x, y. (Parent(x) & Offspring(y) & PassesByGeneticsOrDNA(c, x, y)))", "all c. (InheritedCharacteristic(c) -> all p, o. (Parent(p) & Offspring(o) & Inherits(c, o, p) <-> PassedByGeneticsOrDNA(p, c, o)))", "all x. (Inheriting(x) <-> (exists y, z. (InheritedCharacteristic(y) & Parent(z) & Offspring(x) & PassesByGeneticsOrDNA(y, z, x))))", "all c. (InheritableCharacteristic(c) -> exists p, o. (Parent(p) & Offspring(o) & PassedByGenetics(p, o, c)))", "all c. ((InheritedCharacteristic(c) & PassedFromParentToOffspringByGenetics(c)) <-> Inheriting(c))"]}
{"id": "entailmentbank_validation_465", "nl": "senses are an inherited characteristic.", "fol": "", "prediction": ["all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))", "all x. (Sense(x) -> InheritedCharacteristic(x))"]}
{"id": "entailmentbank_validation_466", "nl": "hearing is an inherited characteristic.", "fol": "", "prediction": ["all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "InheritedCharacteristic(hearing)", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (HearingInheritedCharacteristic(x) -> HearingInheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "all x. (Hearing(x) -> InheritedCharacteristic(x))", "InheritedCharacteristic(hearing)", "InheritedCharacteristic(hearing)", "all x. (Hearing(x) -> InheritedCharacteristic(x))"]}
{"id": "entailmentbank_validation_467", "nl": "better hearing is an inherited characteristic that has a positive impact on an animal's survival.", "fol": "", "prediction": ["all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpactOnSurvival(x))", "all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpactOnSurvival(x))", "all a. (Animal(a) & BetterHearing(a) -> (InheritedCharacteristic(BetterHearing(a)) & PositiveImpactOnSurvival(a)))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpact(x, survival))", "all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpactOnSurvival(BetterHearing(x), x))", "all x. (Animal(x) & InheritedCharacteristic(BetterHearing(x)) -> PositiveImpact(OnSurvival(x)))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all x. ((Animal(x) & HasInheritedCharacteristic(x, better_hearing)) -> HasPositiveImpactOnSurvival(better_hearing, x))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all a. (Animal(a) & InheritedCharacteristic(better_hearing, a) -> PositiveImpactOnSurvival(better_hearing, a))", "all x. ((InheritsBetterHearing(x) & Animal(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & InheritedCharacteristic(x, better_hearing)) -> PositiveImpactOnSurvival(x, better_hearing))", "all x. ((Animal(x) & InheritedCharacteristic(x, hearing) & BetterHearing(x)) -> PositiveImpactOnSurvival(x))", "all x. ((Animal(x) & InheritedCharacteristic(x, BetterHearing)) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_468", "nl": "as the ability of a living thing to survive / to reproduce increases, the likelihood of passing on its traits to its decendents will increase.", "fol": "", "prediction": ["all x. (LivingThing(x) & AbilityToSurviveReproduceIncreases(x) -> LikelihoodOfPassingOnTraitsIncreases(x))", "all x. (LivingThing(x) & AbilityToSurviveIncrease(x) & AbilityToReproduceIncrease(x) -> LikelihoodPassTraitsToDescendentsIncrease(x))", "all x. (LivingThing(x) & CanSurviveBetter(x) & CanReproduceBetter(x) -> IncreasesLikelihoodOfPassingTraits(x))", "all x. ((LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x)) -> LikelihoodPassTraitsToDescendantsIncreases(x))", "all x. ((LivingThing(x) & IncreasesAbilityToSurviveOrReproduce(x)) -> IncreasesLikelihoodOfPassingOnTraits(x))", "all x. (LivingThing(x) & AbilityToSurviveOrReproduceIncrease(x) -> LikelihoodToPassOnTraitsIncrease(x))", "all x. (LivingThing(x) -> (Increases(AbilityToSurviveOrReproduce(x)) -> Increases(LikelihoodOfPassingOnTraits(x))))", "all x. (LivingThing(x) & AbilityToSurviveReproduceIncreases(x) -> LikelihoodOfPassingOnTraitsIncreases(x))", "all x. all y. ((LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x, y)) -> LikelihoodToPassTraitsToDescendantsIncreases(x, y))", "all x. all y. ((LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x) & TraitsOf(y, x)) -> LikelihoodIncreases(PassOnTraitsToDescendants(x, y)))", "``` \nall x. all y. (LivingThing(x) & Trait(y) & AbilityToSurviveOrReproduceIncreases(x, y) -> LikelihoodOfPassingTraitsToDescendantsIncreases(x, y))\n```", "all x. (LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x) -> LikelihoodPassingTraitsToDescendantsIncreases(x))", "all x, y. ((LivingThing(x) & AbilityToSurviveAndReproduce(x, y) -> Increases(y)) -> LikelihoodOfPassingTraits(x, DescendantsOf(x)) -> Increases(z))", "all x. (LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x) -> LikelihoodPassingTraitsToDescendantsIncreases(x))", "all x. all y. ((LivingThing(x) & AbilityToSurviveOrReproduceIncreases(x)) -> (TraitsLikelihoodIncrease(x, y) & PassTraitsToDescendants(x, y)))", "all x. (LivingThing(x) & IncreasesAbilityToSurviveOrReproduce(x) -> IncreasesLikelihoodOfPassingTraitsToDescendants(x))"]}
{"id": "entailmentbank_validation_469", "nl": "animals with traits that positively impact their survival have a greater ability to survive / reproduce.", "fol": "", "prediction": ["all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> GreaterAbilityTo(SurviveOrReproduce, x))", "all x. (Animal(x) & exists y. (Trait(y) & ImpactsSurvivalPositively(y, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. ((Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x))) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x)) -> GreaterAbilitySurviveReproduce(x))", "all x. ((Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x))) -> GreaterAbilityToSurviveReproduce(x))", "all x. ((Animal(x) & exists y. (Trait(y) & PositiveImpactOnSurvival(y, x))) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. ((Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x))) -> GreaterAbilityTo(SurviveOrReproduce(x)))", "all x. (Animal(x) & TraitPositivelyImpactsSurvival(x) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists y. (Trait(y) & ImpactsSurvivalPositively(x, y)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y) & HasTrait(x, y)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. (Animal(x) & exists t. (Trait(t) & ImpactsSurvivalPositively(t) & HasTrait(x, t)) -> GreaterAbilityToSurviveOrReproduce(x))", "all x. ((Animal(x) & exists y. (Trait(y) & PositivelyImpactsSurvival(y, x))) -> GreaterAbilityToSurviveAndReproduce(x))"]}
{"id": "entailmentbank_validation_470", "nl": "the decendants of an animal with traits that positively impacted their survival will also have traits that positivley impact their survival.", "fol": "", "prediction": ["all x. ((Animal(x) & HasTraits(x) & TraitsImpactSurvival(x) > 0) -> all y. (Descendant(y, x) -> HasTraits(y) & TraitsImpactSurvival(y) > 0))", "all x. (Animal(x) & PositiveTraitImpactsSurvival(x) -> all y. (Descendant(y, x) -> PositiveTraitImpactsSurvival(y)))", "all x. (Animal(x) & TraitsPositivelyImpactSurvival(x) -> all y. (Descendant(y, x) -> TraitsPositivelyImpactSurvival(y)))", "all x. (Animal(x) & exists t. (Trait(t) & PositivelyImpactsSurvival(t, x)) -> all y. (Descendant(y, x) -> exists u. (Trait(u) & PositivelyImpactsSurvival(u, y))))", "all x. (Animal(x) & exists y. (Descendant(y, x) & TraitsPositivelyImpactSurvival(x)) -> TraitsPositivelyImpactSurvival(y))", "all x. (Animal(x) & HasTraitsPositiveForSurvival(x) -> all y. (Descendant(y, x) -> HasTraitsPositiveForSurvival(y)))", "all x. (Animal(x) & HasTraitPosImpactSurvival(x) -> all y. (Descendant(y, x) -> HasTraitPosImpactSurvival(y)))", "all x. (Animal(x) & HasTraitsPositiveImpactSurvival(x) -> all y. (Descendant(y, x) -> HasTraitsPositiveImpactSurvival(y)))", "all x. (exists y. (Animal(y) & Descendant(x, y) & Trait(z) & PositivelyImpactsSurvival(z, y)) -> Trait(w) & PositivelyImpactsSurvival(w, x))", "all x. all y. ((Descendant(y, x) & Animal(x) & HasTraitImpactingSurvival(x)) -> HasTraitImpactingSurvival(y))", "all x. (Animal(x) & HasTraitsPosImpactingSurvival(x) -> all y. (Descendant(y, x) -> HasTraitsPosImpactingSurvival(y)))", "all x. (Animal(x) & HasTraitsPositivelyImpactingSurvival(x) -> all y. (Descendant(y, x) -> HasTraitsPositivelyImpactingSurvival(y)))", "all x. ((Animal(x) & PositiveTrait(x)) -> all y. (Descendant(y, x) -> PositiveTrait(y)))", "all x. (Animal(x) & HasTraitThatImpactsSurvivalPositively(x) -> all y. (Descendant(y, x) -> HasTraitThatImpactsSurvivalPositively(y)))", "all x. ((Animal(x) & HasTraitsThatImpactSurvivalPositively(x)) -> all y. (Descendant(y, x) -> HasTraitsThatImpactSurvivalPositively(y)))", "all x. (Animal(x) & HasTraitsThatImpactSurvivalPositively(x) -> all y. (Descendant(y, x) -> HasTraitsThatImpactSurvivalPositively(y)))"]}
{"id": "entailmentbank_validation_471", "nl": "the decendants of an animal with better hearing will also have better hearing.", "fol": "", "prediction": ["all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Descendant(x) & AnimalWithBetterHearing(x) -> HasBetterHearing(x))", "all x. (Animal(x) & HasBetterHearing(x) -> all y. (Descendant(y, x) -> HasBetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x, y. (Descendant(y, x) & HasBetterHearing(x) -> HasBetterHearing(y))", "all x. (exists y. (Animal(y) & BetterHearing(y) & Descendant(x, y)) -> BetterHearing(x))", "all x. (Animal(x) & BetterHearing(x) -> all y. (DescendantOf(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & HasBetterHearing(x) -> all y. (Descendant(y, x) -> HasBetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & HasBetterHearing(x) -> all y. (Descendant(y, x) -> HasBetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))", "all x. (Animal(x) & BetterHearing(x) -> all y. (Descendant(y, x) -> BetterHearing(y)))"]}
{"id": "entailmentbank_validation_472", "nl": "mosquitos can sense carbon dioxide in the air.", "fol": "", "prediction": ["all x. (Mosquito(x) -> CanSenseCarbonDioxideInAir(x))", "all x. (Mosquito(x) -> CanSenseCO2InAir(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxideInAir(x))", "all x. (Mosquito(x) -> CanSenseCO2(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxideInAir(x))", "all x. (Mosquito(x) -> CanSenseCO2InAir(x))", "all x. (Mosquito(x) -> CanSenseCO2(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxide(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxide(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxideInAir(x))", "all x. (Mosquito(x) -> CanSenseCO2(x))", "all x. (Mosquito(x) -> CanSenseCarbonDioxideInAir(x))", "all x. (Mosquito(x) -> CanSenseCO2(x))", "all x. (Mosquito(x) -> CanSense(x, carbon_dioxide_in_air))", "all x. (Mosquito(x) -> CanSenseCO2InAir(x))", "all x. (Mosquito(x) -> CanSenseCO2InAir(x))"]}
{"id": "entailmentbank_validation_473", "nl": "animals are a source of carbon dioxide by exhaling.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2(x) & Exhales(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOf(x, carbon_dioxide) & ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2(x) & Exhales(x))", "all x. (Animal(x) -> SourceOfCarbonDioxide(x, Exhaling))", "", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "FOL Translation:\nall x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))", "all x. (Animal(x) -> SourceOfCO2ByExhaling(x))"]}
{"id": "entailmentbank_validation_474", "nl": "mosquitos sense animals by sensing their carbon dioxide emissions.", "fol": "", "prediction": ["all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2Emissions(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> Senses(x, y, CarbonDioxideEmissions(y))))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCarbonDioxide(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCarbonDioxideEmissions(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & Senses(x, y) & SensesByCarbonDioxide(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2Emissions(x, y)))", "FOL Translation:\nall x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & SensesByCarbonDioxideEmissions(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) & EmitsCarbonDioxide(y) -> SensesByEmissions(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) & EmitsCarbonDioxide(y) -> SensesByCO2(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) & SensesCO2Emissions(y) -> Senses(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> SensesByCO2(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) & SensesByCarbonDioxideEmissions(x, y)))", "all x. (Mosquito(x) -> all y. (Animal(y) -> CanSenseByCO2Emissions(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & SensesByCarbonDioxideEmissions(x, y)))"]}
{"id": "entailmentbank_validation_475", "nl": "living things eat their food source.", "fol": "", "prediction": ["all x. (LivingThing(x) -> exists y. (FoodSourceOf(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSourceOf(x, y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(x, y) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y, x) & Eats(x, y)))", "all x. (LivingThing(x) -> exists y. (FoodSource(y) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_476", "nl": "mosquitos eat blood of animals.", "fol": "", "prediction": ["all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))", "all x. (Mosquito(x) -> exists y. (Animal(y) & EatsBloodOf(x, y)))"]}
{"id": "entailmentbank_validation_477", "nl": "animals are a source of food for mosquitos.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfFoodFor(mosquitos, x))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodForMosquito(x))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> FoodSourceFor(mosquitos, x))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquitos))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquitos))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))", "all x. (Animal(x) -> SourceOfFoodFor(x, mosquito))"]}
{"id": "entailmentbank_validation_478", "nl": "sensing food has a positive impact on finding food.", "fol": "", "prediction": ["all x. (SensingFood(x) -> PositiveImpact(x, FindingFood))", "all x. (SensingFood(x) -> PositiveImpact(x, FindingFood))", "all x. (SensingFood(x) -> PositiveImpact(x, FindingFood))", "FOL Translation:\nall x. (SensingFood(x) -> PositiveImpactOn(FindingFood(x)))", "all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOn(SensingFood(x), FindingFood(x)))", "exists x. (SensingFood(x) & PositiveImpact(x, FindingFood))", "all x. (SensingFood(x) -> PositiveImpact(x, FindingFood))", "FOL Translation:\nall x. (SensesFood(x) -> PositiveImpactOn(FindingFood(x)))", "all x. (SensingFood(x) -> HasPositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOnFindingFood(x))", "all x. (SensingFood(x) -> PositiveImpactOn(FindingFood(x)))", "all x. (SensingFood(x) -> PositiveImpactOn(FindingFood(x)))", "all x. (SensingFood(x) -> PositiveImpact(x, FindingFood))", "all x y. (SensingFood(x, y) -> HasPositiveImpact(SensingFood(x, y), FindingFood(x)))"]}
{"id": "entailmentbank_validation_479", "nl": "sensing animals has a positive impact on a mosquito's ability to find food.", "fol": "", "prediction": ["all x. (SensingAnimals(x) -> PositiveImpactOnFeedingAbility(x, mosquito))", "all x. (SensingAnimals(x) -> PositiveImpact(x, MosquitoFindsFood))", "exists x. (Animal(x) & PositiveImpact(Sensing(x), AbilityToFindFood(mosquito)))", "exists x. (Animal(x) & Sensing(x, mosquito) & PositiveImpact(Sensing(x, mosquito), CanFindFood(mosquito)))", "all x. (Sensing(x, animals) -> PositiveImpact(x, AbilityToFindFood(mosquito)))", "exists x. (SensingAnimals(x) & Mosquito(x) -> PositiveImpactOnFindingFood(x))", "all x. (Mosquito(x) & SensingAnimalsPositiveImpact(x) -> AbilityToFindFood(x))", "exists x. (Animal(x) & Sensing(x) -> PositiveImpact(Mosquito, FindFood(Mosquito)))", "FOL Translation:\nall x. (SensingAnimal(x) & Mosquito(x) -> PositiveImpactOnFindingFood(x))", "all x. (Sensing(x, animal) -> PositiveImpact(x, MosquitoAbilityFindFood))", "all x. (SensingAnimals(x) -> hasPositiveImpactOn(x, MosquitoFindingFood))", "exists x. (SensingAnimals(x) & PositiveImpactOnMosquitoFindFood(x))", "all x. ((Animal(x) & Senses(x, mosquito)) -> PositiveImpact(OnAbilityToFindFood(mosquito)))", "all x. (Animal(x) & SensedBy(mosquito, x) -> PositiveImpactOnFindingFood(mosquito))", "all x. (Animal(x) -> PositiveImpact(Sensing(x), AbilityToFindFood(mosquito)))", "exists x. (Animal(x) & HasPositiveImpactOn(MosquitoAbilityFindFood, x))"]}
{"id": "entailmentbank_validation_480", "nl": "sensing carbon dioxide has a positive impact on a mosquito's ability to find food.", "fol": "", "prediction": ["exists x. (Mosquito(x) & SensingCarbonDioxide(x) -> PositiveImpactOnFindingFood(x))", "exists x. (SensingCO2(x) & PositiveImpact(x, FindFoodAbility(mosquito)))", "all x. (SensingCarbonDioxide(x) -> PositiveImpact(FindingFood(x), Mosquito(x)))", "exists x. (Mosquito(x) & CanSenseCO2(x) -> CanFindFoodBetter(x))", "exists m. exists c. exists f. (Mosquito(m) & CarbonDioxide(c) & Food(f) & Sensing(m, c) & HasPositiveImpactOn(Sensing(m, c), FindFood(m, f)))", "exists x y. (Mosquito(x) & CarbonDioxide(y) & Sensing(x, y) -> PositiveImpactOnFoodFindingAbility(x))", "exists x. (Mosquito(x) & SensingCarbonDioxide(x) -> PositiveImpactOnFindingFood(x))", "exists x, y. (Mosquito(x) & CarbonDioxide(y) & Sensing(x, y) -> PositiveImpactOnFindingFood(x))", "exists x. (Mosquito(x) & exists y. (CarbonDioxide(y) & PositiveImpactOnAbilityToFindFood(x, y)))", "exists x exists y. (CarbonDioxide(x) & Mosquito(y) & Senses(y, x) -> PositiveImpactOn(y, AbilityToFindFood(y)))", "exists x. (Mosquito(x) & SensingCarbonDioxide(x) -> PositiveImpactOnAbilityToFindFood(x))", "all x. (Mosquito(x) & SensingCO2(x) -> PositiveImpact(x, AbilityToFindFood(x)))", "exists x. (Mosquito(x) & SensingCarbonDioxide(x) -> PositiveImpactOnFindingFood(x))", "all x. (Mosquito(x) & SensesCarbonDioxide(x) -> PositiveImpactOnFindingFood(x))", "exists x y. (Mosquito(x) & CarbonDioxide(y) & Sensing(x, y) -> PositiveImpactOnFindingFood(x))", "all x. (Mosquito(x) & SensesCarbonDioxide(x) -> PositiveImpact(OnAbilityToFindFood(x)))"]}
{"id": "entailmentbank_validation_481", "nl": "if a living thing requires something then that something has a positive impact on that living thing.", "fol": "", "prediction": ["all x y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x y. (LivingThing(x) & Requires(x, y) -> HasPositiveImpact(y, x))", "all x y. (LivingThing(x) & Requires(x, y) -> PositiveImpactOn(y, x))", "all x y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x, y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x, y. (LivingThing(x) & Requires(x, y) -> PositiveImpact(y, x))", "all x y. (LivingThing(x) & Requires(x, y) -> PositiveImpactOn(y, x))", "all x y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x y. (LivingThing(x) & Requires(x, y) -> PositiveImpact(y, x))", "all x. all y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x all y. (LivingThing(x) & Requires(x, y) -> PositiveImpact(y, x))", "all x. all y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x. all y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x. all y. ((LivingThing(x) & Requires(x, y)) -> PositiveImpact(y, x))", "all x all y. (LivingThing(x) & Requires(x, y) -> PositiveImpact(y, x))"]}
{"id": "entailmentbank_validation_482", "nl": "a living things require water for survival.", "fol": "", "prediction": ["all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))", "all x. (LivingThing(x) -> RequiresWaterForSurvival(x))"]}
{"id": "entailmentbank_validation_483", "nl": "water has a positive impact on a living thing's survival.", "fol": "", "prediction": ["all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> PositiveImpactOnSurvival(water, x))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> PositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & HasPositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. ((LivingThing(x) & Water(y)) -> PositiveImpactOnSurvival(y, x))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> PositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> PositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> PositiveImpact(water, Survival(x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "exists x. (Water(x) & all y. (LivingThing(y) -> PositiveImpactOnSurvival(x, y)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))", "all x. (LivingThing(x) -> exists y. (Water(y) & PositiveImpactOnSurvival(y, x)))"]}
{"id": "entailmentbank_validation_484", "nl": "increasing the availability of something that has a positive impact on a living thing's survivial can have a positive impact on that living thing's survival.", "fol": "", "prediction": ["all x. all y. (PositiveImpactOnSurvival(x, y) & IncreasedAvailability(x) -> PositiveImpactOnSurvival(x, y))", "all x y. ((HasPositiveImpactOnSurvival(y) & Available(y) & Affectslivingthing(y, x)) -> HasPositiveImpactOnSurvival(livingthing(x)))", "all x all y. ((PositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> PositiveImpactOnSurvival(y, x))", "all x. all y. ((PositiveImpact(y, x) & IncreasedAvailability(y)) -> PositiveImpact(IncreasedAvailability(y), x))", "all x y. ((PositiveImpactOnSurvival(x, y) & IncreasesAvailability(x)) -> PositiveImpactOnSurvival(x, y))", "all x y. (IncreasesAvailabilityOf(x) & PositiveImpactOn(x, y) & LivingThing(y) -> PositiveImpactOnSurvivalOf(y))", "all x. all y. ((LivingThing(x) & HasPositiveImpactOnSurvival(y) & IncreasingAvailability(y)) -> HasPositiveImpactOnSurvival(x))", "all x, y. ((PositiveImpactOnSurvival(x, y) & IncreasesAvailability(x)) -> PositiveImpactOnSurvival(x, y))", "all x y. ((PositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> PositiveImpactOnSurvival(y, x))", "all x. all y. ((HasPositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> HasPositiveImpactOnSurvival(y, x))", "all x. all y. ((HasPositiveImpactOnSurvival(y, x) & IncreasesAvailability(y)) -> PositiveImpactOnSurvival(y, x))", "all x, y. ((PositiveImpact(y) & IncreasesAvailability(y, x) & PositiveImpactOnSurvival(y, x)) -> PositiveImpactOnSurvival(y, x))", "exists x. (PositiveImpactOnSurvival(x) & all y. (LivingThing(y) & HasPositiveImpactOnSurvival(x, y) -> all z. (IncreaseAvailability(x, z) -> PositiveImpactOnSurvival(y))))", "all x y. ((PositiveImpactOn(x, y) & IncreasesAvailability(x)) -> PositiveImpactOnSurvival(y))", "all x. all y. ((PositiveImpactOnSurvival(x) & AvailabilityIncreases(x, y) & LivingThing(y)) -> PositiveImpactOnSurvival(y))", "all x, y. ((PositiveImpactOnSurvival(y, x) & IncreasingAvailability(y)) -> PositiveImpactOnSurvival(y, x))"]}
{"id": "entailmentbank_validation_485", "nl": "increasing the availability of water for a living thing has a positive impact on that living thing's survival.", "fol": "", "prediction": ["all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all z. (LivingThing(z) & IncreasesAvailabilityOfWater(z) -> PositiveImpactOnSurvival(z))", "all x. (LivingThing(x) -> (IncreaseWaterAvailability(x) -> PositiveImpactOnSurvival(x)))", "all x. (LivingThing(x) -> (IncreasedWaterAvailability(x) -> PositiveImpactOnSurvival(x)))", "all x. (LivingThing(x) -> (IncreasedWaterAvailability(x) -> PositiveImpactOnSurvival(x)))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreaseAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))", "all x. ((LivingThing(x) & IncreasedAvailabilityOfWater(x)) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & WaterAvailabilityIncrease(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) -> (IncreaseWaterAvailability(x) -> PositiveImpactOnSurvival(x)))", "all x. (LivingThing(x) & IncreasesWaterAvailability(x) -> PositiveImpactOnSurvival(x))", "all x. (LivingThing(x) & IncreasesAvailabilityOfWater(x) -> PositiveImpactOnSurvival(x))"]}
{"id": "entailmentbank_validation_486", "nl": "storing something is a kind of method for increasing the availability of something.", "fol": "", "prediction": ["all x. all y. (Storing(x, y) -> MethodForIncreasingAvailability(x, y))", "all x. (Storing(x) -> MethodForIncreasingAvailability(x))", "all x. (MethodForIncreasedAvailability(x) <-> Storing(x))", "all x. (Storing(x) -> MethodForIncreasingAvailability(x))", "all x. all y. (Storing(x) & Method(x, y)) -> IncreasesAvailability(x, y)", "all x, y. (Storing(x, y) -> (MethodForIncreasingAvailability(x, y)))", "all x. (Storing(x) -> MethodForIncreasingAvailability(x))", "all x, y. (Storing(x) -> MethodForIncreasingAvailabilityOf(x, y))", "all x y. (Storing(x, y) -> MethodForIncreasingAvailability(x, y))", "all x. (Stored(x) -> exists y. (MethodForIncreasingAvailability(x, y)))", "all x. (Storing(x) -> exists y. (MethodForIncreasingAvailabilityOf(x, y)))", "all x. all y. (Storing(x, y) -> MethodForIncreasingAvailability(x, y))", "all x. (Storing(x) -> exists y. (Method(x, y) & IncreasesAvailability(x, y)))", "all x. (Storing(x) -> exists y. (MethodForIncreasingAvailability(x, y)))", "all x. (Store(x) -> exists y. (MethodForIncreasingAvailability(x, y) & Thing(y)))", "all x. (all y. (Stores(x, y) -> MethodForIncreasingAvailability(x, y)))"]}
{"id": "entailmentbank_validation_487", "nl": "storing water has a positive impact on a living thing's survival by increasing the availability of water.", "fol": "", "prediction": ["exists x. (LivingThing(x) -> exists y. (StoringWater(y) & PositiveImpact(y, Survival(x)) & IncreasesAvailabilityOfWater(y)))", "all x. (LivingThing(x) -> (StoringWater(x) -> PositiveImpactOnSurvival(x, IncreasingWaterAvailability(x))))", "exists x. (Storage(x) & Water(x) & all y. (LivingThing(y) -> PositiveImpact(Storage(x), Survival(y)) & IncreasesAvailability(Storage(x), Water(x))))", "exists x exists y. (StoresWater(x) & LivingThing(y) -> IncreasesWaterAvailability(x, y) & PositiveImpactOnSurvival(IncreasesWaterAvailability(x, y), y))", "exists x y. (StoreWater(x) & LivingThing(y) & PositiveImpact(x, y) & Increases(AvailabilityOfWater, y) & Affects(Survival(y), x))", "exists x exists y (LivingThing(x) & StoreWater(y, x) -> PositiveImpactOnSurvival(y, x) & IncreasesAvailabilityOfWater(y))", "exists x y. (LivingThing(x) & Stores(y, water) & IncreasesAvailability(y, water) -> PositiveImpactOnSurvival(x, y))", "exists x. (LivingThing(x) & StoringWaterIncreasesSurvival(x))", "exists x. (LivingThing(x) -> (StoresWaterBy(x, PositiveImpactOn(Survival(x), AvailabilityOfWater(x)))))", "exists x, y. (StoringWater(x) & LivingThing(y) -> PositiveImpactOnSurvival(x, y) & IncreasesAvailabilityOfWater(x))", "exists x, y. (LivingThing(x) & Water(y) & Storing(y) & IncreasesAvailability(y, x) -> PositiveImpactOnSurvival(y, x))", "FOL Translation:\nall x. (LivingThing(x) -> (StoringWater(x) -> PositiveImpactOnSurvival(x) & IncreasesWaterAvailability(x)))", "exists x exists y. (StoresWater(x) & LivingThing(y) -> PositiveImpactOnSurvival(x, y) & IncreasesAvailabilityOfWater(x, y))", "exists x. (WaterStorage(x) & all y. (LivingThing(y) -> PositiveImpact(x, Survival(y)) & IncreasesAvailability(x, Water(y))))", "all x. (LivingThing(x) & StoringWater(y) -> PositiveImpact(Survival(x), Increases(AvailabilityOfWater(y))))", "exists x. (LivingThing(x) & all y. (StoresWater(y) & IncreasesAvailabilityOfWater(y) -> PositiveImpactOnSurvival(x, y)))"]}
{"id": "entailmentbank_validation_488", "nl": "dry means low in amount of water.", "fol": "", "prediction": ["all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInWaterAmount(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all z. (Dry(z) -> LowInWater(z))", "all x. (Dry(x) <-> LowWaterAmount(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInAmountOfWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInAmountOfWater(x))", "all x. (Dry(x) <-> LowInWater(x))", "all x. (Dry(x) <-> LowInWater(x))", "all x. (Dry(x) -> LowInAmountOfWater(x))"]}
{"id": "entailmentbank_validation_489", "nl": "as dryness increases in an environment, the available water in that environment will decrease.", "fol": "", "prediction": ["all e. ((Increases(Dryness, e)) -> Decreases(AvailableWater, e))", "all e. (Increases(Dryness(e)) -> Decreases(AvailableWater(e)))", "all e. ((Increases(Dryness, e)) -> Decreases(AvailableWater, e))", "all e. (IncreasesDryness(e) -> DecreasesAvailableWater(e))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))", "all e. ((Environment(e) & Increases(Dryness(e))) -> Decreases(AvailableWater(e)))", "all e. (IncreaseDryness(e) -> DecreaseAvailableWater(e))", "all e. (Increases(Dryness(e)) -> Decreases(AvailableWater(e)))", "all e. (Increases(Dryness(e)) -> Decreases(AvailableWater(e)))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))", "all e. (Environment(e) & Increases(Dryness(e)) -> Decreases(AvailableWater(e)))", "all e. (IncreasesDryness(e) -> DecreasesAvailableWater(e))", "all e. (Increases(Dryness(e)) -> Decreases(AvailableWater(e)))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))", "all e. (Increases(Dryness, e) -> Decreases(AvailableWater, e))"]}
{"id": "entailmentbank_validation_490", "nl": "a dry environment is low in availability of water.", "fol": "", "prediction": ["all x. (DryEnvironment(x) -> LowWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowInWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowInWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all x. (DryEnvironment(x) -> LowAvailabilityOfWater(x))", "all e. (DryEnvironment(e) -> LowAvailabilityOfWater(e))", "all x. (DryEnvironment(x) -> LowInWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowWaterAvailability(x))", "all x. (DryEnvironment(x) -> LowWaterAvailability(x))"]}
{"id": "entailmentbank_validation_491", "nl": "storing water increases the water available to organisms in a dry environment.", "fol": "", "prediction": ["exists x. (StoresWater(x) & IncreasesWaterAvailable(x, organisms, dry_environment))", "all e. (DryEnvironment(e) -> (exists s. (StoringWater(s, e) & IncreasesWaterAvailableToOrganisms(s, e))))", "exists x. (DryEnvironment(x) -> (Increases(StoringWater, WaterAvailableToOrganismsIn(x))))", "all x. (DryEnvironment(x) -> (StoringWater(x) -> IncreasesWaterAvailable(x)))", "all e. (DryEnvironment(e) -> exists w, o. (StoresWater(w, e) & Organism(o, e) & IncreasesWaterAvailable(w, o, e)))", "all x. (DryEnvironment(x) -> (StoreWater(x) -> IncreasesWaterAvailableToOrganisms(x)))", "FOL Translation:\nall x. (DryEnvironment(x) -> (StoresWater(x) -> IncreasesWaterAvailableToOrganisms(x)))", "exists x, y, z. (StoringWater(x) & Organism(z) & DryEnvironment(y) & IncreasesWaterAvailableTo(x, z, y))", "FOL Translation:\nall x. (StoringWater(x) -> IncreasesWaterAvailableToOrganismsInDryEnvironment(x))", "exists x, y, z. (StoringWater(x) & WaterAvailable(x, y) & Organism(y) & DryEnvironment(z) -> IncreasesWaterAvailable(x, y, z))", "all x. (DryEnvironment(x) -> (StoreWater(x, w) -> IncreasesWaterAvailableToOrganisms(x)))", "all x. (DryEnvironment(x) -> exists y. (Organism(y) & StoringWater(x) -> IncreasesWaterAvailableTo(y, x)))", "all x. (DryEnvironment(x) -> (exists y. (StoringWater(y) & IncreasesWaterAvailableTo(y, Organisms, x))))", "FOL Translation:\nall x. (DryEnvironment(x) -> (StoringWater(x) -> IncreasesWaterAvailableToOrganisms(x)))", "exists x. (StoresWater(x) & DryEnvironment(y) -> IncreasesWaterAvailableToOrganisms(x, y))", "exists x. (StoringWater(x) & Increases(x, WaterAvailableToOrganismsInDryEnvironment))"]}
{"id": "entailmentbank_validation_492", "nl": "adapting is when a living thing responds to a change in an environment.", "fol": "", "prediction": ["all x. (LivingThing(x) & ChangeInEnvironment(y) & RespondsTo(x, y) <-> Adapting(x, y))", "all x. ((LivingThing(x) & exists e. (Environment(e) & Change(e))) -> Adapts(x))", "exists x, y, z. (LivingThing(x) & Change(y) & Environment(z) & AdaptingOccurs(x, y, z) <-> RespondsToChangeInEnvironment(x, y, z))", "all x. (LivingThing(x) -> (exists y. (ChangeInEnvironment(y) & RespondsTo(x, y)) <-> Adapting(x)))", "all x y z. (LivingThing(x) & Change(y, z) & Environment(z) & RespondsTo(x, y) <-> Adapting(x, y, z))", "all x. (LivingThing(x) & ResponseToChangeInEnvironment(x) -> Adapting(x))", "all x. (LivingThing(x) & RespondsTo(x, Change(Environment)) -> Adapts(x, Change(Environment)))", "all x. (LivingThing(x) & ResponseToChange(x, Environment) -> Adapting(x))", "all x. ((LivingThing(x) & exists y. (ChangeInEnvironment(y) & RespondsTo(x, y))) -> Adapting(x))", "all x. (LivingThing(x) & ChangeInEnvironment(y) & RespondsTo(x, y) <-> Adapts(x))", "all x. (LivingThing(x) & RespondsToChangeInEnvironment(x) <-> Adapting(x))", "all x. (LivingThing(x) & RespondsToChangeInEnvironment(x) <-> Adapting(x))", "all x. (LivingThing(x) & exists y. (Change(y) & Environment(y) & RespondsTo(x, y)) -> Adapting(x))", "all x. (LivingThing(x) & exists e. (Environment(e) & ChangeIn(e)) & RespondsTo(x, e) -> Adapting(x))", "all x. (LivingThing(x) & RespondsToChangeInEnvironment(x) <-> Adapting(x))", "all x. (LivingThing(x) & RespondsToChange(x, EnvironmentChange) -> Adapting(x))"]}
{"id": "entailmentbank_validation_493", "nl": "storing water is an adaptation to a dry environment.", "fol": "", "prediction": ["AdaptationToDryEnvironment(storing_water)", "AdaptationToDryEnvironment(storing_water)", "Adaptation(StoringWater, DryEnvironment)", "exists x. (StoringWater(x) & Adaptation(x, DryEnvironment))", "exists x. (StoringWater(x) & AdaptationTo(x, DryEnvironment))", "Adaptation(StoringWater, DryEnvironment)", "AdaptationTo(storing_water, dry_environment)", "AdaptationToDryEnvironment(storing_water)", "AdaptationTo(storing_water, dry_environment)", "AdaptationToDryEnvironment(storing_water)", "all x. (Adaptation(x, DryEnvironment) -> StoringWater(x))", "Adaptation(x, DryEnvironment) & StoringWater(x)", "Adaptation(StoringWater, DryEnvironment)", "AdaptationFor(storing_water, dry_environment)", "exists x. (StoringWater(x) & AdaptationTo(x, DryEnvironment))", "Adaptation(StoringWater, DryEnvironment)"]}
{"id": "entailmentbank_validation_494", "nl": "as the available water in an environment increases, the populations of organisms in that environment will increase.", "fol": "", "prediction": ["all e. ((Environment(e) & Increases(AvailableWater(e))) -> all o. (Organism(o) & In(e, o) -> Increases(Population(o))))", "all e. (AvailableWaterIncreases(e) -> PopulationsIncrease(e))", "all e. (all w1, w2. (WaterInEnvironment(e, w1) & WaterInEnvironment(e, w2) & w1 < w2) -> exists x1, x2. (PopulationInEnvironment(e, x1) & PopulationInEnvironment(e, x2) & x1 < x2))", "all e. all t1. all t2. ((InEnvironment(e) & WaterAvailable(e, t1) < WaterAvailable(e, t2)) -> exists x. (Organism(x) & InEnvironment(x, e) & Population(x, t1) < Population(x, t2)))", "all e. (Environment(e) & AvailableWaterIncreases(e) -> exists p. (PopulationsIncreaseInEnvironment(p, e)))", "all e. (all x. (IncreaseAvailableWater(e) -> (Organism(x) & InhabitEnvironment(x, e) -> IncreasePopulation(x))))", "all e. (all t1, t2. ((AvailableWater(e, t1) < AvailableWater(e, t2)) -> (PopulationIncrease(e, t1) < PopulationIncrease(e, t2))))", "all e. (all w. (AvailableWater(e, w) -> exists o. (Organism(o) & Environment(e) & IncreasesPopulation(o, e, w))))", "all e. all x. (Organism(x) & Environment(e) & LivesIn(x, e) -> Increases(AvailableWater(e)) -> Increases(PopulationOf(x, e)))", "all e. (all w. (AvailableWaterIncreases(e, w) -> all o. (Organism(o) & InEnvironment(o, e) -> PopulationIncreases(o, e))))", "all e, w1, w2. (Environment(e) & AvailableWater(e, w1) & AvailableWater(e, w2) & Increases(w1, w2) -> all p1, p2. (Populations(e, p1) & Populations(e, p2) & Increases(p1, p2)))", "all e. all w1. all w2. ((Environment(e) & AvailableWater(e, w1) & AvailableWater(e, w2) & w1 < w2) -> (exists p1. exists p2. (Population(e, p1) & Population(e, p2) & p1 < p2)))", "all e, w, t. ((Environment(e) & AvailableWater(e, w, t) & Increases(w)) -> exists p. (Population(e, p, t) & Increases(p)))", "all e. (Increases(AvailableWater(e)) -> Increases(Population(e)))", "all e. (Increase(AvailableWater(e)) -> Increase(PopulationsOfOrganisms(e)))", "all e. ((Environment(e) & exists w. (Water(w) & Increases(w, e))) -> all o. (Organism(o) & LocatedIn(o, e) -> Increases(Population(o), e)))"]}
{"id": "entailmentbank_validation_495", "nl": "an aquatic animal requires great amounts of water to thrive.", "fol": "", "prediction": ["all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))", "all x. (AquaticAnimal(x) -> Requires(x, Water) & GreatAmount(Water) & ToThrive(x))", "all x. (AquaticAnimal(x) -> RequiresGreatAmountsOfWaterToThrive(x))"]}
{"id": "entailmentbank_validation_496", "nl": "as water increases in an environment, the population of aquatic animals will increase.", "fol": "", "prediction": ["all x. (Increases(Water(x), Environment(x)) -> Increases(Population(AquaticAnimals(y)), Environment(x)))", "all e. (WaterIncreases(e) -> exists a. (AquaticAnimal(a) & PopulationIncreases(e, a)))", "all e. (Increases(water, e) -> Increases(Population(aquatic_animals, e)))", "all e. (IncreaseInWater(e) -> IncreaseInPopulation(e, aquatic_animals))", "all e. (WaterIncreases(e) -> PopulationIncreases(AquaticAnimals, e))", "all e. (Environment(e) & Increases(Water(e)) -> Increases(Population(AquaticAnimals(e))))", "all e. (Environment(e) & WaterIncreases(e) -> exists p. (Population(p) & AquaticAnimals(p) & Increases(p, e)))", "all e. (Increases(Water, e) -> Increases(Population(AquaticAnimals), e))", "all x. (Environment(x) & Increases(Water, x) -> Increases(Population(AquaticAnimals), x))", "all e. (Increase(Water(e)) -> Increase(Population(AquaticAnimals(e))))", "FOL Translation:\nall e. (IncreaseWater(e) -> IncreasePopulation(aquaticAnimals, e))", "all e. (Increases(water, e) -> Increases(Population(aquaticAnimals), e))", "all e. (IncreasedWater(e) -> IncreasedPopulationOfAquaticAnimals(e))", "FOL Translation:\nall e. (IncreaseInWater(e) -> IncreaseInPopulation(e, AquaticAnimals))", "all e. (Increase(Water, e) -> Increase(Population(AquaticAnimals), e))", "all e. (Increases(water, e) -> Increases(PopulationOfAquaticAnimals, e))"]}
{"id": "entailmentbank_validation_497", "nl": "a salamander is a kind of aquatic animal.", "fol": "", "prediction": ["AquaticAnimal(salamander)", "Salamander(s) -> AquaticAnimal(s)", "Salamander(x) -> AquaticAnimal(x)", "Salamander(s) -> AquaticAnimal(s)", "Salamander(x) -> AquaticAnimal(x)", "AquaticAnimal(salamander)", "Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)", "AquaticAnimal(salamander)", "all x. (Salamander(x) -> AquaticAnimal(x))", "Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)", "Salamander(x) -> AquaticAnimal(x)", "all x. (Salamander(x) -> AquaticAnimal(x))", "Salamander(s) -> AquaticAnimal(s)", "AquaticAnimal(salamander)"]}
{"id": "entailmentbank_validation_498", "nl": "as water increases in an environment, the population of salamanders may increase.", "fol": "", "prediction": ["all e. (WaterIncreases(e) -> MayIncrease(PopulationOfSalamanders(e)))", "all e. (Increases(water, e) -> MayIncrease(PopulationSalamanders, e))", "FOL Translation:\nall e. (Increases(Water, e) -> MayIncrease(PopulationOfSalamanders, e))", "exists x. (Environment(x) & WaterIncreases(x) -> exists y. (SalamanderPopulation(y, x) & MayIncrease(y)))", "all e. (Increase(Water, e) -> MayIncrease(PopulationOfSalamanders, e))", "all e. (Increases(water, e) -> MayIncrease(Population(salamanders), e))", "all e. (Increase(water, e) -> MayIncrease(Population(salamanders), e))", "all x. (Environment(x) & WaterIncreases(x) -> MayIncrease(PopulationOf(salamanders, x)))", "all e. (WaterIncreases(e) -> (exists p. (Population(p) & Salamanders(p) & MayIncrease(e, p))))", "all e. (IncreaseWater(e) -> may exist p. (IncreasePopulationOfSalamanders(e, p)))", "all e. (Increases(water, e) -> MayIncrease(PopulationOf(salamanders), e))", "all e. (Increases(water, e) -> MayIncrease(PopulationOf(salamander), e))", "all e. ((Environment(e) & WaterIncreases(e)) -> exists p. (Population(salamander, e) & MayIncrease(p)))", "all e. (Increases(Water, e) -> may_increase(Population(salamander), e))", "all e. (Increases(water, e) -> may_increase(Population(salamander), e))", "all e. ((Environment(e) & WaterIncreases(e)) -> exists p. (PopulationOfSalamanders(p, e) & MayIncrease(p)))"]}
{"id": "entailmentbank_validation_499", "nl": "when a body of water receives more water than it can hold, a flood occurs.", "fol": "", "prediction": ["all x. all y. ((BodyOfWater(x) & WaterAmount(y) & ReceivesMoreThanCanHold(x, y)) -> FloodOccurs(x))", "all x. ((BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x)) -> FloodOccurs(x))", "all x. ((BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x)) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreThanCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))", "all x. ((BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x)) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & receivesMoreWater(x) & -CanHold(x, MoreWater(x)) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))", "all x. ((BodyOfWater(x) & ReceivesMoreWaterThanItCanHold(x)) -> FloodOccurs(x))", "all x. ((BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x)) -> FloodOccurs(x))", "all x. (BodyOfWater(x) & ReceivesMoreWaterThanCanHold(x) -> FloodOccurs(x))"]}
{"id": "entailmentbank_validation_500", "nl": "as the amount of water in a body of water increases, the water levels will increase especially at the edge of that body of water.", "fol": "", "prediction": ["all b. (BodyOfWater(b) & Increases(AmountOfWater(b)) -> Increases(WaterLevel(b, Edge(b))))", "FOL Translation:\nall x. (BodyOfWater(x) & IncreaseAmountOfWater(x) -> IncreaseWaterLevelAtEdge(x))", "all x. (BodyOfWater(x) & WaterAmountIncreases(x) -> WaterLevelsIncreaseAtEdges(x))", "all b. (BodyOfWater(b) -> all w. (WaterIncreasesIn(b, w) -> WaterLevelIncreasesAtEdge(b)))", "all x. ((BodyOfWater(x) & Increases(AmountOfWaterIn(x))) -> Increases(WaterLevelAtEdgeOf(x)))", "To translate the given sentence into first-order logic, we need to identify the key components and relationships. Here are the relevant predicates we can establish for the translation:\n\n- `BodyOfWater(w)`: `w` is a body of water.\n- `WaterLevelIncrease(w)`: the water level in body `w` increases.\n- `Edge(e, w)`: `e` is an edge of body of water `w`.\n- `AmountOfWaterIncreases(w)`: the amount of water in body `w` increases.\n- `WaterLevelIncreasesAtEdge(e)`: the water level at edge `e` increases.\n\nNow we combine these to express the relationship: When the amount of water in a body of water increases, water levels increase, especially at the edges:\n\nFOL Translation:\n```\nall w. (BodyOfWater(w) & AmountOfWaterIncreases(w) -> WaterLevelIncrease(w) & exists e. (Edge(e, w) & WaterLevelIncreasesAtEdge(e)))\n```", "all x. (BodyOfWater(x) & Increases(WaterAmount(x)) -> Increases(WaterLevelAtEdge(x)))", "all x. (BodyOfWater(x) & IncreaseAmountOfWater(x) -> IncreaseWaterLevelAtEdge(x))", "all x. (BodyOfWater(x) & Increases(AmountOfWater(x)) -> Increases(WaterLevelAtEdge(x)))", "all x. (BodyOfWater(x) & Increases(AmountOfWater(x)) -> Increases(WaterLevels(x)) & Increases(EdgeWaterLevel(x)))", "all b, x, y. ((BodyOfWater(b) & AmountOfWaterIncreases(b, x) & EdgeOfBody(b, y)) -> WaterLevelIncreasesAt(y))", "all b, w. ((BodyOfWater(b) & Water(w) & IncreasesAmountOf(w, b)) -> IncreaseWaterLevelsEdge(b))", "all x. (BodyOfWater(x) & Increase(WaterAmount(x)) -> Increase(WaterLevelsAtEdge(x)))", "To translate the given sentence into first-order logic, we should focus on the relationships mentioned: the amount of water in a body of water, the water levels, and their increase especially at the edge of the water body. Let's identify the components:\n\n1. For a body of water (`BodyOfWater`), when the `AmountOfWater` increases, the `WaterLevel` at the `Edge` of that `BodyOfWater` increases.\n2. We need predicates like `BodyOfWater(x)`, `AmountOfWater(x, y)` for the amount of water in `x`, `Increases(y)` when `y` increases, and `WaterLevel(x, z)` for the water level at a point `z` on body `x`.\n\nFOL Translation:\n```\nall x. (BodyOfWater(x) -> (Increases(AmountOfWater(x)) -> Increases(WaterLevelAtEdge(x))))\n```\nIn this translation:\n- `x` is a body of water.\n- `Increases(AmountOfWater(x))` indicates that the amount of water in `x` increases.\n- `Increases(WaterLevelAtEdge(x))` indicates that the water level increases at the edge of `x`.", "all x. ((BodyOfWater(x) & Increases(AmountOfWater(x))) -> Increases(WaterLevels(x)) & Increases(WaterLevelAtEdge(x)))", "all x. ((BodyOfWater(x) & Increases(AmountOfWater(x))) -> Increases(WaterLevelsAtEdge(x)))"]}
{"id": "entailmentbank_validation_501", "nl": "a flood is a result of a large increase of water in a body of water.", "fol": "", "prediction": ["all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & In(y, x) & BodyOfWater(x)))", "ResultOf(aFlood(x), (exists y. (LargeIncrease(y) & Water(y) & InBodyOfWater(y))))", "all x. (Flood(x) -> exists y. (IncreaseOfWater(y) & Large(y) & ResultOf(x, y) & BodyOfWater(y)))", "all x. (Flood(x) -> exists y. (BodyOfWater(y) & LargeIncreaseOfWater(y) & ResultOf(x, y)))", "ResultOfFlood(w, f) <-> LargeIncreaseOfWater(w) & BodyOfWater(w)", "all x. (Flood(x) -> exists y. (BodyOfWater(y) & LargeIncreaseOfWaterIn(y, x)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & In(y, x) & BodyOfWater(x)))", "all x. (Flood(x) -> exists y. (BodyOfWater(y) & LargeIncreaseOfWaterIn(y, x)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InBodyOfWater(y) & ResultOf(x, y)))", "all x. ((Flood(x) -> exists y. (LargeIncreaseOfWater(y) & BodyOfWater(z) & ResultOf(x, y, z))))", "all x. (Flood(x) -> exists y. (WaterIncrease(y) & BodyOfWater(y) & ResultOf(x, y)))", "exists x, y. (Flood(x) & BodyOfWater(y) & LargeIncreaseOfWaterIn(y) & Result(x, LargeIncreaseOfWaterIn(y)))", "all x. (Flood(x) -> exists y. (BodyOfWater(y) & LargeIncreaseOfWaterIn(y) & ResultOf(x, LargeIncreaseOfWaterIn(y))))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & In(y, BodyOfWater(y)) & Result(x, y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InBodyOfWater(y, x)))", "ResultOf(a flood, a large increase of water in a body of water)"]}
{"id": "entailmentbank_validation_502", "nl": "a body of water is a part of some environments.", "fol": "", "prediction": ["exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) -> exists y. (Environment(y) & PartOf(x, y)))", "exists e. (Environment(e) & exists b. (BodyOfWater(b) & PartOf(b, e)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists x. (BodyOfWater(x) & exists y. (Environment(y) & PartOf(x, y)))", "exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))", "exists y. (Environment(y) & exists x. (BodyOfWater(x) & PartOf(x, y)))"]}
{"id": "entailmentbank_validation_503", "nl": "a flood is a result of a large increase of water in an environment.", "fol": "", "prediction": ["all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, z) & Result(x, y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y) & In(y, Environment())))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y) & InEnvironment(y)))", "all x. (Flood(x) -> exists y. (IncreaseOfWater(y) & Large(y) & ResultOf(x, y) & InEnvironment(y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, z) & ResultOf(x, y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, z) & ResultOf(x, y)))", "ResultOfFlood(flood, IncreaseOfWater(y, environment(z))) -> (Large(y) & InEnvironment(y, z))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y) & InEnvironment(y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, x)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, x)))", "FOL Translation:\nall x. (Flood(x) -> exists y z. (LargeIncreaseOfWater(y) & InEnvironment(z) & ResultOf(x, y, z)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y) & InEnvironment(y, z)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & InEnvironment(y, x)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & Causes(y, x)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y) & InEnvironment(x, y)))", "all x. (Flood(x) -> exists y. (LargeIncreaseOfWater(y) & ResultOf(x, y)))"]}
{"id": "entailmentbank_validation_504", "nl": "a flood may cause the population of salamander to increase in an environment.", "fol": "", "prediction": ["exists x. exists y. (Flood(x) & Environment(y) & Causes(x, Increase(Population(salamander), y)))", "exists f, e. (Flood(f) & Environment(e) & Causes(f, Increase(Population(Salamander), e)))", "exists x. (Flood(x) & exists y. (Environment(y) & Causes(x, Increase(Population(salamander, y)))))", "exists e. (Flood(e) & ensures all p. (Environment(p) -> exists s. (Salamander(s) & IncreasePopulation(s, p))))", "exists x. (Flood(x) & exists y. (Environment(y) & Causes(x, Increase(Population(salamander), y))))", "exists e. (Environment(e) & exists f. (Flood(f) & InEnvironment(f, e) -> exists p. (Population(p) & OfSalamander(p) & InEnvironment(p, e) & CauseIncrease(f, p))))", "exists f, e. (Flood(f) & Environment(e) & MayCause(f, e, Increase(Population(salamander), e)))", "exists e. (Flood(e) -> exists p. (PopulationOf(salamander, p) & Increase(p) & OccurIn(e, environment)))", "exists x. exists y. (Flood(x) & Environment(y) -> MayCause(IncreasePopulation(salamander), y))", "exists x. exists y. (Flood(x) & Population(y) & Salamander(y) & Environment(z) & Causes(x, Increase(y, z)))", "exists e. (Flood(e) & all x. (Salamander(x) & Inhabits(x, e)) -> IncreaseInPopulation(x, e))", "exists e. (Environment(e) & exists f. (Flood(f) & MayCause(f, exists p. (PopulationOf(p, salamander) & Increase(p, e)))))", "exists f, e. (Flood(f) & Environment(e) -> exists p. (Population(p) & Of(p, salamander) & Increases(p, e)))", "exists f, e. (Flood(f) & Environment(e) & Causes(f, exists p. (Population(p) & OfSalamander(p) & Increases(p, e))))", "exists f, e. (Flood(f) & Environment(e) & (Causes(f, Increase(Population(salamander), e))))", "exists e. (Environment(e) & exists f. (Flood(f) & OccursIn(f, e) -> exists p. (Population(salamander, p) & Increases(p, e))))"]}
{"id": "entailmentbank_validation_505", "nl": "frogs / turtles / fish / mice / birds are kinds of animals.", "fol": "", "prediction": ["all x. ((Frog(x) -> Animal(x)) & (Turtle(x) -> Animal(x)) & (Fish(x) -> Animal(x)) & (Mouse(x) -> Animal(x)) & (Bird(x) -> Animal(x)))", "all x. (Frog(x) -> Animal(x)) & all y. (Turtle(y) -> Animal(y)) & all z. (Fish(z) -> Animal(z)) & all w. (Mouse(w) -> Animal(w)) & all v. (Bird(v) -> Animal(v))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "In translating this sentence into first-order logic, we need to capture the claim that each of these entities (frogs, turtles, fish, mice, and birds) are types of animals. Here's the translation:\n\nall x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) -> Animal(x)) & (Turtle(x) -> Animal(x)) & (Fish(x) -> Animal(x)) & (Mouse(x) -> Animal(x)) & (Bird(x) -> Animal(x)))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))", "all x. ((Frog(x) -> Animal(x)) & (Turtle(x) -> Animal(x)) & (Fish(x) -> Animal(x)) & (Mouse(x) -> Animal(x)) & (Bird(x) -> Animal(x)))", "all x. ((Frog(x) -> Animal(x)) & (Turtle(x) -> Animal(x)) & (Fish(x) -> Animal(x)) & (Mouse(x) -> Animal(x)) & (Bird(x) -> Animal(x)))", "all x. (Frog(x) -> Animal(x)) & all y. (Turtle(y) -> Animal(y)) & all z. (Fish(z) -> Animal(z)) & all w. (Mouse(w) -> Animal(w)) & all u. (Bird(u) -> Animal(u))", "all x. ((Frog(x) | Turtle(x) | Fish(x) | Mouse(x) | Bird(x)) -> Animal(x))"]}
{"id": "entailmentbank_validation_506", "nl": "alligators eat frogs / turtles / fish / mice / birds.", "fol": "", "prediction": ["all x. (Alligator(x) -> (eats(x, frogs) & eats(x, turtles) & eats(x, fish) & eats(x, mice) & eats(x, birds)))", "all x. (Alligator(x) -> exists y. ((Frog(y) | Turtle(y) | Fish(y) | Mouse(y) | Bird(y)) & Eats(x, y)))", "all x. (Alligator(x) -> (Eats(x, frogs) | Eats(x, turtles) | Eats(x, fish) | Eats(x, mice) | Eats(x, birds)))", "all x. (Alligator(x) -> (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists w. (Fish(w) & Eats(x, w)) | exists u. (Mouse(u) & Eats(x, u)) | exists v. (Bird(v) & Eats(x, v))))", "all y. (Alligator(y) -> (exists z. (Frog(z) & Eats(y, z)) | exists z. (Turtle(z) & Eats(y, z)) | exists z. (Fish(z) & Eats(y, z)) | exists z. (Mouse(z) & Eats(y, z)) | exists z. (Bird(z) & Eats(y, z))))", "exists x. (Alligator(x) & (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists w. (Fish(w) & Eats(x, w)) | exists u. (Mouse(u) & Eats(x, u)) | exists v. (Bird(v) & Eats(x, v))))", "all x. (Alligator(x) -> (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists w. (Fish(w) & Eats(x, w)) | exists u. (Mouse(u) & Eats(x, u)) | exists v. (Bird(v) & Eats(x, v))))", "all x. (Alligator(x) -> exists y. (Frog(y) & Eats(x, y) | Turtle(y) & Eats(x, y) | Fish(y) & Eats(x, y) | Mouse(y) & Eats(x, y) | Bird(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Frog(y) | Turtle(y) | Fish(y) | Mouse(y) | Bird(y) & Eats(x, y)))", "all x. (Alligator(x) -> (Eats(x, frog) | Eats(x, turtle) | Eats(x, fish) | Eats(x, mouse) | Eats(x, bird)))", "all x. (Alligator(x) -> exists y. ((Frog(y) | Turtle(y) | Fish(y) | Mouse(y) | Bird(y)) & Eats(x, y)))", "all x. (Alligator(x) -> (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists w. (Fish(w) & Eats(x, w)) | exists u. (Mouse(u) & Eats(x, u)) | exists v. (Bird(v) & Eats(x, v))))", "all x. (Alligator(x) -> (exists y. (Frog(y) & Eats(x, y)) | exists z. (Turtle(z) & Eats(x, z)) | exists a. (Fish(a) & Eats(x, a)) | exists b. (Mouse(b) & Eats(x, b)) | exists c. (Bird(c) & Eats(x, c))))", "all x. (Alligator(x) -> exists y. ((Frog(y) | Turtle(y) | Fish(y) | Mouse(y) | Bird(y)) & Eats(x, y)))", "all x. (Alligator(x) -> (Eats(x, frog) & Eats(x, turtle) & Eats(x, fish) & Eats(x, mouse) & Eats(x, bird)))", "all x. (Alligator(x) -> (exists y. (Frog(y) -> Eats(x, y)) & exists z. (Turtle(z) -> Eats(x, z)) & exists w. (Fish(w) -> Eats(x, w)) & exists u. (Mouse(u) -> Eats(x, u)) & exists v. (Bird(v) -> Eats(x, v))))"]}
{"id": "entailmentbank_validation_507", "nl": "alligators eat animals.", "fol": "", "prediction": ["all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))", "all x. (Alligator(x) -> exists y. (Animal(y) & Eats(x, y)))"]}
{"id": "entailmentbank_validation_508", "nl": "a predator eats other animals for food.", "fol": "", "prediction": ["exists x. (Predator(x) -> all y. (Animal(y) & OtherThan(x, y) -> EatsForFood(x, y)))", "all x. (Predator(x) -> exists y. (Animal(y) & OtherThan(y, x) & EatsForFood(x, y)))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))", "all x. (Predator(x) -> exists y. (Animal(y) & OtherThan(x, y) & EatsForFood(x, y)))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y)))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x != y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))", "all x. (Predator(x) -> exists y. (Animal(y) & EatsForFood(x, y) & x \u2260 y))"]}
{"id": "entailmentbank_validation_509", "nl": "alligators are a kind of predator.", "fol": "", "prediction": ["all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))", "all x. (Alligator(x) -> Predator(x))"]}
{"id": "entailmentbank_validation_510", "nl": "as the population of prey decreases, competition between predators will increase.", "fol": "", "prediction": ["all t. (Decreases(Population(prey), t) -> Increases(CompetitionBetween(predators), t))", "all x. (Prey(x) -> Decreases(Population(x))) -> all y. (Predator(y) -> Increases(CompetitionBetween(y)))", "all x. (Prey(x) & DecreasingPopulation(x) -> all y. (Predator(y) -> IncreasingCompetitionAmong(y)))", "all x. (Decreases(Population(prey)) -> Increase(Competition(Predators(x))))", "all x. (PreyPopulationDecreases(x) -> exists y. (Competition(y) & between(y, Predators) & Increases(y)))", "all t. (Decreases(Population(prey, t)) -> Increases(CompetitionBetween(predators, t)))", "all p. (Decrease(PopulationOf(p, prey)) -> Increase(CompetitionAmong(predators)))", "all t. ((Decrease(Population(prey), t)) -> Increase(Competition(between(predator)), t))", "exists x, y. (Prey(x) & Predators(y) & Decrease(Population(x)) -> Increase(Competition(y)))", "all t. (Decreases(Population(prey, t)) -> Increases(Competition(predators, t)))", "all p1. (all p2. (Prey(p1) & PreyPopulationDecreases(p1) & Predator(p2) -> exists p3. (Predator(p3) & CompetitionIncreases(p2, p3))))", "all x, y. ((PreyPopulationDecreases(x) & PredatorPopulation(y)) -> CompetitionBetweenPredatorsIncreases(y))", "all x y. (PreyPopulationDecreases(x) & Predator(y) -> CompetitionIncreases(y))", "all x y. ((PreyPopulationDecreases(x) & Predator(x) & Predator(y) & Compete(x, y)) -> CompetitionIncreases(x, y))", "all x. ((PopulationOfPreyDecreases(x)) -> exists y. (Predator(z) & Predator(y) & CompetitionIncreases(z, y)))", "FOL Translation:\nall x. (PreyPopulationDecreases(x) -> exists y. (CompetitionBetween(y, z) & Predators(y) & Predators(z) & Increases(y, z)))"]}
{"id": "entailmentbank_validation_511", "nl": "as the population of prey decreases, competition between alligators will increase.", "fol": "", "prediction": ["all t. (Decreases(PopulationOfPrey(t)) -> Increases(CompetitionBetweenAlligators(t)))", "all t. (Decreases(PopulationOf(prey, t)) -> Increases(Competition(alligators, t)))", "all t. (Decreases(Population(prey), t) -> Increases(Competition(alligators), t))", "all x. (Alligator(x) -> (Decreases(Population(prey)) -> Increases(Competition(x))))", "Decrease(Population(prey)) -> Increase(Competition(all x. Alligator(x)))", "FOL Translation:\nDecreases(Population(prey)) -> Increases(CompetitionBetween(alligators))", "all t. (Decreases(Population(prey), t) -> Increases(CompetitionBetween(alligators), t))", "all t. (Decreases(Population(prey), t) -> Increases(Competition(alligator), t))", "all x. all y. ((Alligator(x) & Alligator(y) & PreyPopulationDecreases) -> CompetitionIncreases(x, y))", "all p. (Decrease(Population(prey)) -> Increase(Competition(alligator, alligator)))", "all p. (Decrease(Population(prey, p)) -> Increase(Competition(alligators)))", "all x. (Alligator(x) -> (Decrease(Population(prey)) -> Increase(Competition(x))))", "FOL Translation:\nall x y. ((PreyPopulationDecrease -> Alligator(x) & Alligator(y) & x \u2260 y) -> CompetitionIncrease(x, y))", "all x. (Alligator(x) & Decreases(Population(prey)) -> Increases(Competition(x)))", "all t. (Decreases(Population(prey, t)) -> Increases(CompetitionBetween(alligator, t)))", "``` \nall t. (Decreases(Population(prey, t)) -> Increases(Competition(alligators, t)))\n```"]}
{"id": "entailmentbank_validation_512", "nl": "competition may cause animals to act aggressively towards members of their own species.", "fol": "", "prediction": ["all x. exists y. (Animal(x) & Conspecific(y, x) & Competition(x, y) -> ActsAggressively(x, y))", "all x, y. ((Animal(x) & Animal(y) & SameSpecies(x, y) & Competition(x, y)) -> ActsAggressively(x, y))", "all x. (Animal(x) & exists y. (Competition(y) & InvolvedIn(x, y)) -> exists z. (MemberOfSameSpecies(z, x) & ActsAggressivelyTowards(x, z)))", "all x. (Animal(x) & exists y. (MemberOfSpecies(y, x) & Competition(x, y)) -> ActsAggressivelyTowards(x, y))", "all x. (Animal(x) & exists y. (MemberOfSameSpecies(x, y) & CompetitionCausesAggression(x, y) -> ActsAggressively(x, y)))", "all x. (Animal(x) -> (CompetitionPresent(x) -> exists y. (SameSpecies(x, y) & ActsAggressivelyTowards(x, y))))", "all a. all s. (Animal(a) & Species(s) & MemberOf(a, s) & Competition(c) & Causes(c, a, ActsAggressivelyTowards(a, a)))", "all x. all y. ((Animal(x) & Animal(y) & SameSpecies(x, y) & CompetitionPresent(x)) -> MayActAggressivelyTowards(x, y))", "all x. (Animal(x) & CompetitionCauseAggression(x) -> exists y. (SameSpecies(x, y) & ActsAggressivelyTowards(x, y)))", "all x. (Animal(x) & exists y. (Competition(y) & Causes(y, ActsAggressively(x, x))) -> ActsAggressively(x, x))", "all x. (Animal(x) & exists y. (Species(y) & MemberOf(x, y)) -> (exists z. (Competition(z, x) -> exists w. (Animal(w) & MemberOf(w, y) & x != w & ActAggressively(x, w)))))", "all x. (Animal(x) & exists y. (Competition(x, y)) -> exists z. (MemberOfSpecies(z, x) & AggressiveTowards(x, z)))", "all x. (Animal(x) & exists y. (Competition(y) & Causes(y, x))) -> exists z. (MemberOfSpecies(z, x) & ActsAggressivelyTowards(x, z))", "all x. (Animal(x) -> (exists y. (Competition(y) & Involves(y, x)) -> exists z. (AggressiveTowards(x, z) & SameSpecies(x, z))))", "all x. (Animal(x) & exists y. (MemberOfSameSpecies(x, y) & Competition(x, y)) -> ActsAggressivelyTowards(x, y))", "all x. (Animal(x) & exists y. (Competition(y) & Involves(y, x)) -> exists z. (MemberOfSameSpecies(x, z) & ActsAggressivelyTowards(x, z)))"]}
{"id": "entailmentbank_validation_513", "nl": "as the population of prey decreases, agression between alligators will increase.", "fol": "", "prediction": ["FOL Translation:\nall x. (PreyPopulationDecreases -> (Alligator(x) -> AggressionIncreasesBetween(x)))", "all x. (Alligator(x) & PopulationDecrease(prey) -> IncreaseAggression(x))", "all x. ((Alligator(x) & PopulationDecreases(prey)) -> AggressionIncreases(x))", "all t. (Decrease(Population(prey), t) -> Increases(Aggression(alligator), t))", "all t. (Decrease(Population(prey), t) -> Increase(Aggression(alligator), t))", "all x. (Alligator(x) -> Decrease(Population(preys)) -> Increase(Aggression(x, Alligator)))", "all x. (alligator(x) -> (Decrease(Population(prey)) -> Increase(Aggression(x))))", "all x. (Alligator(x) & PreyPopulationDecreases -> AggressionIncreases(x))", "FOL Translation:\nDecreasePopulation(prey) -> IncreaseAggression(all x. (Alligator(x) & Aggression(x)))", "all p. (PopulationOfPreyDecreases(p) -> IncreaseAggression(alligator, alligator))", "all x. (Alligator(x) -> (Decreases(Population(prey)) -> Increases(AggressionBetween(x, others))))", "all x. (Alligator(x) & PopulationDecrease(prey) -> IncreasesAggression(x))", "all x. (Alligator(x) -> (Decreases(Population(prey)) -> Increases(Aggression(x))))", "all p. (PopulationDecreases(prey, p) -> IncreaseAggression(alligators))", "all y. (Alligator(y) & Decreases(Population(prey)) -> Increases(Aggression(y)))", "all x. (Alligator(x) & Decreases(Population(prey)) -> Increases(AggressionBetweenAlligators(x)))"]}
{"id": "entailmentbank_validation_514", "nl": "a drought occurs over a period of months / years.", "fol": "", "prediction": ["exists x. (Drought(x) & OccursOver(x, Period(months)) | OccursOver(x, Period(years)))", "exists d. (Drought(d) & exists t. (PeriodOfTime(t) & Over(t, d) & (Months(t) | Years(t))))", "exists x. (Drought(x) & (Months(x) | Years(x)))", "exists t. (Drought(t) & PeriodOfMonthsOrYears(t))", "exists p, t. (DroughtOccurs(p) & (PeriodOfMonths(t) | PeriodOfYears(t)))", "exists x. (Drought(x) & OccursOverPeriod(x) & (Months(x) | Years(x)))", "exists t. (Drought(t) & TimePeriod(t) & (Months(t) | Years(t)))", "exists t. (DroughtOccurs(t) & (PeriodOfMonthsOrYears(t)))", "exists x. (Drought(x) & OccursOverPeriod(x, months) | OccursOverPeriod(x, years))", "exists t. (TimePeriod(t) & (Months(t) | Years(t)) & Occurs(drought, t))", "exists x. ((PeriodOfTime(x) & (Months(x) | Years(x))) & DroughtOccursOver(x))", "exists x. (Drought(x) & exists y. (Months(y) | Years(y) & OccursOverPeriod(x, y)))", "exists x. (Drought(x) & occursOverPeriod(x, months) | occursOverPeriod(x, years))", "exists x. (Drought(x) & OccursOver(x, y) & (Period(y) & (Months(y) | Years(y))))", "exists x. (Drought(x) & OccursOverPeriod(x) & (Months(y) | Years(z)))", "exists x. (Drought(x) & (Period(x, months) | Period(x, years)))"]}
{"id": "entailmentbank_validation_515", "nl": "drought is when available water decreases in an environment over a period of months / years.", "fol": "", "prediction": ["Drought(d) <-> exists e, t. (Environment(e) & TimePeriod(t) & Duration(t, months) | Duration(t, years) & Decreases(AvailableWater, e, t))", "Drought(x) <-> (Environment(x) & exists t. (TimePeriod(t) & OverPeriod(t, months_or_years) & all y. (AvailableWater(x, t, y) -> Decreases(y))))", "Drought(x) <-> (TimePeriod(x) & all e, w. (Environment(e) & AvailableWater(w, e, x) -> DecreasesOverMonthsOrYears(w, e)))", "Drought(x) <-> (exists e, t. (AvailableWaterDecreases(e, x, t) & Environment(e) & (Months(t) | Years(t))))", "Drought() <-> exists e, p. (Environment(e) & AvailableWaterDecreases(e, p) & MonthsOrYears(p))", "Drought(x) <-> (exists y. (Environment(y) & Decreases(AvailableWater, y) & OverPeriodOf(MonthsOrYears)))", "Drought(x) <-> (exists y. (Water(y) & Environment(z) & TimePeriod(months) | TimePeriod(years) & Decreases(y, z, x)))", "Drought(d) <-> exists e, t. (Environment(e) & AvailableWaterDecreases(e, t) & TimePeriod(t) & OverMonthsOrYears(t))", "Drought(d) <-> exists e, t1, t2. (Environment(e) & Decreases(AvailableWater(e, t1), AvailableWater(e, t2)) & MonthsOrYears(t1, t2) & Before(t1, t2))", "Drought(x) <-> (AvailableWater(y, x) & Environment(x) & TimePeriod(t) & MonthsOrYears(t) & Decreases(y, t, x))", "Drought(x) <-> (exists e, p. (Environment(e) & AvailableWaterDecreases(x, e, p) & Duration(p) & PeriodOfMonthsOrYears(p)))", "Drought(x) <-> (Event(x) & exists e, n, y. (AvailableWater(e) & Environment(e, y) & Decreases(e, n, y) & TimePeriod(n, months | years)))", "Drought occurs when available water decreases in an environment over a period of months/years.\n\nall e. (Drought(e) <-> exists t. (TimePeriod(t) & DurationInMonthsOrYears(t) & Environment(e) & exists w. (AvailableWater(e, w) & Decreases(w, t))))", "Drought(x) <-> (AvailableWaterDecreases(x) & Environment(x) & PeriodOfMonthsOrYears(x))", "Drought(e) <-> exists w, t. (AvailableWaterDecreases(w, e) & InEnvironment(w, e) & OverPeriodOfMonthsOrYears(t, e))", "Drought(x) <-> (exists y. (Water(y) & Available(y) & all z. (Environment(z) -> DecreasesOverTime(y, z, months_years))))"]}
{"id": "entailmentbank_validation_516", "nl": "as available water decreases, the population of plants will decrease.", "fol": "", "prediction": ["all t. (Decreases(AvailableWater, t) -> Decreases(Population(plants), t))", "all x. (Decreases(AvailableWater(x)) -> Decreases(PopulationOfPlants(x)))", "FOL Translation:\nall t. (Decreases(AvailableWater, t) -> Decreases(PopulationOfPlants, t))", "all x. (AvailableWater(x) -> -Decrease(x) | DecreasePopulation(plants))", "all t. (Decrease(AvailableWater, t) -> Decrease(PopulationOfPlants, t))", "all x. (Decreases(AvailableWater(x)) -> Decreases(PopulationOfPlants(x)))", "FOL Translation:\nall x. (AvailableWaterDecreases(x) -> PlantPopulationDecreases(x))", "all t. (Decreases(AvailableWater, t) -> Decreases(PopulationOfPlants, t))", "all t. (Decreases(AvailableWater(t)) -> Decreases(PopulationOfPlants(t)))", "all x. (Decreases(AvailableWater(x)) -> Decreases(PopulationOfPlants(x)))", "all t. (Decreases(AvailableWater(t)) -> Decreases(PopulationOfPlants(t)))", "As the original sentence talks about a decrease in water availability leading to a decrease in the population of plants, it is expressing a conditional or causal relationship. However, in first-order logic, this is often modeled simply as an implication. \n\nHere is the translation into FOL:\n\nDecreaseAvailableWater -> DecreasePlantPopulation", "all x. (AvailableWaterDecreases(x) -> PopulationOfPlantsDecreases(x))", "all x. ((Decreases(AvailableWater(x))) -> Decreases(PopulationOfPlants(x)))", "all x. (WaterAvailableDecreases(x) -> PopulationDecreases(x, plants))", "all x. ((AvailableWaterDecreases(x)) -> (PlantPopulationDecreases(x)))"]}
{"id": "entailmentbank_validation_517", "nl": "a drought that occurs over a period of months / years may cause the population of plants in an environment to decrease.", "fol": "", "prediction": ["exists d. (Drought(d) & OccursOverPeriod(d, months) | OccursOverPeriod(d, years)) -> may c. (PopulationOfPlantsIn(d, c) & Environment(c) -> Decreases(c))", "exists d. (Drought(d) & OccursOverPeriod(d, months_years) -> exists e. (Environment(e) & Causes(d, DecreasePopulationOfPlants(e))))", "exists d. (Drought(d) & OccursOverPeriod(d, \"monthsOrYears\") -> all e. (Environment(e) -> DecreasesPopulationOfPlants(d, e)))", "exists x. (Drought(x) & OccursOverPeriodOfMonthsOrYears(x) -> all y. ((Plant(y) & InEnvironment(y)) -> MayCauseDecreaseInPopulation(x, y)))", "exists d. (Drought(d) & OverPeriodOfMonthsOrYears(d) -> exists e. (Environment(e) -> may x. (Plant(x) & In(e, x) -> DecreasePopulation(x))))", "exists d. (Drought(d) & OccursOverPeriodOfMonthsOrYears(d) -> exists e. (Environment(e) -> exists p. (PlantsPopulationIn(e, p) & MayDecrease(p))))", "exists d. (Drought(d) & OccursOverPeriod(d, months/years) -> may exists e. (Environment(e) & exists p. (PopulationOfPlants(p, e) & Decreases(p))))", "exists x. (Drought(x) & OccursOverPeriod(x, months_or_years) -> mayCause(x, exists y. (PopulationOf(y, plants) & InEnvironment(y, some_environment) & Decrease(y))))", "exists d. (Drought(d) & OccursOverPeriodOf(d, months_years) -> all e. (Environment(e) -> CanCauseDecreaseInPopulationOf(d, plants, e)))", "exists d. (Drought(d) & OccursOver(d, \"months/years\") -> all e. (Environment(e) -> exists p. (PlantPopulation(p, e) & Decreases(p))))", "exists d. (Drought(d) & OccursOverMonthsOrYears(d) -> all e. (Environment(e) -> exists p. (PlantsPopulation(p, e) & Decreases(p, e))))", "exists d. (Drought(d) & OccursOverPeriod(d, months_years) -> all e. (Environment(e) -> exists t. (Period(t, months_years) & Causes(d, DecreasePopulation(plants, e)))))", "exists d. (Drought(d) & OccursOverPeriod(d, months) | OccursOverPeriod(d, years) -> all e. (Environment(e) -> MayCause(PopulationDecrease(plants, e))))", "exists d. (Drought(d) & Occurs(d, months_years) -> all e. (Environment(e) -> exists x. (Plant(x) & LivesIn(x, e) -> MayCauseDecrease(d, x))))", "exists d. (Drought(d) & OccursOverPeriod(d, months_or_years) -> all e. (Environment(e) -> exists p. (Plant(p) & InEnvironment(p, e) & MayCauseDecrease(d, p))))", "exists p. (Drought(p) & OccursOverMonthsOrYears(p) -> all e. (Environment(e) -> exists x. (PlantPopulationDecreasesIn(x, e))))"]}
{"id": "entailmentbank_validation_518", "nl": "a marsh willow herb is a kind of plant.", "fol": "", "prediction": ["MarshWillowHerb(x) -> Plant(x)", "MarshWillowHerb(y) -> Plant(y)", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))", "all z. (MarshWillowHerb(z) -> Plant(z))", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))", "MarshWillowHerb(x) -> Plant(x)", "MarshWillowHerb(x) -> Plant(x)", "Plant(marsh_willow_herb)", "MarshWillowHerb(m) -> Plant(m)", "all x. (MarshWillowHerb(x) -> Plant(x))", "all x. (MarshWillowHerb(x) -> Plant(x))"]}
{"id": "entailmentbank_validation_519", "nl": "a drought that occurs over a period of months / years may cause the population of marsh willow herb in an environment to decrease.", "fol": "", "prediction": ["exists d. (Drought(d) & OccursOver(d, PeriodOfMonthsOrYears) -> all e. (Environment(e) -> exists p. (Population(p, marsh_willow_herb, e) -> MayCauseDecrease(d, p))))", "exists d, t, e. (Drought(d) & OccursOverPeriod(d, t) & (Months(t) | Years(t)) -> all m. (MarshWillowHerb(m) & InEnvironment(m, e) -> Causes(d, PopulationDecrease(m, e))))", "exists d. (Drought(d) & OccursOverPeriod(d, 'months / years') -> all e. (Environment(e) -> exists p. (Population(p, marsh_willow_herb, e) & Decreases(p))))", "exists d. (Drought(d) & OccursOverPeriod(d, months_years) -> all e. (Environment(e) -> exists p. (Population(p, marsh_willow_herb, e) & Decreases(p, d))))", "exists d. (Drought(d) & OccursOverPeriod(d, MonthsOrYears) -> all e. (Environment(e) -> causes(d, exists p. (PopulationOf(p, MarshWillowHerb, e) & Decreases(p)))))", "exists d. (Drought(d) & OccursOverPeriod(d, months_years) -> all e. (Environment(e) -> (exists p. (PopulationOf(marsh_willow_herb, e) = p & MayCauseDecrease(d, p)))))", "exists d. (Drought(d) & OccursOver(d, months_years) -> all e. (Environment(e) -> DecreasePopulation(marsh_willow_herb, e)))", "exists d. (Drought(d) & OccursOver(d, PeriodOfMonthsOrYears) -> all e. (Environment(e) -> MayCause(d, Decrease(Population(marsh_willow_herb, e)))))", "exists d. (Drought(d) & OccursOverMonthsOrYears(d) -> all e. (Environment(e) -> exists p. (PopulationOfMarshWillowHerb(p, e) & Decreases(p, d))))", "exists d, t. ((Drought(d) & Duration(t) & OverPeriod(d, t) & MonthsOrYears(t)) -> all e. (Environment(e) -> exists p. (Population(p) & OfMarshWillowHerb(p, e) & MayCauseDecrease(d, p))))", "exists x. (Drought(x) & OccursOverPeriod(x, months_years) -> all y. (Environment(y) -> causes(PopulationDecrease(marsh_willow_herb, y), x)))", "exists d. (Drought(d) & OccursPeriod(d, monthsYears) -> all e. (Environment(e) & Causes(d, DecreasePopulation(marshWillowHerb, e))))", "exists x. (Drought(x) & OccursOverPeriodOfMonthsOrYears(x) -> all y. (Environment(y) -> DecreasePopulation(marsh_willow_herb, y)))", "exists x. (Drought(x) & OccursOverPeriod(x, months_years) -> all y. (Environment(y) -> exists z. (Population(z, marsh_willow_herb, y) & Decreases(z))))", "exists d. (Drought(d) & OccursOverPeriod(d, monthsYears) -> all e. (Environment(e) -> CanCause(d, exists p. (Population(p) & Decreases(p) & Of(p, marshWillowHerb) & In(p, e)))))", "exists d. exists t. exists e. (Drought(d) & OccursOverPeriod(d, t) & (Months(t) | Years(t)) -> all p. (Environment(e) & MarshWillowHerb(p) & LocatedIn(p, e) -> MayCause(Decrease(Population(p, e)), d)))"]}
{"id": "entailmentbank_validation_520", "nl": "sweat is used for adjusting to hot temperatures by some animals.", "fol": "", "prediction": ["FOL Translation:\nexists x. (Animal(x) & UsesForSweating(x, AdjustingToHotTemperatures))", "exists x. (Animal(x) & UsesSweatForAdjustingToHotTemperatures(x))", "exists x. (Animal(x) & UsesSweatForAdjustment(x, hot_temperatures))", "exists z. (Animal(z) & AdjustsToHotTemperaturesByUsingSweat(z))", "exists x. (Animal(x) & UsesFor(x, sweat, AdjustingToHotTemperatures))", "exists x. (Animal(x) & UsesSweatForAdjustingToHotTemperatures(x))", "exists x. (Animal(x) & UsesSweatToAdjustToHeat(x))", "exists x. (Animal(x) & UsesSweatForTemperatureAdjustment(x) & HotTemperature(y) & TemperatureAdjustment(y, x))", "exists x. (Animal(x) & UsesForSweat(x, HotTemperatures))", "exists x. (Animal(x) & UsesForAdjustingToTemperature(x, sweat) & Temperature(hot))", "exists x. (Animal(x) & UsesSweatForAdjustingToHotTemperatures(x))", "exists x. (Animal(x) & usesForAdjustingToHotTemperatures(x, sweat))", "exists x. (Animal(x) & UsesSweatForAdjustingToHotTemperatures(x))", "exists x. (Animal(x) & UsesForSweat(x, AdjustToHotTemperatures))", "exists x. (Animal(x) & UsesFor(x, sweat, AdjustToHotTemperatures))", "exists x. (Animal(x) & AdjustsToHotTemperatures(x, sweat))"]}
{"id": "entailmentbank_validation_521", "nl": "sweat cools a body.", "fol": "", "prediction": ["exists x. (Body(x) & exists y. (Sweat(y) & Cools(y, x)))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. (Sweat(x) -> all y. (Body(y) -> Cools(x, y)))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x, y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))", "exists x. exists y. (Sweat(x) & Body(y) & Cools(x, y))"]}
{"id": "entailmentbank_validation_522", "nl": "when the body is hot, sweat is used to cool the body.", "fol": "", "prediction": ["", "all x. (Body(x) & Hot(x) -> uses(Sweat, Cool(x)))", "all x. (Hot(x) -> UsedToCool(Sweat, x))", "all x. (Body(x) & Hot(x) -> UsesToCool(sweat, x))", "all x. (Body(x) & Hot(x) -> exists y. (Sweat(y) & UsedToCool(y, x)))", "all x. (Body(x) & Hot(x) -> exists y. (Sweat(y) & UsedToCool(y, x)))", "all x. (Body(x) & Hot(x) -> UsedToCool(sweat, x))", "all x. ((Body(x) & Hot(x)) -> exists y. (Sweat(y) & UsedToCool(y, x)))", "", "all x. (Body(x) & Hot(x) -> UsedToCool(sweat, x))", "", "all x. ((Body(x) & Hot(x)) -> UsedToCool(sweat, x))", "", "", "all x. (Body(x) & Hot(x) -> UsedToCool(sweat, x))", "all x. (Hot(x) -> UsedToCool(sweat, x))"]}
{"id": "entailmentbank_validation_523", "nl": "panting is when an animal's body is cooled by hanging out their tongue.", "fol": "", "prediction": ["all x. (Panting(x) -> (Animal(y) & CoolsBodyByHangingOutTongue(y)))", "all x. (Panting(x) <-> (Animal(x) & CooledByHangingTongue(x)))", "all x. (Panting(x) <-> (Animal(x) & CoolingByTongue(x)))", "all x. (Animal(x) -> (Panting(x) <-> CooledByHangingTongueOut(x)))", "all x. (Panting(x) <-> exists y. (Animal(y) & BodyCooledByHangingTongueOut(y, x)))", "all x. (Panting(x) <-> (Animal(x) & CoolsBodyByHangingOutTongue(x)))", "all x. (Panting(x) <-> exists y. (Animal(y) & BodyCooledByHangingTongueOut(y)))", "", "all x. (Pant(x) <-> (Animal(x) & CoolBodiesByTongue(x)))", "", "all x. (Panting(x) <-> exists y. (Animal(y) & CoolsByHangingTongue(y, x)))", "all x. (Panting(x) <-> (Animal(x) & CooledByHangingTongueOut(x)))", "all x. (Panting(x) <-> (Animal(x) & Exists y. (Body(y, x) & Cooled(y) & HangsOutTheTongue(y))))", "all x. (Panting(x) <-> (Animal(x) & Cooling(x) & Exists y. (Tongue(y) & PartOf(y, x) & HangsOut(y, x))))", "", "all x. (Panting(x) <-> exists y. (Animal(y) & CoolsBodyByHangingOutTongue(y)))"]}
{"id": "entailmentbank_validation_524", "nl": "panting and sweating are used to cool the body.", "fol": "", "prediction": ["all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((PantingUsedToCool(x) & SweatingUsedToCool(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))", "all x. ((Panting(x) | Sweating(x)) -> UsedToCoolBody(x))"]}
{"id": "entailmentbank_validation_525", "nl": "cooling means decreasing heat / temperature.", "fol": "", "prediction": ["all x. (Cooling(x) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. ((Cooling(x) & (Heat(x) | Temperature(x))) -> Decreases(x, Heat/Temperature))", "all x. (Cooling(x) -> DecreasesHeat(x) | DecreasesTemperature(x))", "all x. (Cooling(x) -> Decreases(x, heat) | Decreases(x, temperature))", "all x. (Cooling(x) -> (Decreasing(x, Heat) | Decreasing(x, Temperature)))", "all x. (Cooling(x) -> Decreases(x, Temperature) | Decreases(x, Heat))", "all x. (Cooling(x) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. (Cooling(x) -> DecreasesHeatOrTemperature(x))", "all x. (Cooling(x) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. (Cooling(x) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. (Cooling(x) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. (Cooling(x) <-> DecreasesHeatOrTemperature(x))", "all x. (Cooling(x) -> Decreasing(x, Heat) | Decreasing(x, Temperature))", "all x. ((Cooling(x) & (Heat(x) | Temperature(x))) -> Decreases(x, Heat) | Decreases(x, Temperature))", "all x. (Cooling(x) -> (DecreasingHeat(x) | DecreasingTemperature(x)))", "all t. (Cooling(t) -> (Decreases(t, heat) | Decreases(t, temperature)))"]}
{"id": "entailmentbank_validation_526", "nl": "if an animal becomes too hot then that animal may die.", "fol": "", "prediction": ["", "", "", "", "all x. (Animal(x) & BecomesTooHot(x) -> MayDie(x))", "", "", "all x. ((Animal(x) & TooHot(x)) -> MayDie(x))", "", "", "", "", "", "", "", ""]}
{"id": "entailmentbank_validation_527", "nl": "cooling can be used by an animal for survival.", "fol": "", "prediction": ["exists x. (Animal(x) & exists y. (Cooling(y) & UsedFor(x, y, Survival)))", "exists x. (Animal(x) -> CanUseForSurvival(x, cooling))", "exists a. (Animal(a) & exists c. (Cooling(c) & UsedByForSurvival(a, c)))", "exists x. exists y. (Animal(x) & Survival(y) & CanUseFor(x, cooling, y))", "exists x. (Animal(x) & exists y. (Cooling(y) & UsedFor(x, y, Survival(x))))", "exists x. (Animal(x) & exists y. (Cooling(y) & UsedByFor(x, y, Survival)))", "exists x. (exists y. (Animal(x) & Cooling(y) & UsedFor(x, y, Survival(x))))", "exists x. exists y. (Cooling(y) & Animal(x) & UsedFor(y, Survival(x)))", "exists x. (Animal(x) -> exists y. (Cooling(y) & UsedForSurvival(x, y)))", "exists a. (Animal(a) & exists c. (Cooling(c) & CanBeUsedForSurvivalBy(c, a)))", "exists x. (Animal(x) & exists y. (Cooling(y) & UsedFor(x, y, survival)))", "exists x. (Animal(x) -> CanUseForSurvival(x, cooling))", "exists a. (Animal(a) -> exists c. (Cooling(c) & UsedForSurvivalBy(a, c)))", "exists x. (Animal(x) & UsedForSurvival(cooling, x))", "exists x. (Animal(x) & exists y. (Cooling(y) & UsedFor(x, y, survival)))", "exists x, y. (Animal(x) & Cooling(y) & UsedFor(x, y, survival))"]}
{"id": "entailmentbank_validation_528", "nl": "if the environmental temperature is too hot then an animal in that environment may become hot.", "fol": "", "prediction": ["all x. (AnimalInEnvironment(x) & EnvironmentalTemperatureTooHot -> MayBecomeHot(x))", "all x. all y. ((Animal(x) & Environment(y) & IsIn(x, y) & EnvironmentalTemperatureTooHot(y)) -> MayBecomeHot(x))", "all x. (Animal(x) & InEnvironment(x, y) & EnvironmentalTemperature(y, TooHot) -> MayBecomeHot(x))", "all x. (Animal(x) & all y. (Environment(y) & IsIn(x, y) & TooHot(Temperature(y)) -> MayBecomeHot(x)))", "all e, a. ((Environment(e) & TemperatureHot(e)) -> (exists x. (Animal(x) & InEnvironment(x, e) & BecomesHot(x))))", "all x. (Environment(x) & TemperatureTooHot(x) -> exists y. (AnimalInEnvironment(y, x) & BecomesHot(y)))", "all e. all a. ((Environment(e) & Animal(a) & InEnvironment(a, e) & TemperatureTooHot(e)) -> BecomesHot(a))", "all x. ((EnvironmentTempTooHot(x) & InEnvironment(y, x)) -> MayBecomeHot(y))", "all x. all y. ((Animal(x) & Environment(y) & In(x, y) & TooHot(y)) -> MayBecomeHot(x))", "all e. (EnvironmentalTempTooHot(e) -> exists a. (AnimalInEnvironment(a, e) & MayBecomeHot(a)))", "all x. ((Animal(x) & Environment(y) & LocatedIn(x, y) & Temperature(y, hot)) -> MayBecomeHot(x))", "all x y. ((Environment(x) & Includes(y, x) & Animal(y) & TooHot(x)) -> MayBecomeHot(y))", "all x y. ((EnvironmentalTemperature(x) & TooHot(x) & InEnvironment(y, x)) -> MayBecomeHot(y))", "all x. all y. ((Environment(y) & TemperatureTooHot(y) & Animal(x) & InEnvironment(x, y)) -> MayBecomeHot(x))", "all x. (EnvironmentalTemperature(x, hot) -> exists y. (AnimalInEnvironment(y, x) & MayBecomeHot(y)))", "all x. (Animal(x) & exists y. (Environment(y) & In(x, y) & TooHot(y)) -> MayBecomeHot(x))"]}
{"id": "entailmentbank_validation_529", "nl": "if the temperature of an animal's environment becomes too hot then that animal must cool itself.", "fol": "", "prediction": ["", "all x. (Animal(x) & Environment(y, x) & Temperature(y) & TooHot(y) -> MustCoolItself(x))", "all x. (Animal(x) & Environment(y) & Temperature(y, z) & BecomesTooHot(z) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & EnvironmentOf(y, x) & Temperature(y, hot)) -> MustCoolItself(x))", "all x. ((Animal(x) & EnvironmentTemperatureIsHot(x)) -> MustCoolItself(x))", "all x. (Animal(x) & Temperature(Environment(x), hot) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & EnvironmentOf(x, y) & TemperatureBecomesTooHot(y)) -> MustCoolItself(x))", "all x. (Animal(x) & Environment(y) & TemperatureTooHot(y) & LivesIn(x, y) -> MustCoolItself(x))", "all x. (Animal(x) & Environment(y) & TooHot(y) & HasEnvironment(x, y) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & EnvironmentOf(y, x) & TooHot(y)) -> MustCoolItself(x))", "all x. (Animal(x) & TooHot(Environment(x)) -> MustCoolItself(x))", "all x. (Animal(x) & Environment(e) & Temperature(e, hot) -> MustCoolItself(x))", "all x. (Animal(x) & TemperatureOfEnvironment(x) = too_hot -> MustCoolItself(x))", "all x. all y. ((Animal(x) & EnvironmentOf(y, x) & Temperature(y, hot)) -> MustCoolItself(x))", "all x. all y. (Animal(x) & Environment(y) & BecomesTooHot(TemperatureOf(y)) -> MustCoolItself(x))", "all x. all y. ((Animal(x) & Environment(y) & BecomesTooHot(Temperature(y))) -> MustCoolItself(x))"]}
{"id": "entailmentbank_validation_530", "nl": "an animal cooling itself is an adaptation to hot temperatures.", "fol": "", "prediction": ["exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "all a. (Animal(a) & CoolsItself(a) -> AdaptationToHotTemperatures(a))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & Cooling(x) & IsAdaptationTo(x, HotTemperatures))", "exists x. (Animal(x) & CoolsItself(x) -> AdaptationToHotTemperatures(x))", "exists x. (Animal(x) & CoolingItself(x) -> AdaptationToHotTemperatures(x))"]}
{"id": "entailmentbank_validation_531", "nl": "an example of adaptations to hot temperatures are panting and sweating.", "fol": "", "prediction": ["exists x. (Adaptation(x, hot_temperatures) & (x = panting | x = sweating))", "exists x. (AdaptationToHotTemperature(x) & (ExampleOf(x, panting) & ExampleOf(x, sweating)))", "exists x. (AdaptationToHotTemperature(x) & (Panting(x) | Sweating(x)))", "Exists x. (Adaptation(x, hot_temperatures) & (Panting(x) | Sweating(x)))", "exists x. (AdaptationToHotTemperatures(x) & (x = Panting | x = Sweating))", "exists x. (AdaptationToHotTemperature(x) & (Panting(x) | Sweating(x)))", "exists x. (AdaptationToHotTemperatures(x) & (x = panting | x = sweating))", "exists x. (AdaptationToHotTemperature(x) & (x = Panting | x = Sweating))", "exists x. (Adaptation(x) & CausedBy(x, HotTemperatures) & (x = Panting | x = Sweating))", "exists x. (AdaptationToHotTemperatures(x) & (Panting(x) | Sweating(x)))", "exists a, b, c, d. (ExampleOfAdaptation(a) & Panting(b) & Sweating(c) & HotTemperature(d) & ToAdaptTo(b, d) & ToAdaptTo(c, d) & PartOf(a, b) & PartOf(a, c))", "exists x. (AdaptationToHotTemperatures(x) & (x = panting | x = sweating))", "exists x. (AdaptationToHotTemperatures(x) & (Panting(x) | Sweating(x)))", "exists x y z. (AdaptationToHotTemperature(x) & example(x, y) & Panting(y) & example(x, z) & Sweating(z))", "exists x. (AdaptationToHotTemperatures(x) & (x = panting | x = sweating))", "exists x. (AdaptationToHotTemperatures(x) & ((x = panting) | (x = sweating)))"]}
{"id": "entailmentbank_validation_532", "nl": "cellular respiration is when a cell converts from oxygen and carbohydrates into carbon dioxide, water, and energy.", "fol": "", "prediction": ["all x. (Cell(x) & ConvertsFrom(x, oxygen, carbohydrates) -> ConvertsTo(x, carbon_dioxide, water, energy))", "CellularRespiration(x) <-> (Cell(x) & Converts(x, oxygen & carbohydrates, carbon_dioxide & water & energy))", "CellularRespiration(cell, oxygen, carbohydrates, carbonDioxide, water, energy) <-> (Converts(cell, oxygen, carbohydrates) & Produces(cell, carbonDioxide, water, energy))", "CellularRespiration(convert(cell, from(oxygen, carbohydrates), into(carbon_dioxide, water, energy)))", "CellularRespiration(x) <-> (Cell(x) & Converts(x, Oxygen, Carbohydrates, CarbonDioxide, Water, Energy))", "CellularRespiration(x) <-> (Cell(x) & ConvertsFromTo(x, {Oxygen, Carbohydrates}, {CarbonDioxide, Water, Energy}))\n\nInterpretation: `CellularRespiration(x)` is defined to be equivalent to the condition where `x` is a cell that is capable of converting oxygen and carbohydrates into carbon dioxide, water, and energy.", "CellularRespiration(x) <-> (Conversion(x) & Exists y. (Cell(y) & ConvertsFrom(y, Oxygen, Carbohydrates, x) & ConvertsTo(y, CarbonDioxide, Water, Energy, x)))", "Exist x y z w e. (Cell(x) & Oxygen(y) & Carbohydrates(z) & Converts(x, y, z) & Produces(x, CarbonDioxide(w), Water(e), Energy(e)))", "CellularRespiration(x) <-> (Cell(x) & Converts(x, {oxygen, carbohydrates}, {carbon_dioxide, water, energy}))", "CellularRespiration(x) <-> (Process(x) & Converts(x, Cell, [Oxygen, Carbohydrates], [CarbonDioxide, Water, Energy]))", "all x. (Cell(x) & Converts(x, [oxygen, carbohydrates], [carbon_dioxide, water, energy]) <-> CellularRespiration(x))", "CellularRespiration(x) <-> (Process(x) & CellConvertsFromTo(x, OxygenAndCarbohydrates, CarbonDioxideAndWaterAndEnergy))", "CellularRespiration(x) <-> (Converts(x, From([Oxygen, Carbohydrates]), To([CarbonDioxide, Water, Energy])) & IsA(x, CellProcess))", "CellularRespiration(x) <-> (Converts(x, Cell(y), {Oxygen, Carbohydrates}, {CarbonDioxide, Water, Energy}))\n\n(Note: This representation assumes `Converts` is a relation involving inputs and outputs of a process described by `x` in the context of `Cell`.)", "FOL Translation:\nall c. (Cell(c) & Process(c, oxygen, carbohydrates, carbon_dioxide, water, energy) <-> CellularRespiration(c))", "all x. (CellularRespiration(x) -> (Produces(x, carbon_dioxide) & Produces(x, water) & Produces(x, energy) & Requires(x, oxygen) & Requires(x, carbohydrates)))"]}
{"id": "entailmentbank_validation_533", "nl": "living things require respiration to use energy.", "fol": "", "prediction": ["FOL Translation:\nall x. (LivingThing(x) -> RequiresRespiration(x, UseEnergy))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationForEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationForEnergyUse(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> Requires(x, respiration, energyUse))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationForEnergy(x))", "all x. (LivingThing(x) -> RequiresRespirationForEnergyUse(x))", "all x. (LivingThing(x) -> RequiresRespirationToUseEnergy(x))", "all x. (LivingThing(x) -> RequiresRespiration(x, UseEnergy(x)))"]}
{"id": "entailmentbank_validation_534", "nl": "living things must convert oxygen into carbon dioxide to use energy.", "fol": "", "prediction": ["all x. (LivingThing(x) -> MustConvertOxygenToCarbonDioxideToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvert(x, oxygen, carbon_dioxide) & UsesEnergy(x))", "all x. (LivingThing(x) -> ConvertsOxygenToCarbonDioxide(x) & ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCarbonDioxide(x, UseEnergy(x)))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> Converts(x, oxygen, carbon_dioxide) & UsesEnergy(x))", "all x. (LivingThing(x) -> MustConvertToUseEnergy(x, oxygen, carbon_dioxide))", "all x. (LivingThing(x) -> MustConvertOxygenIntoCarbonDioxide(x) & UseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenIntoCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCarbonDioxide(x) to UseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCarbonDioxide(x) & UseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCarbonDioxideToUseEnergy(x))", "all x. (LivingThing(x) -> MustConvertOxygenToCO2ForEnergy(x))", "all x. (LivingThing(x) -> MustConvert(x, oxygen, carbon_dioxide, UseEnergy))"]}
{"id": "entailmentbank_validation_535", "nl": "breathing is when animals convert oxygen into carbon dioxide.", "fol": "", "prediction": ["all x. (Animal(x) -> (Breathing(x) <-> ConvertsTo(x, oxygen, carbon_dioxide)))", "all x. (Animal(x) -> (ConvertOxygenIntoCO2(x) <-> Breathing(x)))", "all x. (Animal(x) -> Breathing(x) <-> ConvertsTo(x, oxygen, carbon_dioxide))", "all x. (Breathing(x) <-> (Animal(x) & Converts(x, oxygen, carbon_dioxide)))", "all x. (Animal(x) & Happens(breathing, x) -> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> Breathing(x) <-> ConvertsOxygenToCarbonDioxide(x))", "all x. (Animal(x) -> Breathing(x) <-> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> Breathing(x) <-> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> (Breathing(x) <-> Converts(x, oxygen, carbon_dioxide)))", "all x. (Animal(x) -> Breathing(x) <-> Converts(x, oxygen, carbon_dioxide))", "all x. (Animal(x) -> (Breathing(x) <-> Converts(x, oxygen, carbon_dioxide)))", "all x. (Animal(x) & Breathing(x) -> ConvertsOxygenToCO2(x))", "all x. (Animal(x) -> (Breathing(x) <-> ConvertsOxygenToCO2(x)))", "all x. (Animal(x) -> (exists y. (Breathing(y) & Converts(y, oxygen, carbon_dioxide))))", "all x. (Breathing(x) <-> (Animal(x) & Converts(x, oxygen, carbon_dioxide)))", "all x. (Animal(x) -> (exists y. (Breathes(y) & Converts(y, oxygen, carbon_dioxide))))"]}
{"id": "entailmentbank_validation_536", "nl": "living things must breathe to use energy.", "fol": "", "prediction": ["all x. (LivingThing(x) -> (MustBreathe(x) -> UseEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & UsesEnergy(x)))", "all x. (LivingThing(x) -> (Breathe(x) -> UseEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) -> UseEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) -> CanUseEnergy(x)))", "all x. (LivingThing(x) -> (Breathes(x) <-> UsesEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & UsesEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & UseEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & CanUseEnergy(x)))", "all x. (LivingThing(x) -> (Breathes(x) -> UsesEnergy(x)))", "all x. (LivingThing(x) -> (MustBreathe(x) & UsesEnergy(x)))", "all x. (LivingThing(x) -> (Breathe(x) -> CanUseEnergy(x)))", "all x. (LivingThing(x) & UsesEnergy(x) -> MustBreathe(x))", "all x. (LivingThing(x) -> (Breathe(x) -> UseEnergy(x)))", "all x. (LivingThing(x) -> (Breathe(x) -> UsesEnergy(x)))", "all x. (LivingThing(x) -> (MustBreatheToUseEnergy(x)))"]}
{"id": "entailmentbank_validation_537", "nl": "breathing out is when animals exhale carbon dioxide from their lungs into the air.", "fol": "", "prediction": ["all x. (BreathingOut(x) <-> (Animal(x) & exists y. (CarbonDioxide(y) & Exhale(x, y) & FromLungs(x, y) & IntoAir(y))))", "all x. ((Animal(x) & Exhale(x, carbon_dioxide)) -> BreathingOut(x))", "all x. (Animal(x) & BreathingOut(x) -> exists y. (Exhale(x, y) & CarbonDioxide(y) & From(y, Lungs(x)) & Into(y, Air)))", "all x. (Animal(x) -> (BreathingOut(x) <-> exists y. (CarbonDioxide(y) & Exhale(x, y) & FromLungs(x, y) & IntoAir(y))))", "all x. (BreathingOut(x) <-> (Animal(x) & ExhalesCO2FromLungsIntoAir(x)))", "all a. (Animal(a) & BreathingOut(a) -> exists c, l. (Exhales(a, c) & CarbonDioxide(c) & FromLungs(a, l) & IntoAir(c)))", "all x. (Animal(x) -> BreathingOut(x) <-> Exhales(x, carbon_dioxide) & From(x, lungs) & Into(x, air))", "all x. (Animal(x) & BreathesOut(x) -> exists y. (CarbonDioxide(y) & ExhalesFromLungs(x, y) & IntoAir(y)))", "all x. (BreathingOut(x) & Animal(x) -> exists y. (ExhalesCarbonDioxideFromLungsIntoAir(x, y) & CarbonDioxide(y)))", "all x. (Animal(x) -> (BreathingOut(x) <-> exists y. (CarbonDioxide(y) & Exhale(x, y) & FromTheirLungs(x, y) & IntoAir(y))))", "all x. (Animal(x) -> (BreathingOut(x) <-> (Exhales(x, carbon_dioxide) & FromLungs(x) & IntoAir(x))))", "all x. (BreathingOut(x) <-> exists y. (Animal(y) & Exhales(y, carbon_dioxide) & From(y, Lungs(y)) & Into(y, air)))", "all x. (Animal(x) -> (exists y. (BreathesOut(x, y) & Exhales(x, carbon_dioxide) & FromLungs(x) & IntoAir(y))))", "all x. (Animal(x) -> (BreathingOut(x) <-> (exists y. (Lung(y) & PartOf(y, x) & Exhales(x, carbon_dioxide, y, air)))))", "all x. (Animal(x) -> exists y. (BreathesOut(x, y) & Exhales(x, y, carbondioxide) & FromLungs(x, y) & IntoAir(y)))", "all x. (Animal(x) -> (BreathingOut(x) <-> exists y. (CarbonDioxide(y) & Exhale(x, y) & FromLungs(x, y) & IntoAir(y))))"]}
{"id": "entailmentbank_validation_538", "nl": "animals are a source of carbon dioxide by breathing.", "fol": "", "prediction": ["all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))", "all x. (Animal(x) -> SourceOfCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> SourceOfCO2ByBreathing(x))"]}
{"id": "entailmentbank_validation_539", "nl": "a source of something produces that something.", "fol": "", "prediction": ["all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x, y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. (all y. (SourceOf(x, y) -> Produces(x, y)))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all z. (SourceOf(z, w) -> Produces(z, w))", "all x, y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x. all y. (SourceOf(x, y) -> Produces(x, y))", "all x y. (SourceOf(x, y) -> Produces(x, y))"]}
{"id": "entailmentbank_validation_540", "nl": "animals produce carbon dioxide by breathing.", "fol": "", "prediction": ["all x. (Animal(x) -> ProducesCO2ByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> Produces(x, carbon_dioxide) & ByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxide(x) & ByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCO2ByBreathing(x))", "all x. (Animal(x) -> exists y. (Breathing(x) & Produces(x, carbon_dioxide)))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> exists y. (Breathing(x, y) & ProducesCarbonDioxide(x)))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByBreathing(x))", "all x. (Animal(x) -> ProducesByBreathing(x, carbon_dioxide))"]}
{"id": "entailmentbank_validation_541", "nl": "animals produce carbon dioxide by using energy.", "fol": "", "prediction": ["all x. (Animal(x) & UsesEnergy(x) -> ProducesCarbonDioxide(x))", "all x. (Animal(x) -> ProduceCarbonDioxideByUsingEnergy(x))", "all x. (Animal(x) -> ProducesCarbonDioxideByUsingEnergy(x))", "all a. (Animal(a) -> exists e. (UsesEnergy(a, e) & Produces(a, carbon_dioxide)))", "all x. (Animal(x) -> Produces(x, carbon_dioxide) & UsesEnergy(x))", "all x. (Animal(x) -> exists y. (Energy(y) & ProducesCarbonDioxide(x, y)))", "all x. (Animal(x) -> (UsesEnergy(x) -> ProducesCarbonDioxide(x)))", "all x. (Animal(x) -> exists y. (CarbonDioxide(y) & Produces(x, y) & UsesEnergy(x)))", "all x. (Animal(x) -> ProducesCO2ByUsingEnergy(x))", "all x. (Animal(x) -> ProducesCO2(x) & UsesEnergy(x))", "all x. (Animal(x) & UsesEnergy(x) -> ProducesCO2(x))", "all x. (Animal(x) -> ProducesCarbonDioxide(x) & UsesEnergy(x))", "all x. (Animal(x) & UsesEnergy(x) -> ProducesCarbonDioxide(x))", "all x. (Animal(x) -> exists y. (UtilizesEnergy(x, y) & Produces(x, carbon_dioxide)))", "all x. (Animal(x) -> ProducesCO2ByUsingEnergy(x))", "all x. (Animal(x) -> exists y. (Produce(x, carbon_dioxide) & UseEnergy(x)))"]}
{"id": "entailmentbank_validation_542", "nl": "carbohydrates are used for storing energy.", "fol": "", "prediction": ["all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))", "all x. (Carbohydrate(x) -> UsedForStoringEnergy(x))"]}
{"id": "entailmentbank_validation_543", "nl": "photosynthesis makes energy for the plant by converting carbon dioxide, water, and sunlight into carbohydrates.", "fol": "", "prediction": ["exists p. (all e, c, w, s. ((Photosynthesis(p) & Converts(p, c, w, s, e) & CarbonDioxide(c) & Water(w) & Sunlight(s)) -> EnergyForPlant(e) & Carbohydrates(e)))", "exists x. (Plant(x) & ForAll e. (Energy(e) -> MakesForPlant(photosynthesis, e, x) & Converts(photosynthesis, [CarbonDioxide, Water, Sunlight], Carbohydrates)))", "all x. (Plant(x) -> exists y. (Photosynthesis(y) & Converts(y, carbon_dioxide, water, sunlight, carbohydrates) & MakesEnergyFor(y, x)))", "exists p. (Plant(p) & Process(photosynthesis) & MakesEnergyFor(p, photosynthesis) & all c, w, s, carb. ((CarbonDioxide(c) & Water(w) & Sunlight(s) -> ConvertsInto(photosynthesis, {c, w, s}, carb)) & Carbohydrate(carb)))", "exists x. (Photosynthesis(x) & all y. (Plant(y) -> MakesEnergyFor(x, y) & Converts(x, carbon_dioxide, water, sunlight, carbohydrates)))", "`all p. (Plant(p) & exists c. (CarbonDioxide(c) & exists w. (Water(w) & exists s. (Sunlight(s) & exists b. (Carbohydrate(b) & Photosynthesis(p, c, w, s, b) & MakesEnergyFor(p, b))))))`", "exists p. (Plant(p) & exists e. (Energy(e) & MakesFor(photosynthesis, e, p) & exists c. (ConvertsTo(photosynthesis, c, carbohydrates) & Inputs(c, carbon_dioxide) & Inputs(c, water) & Inputs(c, sunlight))))", "exists p. (Plant(p) & exists c, w, s, e. (CarbonDioxide(c) & Water(w) & Sunlight(s) & Carbohydrates(e) & Photosynthesis(p, c, w, s, e) & MakesEnergyFor(e, p)))", "exists x. (Photosynthesis(x) & all y. (Plant(y) -> MakesEnergyFor(x, y) & Converts(x, CarbonDioxide, Water, Sunlight, Carbohydrates)))", "exists p. (Plant(p) & exists e. (Energy(e) & Makes(photosynthesis, e, p) & exists c. (Carbohydrates(c) & Converts(photosynthesis, carbon_dioxide, water, sunlight, c))))", "exists p. (Plant(p) & exists e. (Energy(e) & PhotosynthesisMakes(e, p) & exists c. (Converts(p, carbon_dioxide, water, sunlight, c) & Carbohydrates(c))))", "exists p. (Plant(p) & exists e. (Energy(e) & MakesByConverting(photosynthesis, e, p, carbon_dioxide, water, sunlight, carbohydrates)))", "`all p. (Plant(p) -> exists e, c, w, s. (Photosynthesis(p, e) & Converts(p, e, c, w, s, carbohydrates)))`", "exists p. (Plant(p) & exists e, c, w, s, carb. (Photosynthesis(p, e, c, w, s, carb) & ProcessConverts(e, c, w, s, carb) & ProducesEnergyFor(e, p) & Input(c, CarbonDioxide) & Input(w, Water) & Input(s, Sunlight) & Output(carb, Carbohydrates)))", "exists x. (Photosynthesis(x) & Converts(x, carbon_dioxide, water, sunlight, carbohydrates) & ProvidesEnergyFor(x, plant))", "exists x. (Plant(x) & Photosynthesis(x) & MakesEnergyFor(x, Energy) & Converts(x, {CarbonDioxide, Water, Sunlight}, Carbohydrates))"]}
{"id": "entailmentbank_validation_544", "nl": "photosynthesis stores energy.", "fol": "", "prediction": ["exists x. (Photosynthesis(x) & StoresEnergy(x))", "PhotosynthesisStoresEnergy.", "all x. (Photosynthesis(x) -> StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "exists y. (Photosynthesis(y) & StoresEnergy(y))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "Exist f. (Photosynthesis(f) & StoresEnergy(f))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "StoresEnergy(photosynthesis)", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "all x. (Photosynthesis(x) -> StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))", "exists x. (Photosynthesis(x) & StoresEnergy(x))"]}
{"id": "entailmentbank_validation_545", "nl": "if something is required to use something else then that something is a source of that something else.", "fol": "", "prediction": ["all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> Source(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x, y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x all y. (RequiredToUse(y, x) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))", "all x y. (RequiredToUse(x, y) -> SourceOf(x, y))"]}
{"id": "entailmentbank_validation_546", "nl": "respiration is a source of energy for living things.", "fol": "", "prediction": ["all x. (LivingThing(x) -> SourceOfEnergyFor(respiration, x))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> exists y. (SourceOfEnergy(y, x) & Respiration(y)))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) & RespirationSourceOfEnergy(x))", "all x. (LivingThing(x) -> SourceOfEnergyFor(respiration, x))", "all x. (LivingThing(x) -> exists y. (Respiration(y) & SourceOfEnergyFor(y, x)))", "all x. (LivingThing(x) -> exists y. (Respiration(y) & SourceOfEnergyFor(y, x)))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> exists y. (SourceOfEnergy(y, x) & Respiration(y)))", "all x. (LivingThing(x) -> exists y. (Respiration(y) & SourceOfEnergyFor(y, x)))", "all x. (LivingThing(x) -> SourceOfEnergy(respiration, x))", "all x. (LivingThing(x) -> exists y. (SourceOfEnergy(y, x) & Respiration(y)))"]}
{"id": "entailmentbank_validation_547", "nl": "if something releases something else then that something is the source of that something else.", "fol": "", "prediction": ["all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x all y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x. all y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> IsSourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x, y. (Releases(x, y) -> SourceOf(x, y))", "all x. all y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))", "all x y. (Releases(x, y) -> SourceOf(x, y))"]}
{"id": "entailmentbank_validation_548", "nl": "respiration releases energy.", "fol": "", "prediction": ["all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "FOL Translation:\nall x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all y. (Respiration(y) -> ReleasesEnergy(y))", "exists x.exists y. (Respiration(x) & Releases(x, y) & Energy(y))", "FOL Translation:\nall x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))", "all x. (Respiration(x) -> ReleasesEnergy(x))"]}
{"id": "entailmentbank_validation_549", "nl": "photosynthesis stores energy and respiration releases energy.", "fol": "", "prediction": ["StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)", "StoresEnergy(photosynthesis) & ReleasesEnergy(respiration)"]}
{"id": "entailmentbank_validation_550", "nl": "digestion is when stomach acid breaks down food.", "fol": "", "prediction": ["all x. (Digestion(x) <-> exists y exists z. (StomachAcid(y) & Food(z) & BreaksDown(y, z)))", "all x. (Digestion(x) <-> exists y, z. (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))", "all x. (Digestion(x) <-> exists y exists z (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))", "all x. (Digestion(x) <-> exists y exists z. (StomachAcid(y) & Food(z) & BreaksDown(y, z)))", "all x. (Digestion(x) <-> exists y. (StomachAcid(y) & BreaksDown(y, x) & Food(x)))", "Digestion(x) <-> exists y exists z exists w. (StomachAcid(y) & Food(z) & BreaksDown(y, z) & Time(w) & HappensAt(y, z, w) & When(x, w))", "all x. (Digestion(x) <-> exists y exists z. (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))", "all x. (Digestion(x) <-> exists y. exists z. (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))", "all x. (Digestion(x) <-> (exists y. (StomachAcid(y) & BreaksDown(y, Food(x)))))", "all x. (Digestion(x) <-> (exists y. (StomachAcid(y) & BreaksDown(y, x) & Food(x))))", "all x. (Digestion(x) <-> exists y. (StomachAcid(y) & BreaksDown(y, Food(x))))", "exists x. (Digestion(x) <-> exists y. (StomachAcid(y) & BreaksDown(y, Food)))", "all x. (Digestion(x) <-> exists y z. (StomachAcid(y) & Food(z) & BreaksDown(y, z)))", "Digestion(x) <-> (exist w. exist y. (StomachAcid(w) & Food(y) & BreaksDown(w, y)))", "exists x. (Digestion(x) <-> (StomachAcid(y) & BreaksDown(y, Food(z))))", "all x. (Digestion(x) <-> exists y z. (StomachAcid(y) & Food(z) & BreaksDown(y, z, x)))"]}
{"id": "entailmentbank_validation_551", "nl": "the digestive system digests food for the body.", "fol": "", "prediction": ["Digests(digestive_system, food, body)", "all x. (DigestiveSystem(x) -> exists y. (Food(y) & Body(z) & DigestsFor(x, y, z)))", "all x. (DigestiveSystem(x) -> exists y. (Food(y) & DigestsFor(x, y, Body)))", "exists x. (DigestiveSystem(x) & exists y. (Body(y) & DigestsFor(x, food, y)))", "all x. (DigestiveSystem(x) -> all y. (Food(y) & PartOfBody(y) -> Digests(x, y)))", "all x. (DigestiveSystem(x) -> all y. (Body(y) -> DigestsFoodFor(x, y)))", "all x. (DigestiveSystem(x) -> exists y. (Food(y) & Body(z) & DigestsFor(x, y, z)))", "Digests(digestive_system, food, body)", "all x. (DigestiveSystem(x) -> exists y. (Food(y) & DigestsFor(x, y, body)))", "Digests(digestive_system, food, body)", "FOL Translation:\nDigestiveSystem(digestive_system) & Body(body) -> DigestsFoodFor(digestive_system, body)", "all x. ((DigestiveSystem(x) & Body(y) & ProvidesFor(x, y)) -> Digests(x, Food(z)))", "FOL Translation:\nall x. (DigestiveSystem(x) -> exists y. (Food(y) & Digests(x, y) & ForBody(y)))", "DigestiveSystem(ds) & Food(f) & Body(b) -> Digests(ds, f, b)", "DigestsFor(digestive_system, food, body)", "DigestsFor(digestive_system, food, body)"]}
{"id": "entailmentbank_validation_552", "nl": "the digestive system breaks down food.", "fol": "", "prediction": ["```plaintext\nall x. (DigestiveSystem(x) -> BreaksDown(x, Food))\n```", "all x. (Food(x) -> BreaksDown(digestive_system, x))", "all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDown(y, x)))", "all x. (Food(x) -> BreaksDown(digestive_system, x))", "all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDown(y, x)))", "all x. (Food(x) -> BreaksDown(digestive_system, x))", "all x. (DigestiveSystem(x) -> BreaksDown(x, food))", "exists d. (DigestiveSystem(d) & all f. (Food(f) -> BreaksDown(d, f)))", "exists x. (DigestiveSystem(x) & all y. (Food(y) -> BreaksDown(x, y)))", "all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDown(y, x)))", "BreaksDown(digestive_system, food)", "all x. (DigestiveSystem(x) -> BreaksDownFood(x))", "BreaksDown(digestive_system, food)", "all x. (Food(x) -> BreaksDown(digestive_system, x))", "BreaksDown(digestive_system, food)", "all x. (Food(x) -> BreaksDown(digestive_system, x))"]}
{"id": "entailmentbank_validation_553", "nl": "if something is made of something else then that something can be broken down into that something else.", "fol": "", "prediction": ["all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x all y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (MadeOf(x, y) -> CanBeBrokenDownInto(x, y))"]}
{"id": "entailmentbank_validation_554", "nl": "if something is made of something else then that something contains that something else.", "fol": "", "prediction": ["all x y. (MadeOf(x, y) -> Contains(x, y))", "all x, y. (MadeOf(x, y) -> Contains(x, y))", "all x. all y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x. all y. (MadeOf(x, y) -> Contains(x, y))", "all x. all y. (MadeOf(x, y) -> Contains(x, y))", "all x. all y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x, y. (MadeOf(x, y) -> Contains(x, y))", "all x, y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))", "all x, y. (MadeOf(x, y) -> Contains(x, y))", "all x y. (MadeOf(x, y) -> Contains(x, y))"]}
{"id": "entailmentbank_validation_555", "nl": "if something contains something else then that something can be broken down into that something else.", "fol": "", "prediction": ["all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x, y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x, y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x, y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))", "all x. all y. (Contains(x, y) -> CanBeBrokenDownInto(x, y))"]}
{"id": "entailmentbank_validation_556", "nl": "the digestive system breaks down food into the substances it contains.", "fol": "", "prediction": ["Exists x. (DigestiveSystem(x) & BreaksDown(x, food, substances(food)))", "all x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDown(digestive_system, x, y)))", "all x. (Food(x) -> exists y. (Substance(y) & BreaksDownInto(digestive_system, x, y)))", "all x. (Food(x) -> exists y. (Substance(y) & BreaksDownInto(digestive_system, x, y)))", "all x. (Food(x) -> exists y. (DigestiveSystemBreaksDown(x, y) & SubstanceContainedIn(y, x)))", "all x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDown(digestive_system, x, y)))", "all x. (Food(x) -> exists y. (Substance(y) & BreaksDown(digestive_system, x, y)))", "all x. (Food(x) & ContainsSubstance(x, y) -> BreaksDownInto(digestive_system, x, y))", "FOL Translation:\nall x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDown(digestive_system, x, y)))", "all x y. ((DigestiveSystem(x) & Food(y)) -> BreaksDown(x, y))", "FOL Translation:\nall x. (DigestiveSystem(x) -> all y. (Food(y) -> exists z. (Substance(z) & BreaksDownInto(x, y, z))))", "FOL Translation:\nall x. (DigestiveSystem(x) -> all y. (Food(y) -> breaksDownInto(x, y, Substances(y))))", "DigestiveSystem(x) & BreaksDown(x, food, y) & Contains(food, y)", "all x. (Food(x) -> exists y. (Substance(y) & Contains(x, y) & BreaksDownInto(digestive_system, x, y)))", "exists x. (DigestiveSystem(x) & all y. (Food(y) -> DecomposesInto(x, y, z) & Substances(y, z)))", "all x. (Food(x) & PartOf(digestive_system, y) & BreaksDown(y, x, SubstancesContained(x)))"]}
{"id": "entailmentbank_validation_557", "nl": "food contains nutrients for living things.", "fol": "", "prediction": ["FOL Translation:\nall x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> ContainsFor(y, z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> ProvidesNutrientsFor(y, z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & For(y, LivingThing(z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> Needs(z, y))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & forLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> For(y, z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(x)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (LivingThing(x) -> exists y. (Food(y) & ContainsNutrients(y, x)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(x)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & all z. (LivingThing(z) -> Nutrients(y, z))))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))", "all x. (Food(x) -> exists y. (Nutrient(y) & Contains(x, y) & ForLivingThings(y)))"]}
{"id": "entailmentbank_validation_558", "nl": "the digestive system breaks down food into nutrients for the body.", "fol": "", "prediction": ["all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDownInto(y, x, NutrientsForBody)))", "all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDownInto(y, x, NutrientsForBody)))", "exists x. (DigestiveSystem(x) & all y. (Food(y) -> exists z. (Nutrients(z) & BreaksDownInto(x, y, z) & ForBody(z))))", "all z. (DigestiveSystem(z) -> all w. (Food(w) -> exists v. (Nutrients(v) & BreaksDown(z, w, v))))", "DigestiveSystem(x) & Food(y) & Body(z) -> BreaksDownInto(x, y, Nutrients(y, z))", "all x. ((DigestiveSystem(x) & BreaksDown(x, y, z) & Food(y) & Nutrients(z)) -> BenefitsBody(z))", "all x. (Food(x) -> exists y. (DigestiveSystem(y) & BreaksDown(y, x) & ProductsBecome(x, NutrientsForBody)))", "all x. (DigestiveSystem(x) -> exists y. (Food(y) -> exists z. (BreaksDown(x, y, z) & Nutrients(z) & ForBody(z))))", "all x. (Food(x) & DigestiveSystem(ds) -> BreaksDownInto(ds, x, Nutrients(n, body)))", "all x. (Food(x) -> exists y. (Nutrient(y) & BreaksDown(digestive_system, x, y) & For(y, body)))", "all x. (DigestiveSystem(x) -> CanBreakDownInto(x, food, nutrients))", "all x. (Food(x) -> exists y. (Nutrient(y) & BreaksDown(digestive_system, x, y) & For(y, body)))", "all x. (DigestiveSystem(x) -> all y. (Food(y) -> exists z. (Nutrients(z) & BreaksDownInto(x, y, z) & ForBody(z))))", "exists x. (DigestiveSystem(x) & all y. (Food(y) -> exists z. (Nutrients(z) & BreaksDownInto(x, y, z) & ForBody(z))))", "exists x. (DigestiveSystem(x) & all y. (Food(y) -> exists z. (Nutrient(z) & BreaksDownInto(x, y, z) & ForTheBody(z))))", "all x. (DigestiveSystem(x) -> BreaksDownFoodIntoNutrients(x))"]}
{"id": "entailmentbank_validation_559", "nl": "scales are a covering around the body of a scaled animal.", "fol": "", "prediction": ["all x. (ScaledAnimal(x) -> exists y. (Scale(y) & CoversBodyOf(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, BodyOf(x))))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, Body(x))))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & CoversBody(y, x)))", "all z. (ScaledAnimal(z) -> exists y. (Scale(y) & CoversAround(y, z)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Covering(y) & AroundBodyOf(y, x) & Scales(y)))", "all x. (ScaledAnimal(x) -> exists y. (Scales(y) & CoversAroundBody(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Covering(y) & AroundBodyOf(y, x) & Scale(y)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & CoversBody(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scales(y) & CoversBodyOf(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scales(y) & CoversBody(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & Covers(y, x)))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & CoversBody(y, x)))"]}
{"id": "entailmentbank_validation_560", "nl": "a fish is a kind of scaled animal.", "fol": "", "prediction": ["all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all z. (Fish(z) -> ScaledAnimal(z))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))", "all x. (Fish(x) -> ScaledAnimal(x))"]}
{"id": "entailmentbank_validation_561", "nl": "fish is a kind of scaled animal with scales covering around the body.", "fol": "", "prediction": ["all x. (Fish(x) -> (ScaledAnimal(x) & ScalesCover(x, Body(x))))", "all x. (Fish(x) -> (ScaledAnimal(x) & ScalesCoverBody(x)))", "all x. (Fish(x) -> ScaledAnimal(x) & HasScales(x) & ScalesCoverBody(x))", "all x. (Fish(x) -> ScaledAnimal(x) & HasScales(x) & Covers(x, Body(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & HasScalesCoveringBody(x)))", "all x. (Fish(x) -> ScaledAnimal(x) & HasScales(x) & ScalesCoverBody(x))", "all x. (Fish(x) -> (ScaledAnimal(x) & HasScalesCoveringBody(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & CoveredWithScales(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & HasScalesCoveringBody(x)))", "FOL Translation:\nall x. (Fish(x) -> (ScaledAnimal(x) & HasScales(x) & Covers(x, Body(x))))", "all x. (Fish(x) -> (ScaledAnimal(x) & HasScalesCoveringBody(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & ScalesCoverAroundBody(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & HasScales(x) & ScalesCoverBody(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & hasScalesCoveringBody(x)))", "all x. (Fish(x) -> (ScaledAnimal(x) & ScalesCoverBody(x)))", "FOL Translation:\nall x. (Fish(x) -> (ScaledAnimal(x) & HasScalesCoveringBody(x)))"]}
{"id": "entailmentbank_validation_562", "nl": "scales are used for protection by scaled animals.", "fol": "", "prediction": ["all x. (ScaledAnimal(x) -> UsedFor(scales, ProtectionBy(x)))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, Scales))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, Scales))", "all x. (ScaledAnimal(x) -> UseForProtection(scales, x))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> UsedForProtection(scales, x))", "all x. (ScaledAnimal(x) -> UsedForProtection(scales, x))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> UsesForProtection(x, scales))", "all x. (ScaledAnimal(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (ScaledAnimal(x) -> UsedForProtection(scales, x))", "all x. (ScaledAnimal(x) -> UsedForProtection(scales, x))", "all x. (ScaledAnimal(x) & ScalesUsedForProtection(x))", "all x. (ScaledAnimal(x) -> UsedForProtection(scales, x))"]}
{"id": "entailmentbank_validation_563", "nl": "scales are used for protection by fish.", "fol": "", "prediction": ["all x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all z. (Fish(z) -> exists y. (Scale(y) & Protects(y, z)))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) & UsesForProtection(x, scales))", "all x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) & HasScales(x) -> UsedForProtection(scales, x))", "all x. (Fish(x) -> UsedForProtectionBy(scales, x))", "FOL Translation:\nall x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) & Scales(x) -> UsedForProtectionBy(Scales(x), x))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtection(y, x)))", "all x. (Fish(x) -> exists y. (Scale(y) & UsedForProtectionBy(y, x)))", "all x. (Fish(x) -> exists y. (Scales(y) & UsedForProtectionBy(y, x)))"]}
{"id": "entailmentbank_validation_564", "nl": "a human is a kind of animal.", "fol": "", "prediction": ["all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))", "all x. (Human(x) -> Animal(x))"]}
{"id": "entailmentbank_validation_565", "nl": "an animal is a kind of living thing.", "fol": "", "prediction": ["all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))", "all x. (Animal(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_566", "nl": "a human is a kind of living thing.", "fol": "", "prediction": ["all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "FOL Translation:\nall x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))", "all x. (Human(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_567", "nl": "a plant is a kind of living thing.", "fol": "", "prediction": ["all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))", "all x. (Plant(x) -> LivingThing(x))"]}
{"id": "entailmentbank_validation_568", "nl": "an apple tree is a kind of plant.", "fol": "", "prediction": ["Plant(apple_tree)", "Plant(apple_tree)", "AppleTree(x) -> Plant(x)", "Plant(apple_tree)", "AppleTree(tree) -> Plant(tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Plant(apple_tree)", "Tree(apple) -> Plant(apple)", "Plant(apple_tree)", "Plant(apple_tree)", "all z. (AppleTree(z) -> Plant(z))", "Plant(apple_tree)"]}
{"id": "entailmentbank_validation_569", "nl": "an apple tree is a kind of living thing.", "fol": "", "prediction": ["LivingThing(apple_tree)", "AppleTree(a) -> LivingThing(a)", "LivingThing(apple_tree)", "all x. (AppleTree(x) -> LivingThing(x))", "LivingThing(apple_tree)", "all x. (AppleTree(x) -> LivingThing(x))", "AppleTree(x) -> LivingThing(x)", "all x. (AppleTree(x) -> LivingThing(x))", "LivingThing(apple_tree)", "Tree(apple_tree) & LivingThing(apple_tree)", "all x. (AppleTree(x) -> LivingThing(x))", "Kind(apple_tree, living_thing)", "Tree(apple_tree) -> LivingThing(apple_tree)", "LivingThing(apple_tree)", "LivingThing(apple_tree)", "LivingThing(apple_tree)"]}
{"id": "entailmentbank_validation_570", "nl": "all living things are made of cells according to the cell theory.", "fol": "", "prediction": ["FOL Translation:\nall x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCellsAccordingToCellTheory(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))", "all x. (LivingThing(x) -> MadeOfCells(x))"]}
{"id": "entailmentbank_validation_571", "nl": "both the human and the apple tree are made of cells.", "fol": "", "prediction": ["MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "Human(h) & AppleTree(a) & MadeOfCells(h) & MadeOfCells(a)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "Human(h) & AppleTree(t) & MadeOfCells(h) & MadeOfCells(t)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)", "MadeOfCells(human) & MadeOfCells(apple_tree)"]}
{"id": "entailmentbank_validation_572", "nl": "a plant cell is a kind of cell.", "fol": "", "prediction": ["Cell(plant_cell)", "Cell(plant_cell) & KindOf(plant_cell, cell)", "Cell(plant_cell)", "Cell(plant_cell)", "Cell(plant_cell)", "Cell(plant_cell)", "Cell(x) & PlantCell(x) -> Cell(x)", "Cell(plant_cell)", "PlantCell(x) -> Cell(x)", "PlantCell(x) -> Cell(x)", "Cell(plant_cell)", "Cell(plant_cell) -> Cell(plant_cell)", "Cell(plant_cell)", "Cell(plant_cell)", "Cell(plant_cell) & KindOf(plant_cell, cell)", "Cell(plant_cell)"]}
{"id": "entailmentbank_validation_573", "nl": "a cell nucleus is a part of a cell.", "fol": "", "prediction": ["exists x. exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "all x. (CellNucleus(x) -> exists y. (Cell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) & exists y. (Cell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) & exists y. (Cell(y) & PartOf(x, y)))", "exists x. (Cell(x) & exists y. (Nucleus(y) & PartOf(y, x)))", "exists x. exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. (Cell(x) & PartOf(cell_nucleus, x))", "exists x, y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) -> exists y. (Cell(y) & PartOf(x, y)))", "exists x exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) -> exists y. (Cell(y) & PartOf(x, y)))", "exists x exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x exists y. (CellNucleus(x) & Cell(y) & PartOf(x, y))", "exists x. (Cell(x) & exists y. (CellNucleus(y) & PartOf(y, x)))"]}
{"id": "entailmentbank_validation_574", "nl": "a cell nucleus is a part of a plant cell.", "fol": "", "prediction": ["exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) -> exists y. (PartOf(x, y) & PlantCell(y)))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) & exists y. (PlantCell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x, y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x. exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x. (CellNucleus(x) & exists y. (PlantCell(y) & PartOf(x, y)))", "exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x, y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) -> exists y. (PlantCell(y) & PartOf(x, y)))", "exists x exists y. (CellNucleus(x) & PlantCell(y) & PartOf(x, y))", "exists x. (CellNucleus(x) & exists y. (PlantCell(y) & PartOf(x, y)))"]}
{"id": "entailmentbank_validation_575", "nl": "a cell wall is a part of a plant cell for supporting and protecting the cell membrane.", "fol": "", "prediction": ["exists x. (CellWall(x) & exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, y) & Protects(x, CellMembrane(y))))", "all x. (CellWall(x) -> exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))", "all x. ((CellWall(x) & PartOf(x, plant_cell)) -> (Supports(x, CellMembrane) & Protects(x, CellMembrane)))", "all x. (CellWall(x) -> exists y. (PartOf(x, y) & PlantCell(y) & Supports(x, y) & Protects(x, CellMembrane(y))))", "all x. (CellWall(x) -> exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))", "exists x. (CellWall(x) -> exists y. (PartOf(x, y) & PlantCell(y) & Supports(x, z) & Protects(x, z) & CellMembrane(z)))", "all x. ((CellWall(x) & PartOf(x, PlantCell)) -> Supports(x, CellMembrane) & Protects(x, CellMembrane))", "all x. ((CellWall(x) & PartOf(x, PlantCell)) -> Supports(x, CellMembrane) & Protects(x, CellMembrane))", "all x. ((CellWall(x) & PartOf(x, PlantCell)) -> (Supports(x, CellMembrane) & Protects(x, CellMembrane)))", "all x. (CellWall(x) -> exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))", "exists x. (CellWall(x) -> exists y. (PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))", "FOL Translation:\nall x. ((CellWall(x) & exists y. (PlantCell(y) & PartOf(x, y))) -> SupportsAndProtects(x, CellMembrane(y)))", "PartOf(cell_wall, plant_cell) & Function(cell_wall, support_cell_membrane) & Function(cell_wall, protect_cell_membrane)", "PartOf(cell_wall, plant_cell) & Purpose(cell_wall, supports_and_protects(cell_membrane))", "exists x exists y. (CellWall(x) & PlantCell(y) & PartOf(x, y) & Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y)))", "all x. ((CellWall(x) & PartOf(x, PlantCell(y))) -> (Supports(x, CellMembrane(y)) & Protects(x, CellMembrane(y))))"]}
{"id": "entailmentbank_validation_576", "nl": "chloroplast is a part of a plant cell.", "fol": "", "prediction": ["PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)", "PartOf(chloroplast, plant_cell)"]}
{"id": "entailmentbank_validation_577", "nl": "a cell nucleus, chloroplast and a cell wall are part of a plant cell.", "fol": "", "prediction": ["all x. ((CellNucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))", "PartOf(cell_nucleus, plant_cell) & PartOf(chloroplast, plant_cell) & PartOf(cell_wall, plant_cell)", "all x. ((CellNucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))", "all x. (CellNucleus(x) -> PartOf(x, PlantCell)) & all y. (Chloroplast(y) -> PartOf(y, PlantCell)) & all z. (CellWall(z) -> PartOf(z, PlantCell))", "all x. ((CellNucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))", "all x. (PlantCell(x) -> exists y exists z exists w. (CellNucleus(y) & PartOf(y, x) & Chloroplast(z) & PartOf(z, x) & CellWall(w) & PartOf(w, x)))", "PartOf(cell_nucleus, plant_cell) & PartOf(chloroplast, plant_cell) & PartOf(cell_wall, plant_cell)", "all x. ((Nucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))", "PartOf(cell_nucleus, plant_cell) & PartOf(chloroplast, plant_cell) & PartOf(cell_wall, plant_cell)", "all x. (PlantCell(x) -> (PartOf(cell_nucleus, x) & PartOf(chloroplast, x) & PartOf(cell_wall, x)))", "PartOf(cell_nucleus, plant_cell) & PartOf(chloroplast, plant_cell) & PartOf(cell_wall, plant_cell)", "all x. (CellNucleus(x) | Chloroplast(x) | CellWall(x) -> PartOf(x, plant_cell))", "PartOf(cell_nucleus, plant_cell) & PartOf(chloroplast, plant_cell) & PartOf(cell_wall, plant_cell)", "inCellNucleus(y, x) & Chloroplast(y, x) & CellWall(y, x) -> PlantCell(x)", "all x. (CellNucleus(x) | Chloroplast(x) | CellWall(x) -> PartOf(x, PlantCell))", "all x. ((Nucleus(x) | Chloroplast(x) | CellWall(x)) -> PartOf(x, PlantCell))"]}
{"id": "entailmentbank_validation_578", "nl": "a computer room is used to control the assembly process in a factory.", "fol": "", "prediction": ["exists x exists y exists z. (ComputerRoom(x) & Factory(z) & UsedToControl(x, y) & AssemblyProcess(y) & In(z, y))", "Exists x. (ComputerRoom(x) & Exists y. (Factory(y) & UsedToControl(x, AssemblyProcess, y)))", "exists x. (ComputerRoom(x) & exists y. (Factory(y) & UsedToControlAssemblyProcessIn(x, y)))", "exists x. (ComputerRoom(x) & UsedToControl(x, assembly_process) & In(x, factory))", "exists x. (ComputerRoom(x) & exists y. (AssemblyProcess(y) & Factory(z) & UsedToControl(x, y, z)))", "exists x. (ComputerRoom(x) & exists y. (Factory(y) & ControlsAssemblyProcess(x, y)))", "exists x. (ComputerRoom(x) & exists y. (AssemblyProcess(y) & exists z. (Factory(z) & UsedToControl(x, y, z))))", "exists x. exists y. (ComputerRoom(x) & AssemblyProcess(y) & UsedToControl(x, y) & InFactory(y))", "exists x. (ComputerRoom(x) & exists y. (Factory(y) & UsedToControl(x, AssemblyProcess(y))))", "exists x. (ComputerRoom(x) & exists y. (Factory(y) & ControlsAssemblyProcess(x, y)))", "exists x. (ComputerRoom(x) & UsedToControl(x, AssemblyProcess) & In(x, Factory))", "exists x, y. (ComputerRoom(x) & Factory(y) & UsedToControlAssemblyProcessIn(x, y))", "exists x. (ComputerRoom(x) & exists y. (UsedToControl(x, y) & AssemblyProcess(y) & exists z. (Factory(z) & InFactory(y, z))))", "exists x. (ComputerRoom(x) & exists y. (AssemblyProcess(y) & Factory(z) & Controls(x, y) & In(z, x)))", "exists x. (exists y. (ComputerRoom(x) & AssemblyProcess(y) & Factory(z) & UsedToControl(x, y, z)))", "exists x. (ComputerRoom(x) & exists y. (AssemblyProcess(y) & Factory(y) & UsedToControl(x, y)))"]}
{"id": "entailmentbank_validation_579", "nl": "the cell nucleus controls many of the functions of the cell.", "fol": "", "prediction": ["exists c. (CellNucleus(c) & all f. (FunctionOfCell(f) -> Controls(c, f)))", "exists x. (CellNucleus(x) -> all y. (CellFunction(y) & FunctionOf(y, z) & PartOf(x, z) -> Controls(x, y)))", "FOL Translation:  \nall x. (Cell(x) & Nucleus(y) & In(x, y) -> Controls(y, x))", "exists x. (CellNucleus(x) & exists y. (Cell(y) & ControlsFunctionsOf(x, y)))", "exists x. (CellNucleus(x) -> all y. (FunctionOfCell(y) & Controls(x, y)))", "exists x. (CellNucleus(x) & exists y. (Cell(y) & Controls(x, y)))", "exists x. (CellNucleus(x) & all y. (FunctionOfCell(y) -> Controls(x, y)))", "exists x. (Cell(x) & exists y. (Nucleus(y) & Controls(y, x)))", "exists x. (CellNucleus(x) -> exists y. (Cell(y) & Controls(x, y)))", "all x. (Cell(x) & Nucleus(y) & PartOf(y, x) -> Controls(y, FunctionsOf(x)))", "exists x. (CellNucleus(x) -> exists y. (Cell(y) & Controls(x, y)))", "exists x. (Cell(x) & exists y. (Nucleus(y) & Controls(y, x) & FunctionsOf(x)))", "exists x. (CellNucleus(x) & all y. (Function(y) & OfTheCell(y) -> Controls(x, y)))", "exists x. (CellNucleus(x) & exists y. (Cell(y) & Controls(x, y)))", "all x. ((CellNucleus(x) & PartOf(x, c)) -> Controls(x, c))", "exists x exists y. (CellNucleus(x) & Cell(y) & Controls(x, y))"]}
{"id": "entailmentbank_validation_580", "nl": "controlling is a kind of function.", "fol": "", "prediction": ["KindOf(controlling, function)", "all x. (Controlling(x) -> Function(x))", "all x. (Controlling(x) -> Function(x))", "KindOf(controlling, function)", "Function(controlling)", "all x. (Controlling(x) -> Function(x))", "Function(controlling)", "Function(controlling)", "all x. (Controlling(x) -> Function(x))", "Function(controlling)", "Function(controlling)", "Function(controlling)", "Function(controlling)", "Function(controlling)", "all x. (Controlling(x) -> Function(x))", "all x. (Controlling(x) -> Function(x))"]}
{"id": "entailmentbank_validation_581", "nl": "a computer room in a factory has a similar function to the cell nucleus in controlling the functions.", "fol": "", "prediction": ["all x y z. ((ComputerRoom(x) & Factory(y) & LocatedIn(x, y) & CellNucleus(z)) -> SimilarFunction(x, z, ControllingFunctions))", "exists x. (ComputerRoom(x) & LocatedIn(x, factory) & exists y. (CellNucleus(y) & SimilarFunction(x, y, ControllingFunctions)))", "exists x exists y exists z exists w. (ComputerRoom(x) & In(y, factory) & SimilarFunction(x, z) & CellNucleus(z) & ControlsFunctions(z, w))", "exists x. (ComputerRoom(x) & InFactory(x) & exists y. (CellNucleus(y) & SimilarFunction(x, y) & ControlsFunctions(x)))", "exists x, y, z. (ComputerRoom(x) & Factory(y) & In(z, y) & SimilarFunction(x, z) & CellNucleus(z) & ControlsFunctions(z))", "exists x, y, z, w. (ComputerRoom(x) & Factory(y) & In(x, y) & CellNucleus(z) & ControlsFunctions(x, w) & ControlsFunctions(z, w))", "exists r, l. (ComputerRoom(r) & InFactory(r) & CellNucleus(l) & SimilarFunction(r, l) & ControlsFunctions(r))", "exists x, y, z, w. (ComputerRoom(x) & InFactory(x, y) & CellNucleus(z) & SimilarFunctionInControllingFunctions(x, z))", "exists x. exists y. (ComputerRoom(x) & Factory(y) & In(y, x) & all f. (Function(f, x) <-> Function(f, CellNucleus)))", "exists x exists y exists z. (ComputerRoom(x) & Factory(y) & Nucleus(z) & SimilarFunction(x, z) & ControlsFunctions(x))", "exists x, y. (ComputerRoom(x) & InFactory(x) & CellNucleus(y) -> SimilarFunction(x, y) & ControlsFunctions(x))", "exists x, y. (ComputerRoom(x) & Factory(y) & In(x, y) & SimilarFunction(x, CellNucleus) & ControlsFunctions(x))", "exists x. ((ComputerRoom(x) & InFactory(x)) -> exists y. ((CellNucleus(y) & SimilarFunction(x, y)) & ControlsFunction(x) & ControlsFunction(y)))", "exists x, y. (ComputerRoom(x) & InFactory(x) & CellNucleus(y) -> SimilarFunction(x, y, ControllingFunctions))", "exists x, y. (ComputerRoom(x) & InFactory(x) & CellNucleus(y) & SimilarFunction(x, y) & ControlsFunctions(x) & ControlsFunctions(y))", "exists x. exists y. (ComputerRoom(x) & InFactory(y) & SimilarFunction(x, CellNucleus) & Controls(x, FactoryFunctions))"]}
{"id": "entailmentbank_validation_582", "nl": "if something does not contain something else, then that something else cannot be found in that something.", "fol": "", "prediction": ["all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x all y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))", "all x y. (-Contains(x, y) -> -FoundIn(y, x))", "all x, y. (-Contains(x, y) -> -FoundIn(y, x))"]}
{"id": "entailmentbank_validation_583", "nl": "a prokaryotic cell does not contain a nucleus.", "fol": "", "prediction": ["all x. (ProkaryoticCell(x) -> -ContainsNucleus(x))", "all x. (ProkaryoticCell(x) -> -ContainsNucleus(x))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -ContainsNucleus(x))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, Nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, Nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "all x. (ProkaryoticCell(x) -> -Contains(x, nucleus))", "ProkaryoticCell(x) -> -Contains(x, nucleus)"]}
{"id": "entailmentbank_validation_584", "nl": "a nucleus cannot be found in prokaryotic cells.", "fol": "", "prediction": ["all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "FOL Translation:\nall x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))", "all x. (ProkaryoticCell(x) -> -exists y. (Nucleus(y) & FoundIn(y, x)))"]}
{"id": "entailmentbank_validation_585", "nl": "photosynthesis makes food for the plant.", "fol": "", "prediction": ["exists x. (Plant(x) -> MakesFoodFor(photosynthesis, x))", "FOL Translation:\nall x. (Plant(x) -> PhotosynthesisMakesFoodFor(x))", "MakesFoodFor(photosynthesis, plant)", "exists x. exists y. (Plant(y) & Photosynthesis(x) & MakesFoodFor(x, y))", "exists x. (Plant(x) & PhotosynthesisMakesFoodFor(x))", "exists x. (Plant(x) & PhotosynthesisMakesFoodFor(x))", "exists p. (Plant(p) & MakesFoodFor(photosynthesis, p))", "exists x. (Plant(x) -> MakesFoodFor(Photosynthesis, x))", "exists x. (Photosynthesis(x) & all y. (Plant(y) -> MakesFoodFor(x, y)))", "`all x. (Plant(x) -> PhotosynthesisMakesFoodFor(x))`", "exists x. (Plant(x) & MakesFoodFor(photosynthesis, x))", "exists x. (Plant(x) & MakesFoodFor(photosynthesis, x))", "exists x. exists y. (Photosynthesis(x) & Food(y) & MakesFor(x, y, plant))", "exists x. (Plant(x) -> MakesFoodFor(photosynthesis, x))", "exists x. (Photosynthesis(x) & MakesFoodForPlant(x))", "exists x. (Plant(x) & MakesFoodFor(photosynthesis, x))"]}
{"id": "entailmentbank_validation_586", "nl": "a leaf performs photosynthesis / gas exchange.", "fol": "", "prediction": ["all z. (Leaf(z) -> (PerformsPhotosynthesis(z) & PerformsGasExchange(z)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) / PerformsGasExchange(x)))", "all x. (Leaf(x) -> Performs(x, photosynthesis_gas_exchange))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "Leaf(x) -> PerformsPhotosynthesis(x) & PerformsGasExchange(x)", "all x. ((Leaf(x) -> Performs(x, photosynthesis)) & (Leaf(x) -> Performs(x, gas_exchange)))", "all x. (Leaf(x) -> PerformsPhotosynthesis(x) & PerformsGasExchange(x))", "exists x. (Leaf(x) & (Performs(x, photosynthesis) & Performs(x, gas_exchange)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "all x. (Leaf(x) -> PerformsPhotosynthesis(x) | PerformsGasExchange(x))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) | PerformsGasExchange(x)))", "all x. (Leaf(x) -> PerformsPhotosynthesis(x) | PerformsGasExchange(x))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) | PerformsGasExchange(x)))", "all x. (Leaf(x) -> (PerformsPhotosynthesis(x) & PerformsGasExchange(x)))", "all x. (Leaf(x) -> PerformsPhotosynthesis(x) | PerformsGasExchange(x))"]}
{"id": "entailmentbank_validation_587", "nl": "a leaf makes food for the plant by performing photosynthesis.", "fol": "", "prediction": ["exists x. (Leaf(x) & Plant(y) & MakesFoodFor(x, y) & Performs(x, Photosynthesis))", "exists x. (Leaf(x) & MakesFoodForPlant(x) & PerformsPhotosynthesis(x))", "exists x. (Leaf(x) & makesFoodFor(x, plant) & PerformsPhotosynthesis(x))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & Performs(x, Photosynthesis)))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & Plant(y) & MakesFoodFor(x, y) & Performs(x, Photosynthesis))", "exists x. (Leaf(x) & Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x))", "exists x. (Leaf(x) & MakesFoodForPlant(x) & PerformsPhotosynthesis(x))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & all y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & makesFoodFor(x, plant) & Performs(x, photosynthesis))", "exists x. (Leaf(x) -> MakesFoodForPlant(x, plant) & Performs(x, Photosynthesis))", "exists x. (Leaf(x) & Plant(y) & MakesFoodFor(x, y) & Performs(x, Photosynthesis))", "exists x. (Leaf(x) & exists y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & all y. (Plant(y) & MakesFoodFor(x, y) & PerformsPhotosynthesis(x)))"]}
{"id": "entailmentbank_validation_588", "nl": "providing food is a kind of specific life process.", "fol": "", "prediction": ["SpecificLifeProcess(providing_food)", "LifeProcess(providing_food)", "KindOf(ProvidingFood, SpecificLifeProcess)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "SpecificLifeProcess(providing_food)", "KindOf(SpecificLifeProcess(providing_food), LifeProcess)", "KindOf(providing_food, specific_life_process)", "SpecificLifeProcess(providing_food)"]}
{"id": "entailmentbank_validation_589", "nl": "a leaf performs a specific life process of making food for the plants.", "fol": "", "prediction": ["FOL Translation:\nexists x. (Leaf(x) & Performs(x, MakingFoodForPlants))", "exists x. (Leaf(x) & PerformsSpecificLifeProcess(x, MakingFoodForPlants))", "exists x. (Leaf(x) & PerformsLifeProcess(x, make_food_for_plants))", "exists x. (Leaf(x) & PerformsLifeProcess(x, MakingFood) & For(x, Plants))", "exists x. (Leaf(x) & Performs(x, MakingFoodForPlants))", "exists x. (Leaf(x) & Performs(x, SpecificLifeProcess) & MakesFoodForPlants(x))", "exists x. (Leaf(x) & PerformsLifeProcess(x) & MakesFoodForPlants(x))", "exists x. (Leaf(x) & PerformsLifeProcess(x, MakingFoodForPlants))", "exists x. (Leaf(x) & PerformsLifeProcess(x) & MakesFoodForPlants(x))", "exists x. (Leaf(x) & PerformsLifeProcess(x, MakingFood) & ForPlants(MakingFood))", "exists x. (Leaf(x) & Performs(x, MakeFoodForPlants))", "exists x. (Leaf(x) & PerformsLifeProcess(x) & MakesFoodForPlants(x))", "exists x. (Leaf(x) & PerformLifeProcess(x) & MakeFoodForPlants(x))", "exists x. (Leaf(x) & PerformsLifeProcess(x, MakingFoodForPlants))", "exists x. (Leaf(x) & PerformsSpecificLifeProcess(x, MakingFoodForPlants))", "exists x. (Leaf(x) & PerformsLifeProcess(x, make_food_for_plants))"]}
{"id": "entailmentbank_validation_590", "nl": "organs perform specific life process in organisms.", "fol": "", "prediction": ["all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all o. (Organ(o) -> exists p. (LifeProcess(p) & Performs(o, p) & exists x. (Organism(x) & In(o, x))))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & Performs(x, y, SpecificLifeProcess)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & Performs(x, SpecificLifeProcess, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcessIn(x, y)))", "all x. (Organ(x) -> (exists y. (Organism(y) & PerformsLifeProcess(x, y))))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsSpecificLifeProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))", "all x. (Organ(x) & exists y. (Organism(y) & PartOf(x, y)) -> exists z. (LifeProcess(z) & Performs(x, z)))", "all x. (Organ(x) & Exists y. (Organism(y) & In(x, y)) -> exists z. (LifeProcess(z) & Performs(x, z)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsProcess(x, y)))", "all x. (Organ(x) -> exists y. (Organism(y) & PerformsLifeProcess(x, y)))"]}
{"id": "entailmentbank_validation_591", "nl": "a leaf in a plant is performing like an organ in organisms.", "fol": "", "prediction": ["exists x. exists y. exists z. (Leaf(x) & InPlant(x, y) & Plant(y) & Organ(z) & InOrganisms(z) & PerformsLike(x, z))", "exists x, y, z. (Leaf(x) & In(y, z) & Plant(y) & Organ(z) & OrganLike(x, z))", "exists x. (Leaf(x) & InPlant(x) & exists y. (Organ(y) & InOrganisms(y) & PerformsLike(x, y)))", "exists x. exists y. exists z. (Plant(y) & Leaf(x) & In(Organs(z), Organism(z)) & PerformsLike(x, z))", "exists x, y, z. (Leaf(x) & In(y, z) & Plant(y) & Organ(z) & Organism(z) & PerformsLike(x, z))", "exists x, y, z. (Leaf(x) & InPlant(x, y) & Plant(y) & Organ(z) & InOrganism(z) & PerformsLike(x, z))", "exists x, y, z, w. (Leaf(x) & InPlant(x, y) & Plant(y) & Like(x, z) & Organ(z) & InOrganism(z, w) & Organism(w))", "exists x. exists y. exists z. (Leaf(x) & InPlant(x, y) & Plant(y) & OrganLike(x, z) & Organ(z) & InOrganisms(z))", "Translate the sentence into first-order logic:\n\nexists l. exists p. exists o. (Leaf(l) & Plant(p) & Organ(o) & In(l, p) & PerformsLike(l, o))", "exists x. (Leaf(x) & InPlant(x) & exists y. (Organ(y) & InOrganisms(y) & PerformsLike(x, y)))", "exists x exists y. (Leaf(x) & Plant(y) & PartOf(x, y) & exists z exists w. (Organ(z) & Organism(w) & PartOf(z, w) & PerformsLike(x, z)))", "exists x, y, z, w. (Leaf(x) & InPlant(x, y) & Organ(z) & InOrganism(z, w) & PerformsLike(x, z))", "exists x. exists y. (Leaf(x) & In(Plant(y), x) & PerformingLike(x, z) & Organ(z) & InOrganisms(z))", "all x. (((Leaf(x) & PartOf(x, y) & Plant(y)) -> exists z. (Organ(z) & Organism(w) & PartOf(z, w) & PerformsLike(x, z))))", "exists x, y, z. (Leaf(x) & InPlant(x, y) & Organ(z) & InOrganism(z) & PerformsLike(x, z))", "exists x. exists y. (Leaf(x) & Plant(y) & InPlant(x, y) & exists z. (Organ(z) & InOrganisms(z) & PerformsLike(x, z)))"]}
{"id": "entailmentbank_validation_592", "nl": "taking in carbon dioxide is a stage in the photosynthesis process.", "fol": "", "prediction": ["Stage(take_in_carbon_dioxide, photosynthesis_process)", "exists y. (StageInPhotosynthesis(y) & TakesIn(y, carbon_dioxide))", "StageInPhotosynthesis(taking_in_carbon_dioxide)", "StageInPhotosynthesis(taking_in_carbon_dioxide)", "exists x. (Stage(x, photosynthesis) & TakesInCarbonDioxide(x))", "all x. (PhotosynthesisProcess(x) -> exists y. (Stage(y, x) & TakesIn(y, carbon_dioxide)))", "all x. (StageInPhotosynthesis(x) -> (exists y. (TakingIn(y, carbon_dioxide) & PartOf(y, x))))", "StageInPhotosynthesis(taking_in_carbon_dioxide)", "exists x. (StageInPhotosynthesis(x) & TakesInCarbonDioxide(x))", "StageInProcess(take_in_carbon_dioxide, photosynthesis)", "StageInPhotosynthesisProcess(taking_in_carbon_dioxide)", "`exists x exists y. (Stage(x, PhotosynthesisProcess(y)) & TakesInCarbonDioxide(x))`", "exists x. (StageInPhotosynthesis(x) & TakesInCarbonDioxide(x))", "exists x. (StageInPhotosynthesis(x) & TakingInCarbonDioxide(x))", "exists x. (Stage(x) & Process(x, photosynthesis) & TakesIn(x, carbon_dioxide))", "exists z. (Stage(z, PhotosynthesisProcess) & TakesIn(z, CarbonDioxide))"]}
{"id": "entailmentbank_validation_593", "nl": "absorbing something is a kind of method for taking something in.", "fol": "", "prediction": ["all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x y. (Absorbing(x, y) -> IsMethodForTakingIn(x, y))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "FOL Translation:\nall x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))", "all x. (Absorbing(x) -> MethodForTakingIn(x))"]}
{"id": "entailmentbank_validation_594", "nl": "absorbing carbon dioxide is a stage in the photosynthesis process.", "fol": "", "prediction": ["StageInPhotosynthesis(absorbing_carbon_dioxide)", "Stage(absorbing_carbon_dioxide, photosynthesis_process)", "StageInPhotosynthesisProcess(absorbing_carbon_dioxide)", "Stage(absorbing_carbon_dioxide, photosynthesis_process)", "StageInProcess(absorb_carbon_dioxide, photosynthesis)", "Stage(absorbing_carbon_dioxide, photosynthesis_process)", "exists x. (Stage(x) & InProcess(x, photosynthesis) & Absorbs(x, carbon_dioxide))", "Stage(absorbing_carbon_dioxide, photosynthesis_process)", "Stage(inabsorbing_carbon_dioxide, photosynthesis_process)", "exists x. (StageInProcess(x, photosynthesis) & Absorbing(x, carbon_dioxide))", "Stage(absorbing_carbon_dioxide, photosynthesis_process)", "exists x. (StageOf(x, photosynthesis_process) & AbsorbingCarbonDioxide(x))", "exists y. (Stage(y) & InProcess(y, photosynthesis) & AbsorbsCarbonDioxide(y))", "StageInProcess(absorbing_carbon_dioxide, photosynthesis_process)", "StageInPhotosynthesis(absorbing_carbon_dioxide)", "StageInProcess(absorbing_carbon_dioxide, photosynthesis_process)"]}
{"id": "entailmentbank_validation_595", "nl": "carbon dioxide can be found in the air.", "fol": "", "prediction": ["exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (CarbonDioxide(x) & FoundIn(x, air))", "exists x. (CarbonDioxide(x) & CanBeFoundIn(x, air))", "exists x. (CarbonDioxide(x) & CanBeFoundIn(x, air))", "exists x. (Air(x) & Found(carbon_dioxide, x))", "exists x. (CarbonDioxide(x) & FoundIn(x, air))", "exists x. (CarbonDioxide(x) & CanBeFoundIn(x, air))", "exists x. (CarbonDioxide(x) & FoundIn(x, air))", "exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (Air(x) & FoundIn(carbon_dioxide, x))", "exists x. (CarbonDioxide(x) & CanBeFoundIn(x, air))", "exists x. (CarbonDioxide(x) & CanBeFoundIn(x, air))", "exists x. (CarbonDioxide(x) & FoundIn(x, air))", "exists x. (CarbonDioxide(x) & FoundInAir(x))", "exists x. (CarbonDioxide(x) & FoundIn(x, air))"]}
{"id": "entailmentbank_validation_596", "nl": "absorbing carbon dioxide from the air is a stage in the photosynthesis process.", "fol": "", "prediction": ["FOL Translation:\nStageInPhotosynthesis(AbsorbCO2FromAir)", "StageInPhotosynthesis(AbsorbingCarbonDioxideFromAir)", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "`PhotosynthesisStage(absorbCarbonDioxideAir)`", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "StageInPhotosynthesis(AbsorbCarbonDioxideFromAir)", "StageInPhotosynthesis(AbsorbCO2FromAir)", "Stage(x, photosynthesis) & Absorb(x, carbon_dioxide, air)", "exists x. (Stage(x) & AbsorbingCarbonDioxideFromAir(x) & InPhotosynthesisProcess(x))", "Exists y. (AbsorbingCarbonDioxide(y) & StageInPhotosynthesis(y))", "exists x. (Stage(x, photosynthesis_process) & AbsorbsCO2FromAir(x))", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "StageInPhotosynthesis(AbsorbCO2FromAir)", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)", "StageInPhotosynthesis(absorbing_carbon_dioxide_from_air)"]}
{"id": "entailmentbank_validation_597", "nl": "plants perform photosynthesis.", "fol": "", "prediction": ["all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all z. (Plant(z) -> PerformPhotosynthesis(z))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))", "all x. (Plant(x) -> PerformsPhotosynthesis(x))"]}
{"id": "entailmentbank_validation_598", "nl": "a plant absorbs carbon dioxide from the air to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & FromAir(y) & Absorbs(x, y) & CanPerformPhotosynthesis(x)))", "exists x. (Plant(x) -> (exists y. (CarbonDioxide(y) & Absorbs(x, y))) & FromAir(y) & ToPerform(x, Photosynthesis))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & FromAir(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & Air(z) & AbsorbsFrom(x, y, z) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & FromAir(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> (exists y. (CarbonDioxide(y) & Absorbs(x, y) & FromAir(y))) & PerformsPhotosynthesis(x))", "exists x. (Plant(x) -> (Absorbs(x, carbon_dioxide) & From(x, air) & Performs(x, photosynthesis)))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & From(y, air) & Absorbs(x, y) & Performs(x, Photosynthesis)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & FromAir(y) & Absorbs(x, y) & ForPerformingPhotosynthesis(x, y)))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & Absorbs(x, y) & FromAir(y) & CanPerformPhotosynthesis(x)))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & Air(z) & From(y, z) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> (exists y. (CarbonDioxide(y) & FromAir(y, x) & Absorbs(x, y)) & CanPerformPhotosynthesis(x)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & FromAir(z) & PerformPhotosynthesis(x) & Absorbs(x, y, z)))", "exists x. (Plant(x) & exists y. (CarbonDioxide(y) & From(y, air) & Absorbs(x, y) & CanPerformPhotosynthesis(x)))", "exists x. (Plant(x) -> exists y. (CarbonDioxide(y) & Source(y, air) & Absorbs(x, y) & Performs(x, Photosynthesis)))", "exists x. (Plant(x) & Absorbs(x, carbon_dioxide) & From(x, air) & Performs(x, photosynthesis))"]}
{"id": "entailmentbank_validation_599", "nl": "when carbon dioxide in the atmosphere is absorbed by plants, the amount of carbon dioxide in the atmosphere is reduced in the atmosphere.", "fol": "", "prediction": ["all x. (AtmosphericCO2(x) & AbsorbedByPlants(x) -> ReducedCO2Amount(x))", "all x. (AtmosphereContains(carbon_dioxide, x) & AbsorbedBy(carbon_dioxide, plants) -> ReducedAmount(carbon_dioxide, atmosphere))", "exists x, y. (CarbonDioxide(x) & Atmosphere(y) & AbsorbedBy(x, y, Plants) -> ReducedInAtmosphere(x, y))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedBy(x, plants) -> Reduced(x, atmosphere))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & IsAbsorbedByPlants(x) -> ReducedAmount(x, atmosphere))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedByPlants(x) -> ReducedInAtmosphere(x))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedBy(x, plants) -> ReducedInAtmosphere(x))", "all x y. ((CarbonDioxide(x) & Atmosphere(y) & AbsorbedBy(x, Plants)) -> ReducedAmount(x, y))", "FOL Translation:\nall x, y. (CarbonDioxide(x) & Atmosphere(y) & AbsorbedBy(x, plants) -> ReducedInAtmosphere(x, y))", "exists x, y. (CarbonDioxide(x) & InAtmosphere(x, y) & AbsorbedBy(x, plants) -> ReducedAmount(x, y))", "exists x. (CarbonDioxide(x) & Atmosphere(y) & InAtmosphere(x, y) & AbsorbedBy(x, Plants) -> ReducedAmountIn(y, x))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedByPlants(x) -> ReducedInAtmosphere(x))", "all x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedByPlants(x) -> ReducedInAtmosphere(x))", "all x y. ((CarbonDioxide(x) & Atmosphere(y) & AbsorbedBy(x, plants)) -> ReducedAmount(x, y))", "all x. (CarbonDioxideInAtmosphere(x) & AbsorbedBy(x, plants) -> ReducedAmount(x, atmosphere))", "exists x. (CarbonDioxide(x) & InAtmosphere(x) & AbsorbedBy(x, plants) -> ReducedInAtmosphere(x))"]}
{"id": "entailmentbank_validation_600", "nl": "plant photosynthesis reduces the amount of carbon dioxide in the air.", "fol": "", "prediction": ["exists x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(x, carbon_dioxide, air))", "all x. (Plant(x) & PerformsPhotosynthesis(x) -> ReducesCO2InAir(x))", "exists x. (Plant(x) & Photosynthesis(x) -> ReducesCarbonDioxideInAir(x))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesCarbonDioxide(x, air))", "all x. (Plant(x) & PerformsPhotosynthesis(x) -> ReducesCarbonDioxide(x, air))", "exists x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "exists x. (PlantPhotosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "exists x. (Plant(x) & Photosynthesis(x) -> ReducesAmount(x, carbon_dioxide, air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesCarbonDioxideInAir(x))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOfCO2InAir(x))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesCO2InAir(x))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(carbon_dioxide, air))", "all x. (Plant(x) & Photosynthesis(x) -> ReducesAmountOf(CO2, Air))", "exists p. (Plant(p) & Photosynthesis(p) -> Reduces(p, CarbonDioxide, Air))"]}
{"id": "entailmentbank_validation_601", "nl": "sunlight is a kind of solar energy.", "fol": "", "prediction": ["KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "IsKindOf(sunlight, solar_energy)", "KindOf(sunlight, solar_energy)", "Kind(sunlight, solar_energy)", "Kind(sunlight, solar_energy)"]}
{"id": "entailmentbank_validation_602", "nl": "photosynthesis means green plants convert from carbon dioxide and water and solar energy into carbohydrates and food and oxygen for themselves.", "fol": "", "prediction": ["all x. (GreenPlant(x) & PerformsPhotosynthesis(x) -> Converts(x, (CarbonDioxide & Water & SolarEnergy), (Carbohydrates & Food & Oxygen) & For(x)))", "all x. (GreenPlant(x) & Photosynthesis(x) -> Converts(x, [CarbonDioxide, Water, SolarEnergy], [Carbohydrates, Food, Oxygen]))", "Photosynthesis(x) -> (GreenPlant(x) & Converts(x, [CarbonDioxide, Water, SolarEnergy], [Carbohydrates, Food, Oxygen]))", "Means(photosynthesis, \n    all x. ((GreenPlant(x) & \n    ConvertsFrom(x, carbon_dioxide) & \n    ConvertsFrom(x, water) & \n    ConvertsFrom(x, solar_energy) & \n    ConvertsInto(x, carbohydrates) & \n    ConvertsInto(x, food) & \n    ConvertsInto(x, oxygen)) -> ForThemselves(x)))", "all x. (GreenPlant(x) -> (PhotosynthesisMeans(x) <-> (Converts(x, [CarbonDioxide, Water, SolarEnergy], [Carbohydrates, Food, Oxygen]))))", "FOL Translation:\n\nall x. (GreenPlant(x) & PhotosynthesisMeansConversion(x) -> (Converts(x, CarbonDioxide) & Converts(x, Water) & Converts(x, SolarEnergy) -> ConvertsInto(x, Carbohydrates) & ConvertsInto(x, Food) & ConvertsInto(x, Oxygen) & ForThemselves(x)))", "Photosynthesis is a complex process to translate directly into simple FOL due to its intricate nature and multiple components involved. However, a simplified representation might look like:\n\nFOL Translation:\nall x. (GreenPlant(x) & Photosynthesis(x) -> exists y, z, w. (Carbohydrates(y) & Food(z) & Oxygen(w) & ConvertsFrom(x, CarbonDioxide(x), Water(x), SolarEnergy(x), y, z, w)))", "Photosynthesis(green_plants) <-> (all x. (GreenPlant(x) -> Converts(x, carbon_dioxide, water, solar_energy, carbohydrates, food, oxygen, x)))", "GreenPlant(x) -> (PerformsPhotosynthesis(x) <-> Converts(x, [CarbonDioxide, Water, SolarEnergy], [Carbohydrates, Food, Oxygen]))", "all x. (GreenPlant(x) & PerformsPhotosynthesis(x) -> Converts(x, (CarbonDioxide, Water, SolarEnergy), (Carbohydrates, Food, Oxygen)))", "FOL Translation:\nall x. (GreenPlant(x) & Photosynthesis(x) -> (Converts(x, CarbonDioxide, Water, SolarEnergy, Carbohydrates, Food, Oxygen) & ForThemselves(x)))", "exists x. (GreenPlant(x) -> (PhotosynthesisMeans(x) <-> ((Converts(x, CarbonDioxide) & Converts(x, Water) & Converts(x, SolarEnergy)) -> (Produces(x, Carbohydrates) & Produces(x, Food) & Produces(x, Oxygen)))))", "all x. (GreenPlant(x) -> (Photosynthesis(x) <-> (Converts(x, CarbonDioxide, Water, SolarEnergy, Carbohydrates, Food, Oxygen))))", "Photosynthesis(x) <-> all y. (GreenPlant(y) -> Converts(y, CarbonDioxide, Water, SolarEnergy, Carbohydrates, Food, Oxygen, y))", "all x. (GreenPlant(x) -> PhotosynthesisMeans(Converts(x, {carbon_dioxide, water, solar_energy}, {carbohydrates, food, oxygen})))", "Photosynthesis is a complex process, and translating it into a first-order logic expression requires identifying the relevant predicates. Here is a possible translation:\n\nFOL Translation:\nall x. (GreenPlant(x) & Photosynthesis(x) -> (converts(x, CarbonDioxide, Water, SolarEnergy, Carbohydrates) & converts(x, CarbonDioxide, Water, SolarEnergy, Food) & converts(x, CarbonDioxide, Water, SolarEnergy, Oxygen)))"]}
{"id": "entailmentbank_validation_603", "nl": "photosynthesis means plants convert carbon dioxide and water and sunlight into carbohydrates and food and oxygen.", "fol": "", "prediction": ["all x. (Plant(x) -> (Photosynthesis(x) <-> (Converts(x, carbon_dioxide) & Converts(x, water) & Converts(x, sunlight) -> Converts(x, carbohydrates) & Converts(x, food) & Converts(x, oxygen))))", "all x. (Plant(x) -> (Converts(x, carbon_dioxide, carbohydrates) & Converts(x, water, carbohydrates) & Converts(x, sunlight, carbohydrates) & Converts(x, carbon_dioxide, food) & Converts(x, water, food) & Converts(x, sunlight, food) & Converts(x, carbon_dioxide, oxygen) & Converts(x, water, oxygen) & Converts(x, sunlight, oxygen)))", "FOL Translation:\nall x. (Photosynthesis(x) -> (PlantsConvert(x, carbon_dioxide, water, sunlight, carbohydrates) & PlantsConvert(x, carbon_dioxide, water, sunlight, food) & PlantsConvert(x, carbon_dioxide, water, sunlight, oxygen)))", "Means(photosynthesis, all x. (Plant(x) -> (Converts(x, carbon_dioxide, carbohydrates) & Converts(x, water, carbohydrates) & Converts(x, sunlight, carbohydrates) & Converts(x, carbon_dioxide, food) & Converts(x, water, food) & Converts(x, sunlight, food) & Converts(x, carbon_dioxide, oxygen) & Converts(x, water, oxygen) & Converts(x, sunlight, oxygen))))", "all x. (Photosynthesis(x) -> (exists y, z, u, v, w. (Plant(y) & CarbonDioxide(z) & Water(u) & Sunlight(v) & PhotosynthesisConverts(y, z, u, v, Carbohydrates(w)) & PhotosynthesisConverts(y, z, u, v, Food(w)) & PhotosynthesisConverts(y, z, u, v, Oxygen(w)))))", "all x. (Photosynthesis(x) -> (Plant(x) -> (Converts(x, carbon_dioxide, carbohydrates) & Converts(x, water, carbohydrates) & Converts(x, sunlight, carbohydrates) & Converts(x, carbon_dioxide, food) & Converts(x, water, food) & Converts(x, sunlight, food) & Converts(x, carbon_dioxide, oxygen) & Converts(x, water, oxygen) & Converts(x, sunlight, oxygen))))", "Photosynthesis(all x. (Plant(x) -> (Converts(x, carbon_dioxide, carbohydrates) & Converts(x, water, carbohydrates) & Converts(x, sunlight, carbohydrates) & Converts(x, carbon_dioxide, food) & Converts(x, water, food) & Converts(x, sunlight, food) & Converts(x, carbon_dioxide, oxygen) & Converts(x, water, oxygen) & Converts(x, sunlight, oxygen))))", "Means(photosynthesis, all p. (Plant(p) -> Converts(p, carbon_dioxide, water, sunlight, carbohydrates, food, oxygen)))", "all x. (Process(x) & Photosynthesis(x) -> Converts(plants, carbon_dioxide, water, sunlight, carbohydrates) & Converts(plants, carbon_dioxide, water, sunlight, food) & Converts(plants, carbon_dioxide, water, sunlight, oxygen))", "all x. (Photosynthesis(x) -> (exists y. (Plant(y) & Converts(y, carbon_dioxide, water, sunlight, carbohydrates, food, oxygen))))", "all x. (Photosynthesis(x) -> (Plant(x) & Converts(x, carbon_dioxide, carbohydrates) & Converts(x, water, carbohydrates) & Converts(x, sunlight, carbohydrates) & Converts(x, carbon_dioxide, food) & Converts(x, water, food) & Converts(x, sunlight, food) & Converts(x, carbon_dioxide, oxygen) & Converts(x, water, oxygen) & Converts(x, sunlight, oxygen)))", "all x. (PhotosynthesisProcess(x) -> (exists y. (Plant(y) & Converts(y, CarbonDioxide, Water, Sunlight, Carbohydrates, Food, Oxygen))))", "all x. (Plant(x) -> (Photosynthesis(x) <-> Converts(x, carbon_dioxide, water, sunlight, carbohydrates, food, oxygen)))", "all p. (Plant(p) -> (PhotosynthesisMeans(p) <-> (Converts(p, carbon_dioxide) & Converts(p, water) & Converts(p, sunlight) & ConvertsInto(p, carbohydrates) & ConvertsInto(p, food) & ConvertsInto(p, oxygen))))", "Means(photosynthesis, all x. ((Plant(x) & Consumes(x, carbon_dioxide) & Consumes(x, water) & Consumes(x, sunlight)) -> Produces(x, carbohydrates) & Produces(x, food) & Produces(x, oxygen)))", "Means(photosynthesis, all x. (Plant(x) -> exists y. (CarbonDioxide(y) & Water(y) & Sunlight(y) & Converts(x, y, Carbohydrates) & Converts(x, y, Food) & Converts(x, y, Oxygen))))"]}
{"id": "entailmentbank_validation_604", "nl": "if an orgnism uses a process to convert something into something else, then that something is used for that process.", "fol": "", "prediction": ["all x, y, z, w. ((Organism(x) & UsesProcess(x, y, z, w) & Converts(y, z, w)) -> UsedFor(z, y))", "FOL Translation:\n\nall x, y, z, p. ((Organism(x) & UsesProcess(x, p, y, z)) -> UsedForProcess(y, p, x))", "all x y z p. ((Organism(x) & UsesProcessToConvert(x, p, y, z)) -> UsedForProcess(y, p))", "all x y z. (Organism(x) & UsesProcessToConvert(x, y, z) -> UsedForProcess(y, x))", "all x. all y. all z. all p. ((Organism(x) & UsesProcessToConvert(x, p, y, z)) -> UsedFor(y, p))", "all x, y, z, p. ((Organism(x) & UsesProcess(x, p, y, z)) -> UsedFor(y, p))", "all x y z p. ((Organism(x) & UsesProcessToConvert(x, y, z, p)) -> UsedFor(y, p))", "all x, y, z, p. ((Organism(x) & ConvertsUsingProcess(x, y, z, p)) -> UsedForProcess(y, p))", "all x, y, z. ((Organism(x) & Process(p) & ConvertsUsingProcess(x, p, y, z)) -> UsedForProcess(y, p))", "all x, y, z, p. ((Organism(x) & Process(p) & ConvertsUsingProcess(x, p, y, z)) -> UsedForProcess(y, p))", "all x. all y. all z. all p. ((Organism(x) & UsesProcess(x, p) & Convert(p, y, z)) -> UsedFor(y, p))", "all p, x, y. ((Organism(p) & UsesProcessToConvert(p, x, y)) -> UsedForProcess(x, y))", "all x, y, z, p. ((Organism(x) & UsesProcessToConvert(x, p, y, z)) -> UsedForProcess(p, y))", "all x, y, z, p. ((Organism(x) & ConvertsUsingProcess(x, y, z, p)) -> UsedFor(y, p) & UsedFor(z, p))", "all x, y, z, p. (Organism(x) & UsesProcessToConvert(x, p, y, z) -> IsUsedForProcess(y, p))", "all x. all y. all z. all p. ((Organism(x) & Process(p) & ConvertsUsing(x, p, y, z)) -> UsedFor(y, p))"]}
{"id": "entailmentbank_validation_605", "nl": "a plant uses sunlight for photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) & usesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & UsesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) -> UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) -> UsesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) -> UsesFor(x, sunlight, photosynthesis))", "Exists x. (Plant(x) -> Exists y. (Sunlight(y) & UsesForPhotosynthesis(x, y)))", "exists x. (Plant(x) & UsesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) & exists y. (Sunlight(y) & UsesFor(x, y, photosynthesis)))", "exists x. (Plant(x) & UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & UsesFor(x, sunlight, photosynthesis))", "all x. (Plant(x) -> UsesForPhotosynthesis(x, sunlight))", "`exists x. (Plant(x) -> UsesFor(x, sunlight, photosynthesis))`", "exists x. (Plant(x) & UsesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) -> UsesForPhotosynthesis(x, sunlight))"]}
{"id": "entailmentbank_validation_606", "nl": "in the photosynthesis process sunlight has the role of raw material.", "fol": "", "prediction": ["Process(photosynthesis) & Role(sunlight, raw_material, photosynthesis)", "`all x. (PhotosynthesisProcess(x) -> exists y. (Sunlight(y) & RoleOfRawMaterial(y, x)))`", "In the context of translating this sentence, we define some predicates: \n\n- `PhotosynthesisProcess(p)` for denoting a photosynthesis process.\n- `Sunlight(s)` for denoting sunlight.\n- `RoleOfRawMaterial(s, p)` to indicate that sunlight has the role of a raw material in the photosynthesis process.\n\nWith these predicates, the translation of the given sentence into first-order logic is:\n\n```\nall p. (PhotosynthesisProcess(p) -> exists s. (Sunlight(s) & RoleOfRawMaterial(s, p)))\n```", "exists x. (PhotosynthesisProcess(x) -> exists y. (Sunlight(y) & RoleOf(y, RawMaterial, x)))", "Process(photosynthesis) & Role(sunlight, raw_material, photosynthesis)", "exists p, s. (PhotosynthesisProcess(p) & Sunlight(s) & RoleOf(s, RawMaterial, p))", "exists x. (PhotosynthesisProcess(x) -> exists y. (Sunlight(y) & HasRole(y, RawMaterialIn(x))))", "exists p. (PhotosynthesisProcess(p) & exists s. (Sunlight(s) & HasRoleAsRawMaterial(s, p)))", "exists x. (PhotosynthesisProcess(x) & exists y. (Sunlight(y) & HasRoleOf(y, RawMaterial, x)))", "exists p. (PhotosynthesisProcess(p) -> exists s. (Sunlight(s) & HasRoleOf(s, RawMaterial, p)))", "exists p. (PhotosynthesisProcess(p) & exists s. (Sunlight(s) & HasRole(s, RawMaterial, p)))", "exists p. (PhotosynthesisProcess(p) -> exists s. (Sunlight(s) & RawMaterialInProcess(s, p)))", "exists p. (PhotosynthesisProcess(p) & exists s. (Sunlight(s) & HasRole(s, raw_material, p)))", "InPhotosynthesisProcess(sunlight) & Role(sunlight, raw_material)", "exists p. (PhotosynthesisProcess(p) & exists s. (Sunlight(s) & HasRole(s, RawMaterial, p)))", "In the photosynthesis process, sunlight has the role of raw material.\n\nFOL Translation:\nall x. (PhotosynthesisProcess(x) -> RoleOf(sunlight, rawMaterial, x))"]}
{"id": "entailmentbank_validation_607", "nl": "a plant uses the raw material sunlight for photosynthesis.", "fol": "", "prediction": ["exists x. exists y. (Plant(x) & RawMaterial(y) & Sunlight(y) & UsesFor(x, y, Photosynthesis))", "exists x. (Plant(x) -> exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) -> UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & usesFor(x, sunlight, photosynthesis) & RawMaterial(sunlight))", "exists x. (Plant(x) & RawMaterial(sunlight) & UsesForPhotosynthesis(x, sunlight))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsesForPhotosynthesis(x, y)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsesForPhotosynthesis(x, y)))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))", "exists x. (Plant(x) & uses(x, sunlight) & RawMaterial(sunlight) & ForPhotosynthesis(sunlight))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedForPhotosynthesis(x, y)))", "exists x. (Plant(x) & usesFor(x, sunlight, photosynthesis))", "exists x. (Plant(x) & exists y. (RawMaterial(y) & Sunlight(y) & UsedFor(x, y, Photosynthesis)))"]}
{"id": "entailmentbank_validation_608", "nl": "using a raw material sometimes requires absorbing that raw material.", "fol": "", "prediction": ["exists x. (RawMaterial(x) & (Sometimes(Use(x) -> Absorb(x))))", "all x. (RawMaterial(x) -> (exists y. (Requires(y, Absorb(x)))))", "all x. (RawMaterial(x) -> (RequiresAbsorbing(x, x) | -RequiresAbsorbing(x, x)))", "all x. (RawMaterial(x) -> exists y. (RequiresAbsorbtion(y, x)))", "all x. (RawMaterial(x) -> exists y. (RequiresAbsorbing(x, y) & RawMaterial(y)))", "all x. (RawMaterial(x) -> exists y. (RequiresAbsorption(x, y) & RawMaterial(y)))", "all x. (RawMaterial(x) -> (RequiresAbsorbing(x) <-> Absorbs(x)))", "all x. (RawMaterial(x) -> exists y. (Requires(y, Absorb(x)) & Use(y, x)))", "exists x. (RawMaterial(x) -> exists y. (Absorbs(y, x) & RequiresUsing(y, x)))", "exists x. (RawMaterial(x) -> (RequiresUsing(x) & Absorbing(x)))", "exists x. (RawMaterial(x) -> (exists y. (RequiresUsing(y, x) & Absorbing(y, x))))", "all x. (RawMaterial(x) -> (Uses(x) & SometimesRequiresAbsorbing(x)) -> Absorbs(x))", "exists x. (RawMaterial(x) -> (RequiresAbsorbing(x) | -RequiresAbsorbing(x))) & (RequiresAbsorbing(x) <-> Absorbing(x))", "all x. (RawMaterial(x) -> (exists y. (Absorb(y, x)) & Requires(y, x)))", "all x. all y. ((RawMaterial(x) & Requires(y, x)) -> PossiblyAbsorb(y, x))", "all x. (RawMaterial(x) -> (RequiresAbsorbing(x, x) | -RequiresAbsorbing(x, x)))"]}
{"id": "entailmentbank_validation_609", "nl": "a plant absorbs sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Plant(x) & Absorbs(x, sunlight) & PerformsPhotosynthesis(x))", "exists x. (Plant(x) -> Absorbs(x, sunlight) & PerformsPhotosynthesis(x))", "exists x. (Plant(x) -> (AbsorbsSunlight(x) & PerformsPhotosynthesis(x)))", "exists y. (Plant(y) & Absorbs(y, sunlight) & Performs(y, photosynthesis))", "exists x. (Plant(x) -> (exists y. (Sunlight(y) & Absorbs(x, y)) & PerformsPhotosynthesis(x)))", "all x. (Plant(x) -> (AbsorbsSunlight(x) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) & Absorbs(x, sunlight) & Performs(x, photosynthesis))", "exists x. (Plant(x) -> exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> Absorbs(x, sunlight) & Performs(x, photosynthesis))", "exists x. (Plant(x) -> (AbsorbsSunlight(x) & PerformsPhotosynthesis(x)))", "exists x. (Plant(x) -> (Absorbs(x, sunlight) & Performs(x, photosynthesis)))", "exists x. (Plant(x) -> AbsorbsSunlight(x) & PerformPhotosynthesis(x))", "exists x. (Plant(x) -> (AbsorbsSunlight(x) & CanPerformPhotosynthesis(x)))", "exists x. (Plant(x) & exists y. (Sunlight(y) & Absorbs(x, y) & ToPerform(x, Photosynthesis)))", "exists x. (Plant(x) -> AbsorbsSunlight(x) & PerformPhotosynthesis(x))", "exists x. (Plant(x) -> AbsorbsSunlightTo(x, PerformPhotosynthesis(x)))"]}
{"id": "entailmentbank_validation_610", "nl": "a leaf absorbs sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Leaf(x) & AbsorbsSunlight(x) & CanPerformPhotosynthesis(x))", "exists x. (Leaf(x) & Absorbs(x, sunlight) & Performs(x, photosynthesis))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) -> exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & Absorbs(x, sunlight) & Performs(x, photosynthesis))", "exists x. (Leaf(x) & Absorbs(x, sunlight) & Performs(x, photosynthesis))", "exists x. (Leaf(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "Exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & Performs(x, Photosynthesis)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "all x. (Leaf(x) -> (exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x))))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & CanPerformPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & PerformsPhotosynthesis(x)))", "exists x. (Leaf(x) & exists y. (Sunlight(y) & Absorbs(x, y) & CanPerformPhotosynthesis(x)))"]}
{"id": "entailmentbank_validation_611", "nl": "chlorophyll is found in the cells of leaves.", "fol": "", "prediction": ["exists y. (Chlorophyll(y) & all x. (LeafCell(x) -> FoundIn(y, x)))", "exists y. (Chlorophyll(y) & all x. (Cell(x) & InLeaf(x) -> FoundIn(y, x)))", "exists x. (Chlorophyll(x) & all y. (Leaf(y) -> FoundInCells(x, y)))", "exists y. (Chlorophyll(y) & all x. (Leaf(x) -> FoundInCellsOf(y, x)))", "exists x. (Chlorophyll(x) & all y. (Leaf(y) -> FoundInCells(x, y)))", "exists x. (Cell(x) & FoundIn(chlorophyll, x) & PartOf(x, Leaf(y)))", "all x. (Leaf(x) -> exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(y, x)))", "exists x. (Chlorophyll(x) & all y. (CellOf(y, leaves) -> FoundIn(x, y)))", "exists x. (Chlorophyll(x) & exists y. (Cell(y) & InLeaf(y) & FoundIn(x, y)))", "exists x. (Leaf(x) & exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(y, x)))", "all x. (Leaf(x) -> exists y. (Cell(y) & InChlorophyll(y)))", "exists y. (Leaf(y) & exists x. (Cell(x) & In(Chlorophyll, x) & PartOf(x, y)))", "exists y. (Chlorophyll(y) & all x. (CellOfLeaf(x) -> FoundIn(y, x)))", "all x. (Leaf(x) -> exists y. (Cell(y) & FoundIn(chlorophyll, y)))", "all x. (Leaf(x) -> exists y. (Cell(y) & Contains(y, chlorophyll)))", "exists y. (Chlorophyll(y) & all x. (LeafCell(x) -> FoundIn(y, x)))"]}
{"id": "entailmentbank_validation_612", "nl": "chlorophyll is found in the cells of parts of plants that absorb sunlight to perform photosynthesis.", "fol": "", "prediction": ["exists x. (Chlorophyll(x) & all y. (Cell(y) & PartOfPlant(y) & AbsorbsSunlight(y) & PerformsPhotosynthesis(y) -> FoundIn(x, y)))", "exists x. (Chlorophyll(x) & exists y. (Cell(y) & PartOf(y, Plant(z)) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z) & FoundIn(x, y)))", "all x. ((PartOfPlant(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x)) -> exists y. (Cell(y) & ContainsChlorophyll(y) & In(x, y)))", "exists x. (Chlorophyll(x) & all y. ((Cell(y) & PartOfPlant(y) & AbsorbsSunlight(y) & PerformsPhotosynthesis(y)) -> FoundIn(x, y)))", "`all x. (PlantPart(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x) -> exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(y, x)))`", "FOL Translation:\n\nall x. ((PlantPart(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x)) -> exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(y, x)))", "exists p. (Plant(p) & exists z. (PartOfPlant(z, p) & AbsorbsSunlight(z) & PerformPhotosynthesis(z) & all c. (Cell(c) & FoundIn(chlorophyll, c) -> PartOf(z, c))))", "exists p, c, x. (Part(p) & Cell(c) & Plant(x) & Contains(c, chlorophyll) & In(p, c) & PartOf(p, x) & Absorbs(p, sunlight) & Performs(p, photosynthesis))", "exists x. (Chlorophyll(x) & all y. ((PartOfPlant(y) & AbsorbsSunlight(y) & PerformsPhotosynthesis(y)) -> FoundInCellsOf(x, y)))", "exists x exists y. (Chlorophyll(x) & Cell(y) & PartOfPlant(z) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z) & FoundIn(x, y) & PartOf(y, z))", "exists x. (Chlorophyll(x) & all y. (PartOfPlant(y) & AbsorbsSunlight(y) & PerformsPhotosynthesis(y) -> FoundInCells(x, y)))", "exists c. (Chlorophyll(c) & all p. (PartOfPlant(p) & AbsorbsSunlight(p) & PerformsPhotosynthesis(p) -> exists cell. (InCell(c, cell) & CellOf(cell, p))))", "exists x, y, z. (Chlorophyll(x) & FoundIn(x, y) & Cell(y) & Part(z) & Plant(z) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z))", "exists x. (Chlorophyll(x) & all y. (Cell(y) & PartOf(z, Plant(z)) & AbsorbsSunlight(z) & PerformsPhotosynthesis(z) -> FoundIn(x, y)))", "all x. ((Plant(x) & AbsorbsSunlightToPerformPhotosynthesis(x)) -> exists y. (Cell(y) & PartOf(y, x) & FoundIn(chlorophyll, y)))", "all x. (PartOfPlant(x) & AbsorbsSunlight(x) & PerformsPhotosynthesis(x) -> exists y. (Cell(y) & FoundIn(chlorophyll, y) & PartOf(x, y)))"]}
{"id": "entailmentbank_validation_613", "nl": "chlorophyll is used for absorbing sunlight by plants.", "fol": "", "prediction": ["exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsesFor(y, x, Absorb(sunlight))))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedForAbsorbingSunlightBy(x, y)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbingSunlight, y)))", "all x. (Plant(x) -> UsesFor(x, chlorophyll, Absorb(sunlight)))", "exists y. (Chlorophyll(y) & all z. (Plant(z) -> UsedForAbsorbingSunlightBy(y, z)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedForAbsorbingSunlight(x, y)))", "exists y. (Chlorophyll(y) & all z. (Plant(z) -> UsedForAbsorbingSunlightBy(y, z)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsesForAbsorbing(y, x, sunlight)))", "exists x. (Chlorophyll(x) & UsedForAbsorbingSunlightByPlants(x))", "all x. (Plant(x) -> UsesForAbsorbing(chlorophyll, sunlight, x))", "all x. (Plant(x) -> UsesForAbsorbingSunlight(x, chlorophyll))", "exists y. (Chlorophyll(y) & all x. (Plant(x) -> UsesForAbsorbingSunlight(x, y)))", "exists y. (Chlorophyll(y) & all x. (Plant(x) -> UsesForAbsorbingSunlight(x, y)))", "all x. (Plant(x) -> UsesForAbsorbingSunlight(x, chlorophyll))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbSunlight(y))))", "all x. (Plant(x) -> UsesForAbsorbing(chlorophyll, sunlight, x))"]}
{"id": "entailmentbank_validation_614", "nl": "sunlight is a kind of light.", "fol": "", "prediction": ["KindOf(sunlight, light)", "KindOfLight(sunlight)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "Light(sunlight)", "Kind(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "KindOf(sunlight, light)", "Light(sunlight)"]}
{"id": "entailmentbank_validation_615", "nl": "light is a kind of energy.", "fol": "", "prediction": ["KindOf(light, energy)", "Energy(light)", "Energy(light)", "KindOf(light, energy)", "KindOf(light, energy)", "KindOf(light, energy)", "KindOf(light, energy)", "KindOf(light, energy)", "Energy(light)", "KindOf(light, energy)", "Energy(light)", "KindOf(light, energy)", "Energy(light)", "Energy(light)", "Kind(energy, light)", "KindOf(light, energy)"]}
{"id": "entailmentbank_validation_616", "nl": "sunlight is a kind of light energy.", "fol": "", "prediction": ["KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "LightEnergy(sunlight)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "LightEnergy(sunlight)", "KindOf(sunlight, light_energy)", "LightEnergy(sunlight)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "KindOf(sunlight, light_energy)", "LightEnergy(sunlight)", "IsKindOf(sunlight, light_energy)", "LightEnergy(sunlight)"]}
{"id": "entailmentbank_validation_617", "nl": "chlorophyll is used for absorbing light energy by plants.", "fol": "", "prediction": ["exists y. (Chlorophyll(y) & all z. (Plant(z) -> UsedForAbsorbingLightEnergy(y, z)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsesFor(x, AbsorbLightEnergy)))", "exists y. (Chlorophyll(y) & all z. (Plant(z) -> UsedFor(y, AbsorbLightEnergy, z)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsesFor(y, x, AbsorbingLightEnergy)))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbingLightEnergyBy(y))))", "all x. (Plant(x) -> UsesFor(chlorophyll, AbsorbingLightEnergy, x))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbingLightEnergy) & By(x, y)))", "exists y. (Chlorophyll(y) & all x. (Plant(x) -> UsedForAbsorbingLightEnergy(y, x)))", "FOL Translation:\nall x. (Plant(x) -> UsesFor(x, chlorophyll, AbsorbingLightEnergy))", "exists x. Exists y. (Chlorophyll(x) & Plant(y) & UsedFor(x, AbsorbingLightEnergy) & By(x, y))", "exists c. (Chlorophyll(c) & all p. (Plant(p) -> UsedForAbsorbingLightEnergyBy(c, p)))", "all x. (Plant(x) -> UsesFor(x, chlorophyll, AbsorbingLightEnergy))", "exists x, y. (Chlorophyll(x) & Plant(y) & UsedFor(x, AbsorbingLightEnergy) & By(y, x))", "exists y. (Chlorophyll(y) & all z. (Plant(z) -> UsedFor(y, AbsorbingLightEnergy, z)))", "exists x. (Chlorophyll(x) & UsedForAbsorbingLightEnergyByPlants(x))", "exists x. (Chlorophyll(x) & all y. (Plant(y) -> UsedFor(x, AbsorbLightEnergy, y)))"]}
{"id": "entailmentbank_validation_618", "nl": "some microorganisms have a positive impact on human body.", "fol": "", "prediction": ["exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & HasPositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpact(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpact(x, y)))", "exists x. (Microorganism(x) & HasPositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & HasPositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & PositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpactOn(x, y)))", "exists x. (Microorganism(x) & exists y. (HumanBody(y) & PositiveImpact(x, y)))", "exists x. (Microorganism(x) & HasPositiveImpactOnHumanBody(x))", "exists x. (Microorganism(x) & PositiveImpactOnHumanBody(x))"]}
{"id": "entailmentbank_validation_619", "nl": "if something has a positive impact on another thing, then the relationship is benificial.", "fol": "", "prediction": ["all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x, y. (HasPositiveImpact(x, y) -> Beneficial(x, y))", "all x y. (PositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpactOn(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpact(x, y) -> Beneficial(x, y))", "all x, y. (HasPositiveImpactOn(x, y) -> BeneficialRelationship(x, y))", "all x y. ((HasPositiveImpact(x, y)) -> BeneficialRelationship(x, y))", "all x y. (PositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpactOn(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (PositiveImpactOn(x, y) -> BeneficialRelationship(x, y))", "all x. all y. (HasPositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (PositiveImpact(x, y) -> BeneficialRelation(x, y))", "all x, y. (PositiveImpact(x, y) -> BeneficialRelationship(x, y))", "all x y. (PositiveImpact(x, y) -> BeneficialRelationship(x, y))"]}
{"id": "entailmentbank_validation_620", "nl": "some microorganisms are benificial to human body.", "fol": "", "prediction": ["exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))", "exists x. (Microorganism(x) & BeneficialToHumanBody(x))"]}
{"id": "entailmentbank_validation_621", "nl": "disease-causing microbes have a negative impact on the body.", "fol": "", "prediction": ["all x. (DiseaseCausingMicrobe(x) -> HasNegativeImpactOnBody(x))", "all x. (DiseaseCausingMicrobe(x) -> NegativeImpactOnBody(x))", "all x. (DiseaseCausingMicrobe(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & DiseaseCausing(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOn(x, body))", "all m. (Microbe(m) & CausesDisease(m) -> HasNegativeImpactOnBody(m))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & DiseaseCausing(x) -> NegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOnBody(x))", "all x. (Microbe(x) & CausesDisease(x) -> HasNegativeImpactOn(x, body))", "all x. (DiseaseCausingMicrobe(x) -> HasNegativeImpactOnBody(x))"]}
{"id": "entailmentbank_validation_622", "nl": "if something has a negative impact on another thing, then the relationship is harmful.", "fol": "", "prediction": ["all x y. (HasNegativeImpactOn(x, y) -> HarmfulRelationship(x, y))", "all x y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. (HasNegativeImpactOn(x, y) -> HarmfulRelationship(x, y))", "all x, y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. ((HasNegativeImpactOn(x, y)) -> HarmfulRelationship(x, y))", "all x, y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (HasNegativeImpactOn(x, y) -> HarmfulRelationship(x, y))", "all x. all y. (HasNegativeImpactOn(x, y) -> HarmfulRelationship(x, y))", "all x y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (NegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x, y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))", "all x y. (HasNegativeImpact(x, y) -> HarmfulRelationship(x, y))"]}
{"id": "entailmentbank_validation_623", "nl": "some disease-causing microbes are harmful to human body.", "fol": "", "prediction": ["exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (DiseaseCausingMicrobe(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & DiseaseCausing(x) & HarmfulToHumanBody(x))", "exists x. (DiseaseCausingMicrobe(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & exists y. (HumanBody(y) & HarmfulTo(x, y)))", "exists x. (Microbe(x) & CausesDisease(x) & exists y. (HumanBody(y) & HarmfulTo(x, y)))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (DiseaseCausingMicrobe(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & exists y. (HumanBody(y) & HarmfulTo(x, y)))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (Microbe(x) & CausesDisease(x) & HarmfulToHumanBody(x))", "exists x. (DiseaseCausingMicrobe(x) & exists y. (HumanBody(y) & HarmfulTo(x, y)))"]}
{"id": "entailmentbank_validation_624", "nl": "the relationship between human and microorganisms is sometimes beneficial and sometimes harmful.", "fol": "", "prediction": ["FOL Translation:\nexists x exists y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x. exists y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & ((BeneficialRelationship(x, y) & HarmfulRelationship(x, y))))", "exists x, y. (Human(x) & Microorganism(y) & (Beneficial(x, y) | Harmful(x, y)))", "FOL Translation:\nexists x. (Human(x) & all y. (Microorganism(y) -> (BeneficialRelationship(x, y) | HarmfulRelationship(x, y))))", "all x y. ( (Human(x) & Microorganism(y)) -> (SometimesBeneficial(Relationship(x, y)) & SometimesHarmful(Relationship(x, y))) )", "exists x, y. (Human(x) & Microorganism(y) & ((BeneficialRelationship(x, y) | HarmfulRelationship(x, y)) & (BeneficialRelationship(x, y) & HarmfulRelationship(x, y))))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists x, y. (Human(x) & Microorganism(y) & (BeneficialRelationship(x, y) | HarmfulRelationship(x, y)))", "exists r. (Relationship(r, human, microorganisms) & (Beneficial(r) | Harmful(r)))", "FOL Translation:\nexists x, y. (Human(x) & Microorganism(y) & (SometimesBeneficial(Relationship(x, y)) & SometimesHarmful(Relationship(x, y))))", "all x. (Human(x) & Microorganism(y) -> (BeneficialRelation(x, y) | HarmfulRelation(x, y)))"]}
{"id": "entailmentbank_validation_625", "nl": "water is a kind of nonliving thing.", "fol": "", "prediction": ["NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "Nonliving(thing) & KindOf(water, thing)", "Nonliving(water)", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)", "NonlivingThing(water)"]}
{"id": "entailmentbank_validation_626", "nl": "a river is a kind of body of water.", "fol": "", "prediction": ["all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))", "all x. (River(x) -> BodyOfWater(x))"]}
{"id": "entailmentbank_validation_627", "nl": "a river is a nonliving thing.", "fol": "", "prediction": ["all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "River(x) -> NonlivingThing(x)", "Nonliving(river)", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> Nonliving(x))", "all x. (River(x) -> NonlivingThing(x))", "River(x) -> NonlivingThing(x)", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "all x. (River(x) -> NonlivingThing(x))", "River(y) -> NonLivingThing(y)", "all x. (River(x) -> NonlivingThing(x))"]}
{"id": "entailmentbank_validation_628", "nl": "preferences are generally learned characteristics.", "fol": "", "prediction": ["all x. (Preference(x) -> IsGenerallyLearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all p. (Preference(p) -> LearnedCharacteristic(p))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))", "all x. (Preference(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_629", "nl": "a food preference is a kind of preference.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))", "all x. (FoodPreference(x) -> Preference(x))"]}
{"id": "entailmentbank_validation_630", "nl": "food preference is a kind of learned characteristics.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))", "all x. (FoodPreference(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_631", "nl": "learned characteristics are similar to acquired characteristics.", "fol": "", "prediction": ["all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x))", "all x. (LearnedCharacteristic(x) -> SimilarTo(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> SimilarTo(x, AcquiredCharacteristic))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> SimilarTo(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristicSimilar(x))", "all x. (LearnedCharacteristic(x) -> exists y. (AcquiredCharacteristic(y) & Similar(x, y)))", "all x. (LearnedCharacteristic(x) -> SimilarTo(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> SimilarTo(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, x))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, y) & AcquiredCharacteristic(y))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, AcquiredCharacteristic(x)))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, y) & AcquiredCharacteristic(y))", "all x. (LearnedCharacteristic(x) <-> AcquiredCharacteristic(x))", "all x. (LearnedCharacteristic(x) <-> AcquiredCharacteristic(x))", "all x. (LearnedCharacteristic(x) -> AcquiredCharacteristic(x) & Similar(x, y) & AcquiredCharacteristic(y))"]}
{"id": "entailmentbank_validation_632", "nl": "food preference is a kind of acquired characteristics.", "fol": "", "prediction": ["all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))", "all x. (FoodPreference(x) -> AcquiredCharacteristic(x))"]}
{"id": "entailmentbank_validation_633", "nl": "an animal is a kind of organism.", "fol": "", "prediction": ["all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))", "all x. (Animal(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_634", "nl": "a dog is a kind of animal.", "fol": "", "prediction": ["all x. (Dog(x) -> Animal(x))", "all x. (Dog(x) -> Animal(x))", "all x. (Dog(x) -> Animal(x))", "Dog(d) -> Animal(d)", "all x. (Dog(x) -> Animal(x))", "all x. (Dog(x) -> Animal(x))", "Dog(x) -> Animal(x)", "Dog(x) -> Animal(x)", "all x. (Dog(x) -> Animal(x))", "Dog(d) -> Animal(d)", "all x. (Dog(x) -> Animal(x))", "Animal(dog)", "all x. (Dog(x) -> Animal(x))", "Dog(x) -> Animal(x)", "Dog(x) -> Animal(x)", "all x. (Dog(x) -> Animal(x))"]}
{"id": "entailmentbank_validation_635", "nl": "a dog is a kind of organism.", "fol": "", "prediction": ["all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "Dog(d) -> Organism(d)", "all x. (Dog(x) -> Organism(x))", "Dog(d) -> Organism(d)", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))", "all x. (Dog(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_636", "nl": "an organism's environment affects that organism's acquired characteristics.", "fol": "", "prediction": ["all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, x, AcquiredCharacteristics(x))))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, x, AcquiredCharacteristics(x))))", "all o. (Organism(o) -> all e. (Environment(e) & Affects(e, o) -> AcquiredCharacteristics(o)))", "all x. (Organism(x) -> (exists y. Environment(y) & Affects(y, x, AcquiredCharacteristics(x))))", "all x. all y. ((Organism(x) & EnvironmentAffectsCharacteristics(y, x)) -> AffectsAcquiredCharacteristics(y, x))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, AcquiredCharacteristics(x))))", "all x. all e. ((Organism(x) & Environment(e) & Affects(e, x)) -> AffectsAcquiredCharacteristics(e, x))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, AcquiredCharacteristics(x))))", "all x. all y. ((Organism(x) & Environment(y) & Affects(y, x)) -> AffectsCharacteristics(y, x))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, x, AcquiredCharacteristics(x))))", "all x. all y. ((Organism(x) & Environment(y, x)) -> Affects(y, AcquiredCharacteristics(x)))", "all x. (Organism(x) -> exists y. (Environment(y, x) & Affects(y, Characteristics(x))))", "all x. (Organism(x) -> exists y. (Environment(y) & Affects(y, x'sAcquiredCharacteristics)))", "all x. all y. ((Organism(x) & Environment(y, x)) -> Affects(acquiredCharacteristics(x), y))", "all x. all y. ((Organism(x) & Environment(y) & HasEnvironment(x, y)) -> AffectsEnvironmentOnCharacteristics(y, x))", "all x. all y. ((Organism(x) & EnvironmentOf(y, x)) -> Affects(y, AcquiredCharacteristics(x)))"]}
{"id": "entailmentbank_validation_637", "nl": "the food preference of a dog is affected by its environment.", "fol": "", "prediction": ["all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "all x. (Dog(x) -> exists y. (FoodPreferenceAffectedByEnvironment(x, y)))", "exists x. (Dog(x) -> exists y. (FoodPreference(x, y) & affectedBy(y, Environment(x))))", "all x. (Dog(x) -> exists y. (Environment(y) & Affects(FoodPreference(x), y)))", "all x. (Dog(x) -> exists y. (Environment(y) & Affects(Environment(y), FoodPreference(x))))", "all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "all x. (Dog(x) -> exists y. (Environment(y) & Affects(y, FoodPreference(x))))", "all x. (Dog(x) -> exists y. (FoodPreferenceAffectedByEnvironment(x, y) & Environment(y)))", "exists x. (Dog(x) -> exists y. (FoodPreferenceAffectedByEnvironment(x, y)))", "all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "all x. (Dog(x) -> exists y. (Environment(y, x) -> Affects(FoodPreference(x), y)))", "all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "all x. (Dog(x) -> exists y. (Environment(y) & AffectsFoodPreference(y, x)))", "exists x. (Dog(x) -> exists y. (Environment(y) & Affects(y, FoodPreference(x))))", "all x. (Dog(x) -> exists y. (Environment(y) & Affects(FoodPreference(x), y)))"]}
{"id": "entailmentbank_validation_638", "nl": "following orders is a learned characteristic.", "fol": "", "prediction": ["all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "exists x. (LearnedCharacteristic(x) & FollowingOrders(x))", "LearnedCharacteristic(following_orders)", "LearnedCharacteristic(following_orders)", "LearnedCharacteristic(following_orders)", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "LearnedCharacteristic(following_orders)", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "exists x. (LearnedCharacteristic(x) & FollowingOrders(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all x. (FollowingOrders(x) -> LearnedCharacteristic(x))", "all y. (FollowsOrders(y) -> LearnedCharacteristic(y))"]}
{"id": "entailmentbank_validation_639", "nl": "an example of following orders is coming when called.", "fol": "", "prediction": ["exists x. (FollowingOrders(x) & ExampleOf(x, ComesWhenCalled))", "Exists x. (FollowingOrders(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (FollowingOrders(x) & IsExampleOf(x, y) & (ComesWhenCalled(y)))", "exists x. (FollowingOrder(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (FollowingOrders(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (FollowingOrders(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (FollowingOrder(x) & Example(x, ComingWhenCalled))", "exists x. (FollowingOrder(x) & Example(x) & (ComesWhenCalled(x)))", "exists x. (Example(x) & FollowsOrders(x, ComingWhenCalled(x)))", "exists x. (FollowingOrder(x) & Example(x, ComingWhenCalled))", "Exists x. (OrderFollowingExample(x) & ComesWhenCalled(x))", "Example(following_orders, coming_when_called)", "exists x. (FollowingOrders(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (FollowingOrders(x) & ExampleOf(x, ComingWhenCalled))", "exists x. (ExampleOfFollowingOrders(x) & ComesWhenCalled(x))", "Exists x. (ExampleOfFollowingOrders(x) & ComingWhenCalled(x))"]}
{"id": "entailmentbank_validation_640", "nl": "a dog coming when called is a kind of learned characteristic.", "fol": "", "prediction": ["all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. ((Dog(x) & ComesWhenCalled(x)) -> LearnedCharacteristic(x))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))", "all x. ((Dog(x) & ComesWhenCalled(x)) -> LearnedCharacteristic(x))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))", "all x. (Dog(x) & ComingWhenCalled(x) -> LearnedCharacteristic(x))", "Exists x. (Dog(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))", "all x. (Dog(x) & Called(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. ((Dog(x) & ComesWhenCalled(x)) -> LearnedCharacteristic(x))", "all z. (Dog(z) & ComesWhenCalled(z) -> LearnedCharacteristic(z))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(ComesWhenCalled(x)))", "all x. (Dog(x) & ComesWhenCalled(x) -> LearnedCharacteristic(x))"]}
{"id": "entailmentbank_validation_641", "nl": "hunting is a kind of skill.", "fol": "", "prediction": ["all x. (Hunting(x) -> Skill(x))", "Skill(hunting)", "Skill(hunting)", "all x. (Hunting(x) -> Skill(x))", "Skill(hunting)", "all x. (Hunting(x) -> Skill(x))", "all x. (Hunting(x) -> Skill(x))", "KindOf(hunting, skill)", "all x. (Hunting(x) -> Skill(x))", "Skill(hunting)", "all x. (Hunting(x) -> Skill(x))", "all x. (Hunting(x) -> Skill(x))", "Skill(hunting)", "all x. (Hunting(x) -> Skill(x))", "Skill(hunting)", "Skill(hunting)"]}
{"id": "entailmentbank_validation_642", "nl": "skills are learned characteristics / behaviors.", "fol": "", "prediction": ["all x. (Skill(x) -> (Characteristic(x) | Behavior(x)) & Learned(x))", "all x. (Skill(x) -> exists y. (Characteristic(y) & Behavior(y) & Learned(x, y)))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> (LearnedCharacteristic(x) | Behavior(x)))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))", "all s. (Skill(s) -> exists c. (Characteristic(c) & Learned(c) & IsPartOf(c, s)))", "all x. (Skill(x) -> LearnedCharacteristicOrBehavior(x))"]}
{"id": "entailmentbank_validation_643", "nl": "hunting is a kind of learned behaviors.", "fol": "", "prediction": ["all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "Hunting is defined as an exemplary type of learned behaviors. This can be represented in first-order logic by affirming that for all instances of hunting, they are considered as learned behaviors.\n\nFOL Translation:\nall x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))", "all x. (Hunting(x) -> LearnedBehavior(x))"]}
{"id": "entailmentbank_validation_644", "nl": "inherited characteristics are the opposite of learned characteristics.", "fol": "", "prediction": ["all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. ((InheritedCharacteristic(x) -> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) -> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (-InheritedCharacteristic(x) <-> LearnedCharacteristic(x)))", "all x. ((InheritedCharacteristic(x) -> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) -> -InheritedCharacteristic(x)))", "all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. (InheritedCharacteristic(x) <-> -LearnedCharacteristic(x))", "all x. (InheritedCharacteristics(x) <-> -LearnedCharacteristics(x))", "all x. ((InheritedCharacteristic(x) <-> -LearnedCharacteristic(x)) & (LearnedCharacteristic(x) <-> -InheritedCharacteristic(x)))", "Opposite(InheritedCharacteristics, LearnedCharacteristics)", "Opposite(InheritedCharacteristics, LearnedCharacteristics)"]}
{"id": "entailmentbank_validation_645", "nl": "learned characteristics are not inherited from parents.", "fol": "", "prediction": ["all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritedFrom(x, y)))", "all x. (LearnedCharacteristic(x) -> -(exists y. (Parent(y, x) & InheritedFrom(y, x))))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y, x) & Inherited(x, y)))", "all x. (LearnedCharacteristic(x) -> -exists y. Parent(y) & InheritedFrom(x, y))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritedFrom(x, y)))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritedFrom(x, y)))", "all c. (LearnedCharacteristic(c) -> all x. (Parent(y, x) -> -InheritedFrom(c, x)))", "all x. (LearnedCharacteristic(x) -> -InheritedFromParents(x))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritedFrom(x, y)))", "all x y. (LearnedCharacteristic(x) & Parent(y) -> -InheritedFrom(x, y))", "all x. (LearnedCharacteristic(x) -> -exists y. (Parent(y) & InheritsFrom(x, y)))", "all x. (LearnedCharacteristic(x) -> -InheritsFromParents(x))"]}
{"id": "entailmentbank_validation_646", "nl": "food preference is not inherited from parents.", "fol": "", "prediction": ["all x y. (Parent(x, y) -> -InheritsFoodPreference(y, x))", "all x y z. ((Person(x) & Parent(y, x) & FoodPreference(x, z)) -> -(Inherited(y, z)))", "all x. (Parent(y, x) -> -InheritsFoodPreference(x, y))", "all x y z. (Parent(x, y) & FoodPreference(y, z) -> -FoodPreferenceInherited(y, z, x))", "all x. (Parent(y, x) -> -InheritsFoodPreference(x, y))", "all x. all y. (Parent(y, x) & FoodPreferenceInherited(x, y) -> -InheritFoodPreference(x, y))", "all x. all y. all z. ((Parent(x, y) & Parent(x, z)) -> -(InheritsFoodPreference(y, z)))", "all x. (Parent(y, x) & FoodPreferenceInheritable(x, y) -> -InheritsFoodPreference(x, y))", "all x y. ((Parent(x, y) -> -InheritsFoodPreference(y, x)))", "all x. (Parent(y, x) -> -InheritsFoodPreference(x, y))", "all x y. (Parent(y, x) -> -InheritsFoodPreference(x, y))", "all x y. (Parent(x, y) -> -InheritsFoodPreference(y, x))", "all x. (Person(x) -> -InheritsFoodPreference(x))", "all x, y, z. ((Parent(x, y) & Parent(z, y)) -> -(InheritFoodPreference(y, x) | InheritFoodPreference(y, z)))", "all x. (Parent(y, x) -> -InheritFoodPreference(x, y))", "all x y z. (Parent(x, y) & FoodPreference(y, z) -> -Inherited(z, x))"]}
{"id": "entailmentbank_validation_647", "nl": "the intelligence of animals is an acquired characteristic.", "fol": "", "prediction": ["all x. (Animal(x) -> AcquiredCharacteristic(IntelligenceOf(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x.(IntelligenceOf(x, animals) & AcquiredCharacteristic(IntelligenceOf(x, animals)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) & IntelligenceAcquiredCharacteristic(x))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "AcquiredCharacteristic(IntelligenceOf(animals))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(IntelligenceOf(x)))", "all x. (Animal(x) -> AcquiredCharacteristic(IntelligenceOf(x)))"]}
{"id": "entailmentbank_validation_648", "nl": "the intelligence of a human is an acquired characteristic.", "fol": "", "prediction": ["all x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) & IntelligenceIsAcquiredCharacteristic(x))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "all x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) & Intelligence(x) & AcquiredCharacteristic(Intelligence(x)))", "exists x. (Human(x) -> AcquiredCharacteristic(Intelligence(x)))"]}
{"id": "entailmentbank_validation_649", "nl": "inherited characteristics are the opposite of acquired characteristics.", "fol": "", "prediction": ["Opposite(inherited_characteristics, acquired_characteristics)", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. ((InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "Opposite(inherited_characteristics, acquired_characteristics)", "all x. ((InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) <-> -InheritedCharacteristic(x)))", "Opposite(InheritedCharacteristics, AcquiredCharacteristics)", "all x. ((InheritedCharacteristic(x) -> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) -> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. ((InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. ((InheritedCharacteristic(x) -> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) -> -InheritedCharacteristic(x)))", "all x. ((InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x)) & (AcquiredCharacteristic(x) <-> -InheritedCharacteristic(x)))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))", "all x. (InheritedCharacteristic(x) <-> -AcquiredCharacteristic(x))"]}
{"id": "entailmentbank_validation_650", "nl": "the intelligence of a human is not an inherited characteristic.", "fol": "", "prediction": ["all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(IntelligenceOf(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "The sentence 'the intelligence of a human is not an inherited characteristic' can be translated into first-order logic as follows:\n\nall x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> - InheritedCharacteristic(Intelligence(x)))", "all x. ((Human(x) & IntelligenceCharacterOf(x)) -> -Inherited(x))", "all x. (Human(x) -> -(InheritedCharacteristic(Intelligence(x))))", "all x. (Human(x) -> -InheritedCharacteristic(IntelligenceOf(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -(Inherits(x, Intelligence)))", "FOL Translation:\nall x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))", "all x. (Human(x) -> -InheritedCharacteristic(IntelligenceOf(x)))", "all x. (Human(x) -> -InheritedCharacteristic(Intelligence(x)))"]}
{"id": "entailmentbank_validation_651", "nl": "genes is a vehicle for passing inherited characteristics from parent to offspring.", "fol": "", "prediction": ["Exists x. (Gene(x) & VehicleFor(x, InheritedCharacteristics(x)) & Passes(x, Parent, Offspring))", "Vehicle(genes) & ForPassingInheritedCharacteristics(genes, parent, offspring)", "VehicleForPassingInheritedCharacteristics(genes, parent, offspring)", "VehicleForInheritance(genes)", "VehicleForInheritance(genes)", "`VehicleForPassingInheritedCharacteristics(genes, parent, offspring)`", "VehicleForInheritance(genes, parent, offspring)", "VehicleForPassingInheritedCharacteristics(genes, parent, offspring)", "Vehicle(genes) & all x. (InheritedCharacteristic(x) -> PassesFromParentToOffspring(genes, x))", "VehicleForPassing(genesis, characteristics, parent, offspring) & Inherited(characteristics)", "VehicleForPassingInheritedCharacteristics(genes, parent, offspring)", "Vehicle(genes) & all x. (InheritedCharacteristic(x) -> PassedFromParentToOffspring(x, genes))", "VehicleForInheritingCharacteristics(genes, parent, offspring)", "VehicleForPassingInheritedCharacteristics(genes)", "Exists x. (VehicleForPassing(x) & InheritedCharacteristics(x) & From(parent, x) & To(offspring, x) & Equals(x, genes))", "VehicleForPassingInheritedCharacteristicsFromParentToOffspring(genes)"]}
{"id": "entailmentbank_validation_652", "nl": "a father is a kind of male parent.", "fol": "", "prediction": ["all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))", "all x. (Father(x) -> MaleParent(x))"]}
{"id": "entailmentbank_validation_653", "nl": "a mother is a kind of female parent.", "fol": "", "prediction": ["all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))", "all x. (Mother(x) -> FemaleParent(x))"]}
{"id": "entailmentbank_validation_654", "nl": "genes are a vehicle for passing inherited characteristics from a mother and a father to offspring.", "fol": "", "prediction": ["all g. (Gene(g) -> exists c. (InheritedCharacteristic(c) & all m. all f. all o. (Mother(m) & Father(f) & Offspring(o) & PassesCharacteristics(m, f, g, o, c))))", "all g, m, f, o. (Gene(g) & Mother(m) & Father(f) & Offspring(o) -> VehicleFor(genetic_characteristics, m, f, o))", "all g, c, m, f, o. ((Gene(g) & Characteristic(c) & Mother(m) & Father(f) & Offspring(o) & PassFrom(m, c, o, g) & PassFrom(f, c, o, g)) -> VehicleForPassingInherited(g, c, o))", "all x. (Gene(x) -> exists y exists z exists w. (Mother(y) & Father(z) & Offspring(w) & PassesCharacteristicsTo(x, y, z, w)))", "all g. (Gene(g) -> exists m, f, o. (Mother(m) & Father(f) & Offspring(o) & PassesInheritedCharacteristics(g, m, f, o)))", "all g. (Gene(g) -> exists m. exists f. exists o. (Mother(m) & Father(f) & Offspring(o) & PassesInheritedCharacteristicsFromTo(g, m, f, o)))", "all v. (Gene(v) -> VehicleForPassingInheritedCharacteristics(v, mother, offspring) & VehicleForPassingInheritedCharacteristics(v, father, offspring))", "all x. (Gene(x) -> VehicleForPassingInheritedCharacteristics(x))", "all x. (Gene(x) -> exists y. (Mother(y) & exists z. (Father(z) & exists o. (Offspring(o) & PassesInheritedCharacteristics(x, y, z, o)))))", "all x. (Gene(x) -> exists y exists z. (Mother(y) & Father(z) & PassesInheritedCharacteristics(x, y, z, offspring)))", "all g. (Gene(g) -> exists m exists f exists o. (Mother(m) & Father(f) & Offspring(o) & PassesInheritedCharacteristicsFromTo(g, m, f, o)))", "all x. (Gene(x) -> exists y exists z exists w. (Mother(y) & Father(z) & Offspring(w) & PassesInheritedCharacteristics(x, y, z, w)))", "all x. (Gene(x) -> VehicleForPassingInheritedCharacteristics(x, mother, father, offspring))", "all g, c, p, o. ((Gene(g) & InheritedCharacteristic(c) & Mother(p) & Father(p)) -> VehicleForPassing(g, c, p, o))", "all x. (Gene(x) -> IsVehicleForPassingInheritedCharacteristics(x, mother, offspring) & IsVehicleForPassingInheritedCharacteristics(x, father, offspring))", "all g, c, m, f, o. ((Gene(g) & InheritedCharacteristic(c) & Mother(m) & Father(f) & Offspring(o) & PassesFromTo(g, c, m, o) & PassesFromTo(g, c, f, o)) -> VehicleFor(g, c, m, o) & VehicleFor(g, c, f, o))"]}
{"id": "entailmentbank_validation_655", "nl": "in sexual reproduction sperm is a vehicle for the genes from the father to the offspring.", "fol": "", "prediction": ["In the context of this translation, we need to express the concept that sperm acts as a vehicle for genes from the father to the offspring in sexual reproduction. Here's the FOL representation:\n\nall x. (SexualReproduction(x) -> (exists y. (Sperm(y) & VehicleForGenes(y, Father, Offspring))))", "exists x. (Sperm(x) & VehicleForGenes(x, father, offspring) & InSexualReproduction)", "FOL Translation:\nall x. (Sperm(x) & SexualReproduction(x) -> VehicleForGenesFromFather(x, Offspring))", "exists x. (Sperm(x) & VehicleForGenes(x, father, offspring) & InSexualReproduction(x))", "exists x, y, z. (Sperm(x) & Father(y) & Offspring(z) & SexualReproduction(w) & VehicleForGenes(x, y, z, w))", "InSexualReproduction(x) -> (Vehicle(sperm, GenesFromFather) & From(sperm, father) & To(sperm, offspring))", "exists x. (InSexualReproduction(x) & Sperm(x) & VehicleForGenesFromFatherToOffspring(x))", "all s. (Sperm(s) & InSexualReproduction(s) -> VehicleForGenes(s, father, offspring))", "exists x, y, z. (Sperm(x) & Father(y) & Offspring(z) & VehicleForGenes(x, y, z) & SexualReproductionOccurs(x))", "exists x. (Sperm(x) & VehicleForGenes(x, father, offspring) & InSexualReproduction(x))", "exists f, o, g. (Father(f) & Offspring(o) & Gene(g) & all s. (Sperm(s) -> VehicleForGenes(s, g, f, o)))", "exists x. (Sperm(x) & VehicleForGenes(x) & all y. (Father(y) -> Offspring(y) & -SameAs(x, y)))", "FOL Translation:\nall x. ((SexualReproduction(x) & Sperm(x)) -> VehicleForGenesFromTo(x, father, offspring))", "exists f. (Father(f) -> all s. (Sperm(s) & VehicleForGenes(s, f, o) & Offspring(o)))", "exists x. (SexualReproduction(x) -> exists s, f, o. (Sperm(s) & Father(f) & Offspring(o) & VehicleForGenesFromTo(x, s, f, o)))", "exists x, y, z. (Sperm(x) & VehicleForGenes(x, y, z) & Father(y) & Offspring(z) & InSexualReproduction)"]}
{"id": "entailmentbank_validation_656", "nl": "in sexual reproduction the egg is a vehicle for the genes from the mother to the offspring.", "fol": "", "prediction": ["exists x. exists y. exists z. ((Egg(x) & VehicleForGenes(x, Mother(y), Offspring(z))) <-> SexualReproduction(x, y, z))", "exists x, y, z. (Egg(x) & Mother(y) & Offspring(z) & VehicleForGenes(x, y, z))", "exists x, y, z. (IsEgg(x) & Mother(y) & Offspring(z) & InSexualReproduction(x, y, z) -> VehicleForGenes(x, y, z))", "Exists x. (Egg(x) & ForGenesFromMotherToOffspring(x))", "exists x, y, z. (Egg(x) & Mother(y) & Offspring(z) & VehicleForGenes(x, y, z) & SexualReproduction(x, y, z))", "Exist y. (Egg(y) & VehicleForGenes(y, mother, offspring) & SexualReproduction(y))", "exists x, y, z. (Egg(x) & Mother(y) & Offspring(z) & InSexualReproduction(x) & IsVehicleForGenes(x, y, z))", "Exists x. (Egg(x) & VehicleForGenesFromTo(x, mother, offspring))", "exists x. (Egg(x) & VehicleForGenes(x, mother, offspring) & SexualReproduction(x))", "exists x, y, z. (Egg(x) & Gene(y) & Mother(z) & Offspring(w) & InSexualReproduction(x) & VehicleFor(x, y, w) & From(y, z))", "Exists x. (SexualReproduction(x) -> (Vehicle(Egg, GenesFrom(Mother, OffSpring))))", "InSexualReproduction(y) -> (Egg(y) -> exists z. (VehicleFor(y, GenesFrom(mother, z)) & Offspring(z)))", "exists x, y, z. (Egg(x) & Mother(y) & Offspring(z) & InSexualReproduction(x, y, z) & VehicleForGenes(x, y, z))", "Exists x. (Egg(x) & VehicleForGenesFromTo(x, mother, offspring) & InSexualReproduction(x))", "Exist x. (Egg(x) & InSexualReproduction(x) & vehicleForGenesFromMotherToOffspring(x))", "InSexualReproduction(x) -> all y. ((Egg(y) & From(y, Mother) & To(y, Offspring)) -> VehicleForGenes(y))"]}
{"id": "entailmentbank_validation_657", "nl": "genes are passed from a mother and a father to offspring through the egg and sperm.", "fol": "", "prediction": ["all x. (Gene(x) -> exists y. exists z. (Mother(y) & Father(z) & Offspring(w) & ThroughEgg(x, w) & ThroughSperm(x, w)))", "all x. all y. all z. all p. all q. ((Mother(x) & Father(y) & Offspring(z) & Egg(p) & Sperm(q)) -> (PassedThrough(x, z, p) & PassedThrough(y, z, q)))", "all g. all m. all f. all o. all e. all s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & From(m, e) & From(f, s) & Through(e, s)) -> PassedTo(g, o))", "FOL Translation:\nall g, m, f, o, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassesFrom(m, g, e, o) & PassesFrom(f, g, s, o)) -> PassedToOffspring(g, o))", "all g. all m. all f. all o. all e. all s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s)) -> (PassFromTo(g, m, o, e) & PassFromTo(g, f, o, s)))", "all x y z w v. ((Gene(x) & Mother(y) & Father(z) & Offspring(w) & Egg(v) & Sperm(v)) -> (PassedFromTo(x, y, w) & PassedFromTo(x, z, w)))", "all g. all m. all f. all o. (Gene(g) & Mother(m) & Father(f) & Offspring(o) -> (PassedFrom(g, m, o) & PassedFrom(g, f, o) & Through(g, egg, o) & Through(g, sperm, o)))", "all g, m, f, o, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s)) -> (PassesTo(g, m, o, e) & PassesTo(g, f, o, s)))", "all x. ((Offspring(x)) -> exists y exists z. (Mother(y) & Father(z) & Egg(w) & Sperm(v) & PassesGenes(y, x, w) & PassesGenes(z, x, v)))", "all g. all m. all f. all o. all e. all s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & Passed(g, m, e) & Passed(g, f, s)) -> PassedToOffspring(g, o))", "all g. (Gene(g) -> exists m. exists f. exists o. (Mother(m) & Father(f) & Offspring(o) & PassesThrough(m, g, o, egg) & PassesThrough(f, g, o, sperm)))", "all x. (Gene(x) -> exists y exists z (Mother(y) & Father(z) & PassesTo(x, y, Offspring(x)) & PassesTo(x, z, Offspring(x)) & Through(x, Egg) & Through(x, Sperm)))", "all g, o, m, f, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s)) -> (PassedFromTo(g, m, o, e) & PassedFromTo(g, f, o, s)))", "all g, m, f, o, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s)) -> (PassedFromTo(g, m, o, e) & PassedFromTo(g, f, o, s)))", "all x. all y. (Gene(x) & Offspring(y) -> (PassedFromMother(x, y) & PassedFromFather(x, y) & ThroughEgg(x) & ThroughSperm(x)))", "all g, m, f, o, e, s. ((Gene(g) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & Contributes(m, e) & Contributes(f, s)) -> PassedTo(g, o))"]}
{"id": "entailmentbank_validation_658", "nl": "genes determine the traits for the living things.", "fol": "", "prediction": ["all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, x, Trait)))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, x)))", "all x. ((LivingThing(x) & Trait(y, x)) -> exists z. (Gene(z) & Determines(z, y)))", "all x. ((LivingThing(x) & hasGenes(x, y)) -> Determines(y, Traits(x)))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Trait(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))", "all x. (LivingThing(x) -> exists y. (Gene(y) & Determines(y, Traits(x))))"]}
{"id": "entailmentbank_validation_659", "nl": "traits are passed from a mother and a father to offspring through the egg and sperm.", "fol": "", "prediction": ["all t, m, f, o. ((Trait(t) & Mother(m) & Father(f) & Offspring(o)) -> (PassesThroughTo(t, m, o, egg) & PassesThroughTo(t, f, o, sperm)))", "all x. (Offspring(x) -> exists y. exists z. (Mother(y) & Father(z) & PassesTraitsThroughEgg(y, x) & PassesTraitsThroughSperm(z, x)))", "all t, m, f, o, e, s. ((Trait(t) & Mother(m, o) & Father(f, o) & Egg(e, o) & Sperm(s, o)) -> PassedFromTo(t, m, o, e) & PassedFromTo(t, f, o, s))", "all t, m, f, o, e, s. ((Trait(t) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassesFromToThrough(t, m, f, o, e, s)) -> (PassesFromToThrough(t, m, f, o, e, s)))", "FOL Translation:\nall t. all m. all f. all o. all e. all s. ((Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassedThrough(t, m, e) & PassedThrough(t, f, s)) -> PassesTraitTo(t, o))", "all t. (Trait(t) -> exists m, f, o, e, s. (Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassesThrough(t, m, o, e) & PassesThrough(t, f, o, s)))", "all t. exists m, f, o, e, s. (Trait(t) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & PassedFromTo(t, m, f, o, e, s))", "all x. (Offspring(x) -> exists y. exists z. ((Mother(y) & Father(z) & PassTraitsThroughEggAndSperm(y, z, x))))", "all x. all y. all z. ((Offspring(z) & Mother(x, z) & Father(y, z)) -> exists a. exists b. (Egg(a, x) & Sperm(b, y) & PassesTraits(a, b, z)))", "all x. (Offspring(x) -> exists y exists z. (Mother(y) & Father(z) & PassedTraits(y, x) & PassedTraits(z, x) & ThroughEgg(x) & ThroughSperm(x)))", "all x, y, z, a, b, c. ((Mother(x, z) & Father(y, z) & Offspring(z, c) & Egg(a, c) & Sperm(b, c)) -> (PassTraits(x, z, a) & PassTraits(y, z, b)))", "all x. all y. all z. ((Mother(x) & Father(y) & Offspring(z)) -> (exists e. (Egg(e) & PassesTraitsFrom(x, z, e)) & exists s. (Sperm(s) & PassesTraitsFrom(y, z, s))))", "all t, m, f, o, e, s. ((Trait(t) & Mother(m) & Father(f) & Offspring(o) & Egg(e) & Sperm(s) & Contributes(m, e) & Contributes(f, s)) -> Passed(t, m, f, o))", "all t. (exists m, f, o. (Mother(m) & Father(f) & Offspring(o) & PassedThrough(t, m, o, egg) & PassedThrough(t, f, o, sperm)))", "all x. (Trait(x) -> exists y, z, a, b. (Mother(y) & Father(z) & Offspring(a) & Egg(b) & Sperm(b) & PassedThrough(x, b) & PassesFrom(y, a) & PassesFrom(z, a)))", "all t, m, f, o, e, s. ((Offspring(o) & Mother(m) & Father(f) & Egg(e) & Sperm(s) & PassesFromTo(t, m, o) & PassesFromTo(t, f, o) & Through(t, e) & Through(t, s)) -> Trait(t))"]}
{"id": "entailmentbank_validation_660", "nl": "dna is a kind of nucleic acid.", "fol": "", "prediction": ["KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "Kind(nucleic_acid, dna)", "KindOf(dna, nucleic_acid)", "KindOf(dna, nucleic_acid)", "IsKindOf(dna, nucleic_acid)", "NucleicAcid(dna)", "KindOf(dna, nucleic_acid)"]}
{"id": "entailmentbank_validation_661", "nl": "thymine is found in dna.", "fol": "", "prediction": ["FoundIn(thymine, dna)", "Exists x. (Thymine(x) & FoundIn(x, dna))", "Exists x. (DNA(x) & FoundIn(thymine, x))", "Exists x. (DNA(x) & FoundIn(thymine, x))", "Exists y. (Thymine(y) & FoundIn(y, dna))", "Exists x. (DNA(x) & FoundIn(thymine, x))", "exists x. (Thymine(x) & FoundIn(x, dna))", "FoundIn(thymine, dna)", "FoundIn(thymine, dna)", "FoundIn(thymine, dna)", "Exists x. (DNA(x) & FoundIn(thymine, x))", "FoundIn(thymine, dna)", "Exists x. (Thymine(x) & FoundIn(x, dna))", "Exists y. (DNA(y) & FoundIn(thymine, y))", "exists x. (DNA(x) & FoundIn(thymine, x))", "FOL Translation:\nFoundIn(thymine, dna)"]}
{"id": "entailmentbank_validation_662", "nl": "thymine cannot be found in rna.", "fol": "", "prediction": ["all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "FOL Translation:\nall x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. -(Thymine(x) & FoundIn(x, rna))", "all x. (FoundIn(x, rna) -> -Thymine(x))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))", "all x. (RNA(x) -> -Contains(x, thymine))"]}
{"id": "entailmentbank_validation_663", "nl": "if thymine is found in a strand of nucleic acid, then the nucleic acid is dna.", "fol": "", "prediction": ["exists x. (NucleicAcidStrand(x) & Contains(x, thymine) -> DNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> IsDNA(x))", "exists x. (Strand(x) & NucleicAcid(x) & Found(thymine, x) -> DNA(x))", "exists x. (NucleicAcidStrand(x) & Contains(x, thymine) -> DNA(x))", "exists x. (Strand(x) & NucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))", "exists x. (Strand(x) & NucleicAcid(x) & Found(thymine, x) -> DNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))", "exists x. (NucleicAcidStrand(x) & ThymineFoundIn(x) -> DNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))", "exists x. (NucleicAcidStrand(x) & Contains(x, thymine) -> DNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> IsDNA(x))", "exists x. (FoundIn(thymine, x) & NucleicAcid(x) -> DNA(x))", "exists x. (NucleicAcidStrand(x) & ContainsThymine(x) -> IsDNA(x))", "exists x. (NucleicAcidStrand(x) & Found(thymine, x) -> DNA(x))", "exists x. (StrandOfNucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))", "exists x. (Strand(x) & NucleicAcid(x) & FoundIn(thymine, x) -> DNA(x))"]}
{"id": "entailmentbank_validation_664", "nl": "a researcher found thymine in a strand of nucleic acid.", "fol": "", "prediction": ["exists x. (Researcher(x) & exists y. (Thymine(y) & exists z. (StrandOfNucleicAcid(z) & Found(x, y, z))))", "exists x. (Researcher(x) & exists y. (StrandOfNucleicAcid(y) & FoundIn(thymine, y, x)))", "exists x y. (Researcher(x) & StrandOfNucleicAcid(y) & FoundIn(thymine, y, x))", "exists x. exists y. exists z. (Researcher(x) & Found(x, y, z) & Thymine(y) & StrandOfNucleicAcid(z))", "exists x. (Researcher(x) & exists y. (Thymine(y) & exists z. (StrandOfNucleicAcid(z) & FoundIn(y, z) & FoundBy(x, y))))", "exists x. exists y. (Researcher(x) & Finds(x, y) & Thymine(y) & exists z. (Strand(z) & NucleicAcid(z) & PartOf(y, z)))", "exists x exists y. (Researcher(x) & StrandOfNucleicAcid(y) & Found(x, thymine, y))", "exists x. exists y. (Researcher(x) & Thymine(y) & Found(x, y) & StrandOfNucleicAcid(z) & In(z, y))", "exists x. exists y. (Researcher(x) & StrandOfNucleicAcid(y) & FoundThymineIn(x, y))", "exists x. (Researcher(x) & exists y. (StrandOfNucleicAcid(y) & FoundThymineIn(x, y)))", "exists x. exists y. (Researcher(x) & StrandonNucleicAcid(y) & FoundThymineIn(x, y))", "exists x exists y. (Researcher(x) & NucleicAcid(y) & FoundThymineIn(x, y))", "exists x. exists y. exists z. (Researcher(x) & Strand(y) & NucleicAcid(z) & Contains(y, z) & Found(x, thymine, y))", "exists x exists y. (Researcher(x) & Found(x, y) & Thymine(y) & exists z. (StrandOfNucleicAcid(z) & PartOf(y, z)))", "exists x. exists y. (Researcher(x) & Found(x, y) & Thymine(y) & PartOf(y, z) & StrandOf(z, NucleicAcid))", "exists x. (Researcher(x) & exists y. (NucleicAcidStrand(y) & FoundThymineIn(x, y)))"]}
{"id": "entailmentbank_validation_665", "nl": "the researcher found a strand of dna.", "fol": "", "prediction": ["exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "exists x. (Researcher(the_researcher) & StrandOfDNA(x) & Found(the_researcher, x))", "exists x. (StrandOfDNA(x) & Found(researcher, x))", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "exists x. (Researcher(researcher) & StrandOfDNA(x) & Found(researcher, x))", "exists x. (Researcher(the_researcher) & StrandOfDNA(x) & Found(the_researcher, x))", "exists y. (Researcher(the_researcher) & DNA(y) & Found(the_researcher, y))", "`exists x. (StrandOfDNA(x) & Found(researcher, x))`", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "FOL Translation:\nexists y. (Researcher(x) & Found(x, y) & StrandOfDNA(y))", "FOL Translation:\nexists x. (Researcher(the_researcher) & StrandOfDNA(x) & Found(the_researcher, x))", "exists x. (Researcher(x) & exists y. (StrandOfDNA(y) & Found(x, y)))", "exists x. (Researcher(the_researcher) & DNA(x) & Found(the_researcher, x))", "exists x. (StrandOfDNA(x) & Researcher(researcher) & Found(researcher, x))", "exists y. (StrandOfDNA(y) & Found(researcher, y))"]}
{"id": "entailmentbank_validation_666", "nl": "if a pure dominant organism is crossed a recessive organism, then the offspring will have a 100% probability of being heterozygous dominant.", "fol": "", "prediction": ["all x. (PureDominantOrganism(x) & CrossedWith(x, RecessiveOrganism) -> OffspringHeterozygousDominant100(x))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringProbabilityHeterozygousDominant(100))", "all x y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominant_probability100_percent(x, y))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(x, y) = 1)", "all x. all y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability100())", "all x. all y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(x, y, 100))", "all x, y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability100(x, y))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(x, y) = 100)", "all x. all y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability100(x, y))", "all x. (PureDominantOrganism(x) & CrossedWithRecessive(x) -> OffspringProbHeterozygousDominant(x, 100))", "all x, y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability100(x, y))", "all x. all y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> HeterozygousDominantOffspring(x, y))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(x, y, 1.0))", "all x y. ((PureDominantOrganism(x) & RecessiveOrganism(y) & Crossed(x, y)) -> OffspringHeterozygousDominantProbability(100))", "all x y. ((PureDominant(x) & Recessive(y) & CrossedWith(x, y)) -> (OffspringHeterozygousDominant() & Probability(OffspringHeterozygousDominant()) = 100))", "all x y. ((PureDominant(x) & Recessive(y) & Crossed(x, y)) -> OffspringHeterozygousDominant(x, y))"]}
{"id": "entailmentbank_validation_667", "nl": "a scientist crosses a red-flowered plant with a white-flowered plant, and all offspring have red flowers.", "fol": "", "prediction": ["exists x, y. (Scientist(x) & Plant(y) & HasRedFlowers(y) & Crosses(x, y, z) & Plant(z) & HasWhiteFlowers(z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o)))", "exists x, y. (Scientist(x) & RedFloweredPlant(y) & exists z. (WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))", "exists x, y. (Scientist(x) & Plant(y) & HasRedFlowers(y) & Plant(z) & HasWhiteFlowers(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o)))", "exists x, y. (Scientist(x) & RedFloweredPlant(y) & exists z. (WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))", "exists x, y, z. (Scientist(x) & RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o) -> HasRedFlowers(o)))", "exists x, y, z. (Scientist(x) & Plant(y) & Plant(z) & HasRedFlowers(y) & HasWhiteFlowers(z) & Crosses(x, y, z) & all w. (Offspring(w, y, z) -> HasRedFlowers(w)))", "exists x. (Scientist(x) & exists y. exists z. (Plant(y) & FlowerColor(y, red) & Plant(z) & FlowerColor(z, white) & Crosses(x, y, z) & all o. (Offspring(o, x) -> FlowerColor(o, red))))", "exists x. (Scientist(x) & exists y. (exists z. (RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all w. (Offspring(w, Crossed(y, z)) -> HasRedFlowers(w)))))", "exists x, y. (Scientist(x) & Plant(y) & HasRedFlowers(y) & exists z. (Plant(z) & HasWhiteFlowers(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))", "exists x. (Scientist(x) & exists y. exists z. (RedFlowered(y) & Plant(y) & WhiteFlowered(z) & Plant(z) & Crosses(x, y, z) & all w. (Offspring(w, y, z) -> RedFlowered(w))))", "exists x, y, z. (Scientist(x) & Plant(y) & Plant(z) & HasFlowers(y, red) & HasFlowers(z, white) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasFlowers(o, red)))", "exists x, y. (Scientist(x) & RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> RedFlowers(o)))", "exists x, y. (Scientist(x) & RedFlowerPlant(y) & WhiteFlowerPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o)))", "exists x y z. (Scientist(x) & Plant(y) & Plant(z) & RedFlower(y) & WhiteFlower(z) & Crosses(x, y, z) & all o. (Offspring(o, z) -> RedFlower(o)))", "exists x exists y. (Scientist(x) & RedFloweredPlant(y) & WhiteFloweredPlant(z) & Crosses(x, y, z) & all o. (Offspring(o, x, y, z) -> HasRedFlowers(o)))", "exists x, y. (Scientist(x) & Plant(y) & HasRedFlowers(y) & exists z. (Plant(z) & HasWhiteFlowers(z) & Crosses(x, y, z) & all o. (Offspring(o, y, z) -> HasRedFlowers(o))))"]}
{"id": "entailmentbank_validation_668", "nl": "all the offspring with red flowers are heterozygous dominant.", "fol": "", "prediction": ["all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))", "all x. (Offspring(x) & HasRedFlowers(x) -> HeterozygousDominant(x))"]}
{"id": "entailmentbank_validation_669", "nl": "the offspring with red flowers are crossed with pure recessive white flowered plants.", "fol": "", "prediction": ["exists x y. (Offspring(x) & HasRedFlowers(x) & Plant(y) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessiveWhiteFlowers(y) & CrossedWith(x, y))", "exists x. (Offspring(x) & HasRedFlowers(x) & exists y. (PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y)))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & CrossedWith(x, y) & PureRecessive(y) & HasWhiteFlowers(y))", "exists x, y. (Offspring(x) & HasColor(x, red) & PureRecessive(y) & HasColor(y, white) & Crossed(x, y))", "exists x y. (Offspring(x) & HasRedFlowers(x) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessiveWhiteFloweredPlants(y) & CrossedWith(x, y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessiveWhiteFlowered(y) & CrossedWith(x, y))", "exists x. (Offspring(x) & HasColor(x, red) & CrossedWith(x, PureRecessiveWhiteFloweredPlant))", "exists x. (Offspring(x) & HasRedFlowers(x) & exists y. (Plant(y) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y)))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & CrossedWith(x, y) & Plant(y) & PureRecessive(y) & HasWhiteFlowers(y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & PureRecessive(y) & HasWhiteFlowers(y) & CrossedWith(x, y))", "exists x. (Offspring(x) & HasColor(x, red) & CrossedWith(x, exists y. (PureRecessive(y) & HasColor(y, white))))", "exists x y. (Offspring(x) & HasRedFlowers(x) & Plant(y) & PureRecessiveWhiteFlowers(y) & Crossed(x, y))", "exists x exists y. (Offspring(x) & RedFlowers(x) & CrossedWith(x, y) & PureRecessive(y) & WhiteFlowers(y))", "exists x, y. (Offspring(x) & HasRedFlowers(x) & CrossedWith(x, y) & PureRecessive(y) & HasWhiteFlowers(y))"]}
{"id": "entailmentbank_validation_670", "nl": "heterozygous dominant red flowered plants are crossed with pure recessive white flowered plants.", "fol": "", "prediction": ["exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "HeterozygousDominantRedFlowered(x) & PureRecessiveWhiteFlowered(y) -> Crossed(x, y)", "exists x exists y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "all x. (HeterozygousDominantRedFloweredPlant(x) -> exists y. (PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y)))", "exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "all x y. ((HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y)) -> CrossedWith(x, y))", "exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "all x. ((HeterozygousDominant(x) & RedFlowered(x)) -> exists y. (PureRecessive(y) & WhiteFlowered(y) & Crossed(x, y)))", "all x. (HeterozygousDominantRedFloweredPlant(x) & all y. (PureRecessiveWhiteFloweredPlant(y) -> Crossed(x, y)))", "exists x exists y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "all x y. ((HeterozygousDominant(x) & RedFlowered(x) & Plant(x) & Crossed(x, y) & PureRecessive(y) & WhiteFlowered(y) & Plant(y)) -> Crossed(x, y))", "exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & AreCrossed(x, y))", "exists x exists y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))", "all x. (HeterozygousDominantRedFloweredPlant(x) & exists y. (PureRecessiveWhiteFloweredPlant(y) & CrossedWith(x, y)))", "exists x, y. (HeterozygousDominantRedFloweredPlant(x) & PureRecessiveWhiteFloweredPlant(y) & Crossed(x, y))"]}
{"id": "entailmentbank_validation_671", "nl": "crossing a heterozygous dominant organism with a homozygous recessive organism causes their offspring to be dominant or recessive with either of 50% probability.", "fol": "", "prediction": ["exists x, y. (HeterozygousDominant(x) & HomozygousRecessive(y) -> all z. (Offspring(z, x, y) -> (Dominant(z) | Recessive(z)) & Probability(Dominant(z), 0.5) & Probability(Recessive(z), 0.5)))", "all x y. ((HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(y) & Cross(x, y)) -> forall z. (Offspring(z, x, y) -> ((Dominant(z) & Probability(z, 50)) | (Recessive(z) & Probability(z, 50)))))", "let's break down the sentence:\n\n1. Identify the main components:\n   - Heterozygous dominant organism (HDO)\n   - Homozygous recessive organism (HRO)\n   - Offspring being dominant (DO) or recessive (RO)\n\n2. Keep in mind the probability aspect (50% dominant, 50% recessive).\n\n3. Define predicates:\n   - `HeteroDom(x)`: `x` is heterozygous dominant\n   - `HomoRec(x)`: `x` is homozygous recessive\n   - `Offspring(x, y, z)`: offspring `z` is from parent `x` and parent `y`\n   - `Dominant(z)`: `z` is a dominant offspring\n   - `Recessive(z)`: `z` is a recessive offspring\n\n4. Probability can't be captured directly in standard FOL, but we can express the either/or result in logical terms.\n\n5. Translate the sentence with these predicates.\n\nFOL Translation:\nall x, y, z. ((HeteroDom(x) & HomoRec(y) & Offspring(x, y, z)) -> (Dominant(z) | Recessive(z)))", "exists x, y, z. (HeterozygousDominant(x) & HomozygousRecessive(y) & Offspring(z, x, y) -> (Dominant(z) | Recessive(z)) & Probability(z, Dominant, 0.5) & Probability(z, Recessive, 0.5))", "exists x, y, z. (HeterozygousDominant(x) & HomozygousRecessive(y) & Offspring(x, y, z) -> (Dominant(z) & Probability(z, dominant, 0.5)) | (Recessive(z) & Probability(z, recessive, 0.5)))", "all x. all y. ((HeterozygousDominant(x) & HomozygousRecessive(y) & OffspringOf(z, x, y)) -> (Dominant(z) & Probability(z, 0.5) | Recessive(z) & Probability(z, 0.5)))", "Let's define the necessary predicates:\n- `HeterozygousDominant(x)`: x is a heterozygous dominant organism.\n- `HomozygousRecessive(y)`: y is a homozygous recessive organism.\n- `Offspring(z, x, y)`: z is an offspring of organisms x and y.\n- `Dominant(z)`: z is dominant.\n- `Recessive(z)`: z is recessive.\n\nFOL Translation:\nall x, y. ((HeterozygousDominant(x) & HomozygousRecessive(y)) -> (exists z. (Offspring(z, x, y) & ((Dominant(z) & Probability(z, 0.5)) | (Recessive(z) & Probability(z, 0.5))))))", "exists x, y. (HeterozygousDominant(x) & HomozygousRecessive(y) & Crossing(x, y) -> all z. (Offspring(z, x, y) -> (Dominant(z) & Probability(z, 0.5)) | (Recessive(z) & Probability(z, 0.5))))", "all o. ((HeterozygousDominant(o1) & HomozygousRecessive(o2) & CrossedWith(o1, o2, o)) -> (Dominant(o) & Probability(o, 0.5)) | (Recessive(o) & Probability(o, 0.5)))", "all x. all y. ((HeterozygousDominant(x) & HomozygousRecessive(y) & ParentOf(x, o) & ParentOf(y, o)) -> (OffspringDominant(o) & Probability(OffspringDominant(o), 0.5) | OffspringRecessive(o) & Probability(OffspringRecessive(o), 0.5)))", "all x, y. ((HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(y) & Crosses(x, y)) -> all z. (Offspring(z, x, y) -> (Dominant(z) & Probability(z, dominant, 0.5)) | (Recessive(z) & Probability(z, recessive, 0.5))))", "Let's define relevant predicates and terms: \n- `HeterozygousDominant(x)`: `x` is a heterozygous dominant organism.\n- `HomozygousRecessive(x)`: `x` is a homozygous recessive organism.\n- `Offspring(o, x, y)`: `o` is the offspring of organisms `x` and `y`.\n- `Dominant(o)`: `o` is dominant.\n- `Recessive(o)`: `o` is recessive.\n\nFOL Translation:\nall x, y, o. ((HeterozygousDominant(x) & HomozygousRecessive(y) & Offspring(o, x, y)) -> (Probability(Dominant(o)) = 0.5 & Probability(Recessive(o)) = 0.5))", "all x. all y. (HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(y) & Cross(x, y) -> all z. (Offspring(z, x, y) -> (Dominant(z) & Probability(z, dominant, 50) | Recessive(z) & Probability(z, recessive, 50))))", "exists x, y. ((HeterozygousDominant(x) & HomozygousRecessive(y) & Crosses(x, y)) -> \n  all z. (Offspring(z, x, y) -> (Dominant(z) | Recessive(z)) & \n  (Probability(Dominant(z)) = 0.5 & Probability(Recessive(z)) = 0.5)))", "```\nall x, y. ((HeterozygousDominant(x) & HomozygousRecessive(y) & CrossesWith(x, y)) -> \n  all z. (Offspring(z, x, y) -> (Dominant(z) | Recessive(z)) & ProbDominant(z) = 0.5 & ProbRecessive(z) = 0.5))\n```", "all x. (HeterozygousDominantOrganism(x) & HomozygousRecessiveOrganism(x) -> exists y. (Offspring(y) & (Dominant(y) | Recessive(y)) & ProbabilityOfTrait(y, Dominant, 0.5) & ProbabilityOfTrait(y, Recessive, 0.5)))"]}
{"id": "entailmentbank_validation_672", "nl": "the offspring will have either dominant red flowers or recessive white flowers with either of 50% probability.", "fol": "", "prediction": ["exists x. (Offspring(x) & (ProbabilityOf(RedFlowers(x), 0.5) | ProbabilityOf(WhiteFlowers(x), 0.5)))", "exists o. (Offspring(o) & ((DominantRedFlowers(o) & Probability(o, 50)) | (RecessiveWhiteFlowers(o) & Probability(o, 50))))", "exists x. (Offspring(x) -> (HasDominantRedFlowers(x) & Probability(HasDominantRedFlowers(x), 0.5)) | (HasRecessiveWhiteFlowers(x) & Probability(HasRecessiveWhiteFlowers(x), 0.5)))", "exists x. (Offspring(x) & (Probability(RedFlowers(x), 0.5) | Probability(WhiteFlowers(x), 0.5)))", "exists x. (Offspring(x) & ((DominantRedFlowers(x) & Probability(x, 0.5)) | (RecessiveWhiteFlowers(x) & Probability(x, 0.5))))", "exists x. (Offspring(x) & (Probability(DominantRedFlower(x), 0.5) | Probability(RecessiveWhiteFlower(x), 0.5)))", "exists x. (Offspring(x) & (Probability(RedFlowers(x), 0.5) & Probability(WhiteFlowers(x), 0.5)))", "exists x. (Offspring(x) & ((DominantRedFlowers(x) & Probability(x, 50)) | (RecessiveWhiteFlowers(x) & Probability(x, 50))))", "exists x. (Offspring(x) & ((HasDominantRedFlowers(x) & Probability(x, \"50%\")) | (HasRecessiveWhiteFlowers(x) & Probability(x, \"50%\"))))", "exists x. (Offspring(x) & (HasDominantRedFlowers(x) & Probability(x, 50) | HasRecessiveWhiteFlowers(x) & Probability(x, 50)))", "exists x. (Offspring(x) & ( (DominantRedFlowers(x) & Probability(x, 50)) | (RecessiveWhiteFlowers(x) & Probability(x, 50)) ) )", "exists x. (Offspring(x) & (Probability(RedFlowers(x), 50) | Probability(WhiteFlowers(x), 50)))", "exists o. ((Offspring(o) & Flower(o)) -> (DominantRedFlower(o) & Probability(o, 0.5)) | (RecessiveWhiteFlower(o) & Probability(o, 0.5)))", "exists x. (Offspring(x) & (Probability(x, RedFlowers) = 0.5 | Probability(x, WhiteFlowers) = 0.5) & (Dominant(RedFlowers) | Recessive(WhiteFlowers)))", "To represent the given sentence, we should define predicates and constants. Let's define the predicates `Offspring(x)` to identify offspring instances, `HasDominantRedFlowers(x)` to indicate an offspring has dominant red flowers, `HasRecessiveWhiteFlowers(x)` to indicate an offspring has recessive white flowers, and `Probability(x, y, z)` to represent x having y with probability z.\n\nThe translation in FOL would be:\nall x. (Offspring(x) -> (Probability(x, HasDominantRedFlowers(x), 0.5) | Probability(x, HasRecessiveWhiteFlowers(x), 0.5)))", "exists x. (Offspring(x) & ((DominantRedFlowers(x) | RecessiveWhiteFlowers(x)) & Probability(DominantRedFlowers(x), 0.5) & Probability(RecessiveWhiteFlowers(x), 0.5)))"]}
{"id": "entailmentbank_validation_673", "nl": "each parent carries one sickle cell allele.", "fol": "", "prediction": ["all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> CarriesSickleCellAllele(x, one))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> Carries(x, one_sickle_cell_allele))", "all x. (Parent(x) -> exists y. (SickleCellAllele(y) & Carries(x, y)))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> CarriesOneSickleCellAllele(x))", "all x. (Parent(x) -> CarriesSickleCellAllele(x, one))"]}
{"id": "entailmentbank_validation_674", "nl": "sickle cell anemia is a recessive trait in human.", "fol": "", "prediction": ["RecessiveTraitIn(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "all x. (Human(x) & HasSickleCellAnemia(x) -> RecessiveTrait(HasSickleCellAnemia(x)))", "RecessiveTrait(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "all x. (Human(x) -> RecessiveTrait(sickle_cell_anemia, x))", "RecessiveTrait(sickle_cell_anemia) & TraitOf(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "RecessiveTrait(sickle_cell_anemia, human)", "RecessiveTraitInHuman(sickle_cell_anemia)", "RecessiveTrait(sickle_cell_anemia, human)", "Trait(sickle_cell_anemia) & Recessive(sickle_cell_anemia) & all x. (Human(x) -> HasTrait(x, sickle_cell_anemia) <-> RecessiveInheritance(x, sickle_cell_anemia))", "all x. ((Human(x) & RecessiveTrait(sickle_cell_anemia, x)) <-> Recessive(sickle_cell_anemia))", "RecessiveTraitInHuman(sickle_cell_anemia)"]}
{"id": "entailmentbank_validation_675", "nl": "each parent has one dominant gene and a recessive gene for sickle cell anemia.", "fol": "", "prediction": ["all x. (Parent(x) -> (exists y. (DominantGene(x, y) & SickleCellAnemiaGene(y))) & exists z. (RecessiveGene(x, z) & SickleCellAnemiaGene(z)))", "all x. (Parent(x) -> exists y. (DominantGene(x, y) & RecessiveGene(x, sickle_cell_anemia)))", "all x. (Parent(x) -> exists y. (DominantGene(x, y) & RecessiveGene(x, y) & SickleCellAnemiaGene(y)))", "all x. (Parent(x) -> exists d, r. (DominantGene(x, d) & RecessiveGene(x, r) & SickleCellGene(d) & SickleCellGene(r)))", "all x. (Parent(x) -> exists y. (DominantGene(x, y) & RecessiveGene(x, y) & GeneForSickleCellAnemia(y)))", "all x. (Parent(x) -> exists g1. (DominantGene(g1) & HasGene(x, g1) & exists g2. (RecessiveGene(g2) & HasGene(x, g2) & g1 != g2)))", "all x. (Parent(x) -> exists d. exists r. (DominantGene(x, d) & RecessiveGene(x, r) & SickleCellAnemiaGene(d) & SickleCellAnemiaGene(r)))", "all x. (Parent(x) -> exists d. (DominantGeneForSickleCell(d) & HasGene(x, d) & exists r. (RecessiveGeneForSickleCell(r) & HasGene(x, r))))", "all x. (Parent(x) -> exists g1, g2. (DominantGeneForSickleCellAnemia(g1) & RecessiveGeneForSickleCellAnemia(g2) & HasGene(x, g1) & HasGene(x, g2)))", "all x. (Parent(x) -> exists y. (DominantGene(x, y) & RecessiveGene(x, y) & GeneForSickleCellAnemia(y)))", "all x. (Parent(x) -> exists y. (DominantGeneForSickleCellAnemia(y) & HasGene(x, y) & exists z. (RecessiveGeneForSickleCellAnemia(z) & HasGene(x, z) & y != z)))", "all x. (Parent(x) -> exists y z. (DominantGeneForSickleCell(x, y) & RecessiveGeneForSickleCell(x, z) & Gene(y) & Gene(z) & OneDominantOneRecessive(y, z)))", "all x. (Parent(x) -> (exists y. (DominantGeneForSickleCellAnemia(x, y) & Gene(y))) & exists z. (RecessiveGeneForSickleCellAnemia(x, z) & Gene(z)))", "all x. (Parent(x) -> exists d. exists r. (DominantGene(x, d) & RecessiveGene(x, r) & GeneForSickleCellAnemia(d) & GeneForSickleCellAnemia(r)))", "all x. (Parent(x) -> exists d, r. (DominantGene(x, d) & RecessiveGene(x, r) & GeneForSickleCellAnemia(d) & GeneForSickleCellAnemia(r)))", "all x. (Parent(x) -> exists y. (DominantGeneForSickleCell(y) & RecessiveGeneForSickleCell(y) & HasGene(x, y)))"]}
{"id": "entailmentbank_validation_676", "nl": "heterozygous dominant organisms have one dominant gene and one recessive gene.", "fol": "", "prediction": ["all x. (HeterozygousDominant(x) -> exists y. (DominantGene(y) & Possesses(x, y)) & exists z. (RecessiveGene(z) & Possesses(x, z)))", "all x. (HeterozygousDominant(x) -> exists g1, g2. (DominantGene(g1) & RecessiveGene(g2) & HasGene(x, g1) & HasGene(x, g2) & Different(g1, g2)))", "all x. (HeterozygousDominantOrganism(x) -> exists y. (DominantGene(y) & HasGene(x, y) & exists z. (RecessiveGene(z) & HasGene(x, z))))", "all x. (HeterozygousDominant(x) -> (exists y. (DominantGene(y) & HasGene(x, y)) & exists z. (RecessiveGene(z) & HasGene(x, z))))", "all x. (HeterozygousDominantOrganism(x) -> exists y. (DominantGene(y) & HasGene(x, y)) & exists z. (RecessiveGene(z) & HasGene(x, z)))", "all x. (HeterozygousDominant(x) -> exists y. (DominantGene(y) & PartOf(y, x) & exists z. (RecessiveGene(z) & PartOf(z, x))))", "all x. (HeterozygousDominant(x) -> exists y. (DominantGene(y) & HasGene(x, y) & exists z. (RecessiveGene(z) & HasGene(x, z))))", "all x. (HeterozygousDominantOrganism(x) -> exists y. exists z. (DominantGene(y) & RecessiveGene(z) & HasGene(x, y) & HasGene(x, z) & y != z))", "all x. (HeterozygousDominantOrganism(x) -> exists y. (DominantGene(y) & PartOf(y, x)) & exists z. (RecessiveGene(z) & PartOf(z, x)))", "all x. (HeterozygousDominantOrganism(x) -> exists a. exists b. (DominantGene(a) & RecessiveGene(b) & HasGene(x, a) & HasGene(x, b)))", "all x. (HeterozygousDominant(x) -> (exists y. (DominantGene(x, y) & RecessiveGene(x, y) & DiffGenes(DominantGene(x, y), RecessiveGene(x, y)))))", "all x. (HeterozygousDominant(x) -> exists g1, g2. (DominantGene(g1) & RecessiveGene(g2) & HasGene(x, g1) & HasGene(x, g2)))", "all x. (HeterozygousDominant(x) -> exists y exists z. (DominantGene(y) & RecessiveGene(z) & HasGene(x, y) & HasGene(x, z) & y \u2260 z))", "all x. (HeterozygousDominantOrganism(x) -> (exists y. (DominantGene(y) & HasGene(x, y))) & exists z. (RecessiveGene(z) & HasGene(x, z)))", "all x. (HeterozygousDominant(x) -> exists d. exists r. (DominantGene(d) & RecessiveGene(r) & HasGene(x, d) & HasGene(x, r) & d != r))", "all x. (HeterozygousDominant(x) -> exists g1, g2. (DominantGene(g1) & RecessiveGene(g2) & HasGene(x, g1) & HasGene(x, g2) & g1 != g2))"]}
{"id": "entailmentbank_validation_677", "nl": "both parents are heterozygous dominant for sickle cell anemia.", "fol": "", "prediction": ["all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))", "`all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))`", "HeterozygousDominantForSickleCell(parent1) & HeterozygousDominantForSickleCell(parent2)", "HeterozygousDominant(parent1, sickle_cell_anemia) & HeterozygousDominant(parent2, sickle_cell_anemia)", "exists x. (Parent(x) & HeterozygousDominantForSickleCellAnemia(x)) & exists y. (Parent(y) & x \u2260 y & HeterozygousDominantForSickleCellAnemia(y))", "exists x. (Parent(x) & HeterozygousDominantForSickleCellAnemia(x)) & exists y. (Parent(y) & HeterozygousDominantForSickleCellAnemia(y) & x != y)", "HeterozygousDominant(parent1, sickle_cell_anemia) & HeterozygousDominant(parent2, sickle_cell_anemia)", "exists x. exists y. (Parent(x) & Parent(y) & HeterozygousDominantForSickleCellAnemia(x) & HeterozygousDominantForSickleCellAnemia(y))", "all p. (Parent(p) & HeterozygousDominantForSickleCellAnemia(p))", "exists x. (Parent(x) & HeterozygousDominantForSickleCellAnemia(x)) & exists y. (Parent(y) & HeterozygousDominantForSickleCellAnemia(y) & x \\= y)", "all p. (Parent(p) -> HeterozygousDominantForSickleCellAnemia(p))", "all x. ((Parent(x) & HeterozygousDominantForSickleCellAnemia(x)) & exists y. (Parent(y) & HeterozygousDominantForSickleCellAnemia(y) & y \u2260 x))", "all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))", "all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))", "all x. ((Parent(x) & HeterozygousDominant(x)) -> SickleCellAnemia(x))", "all x. (Parent(x) -> HeterozygousDominantForSickleCellAnemia(x))"]}
{"id": "entailmentbank_validation_678", "nl": "if a heterozygous dominant organism is crossed with a heterozygous dominant organism, then the offspring will have a 25% probability of being homozygous recessive.", "fol": "", "prediction": ["all x. all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> HasProbabilityOfHomozygousRecessiveOffspring(offspring(x, y), 0.25))", "FOL Translation:\nall x all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringHas25PercentProbabilityOfBeingHomozygousRecessive(x, y))", "all x all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & CrossedWith(x, y)) -> HasProbability(Offspring(x, y), HomozygousRecessive, 0.25))", "all x, y, z. ((HeterozygousDominant(x) & HeterozygousDominant(y) & ParentsOf(x, y, z)) -> ProbabilityHomozygousRecessive(z) = 0.25)", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(offspring(x, y), 0.25))", "all x. all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringHomozygousRecessiveWithProbability(x, y, 0.25))", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(offspring, 0.25))", "all x. (HeterozygousDominantOrganism(x) & CrossedWith(x, x) -> OffspringHomozygousRecessiveProb(x, 0.25))", "all x y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> Probability(OffspringHomozygousRecessive, 0.25))", "FOL Translation:\n\nall x. all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringHas25PercentProbabilityHomozygousRecessive(x, y))", "To translate the sentence into first-order logic (FOL), we must define the predicates that capture the structure of genetic inheritance described:\n\n1. **HeterozygousDominant(x)**: Object x is a heterozygous dominant organism.\n2. **CrossedWith(x, y)**: Organism x is crossed with organism y.\n3. **Offspring(z)**: z is an offspring from a genetic cross.\n4. **HomozygousRecessive(z)**: z is homozygous recessive.\n5. **Probability(z, p)**: z has a probability p of being a certain trait.\n\nGiven the sentence, the translation is:\n\nFOL Translation:\n``` \nall x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & CrossedWith(x, y)) -> \n     exists z. (Offspring(z) & Probability(HomozygousRecessive(z), 0.25)))\n```\n\nHere, for any two organisms x and y, if both are heterozygous dominant and they are crossed, then there exists an offspring z that is homozygous recessive with a probability of 25%.", "all x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(x, y, 0.25))", "all x, y, z. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y, z)) -> Has25PercentProbability(HomozygousRecessive(z)))", "all x, y. ((Organism(x) & Organism(y) & HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(x, y) = 0.25)", "Let's denote: \n- `HeterozygousDominant(x)` as organism x is heterozygous dominant.\n- `CrossedWith(x, y)` as organisms x and y are crossed.\n- `Offspring(z, x, y)` as z is an offspring of organisms x and y.\n- `HomozygousRecessive(z)` as organism z is homozygous recessive.\n- `Probability(z, p)` as the probability for condition z is p%.\n\nFOL Translation:\nall x, y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & CrossedWith(x, y)) -> \n            exists z. (Offspring(z, x, y) & Probability(HomozygousRecessive(z), 25)))", "all x. all y. ((HeterozygousDominant(x) & HeterozygousDominant(y) & Crossed(x, y)) -> OffspringProbabilityHomozygousRecessive(Cross(x, y), 0.25))"]}
{"id": "entailmentbank_validation_679", "nl": "the offspring of heterozygous dominant parents will have 25% probability of being homozygous recessive for sickle cell anemia.", "fol": "", "prediction": ["all x. (OffspringOf(x, HeterozygousDominantParents) -> Probability(HomozygousRecessive(x, SickleCellAnemia), 0.25))", "all x. ((Offspring(x) & ParentsHeterozygousDominant(x)) -> Has25PercentProbability(x, HomozygousRecessive))", "all x. ((Offspring(x) & Parent1(x, htp) & Parent2(x, htp) & HeterozygousDominant(htp)) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "all x. ((Offspring(x) & Parents(x, p1, p2) & HeterozygousDominant(p1) & HeterozygousDominant(p2)) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "all x. ((Offspring(x) & HeterozygousDominantParents(x)) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "Let the predicates be:\n- `Offspring(x, y)`: x is an offspring of y.\n- `HeterozygousDominant(y)`: y is a heterozygous dominant parent.\n- `HomozygousRecessiveForSickleCellAnemia(x)`: x is homozygous recessive for sickle cell anemia.\n- `Has25PercentProbability(z)`: z has 25% probability.\n\nFOL Translation:\nall x, y. ((HeterozygousDominant(y) & Offspring(x, y)) -> Has25PercentProbability(HomozygousRecessiveForSickleCellAnemia(x)))", "all x. (Offspring(x, heterozygous_dominant_parents) -> HasProbabilityOfBeing(x, homozygous_recessive_for_sickle_cell_anemia, 0.25))", "all x. ((Offspring(x) & Parents(x, heterozygous_dominant)) -> Has25PercentProbability(HomozygousRecessiveForSickleCellAnemia(x)))", "exists x. (Offspring(x) & Parent(y1) & Parent(y2) & HeterozygousDominant(y1) & HeterozygousDominant(y2) & ProbabilityOfBeingHomozygousRecessiveForSickleCellAnemia(x) = 0.25)", "all x. ((Offspring(x) & Parent1_HeterozygousDominant(x) & Parent2_HeterozygousDominant(x)) -> Probability_HomozygousRecessive(x, 0.25) & SickleCellAnemia(x))", "all x. ((Offspring(x) & HeterozygousDominantParents(x)) -> Probability(HomozygousRecessiveForSickleCellAnemia(x)) = 0.25)", "all x. (OffspringOf(x, HeterozygousDominantParents) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))", "exists x, y, z. (HeterozygousDominant(x) & HeterozygousDominant(y) & Offspring(z, x, y) -> Probability(HomozygousRecessiveForSickleCell(z)) = 0.25)", "all x. (Offspring(x) & HeterozygousDominantParents(x) -> Probability(HomozygousRecessiveSickleCellAnemia(x)) = 0.25)", "all x. (Offspring(x, HeterozygousDominantParents) -> HasProbability(x, HomozygousRecessiveForSickleCellAnemia, 0.25))", "all x. (Offspring(x) & ParentHeterozygousDominant(x) -> Probability(HomozygousRecessiveForSickleCellAnemia(x), 0.25))"]}
{"id": "entailmentbank_validation_680", "nl": "homozygous recessive organisms will show the recessive trait.", "fol": "", "prediction": ["all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowRecessiveTrait(x))", "all x. (HomozygousRecessiveOrganism(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))", "all x. (HomozygousRecessive(x) -> ShowsRecessiveTrait(x))"]}
{"id": "entailmentbank_validation_681", "nl": "the offspring of heterozygous dominant parents will have 25% probability of having sickle cell anemia.", "fol": "", "prediction": ["all x. (OffspringOf(x, heterozygous_dominant_parents) -> Probability(SickleCellAnemia(x)) = 0.25)", "all x. ((Offspring(x) & From(Parents(x, heterozygous_dominant))) -> Probability(SickleCellAnemia(x), 0.25))", "all x. (OffspringOf(x, heterozygous_dominant_parents) -> ProbabilityHasSickleCellAnemia(x, 0.25))", "exists x. (OffspringOf(x, heterozygous_dominant_parents) & Probability(x, sickle_cell_anemia, 0.25))", "Let \"Offspring(x)\" denote that x is an offspring, \"HeterozygousDominantParent(x)\" denote that x is a heterozygous dominant parent, and \"HasSickleCellAnemia(x)\" denote that x has sickle cell anemia. We introduce a notation \"Probability25Percent(x, y)\" to represent that y has a 25% probability of a certain trait or condition if x has certain properties.\n\nFOL Translation:\nall x. (HeterozygousDominantParent(x) -> \n  exists y. (Offspring(y) & Probability25Percent(HasSickleCellAnemia(y), y)))", "all x. ((Offspring(x) & ParentsHeterozygousDominant(x)) -> Probability(SickleCellAnemia(x), 0.25))", "all x. (OffspringOf(x, HeterozygousDominantParents) -> HasProbability(x, SickleCellAnemia, 0.25))", "exists x. (OffspringOf(x, HeterozygousDominantParents) -> ProbabilityOfSickleCellAnemia(x) = 0.25)", "exists x. (Offspring(x) & HeterozygousDominantParents(x) -> ProbabilityOfSickleCellAnemia(x) = 0.25)", "all x, y. (HeterozygousDominantParent(x) & HeterozygousDominantParent(y) & OffspringOf(z, x, y) -> Probability(SickleCellAnemia(z), 0.25))", "All x. ((OffspringOf(x, heterozygous_dominant_parents) & Has25PercentProbability(x, sickle_cell_anemia)) -> True)", "all x. (OffspringOf(x, heterozygous_dominant_parents) -> HasProbability(x, sickle_cell_anemia, 0.25))", "all x, y. ((Parent(x) & Parent(y) & HeterozygousDominant(x) & HeterozygousDominant(y)) -> Has25PercentProbabilityOfSickleCellAnemia(Offspring(x, y)))", "exists x. (OffspringOf(x, heterozygous_dominant_parents) & Probability(SickleCellAnemia(x), 0.25))", "all x. (OffspringOf(x, HeterozygousDominantParents) -> ProbabilityOf(SickleCellAnemia(x)) = 0.25)", "all x. ((Offspring(x) & HeterozygousDominantParents(x)) -> HasProbability(x, sickle_cell_anemia, 0.25))"]}
{"id": "entailmentbank_validation_682", "nl": "one in four is the same as 25%.", "fol": "", "prediction": ["all x. (OneInFour(x) <-> TwentyFivePercent(x))", "SameAs(one_in_four, twenty_five_percent)", "sameAs(OneInFour, TwentyFivePercent)", "Same(one_in_four, twenty_five_percent)", "(1/4 = 25%)", "Proportion(one_in_four) = Proportion(twenty_five_percent)", "all x. (OneInFour(x) <-> TwentyFivePercent(x))", "Percentage(oneInFour, 25)", "Existence of this specific statement in FOL can be slightly abstract due to its mathematical and declarative nature. However, a logical representation might involve comparing the equivalence of two structures: 'one in four' and '25%'. Abstractly:\n\n```\nall x. (OneInFour(x) <-> Percent25(x))\n```\n\nThis suggests that any situation described as 'one in four' can be equivalently described as '25%'.", "all x. (OneInFour(x) <-> EqualsTo(x, 25Percent))", "Percentage(oneInFour, 25)", "Same(one_in_four, twenty_five_percent)", "all x. (OneInFour(x) <-> SameAsTwentyFivePercent(x))", "(all x. (IsOneInFour(x) <-> Is25Percent(x)))", "`one_fourth = twenty_five_percent`", "Equal(one_in_four, twenty_five_percent)"]}
{"id": "entailmentbank_validation_683", "nl": "one in four of the offspring of heterozygous dominant parents will have sickle cell anemia.", "fol": "", "prediction": ["Let us denote: \n- `Offspring(x)`: x is an offspring.\n- `HeterozygousDominantParent(y)`: y is a heterozygous dominant parent.\n- `HasSickleCellAnemia(x)`: x has sickle cell anemia.\n\nWe interpret \"one in four of the offspring\" to mean that there is a 25% probability for a single offspring to have sickle cell anemia, given the specific genetic conditions. This is naturally a probabilistic statement, which is typically not directly expressible in classical FOL. In classic FOL, precise probabilistic reasoning is challenging, but we can express the relevant conditions:\n\nall x, y. ((Offspring(x) & HeterozygousDominantParent(y)) -> (exists z, w. (HasSickleCellAnemia(z) & Offspring(z) & Offspring(w) & Offspring(w) & Offspring(w) & w != z)))", "Let `Offspring(x)`, `HeterozygousDominantParent(x)`, and `HasSickleCellAnemia(x)` represent the predicates for being an offspring, having heterozygous dominant parents, and having sickle cell anemia, respectively.\n\nTo express \"one in four\" of offspring, you could use a probabilistic or frequentist approach, but typically in FOL, we clarify using existential quantifiers for simplicity if such statistics are expressed usually outside strict logical FOL representation. Thus, the primary translation will focus on the offspring having sickle cell anemia when both parents are heterozygous dominant.\n\nFOL Translation:\nall x. ((Offspring(x) & exists y. (HeterozygousDominantParent(y) & ParentOf(y, x))) -> Probability(HasSickleCellAnemia(x), 0.25))", "Let HeterozygousDominant(x) represent \"x is a heterozygous dominant parent\", Offspring(x, y) represent \"y is an offspring of x\", and HasSickleCellAnemia(y) represent \"y has sickle cell anemia\".\n\nFOL Translation:\nall x. (HeterozygousDominant(x) -> (exists y1, y2, y3, y4. (Offspring(x, y1) & Offspring(x, y2) & Offspring(x, y3) & Offspring(x, y4) & HasSickleCellAnemia(y1) & -HasSickleCellAnemia(y2) & -HasSickleCellAnemia(y3) & -HasSickleCellAnemia(y4))))", "Let's break down the sentence for translation:\n\n- We start with \"One in four of the offspring of heterozygous dominant parents\".\n- This suggests there is a probabilistic element involved, which we can express as one quarter of offspring.\n- We recognize \"offspring of heterozygous dominant parents\" as having specific parentage.\n- \"Have sickle cell anemia\" indicates the condition of the offspring.\n\nThus, we translate this sentence as follows.\n\nFOL Translation:\nall x. (OffspringOfHeterozygousDominantParents(x) -> Probability(SickleCellAnemia(x), 0.25))", "Let \"Offspring(x)\" represent an offspring, \"HeterozygousDominantParent(x)\" denote a heterozygous dominant parent, and \"HasSickleCellAnemia(x)\" indicate having sickle cell anemia. We need to represent \"one in four\" conceptually, which could be more broadly expressed using probabilities or interpretations in a set of possible outcomes.\n\nSince strict quantification like \"one in four\" isn't directly expressible in classical FOL, we would use an approximation within our domain assumptions. Here, I'll write it in a way accounting for probabilistic interpretation:\n\nall x y. ((Offspring(x) & HeterozygousDominantParent(y) & Parent(y, x)) -> ProbHasSickleCell(x, 1/4))\n\nThis implies every offspring of heterozygous dominant parents has a 1 in 4 likelihood to have sickle cell anemia.", "To translate this sentence into FOL, we can start by clarifying the entities and predicates involved. Let's assume the following:\n\n1. \\( x \\) is an offspring.\n2. \\( y \\) and \\( z \\) are parents.\n3. \\( HeterozygousDominant(y, z) \\) indicates that both parents are heterozygous dominant.\n4. \\( Offspring(x, y, z) \\) indicates \\( x \\) is an offspring of parents \\( y \\) and \\( z \\).\n5. \\( SickleCellAnemia(x) \\) indicates that \\( x \\) has sickle cell anemia.\n6. \\( OneInFour(x, y, z) \\) indicates that one in four offspring of parents \\( y \\) and \\( z \\) has a property (in this case, sickle cell anemia).\n\nThe sentence indicates a probabilistic outcome (one in four), so to express this using FOL in a simplified manner, we can say: \n\n\\[ \nall y, z. (HeterozygousDominant(y, z) -> exists x. (Offspring(x, y, z) & SickleCellAnemia(x) & OneInFour(x, y, z)))\n\\]\n\nWhile FOL is not naturally suited to express probabilities directly (such as \"one in four\"), this representation attempts to capture the requirement that there exists some offspring with the property. Typically, precise representation of statistical probabilities would require extensions or combinations with probabilistic logic.", "exists x y. (HeterozygousDominant(x) & HeterozygousDominant(y) & Parent(x) & Parent(y) -> all z. (Offspring(z, x, y) -> (Probability(z, SickleCellAnemia, 0.25))))", "To translate the given sentence into first-order logic, let's break down the components:\n\n1. **Dominant and Heterozygous Parents**: Let `HeterozygousDominantParent(x)` be a predicate to denote that `x` is a heterozygous dominant parent.\n2. **Offspring**: Let `Offspring(x, y)` mean `x` is an offspring of `y`.\n3. **Sickle Cell Anemia**: Let `HasSickleCellAnemia(x)` denote that `x` has sickle cell anemia.\n\nBased on the sentence, we are considering a probabilistic model that isn't natively supported by standard first-order logic, but we can simulate the essence by considering conditions over offspring. Here is one way to formalize it:\n\nFOL Translation:\nall y. (HeterozygousDominantParent(y) -> exists x1, x2, x3, x4. (Offspring(x1, y) & Offspring(x2, y) & Offspring(x3, y) & Offspring(x4, y) & HasSickleCellAnemia(x1) & -HasSickleCellAnemia(x2) & -HasSickleCellAnemia(x3) & -HasSickleCellAnemia(x4)))\n\nThis logical translation is a way to symbolize \"one in four\" probabilistically by stating that out of four offspring, one has sickle cell anemia while the others do not.", "all x. ((Offspring(x) & ParentDominance(x, heterozygous_dominant) & ParentRatio(x, 1, 4)) -> HasSickleCellAnemia(x))", "FOL Translation:\nall x. ((Offspring(x) & HeterozygousDominantParents(x)) -> (Probability(SickleCellAnemia(x), 1/4)))", "HeterozygousDominant(x) & Parent(x) & Offspring(y, x) -> ProbabilityOfSickleCellAnemia(y) = 0.25", "Let us define the predicates as follows:\n\n- `Offspring(x)`: x is an offspring.\n- `HeterozygousDominantParent(p)`: p is a heterozygous dominant parent.\n- `HasSickleCellAnemia(x)`: x has sickle cell anemia.\n\nAssuming we want to express that for each pair of heterozygous dominant parents, one in every four of their offspring will have sickle cell anemia, we'll translate the sentence into FOL as:\n\nall p, q, o. ((HeterozygousDominantParent(p) & HeterozygousDominantParent(q) & Offspring(o) & OffspringOf(o, p, q)) -> HasSickleCellAnemia(o) <-> (one_in_four_condition)) \n\nwhere `one_in_four_condition` would symbolize some condition reflecting the probability. FOL doesn't inherently handle probabilistic statements, so the direct representation with traditional FOL does not encapsulate probabilistic assertion as such.", "all x. ((Offspring(x) & Parent(y) & Parent(z) & HeterozygousDominant(y) & HeterozygousDominant(z) & OffspringOf(x, y) & OffspringOf(x, z)) -> Probability(SickleCellAnemia(x), 0.25))", "exists x. (Offspring(x) & HeterozygousDominantParents(x) & ProbabilitySickleCellAnemia(x) = 0.25)", "To translate this sentence into first-order logic, we need to express the relationship between heterozygous dominant parents and their offspring having sickle cell anemia.\n\nLet's determine the predicates:\n- `HeterozygousDominant(parent)`: The parent is heterozygous dominant.\n- `Offspring(parent, child)`: The child is an offspring of the parent.\n- `SickleCellAnemia(child)`: The child has sickle cell anemia.\n\nThe sentence describes a probabilistic event, which can be problematic in strict first-order logic because FOL isn't well-suited to directly express probabilities. However, we'll make use of the given deterministic phrasing \"one in four\" in the context of biological inheritance patterns.\n\nHowever, FOL lacks the capability to directly express probabilistic or statistical information such as \"one in four.\" In practice, specifying probabilistic relations often requires an extension beyond classical FOL, but we can try to represent the condition of having sickle cell anemia given the parental genetic trait as follows, assuming it implies a potential outcome rather than strict probability:\n\nexists x, y. (HeterozygousDominant(x) & HeterozygousDominant(y) & all z. ((Offspring(x, z) & Offspring(y, z)) -> (0.25:<->SickleCellAnemia(z))))\n\nNote: The notation `0.25:<->SickleCellAnemia(z)` here is a symbolic representation meant to express that there is a probabilistic implication or expectation of around 25% likelihood based on inheritance patterns, assuming we could handle probabilistic weights. This simplification assumes ideal genetic expression which is indirectly shown by the Neo-FOL syntax. In standard FOL, we would require a more qualitative description or switch to a probabilistic logic to fully capture the statistical nature.", "To translate the given sentence into first-order logic, we need to understand its components. We should define the natural language sentence components with predicates and quantify the statement as precisely as possible. Given the sentence, the translation into FOL will be:\n\nlet:\n- `Offspring(x, p1, p2)` - x is an offspring of parents p1 and p2.\n- `HeterozygousDominant(p)` - p is heterozygous dominant.\n- `HasSickleCellAnemia(x)` - x has sickle cell anemia.\n- `one_in_four` - relationship representing the probability derived from the premise (this would typically entail probability, which standard FOL doesn't capture, so we'll use a placeholder).\n\nThe FOL translation is more of an approximation due to limitations of expressivity in pure FOL for probabilistic statements:\n\n```\nall p1, p2. (HeterozygousDominant(p1) & HeterozygousDominant(p2) -> \n    one_in_four x. (Offspring(x, p1, p2) & HasSickleCellAnemia(x)))\n```\n\nNote: The concept of \"one in four\" as a probability cannot be accurately depicted in pure FOL as it typically would require some form of probabilistic logic or statistical description, but this translation captures the logic structure and relationships."]}
{"id": "entailmentbank_validation_684", "nl": "a plant is a kind of organism.", "fol": "", "prediction": ["all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "Plant(x) -> Organism(x)", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))", "all x. (Plant(x) -> Organism(x))"]}
{"id": "entailmentbank_validation_685", "nl": "flower is a part of a plant.", "fol": "", "prediction": ["PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)", "PartOf(flower, plant)"]}
{"id": "entailmentbank_validation_686", "nl": "the colors of parts of an organism are inherited characteristics.", "fol": "", "prediction": ["all x y. (PartOf(x, y) & Organism(y) -> InheritedCharacteristic(Colors(x)))", "all x. (PartOf(x, y) & Organism(y) -> InheritedCharacteristic(Color(x)))", "all x. ((Part(x) & Organism(y) & PartOf(x, y)) -> InheritedCharacteristic(Color(x)))", "all x. (PartOf(x, organism) -> exists y. (ColorOf(x, y) & InheritedCharacteristic(y)))", "all x. (PartOf(x, organism) -> exists y. (Color(x, y) & InheritedCharacteristic(y)))", "all x y. (PartOf(x, y) & Organism(y) & Color(x, z) -> InheritedCharacteristic(z))", "all x. (OrganismPart(x) -> exists y. (Color(y, x) & InheritedCharacteristic(y)))", "all x. (PartOf(x, organism) -> exists y. (Color(x, y) & InheritedCharacteristic(y)))", "all x. (PartOf(x, organism) -> exists y. (Color(x, y) & InheritedCharacteristic(y)))", "all x. (Part(x) & BelongsTo(x, organism) -> exists c. (ColorOf(x, c) & InheritedCharacteristic(c)))", "all o, p, c. (PartOf(p, o) & Color(p, c) -> InheritedCharacteristic(c))", "all x. (Part(x) & Organism(y) & PartOf(x, y) -> InheritedCharacteristic(Color(x)))", "all x. (PartOfOrganism(x) -> exists c. (Color(x, c) & InheritedCharacteristic(c)))", "all x. (PartOf(x, organism) & HasColor(x) -> InheritedCharacteristic(HasColor(x)))", "all x. all y. ((Part(x) & Organism(y) & PartOf(x, y)) -> InheritedCharacteristic(Color(x)))", "all x. (PartOf(x, organism) & ColorOf(x, y) -> InheritedCharacteristic(y))"]}
{"id": "entailmentbank_validation_687", "nl": "the color of plants' flowers is a kind of inherited characteristic.", "fol": "", "prediction": ["all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y) & BelongsTo(x, y) & InheritedCharacteristic(HasColor(y))))", "all x. ((Plant(x) & Flower(y) & HasColor(y, z) & PartOf(y, x)) -> InheritedCharacteristic(z))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y) & InheritedCharacteristic(Color(y))))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y, z) & InheritedCharacteristic(HasColor(y, z))))", "all x. (Plant(x) -> exists y. (Flower(y) & Color(y, z) & InheritsCharacteristic(z)))", "all x. (Plant(x) -> exists y. (Flower(x, y) & InheritedCharacteristic(Color(y))))", "exists x. (Plant(x) & exists y. (Flower(y) & HasColor(y) & InheritedCharacteristic(HasColor(y))))", "all x. (exists y. (Plant(x) & Flower(y) & HasFlower(x, y)) -> InheritedCharacteristic(Color(y)))", "FOL Translation:\nall x. (Plant(x) -> exists y. (Flower(y) & PartOf(y, x) & InheritedCharacteristic(Color(y))))", "all x. (Plant(x) -> exists y. (Flower(y) & PartOf(y, x) & InheritedCharacteristic(Color(y))))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y) & InheritedCharacteristic(HasColor(y))))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(x, y) & InheritedCharacteristic(HasColor(x, y))))", "all x. (Plant(x) -> exists y. (Flower(y) & PartOf(y, x) & InheritedCharacteristic(Color(y))))", "all x. (Plant(x) -> exists y. (FlowerColor(y, x) & InheritedCharacteristic(y)))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y, z) & InheritedCharacteristic(z)))", "all x. (Plant(x) -> exists y. (Flower(y) & HasColor(y) & InheritedCharacteristic(Color(y))))"]}
{"id": "entailmentbank_validation_688", "nl": "inheriting is when an inherited characteristic is passed down from parent to offspring by genetics / dna.", "fol": "", "prediction": ["all x y z. ((InheritedCharacteristic(x) & PassedDown(x, y, z) & Parent(y) & Offspring(z) & ByGeneticsOrDNA(x)) -> Inheriting(x, y, z))", "all c. ((InheritedCharacteristic(c) & PassedDownByGenetics(c)) <-> Inheriting(c))", "all x. ((InheritedCharacteristic(x) & PassedDownByGenetics(x)) -> (Inheriting(x) & PassedFromParentToOffspring(x)))", "all x. (InheritedCharacteristic(x) -> (PassedDown(x, Parent, Offspring) & ByGeneticsOrDNA(x)))", "all c. (InheritedCharacteristic(c) -> exists x, y. (Parent(x) & Offspring(y) & PassedDownByGenetics(c, x, y)))", "all x. (InheritedCharacteristic(x) -> (exists y. (exists z. (Parent(y, z) & PassesDown(y, x, z) & ByGeneticsDna(x, y, z)))))", "all c. (InheritedCharacteristic(c) -> exists p, o, g. (Parent(p) & Offspring(o) & PassedDownByGenetics(c, p, o, g) & DNA(g)))", "all x. (Inheriting(x) <-> exists y z. (InheritedCharacteristic(y) & Parent(z) & Offspring(x) & PassedDownByGeneticsOrDNA(y, z, x)))", "all x. (Inheritance(x) <-> exists y exists z. (InheritedCharacteristic(y) & PassedDownByGenetics(z, y) & ParentOf(x, z) & OffspringOf(z, x)))", "all x y z. ((InheritedCharacteristic(x) & Parent(y) & Offspring(z) & PassesDownByGenetics(x, y, z)) -> Inheriting(x, y, z))", "Inherits(x, y) <-> (InheritedCharacteristic(x) & Parent(y) & Offspring(z) & PassedDown(x, y, z) & ByGeneticsOrDNA(x))", "all x. all y. (Parent(x, y) & InheritedCharacteristic(z, y) -> PassedDownByGenetics(z, x, y))", "all x. (Inheriting(x) <-> exists y, z. (InheritedCharacteristic(y) & Parent(z) & Offspring(x) & PassedDownByGenetics(y, z, x)))", "all c. (InheritedCharacteristic(c) -> (exists p, o. (Parent(p) & Offspring(o) & Inherits(p, o, c)) <-> PassedDownByGenetics(c)))", "all x. (Inheriting(x) <-> (exists y. (InheritedCharacteristic(y) & PassedDown(y, x) & FromParent(y, x) & ToOffspring(y, x) & ByGenetics(y, x))))", "all c. (InheritedCharacteristic(c) -> exists p, o. (Parent(p) & Offspring(o) & PassedDownByGenetics(c, p, o)))"]}
{"id": "entailmentbank_validation_689", "nl": "plants offspring can inherit the flower color from their parents.", "fol": "", "prediction": ["all p, o. (PlantOffspring(o, p) -> exists c, f, q. (FlowerColor(f, q) & Parent(p, q) & InheritFlowerColor(o, f)))", "FOL Translation:\nall x y. (PlantOffspring(x) & Parent(y, x) & Plant(y) -> exists z. (FlowerColor(y, z) & InheritsFlowerColor(x, z)))", "all x. all y. ((Plant(x) & Parent(y, x) & HasFlowerColor(y, z)) -> InheritsFlowerColor(x, z))", "all x, y, z. (Plant(x) & Offspring(y, x) & HasParent(y, z) & FlowerColor(z, c) -> InheritFlowerColor(y, c))", "all x. (PlantOffspring(x) -> exists y. (Parent(y, x) & InheritsFlowerColor(x, y)))", "all x. (Plant(x) -> exists y, z. (Parent(y, x) & Parent(z, x) & (FlowerColor(x) = FlowerColor(y) | FlowerColor(x) = FlowerColor(z))))", "all x. all y. all z. ((Plant(x) & Offspring(y, x) & Parent(z, y) & HasFlowerColor(z, c)) -> InheritFlowerColor(y, c))", "all x. (Plant(x) -> exists y. (Offspring(y, x) & InheritsFlowerColor(y, x)))", "all x. all y. ((Plant(x) & Offspring(y, x) & Parent(z, x)) -> exists c. (FlowerColor(y, c) & FlowerColor(z, c)))", "all x. all y. all z. ((PlantOffspring(x) & PlantParent(y) & InheritsFlowerColor(x, z, y)) -> FlowerColor(z, x) & FlowerColor(z, y))", "all x. (PlantOffspring(x) -> exists y. (Parent(y, x) & InheritsFlowerColor(x, y)))", "all x. all y. (Plant(x) & Offspring(y, x) & Parent(z, x) & HasFlowerColor(z, c) -> InheritsFlowerColor(y, c))", "all x. all y. ((Plant(x) & Parent(y, x)) -> exists z. (FlowerColorInherited(x, z) & FlowerColor(y, z)))", "all x, y, z. ((Plant(x) & Offspring(y, x) & Parent(z, x) & HasFlowerColor(z)) -> InheritFlowerColor(y, z))", "all x. (PlantOffspring(x) -> exists y. (PlantParent(y) & InheritsFlowerColor(x, y)))", "all x, y, z. (Plant(x) & Parent(y, x) & Parent(z, x) -> OffspringInheritsFlowerColor(x, y) | OffspringInheritsFlowerColor(x, z))"]}
{"id": "entailmentbank_validation_690", "nl": "yellow is a kind of color.", "fol": "", "prediction": ["Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "KindOf(yellow, color)", "Color(yellow)", "KindOf(yellow, color)", "KindOf(yellow, color)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "Color(yellow)", "KindOf(yellow, color)"]}
{"id": "entailmentbank_validation_691", "nl": "the plant offspring has yellow flowers.", "fol": "", "prediction": ["PlantOffspring(x) & HasYellowFlowers(x)", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "Exists x. (Offspring(x) & HasYellowFlowers(x))", "PlantOffspring(y) & HasYellowFlowers(y)", "exists x. (Offspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "Exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "Exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (Offspring(x) & Plant(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "PlantOffspring(y) & HasYellowFlowers(y)", "Exists x. (PlantOffspring(x) & HasYellowFlowers(x))", "exists x. (PlantOffspring(x) & HasYellowFlowers(x))"]}
{"id": "entailmentbank_validation_692", "nl": "the parents of the plant are likely to have yellow flowers.", "fol": "", "prediction": ["exists x. (ParentOf(x, plant) & LikelyToHaveYellowFlowers(x))", "exists x. (Parent(x, plant) -> LikelyToHaveYellowFlowers(x))", "exists y. (Parent(y, plant) -> LikelyToHaveYellowFlowers(y))", "FOL Translation:\nall x. (ParentOf(x, plant) -> LikelyToHaveYellowFlowers(x))", "exists x. (Parent(x, the_plant) & LikelyToHaveYellowFlowers(x))", "exists x. (Parents(x, plant) & LikelyToHaveYellowFlowers(x))", "exists x. (ParentOf(x, plant) -> LikelyToHaveYellowFlowers(x))", "exists x. (Parent(x, plant) -> LikelyToHaveYellowFlowers(x))", "exists x. (Parent(x, plant) -> LikelyToHaveYellowFlowers(x))", "exists x, y, z. (Parent(x, plant) & Parent(y, plant) & Parent(z, plant) & LikelyToHaveYellowFlowers(x) & LikelyToHaveYellowFlowers(y) & LikelyToHaveYellowFlowers(z))", "exists x. (ParentOf(plant, x) & LikelyToHaveYellowFlowers(x))", "exists x. (Plant(x) & all y. (ParentOf(y, x) -> LikelyToHaveYellowFlowers(y)))", "exists x. (ParentOf(x, plant) -> LikelyToHaveYellowFlowers(x))", "all x. (ParentOfPlant(x) -> LikelyToHaveYellowFlowers(x))", "exists x. (Plant(x) & ParentsLikelyHaveYellowFlowers(x))", "exists x. (Parent(x, plant) -> LikelyToHaveYellowFlowers(x))"]}
{"id": "entailmentbank_validation_693", "nl": "a newly hatched sea turtle walks toward the ocean.", "fol": "", "prediction": ["FOL Translation:\nexists x. (NewlyHatched(x) & SeaTurtle(x) & WalksTowardOcean(x))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))", "exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))", "exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))", "exists x. (NewlyHatched(sea_turtle(x)) & WalksToward(x, ocean))", "exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))", "exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & NewlyHatched(x) & WalksToward(x, ocean))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksToward(x, ocean))", "exists x. (NewlyHatchedSeaTurtle(x) & WalksTowardOcean(x))", "exists x. (NewlyHatched(x) & SeaTurtle(x) & WalksToward(x, ocean))"]}
{"id": "entailmentbank_validation_694", "nl": "if an animal hatches from an egg then that animal is born.", "fol": "", "prediction": ["all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> IsBorn(x))", "all x. (Animal(x) & HatchesFromEgg(x) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))", "all x. ((Animal(x) & HatchesFromEgg(x)) -> Born(x))"]}
{"id": "entailmentbank_validation_695", "nl": "a sea turtle that is just born walks toward the ocean.", "fol": "", "prediction": ["exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardsOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowards(x, ocean))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "Exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksTowardOcean(x))", "exists x. (SeaTurtle(x) & JustBorn(x) & WalksToward(x, ocean))"]}
{"id": "entailmentbank_validation_696", "nl": "an animal knows how to do instinctive behaviors when it is born.", "fol": "", "prediction": ["all x. (Animal(x) -> (Born(x) -> KnowsInstinctiveBehaviors(x)))", "all x. (Animal(x) -> (Born(x) -> KnowsInstinctiveBehaviors(x)))", "all x. (Animal(x) -> exists y. (Behavior(y) & Instinctive(y) & KnowsHowToDo(x, y) & WhenBorn(x)))", "all x. (Animal(x) -> exists y. (KnowsHowTo(x, y) & InstinctiveBehavior(y) & WhenBorn(x)))", "all x. (Animal(x) -> (IsBorn(x) -> KnowsInstinctiveBehaviors(x)))", "exists x. (Animal(x) -> (Born(x) -> KnowsInstinctiveBehaviors(x)))", "all x. (Animal(x) -> (KnowsInstinctiveBehaviors(x, whenBorn)))", "all x. (Animal(x) -> (Born(x) -> KnowsHowToDoInstinctiveBehaviors(x)))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDo(x, y) & Born(x)))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDoWhenBorn(x, y)))", "all x. (Animal(x) -> (exists y. (Born(x) & InstinctiveBehavior(y) & KnowsHowToDo(x, y))))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDoWhenBorn(x, y)))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDo(x, y) & WhenBorn(x)))", "all x. (Animal(x) -> (KnowsInstinctiveBehaviors(x) <- Born(x)))", "all x. (Animal(x) -> exists y. (InstinctiveBehavior(y) & KnowsHowToDo(x, y) & WhenBorn(x)))", "all x. (Animal(x) -> (Born(x) -> KnowsInstinctiveBehaviors(x)))"]}
{"id": "entailmentbank_validation_697", "nl": "walking toward the ocean is sea turtles' instinct behavior.", "fol": "", "prediction": ["all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingToward(ocean)))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingToward(y, ocean)))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingToward(ocean)))", "all x. (SeaTurtle(x) -> InstinctBehavior(WalkingTowardOcean, x))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardsOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkTowardsOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "FOL Translation:\nall x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))", "all x. (SeaTurtle(x) -> InstinctBehavior(x, WalkingTowardOcean))"]}
{"id": "entailmentbank_validation_698", "nl": "a chicken is a kind of bird.", "fol": "", "prediction": ["Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)", "Bird(chicken)"]}
{"id": "entailmentbank_validation_699", "nl": "a chick is a kind of young / baby chicken.", "fol": "", "prediction": ["Young(chick) & Chicken(chick)", "ChickIsYoungChicken(y)", "Chick(y) -> YoungChicken(y)", "Chick(c) -> YoungChicken(c)", "Chick(y) -> YoungChicken(y)", "", "", "Chick(y) -> YoungChicken(y)", "Chick(y) -> YoungChicken(y)", "", "", "", "", "Chick(c) -> YoungChicken(c)", "", ""]}
{"id": "entailmentbank_validation_700", "nl": "a chick is a kind of baby bird.", "fol": "", "prediction": ["all x. (Chick(x) -> BabyBird(x))", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "Chick(y) -> BabyBird(y)", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "Chick(x) -> BabyBird(x)", "BabyBird(chick)", "Chick(x) -> BabyBird(x)", "exists x. (Chick(x) -> BabyBird(x))", "Chick(x) -> BabyBird(x)", "Chick(b) -> BabyBird(b)", "BabyBird(chick)", "Chick(x) -> BabyBird(x)"]}
{"id": "entailmentbank_validation_701", "nl": "an example of an instinctive behavior is a baby bird pecking at its shell to hatch.", "fol": "", "prediction": ["exists x. (InstinctiveBehavior(x) & ExampleOf(x, Pecks(baby_bird, shell_to_hatch)))", "exists x. (ExampleOfInstinctiveBehavior(x) & BabyBird(b) & PeckingAtShellToHatch(b) & x = b)", "exists x. (InstinctiveBehavior(x) & ExampleOf(x, PecksAtShellToHatch(baby_bird)))", "exists x. (InstinctiveBehavior(x) & ExampleOf(x, y) & BabyBirdPeckingAtShell(y) & ToHatch(y))", "exists x. (InstinctiveBehavior(x) & Example(x, Peck(baby_bird, shell)))", "exists x. (ExampleOfInstinctiveBehavior(x) & BabyBird(y) & Shell(z) & PecksAt(y, z) & Hatches(y))", "exists x. (ExampleOfInstinctiveBehavior(x) & BabyBirdPeckingAtShellToHatch(x))", "exists x. (InstinctiveBehavior(x) & Example(x, PecksAtShell(baby_bird_to_hatch)))", "exists x. (InstinctiveBehavior(x) & ExampleOf(x, BabyBirdPeckingAtShellToHatch))", "exists x. (InstinctiveBehavior(x) & Example(x, PecksAtShell(baby_bird)))", "Exists x. (InstinctiveBehavior(x) & ExampleOf(x, y) & BabyBird(y) & PeckAtShellToHatch(y))", "exists x. (InstinctiveBehavior(x) & Example(x, pecking_to_hatch) & BabyBirdPecksAtShellToHatch(pecking_to_hatch))", "exists x y. (Example(x, InstinctiveBehavior) & BabyBird(y) & PecksAtShellToHatch(y) & IsInstance(x, y))", "exists x. (InstinctiveBehavior(x) & Example(x, BabyBirdPeckingAtShellToHatch))", "exists x. (InstinctiveBehavior(x) & Example(x, PecksAtShellToHatch(baby_bird)))", "exists x. (InstinctiveBehavior(x) & ExampleOf(x, PeckingAtShell(baby_bird)))"]}
{"id": "entailmentbank_validation_702", "nl": "a chick pecking at its shell to hatch is an example of an instictive behavior.", "fol": "", "prediction": ["exists x. (Chick(x) & Exists y. (Shell(y) & PecksAt(x, y) & ToHatch(x, y))) -> ExampleOf(x, InstinctiveBehavior)", "exists x. (Chick(x) & PeckingAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOfInstinctiveBehavior(x))", "exists x. ((Chick(x) & PecksAtShellToHatch(x)) -> ExampleOfInstinctiveBehavior(x))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOf(x, InstinctiveBehavior))", "exists x. (Chick(x) & PeckAtShellToHatch(x) & ExampleOfInstinctiveBehavior(x))", "", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOfInstinctiveBehavior(x))", "", "exists c. (Chick(c) & PecksAtShellToHatch(c) -> ExampleOf(c, InstinctiveBehavior))", "exists x. (Chick(x) & PecksAtShell(x) & Hatching(x) & ExampleOfInstinctiveBehavior(x))", "exists x. (Chick(x) & PecksAtShellToHatch(x) & ExampleOfInstinctiveBehavior(x))"]}
{"id": "entailmentbank_validation_703", "nl": "receiving the recessive gene for a trait from each parent causes the offspring to have that recessive trait.", "fol": "", "prediction": ["all x. ((exists y, z. (Parent(y, x) & Parent(z, x) & RecessiveGene(y, t) & RecessiveGene(z, t))) -> HasRecessiveTrait(x, t))", "all x. (Offspring(x) & exists y. (Parent(y) & PassesRecessiveGene(y, x)) & exists z. (Parent(z) & PassesRecessiveGene(z, x)) -> HasRecessiveTrait(x))", "all x. (exists y. (Parent(y, x) & RecessiveGeneForTrait(y)) & exists z. (Parent(z, x) & RecessiveGeneForTrait(z)) -> HasRecessiveTrait(x))", "all x. all p1. all p2. (RecessiveGene(p1, x) & RecessiveGene(p2, x) & Parent(p1, y) & Parent(p2, y) -> HasRecessiveTrait(y, x))", "all x. (Offspring(x) & exists p1, p2. (Parent(p1, x) & Parent(p2, x) & HasRecessiveGeneTrait(x, p1) & HasRecessiveGeneTrait(x, p2)) -> HasRecessiveTrait(x))", "all x y. ((Offspring(x) & Parent(y, x) & RecessiveGeneForTrait(y)) -> HasRecessiveTrait(x))", "all x. all y. all z. ((Offspring(x) & Parent(y, x) & Parent(z, x) & RecessiveGeneForTrait(y) & RecessiveGeneForTrait(z)) -> HasRecessiveTrait(x))", "all x. ((exists y. exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGeneFrom(y, x) & ReceivesRecessiveGeneFrom(z, x))) -> HasRecessiveTrait(x))", "all x. (Offspring(x) & exists y exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z)) -> HasRecessiveTrait(x))", "all x. (exists y. exists z. (Offspring(x) & Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, Trait, y) & ReceivesRecessiveGene(x, Trait, z)) -> HasRecessiveTrait(x, Trait))", "all x. (exists g1, g2, p1, p2. (RecessiveGeneForTrait(g1) & InheritedFrom(x, g1, p1) & RecessiveGeneForTrait(g2) & InheritedFrom(x, g2, p2) & Parent(p1, x) & Parent(p2, x) & p1 \u2260 p2) -> HasRecessiveTrait(x))", "all x. (Offspring(x) & exists y. exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z))) -> HasRecessiveTrait(x)", "all x. (exists p1, p2. (Parent(p1, x) & Parent(p2, x) & ReceivesRecessiveGene(x, p1) & ReceivesRecessiveGene(x, p2)) -> HasRecessiveTrait(x))", "all x. ((exists y. (Parent(y, x) & RecessiveGeneForTrait(y)) & exists z. (Parent(z, x) & RecessiveGeneForTrait(z))) -> HasRecessiveTrait(x))", "all x. all y. all z. ((Offspring(x) & Parent(y, x) & Parent(z, x) & RecessiveGeneForTraitFrom(y, x) & RecessiveGeneForTraitFrom(z, x)) -> HasRecessiveTrait(x))", "all x. (exists y. (Parent(y, x) & ReceivesRecessiveGene(x, y)) & exists z. (Parent(z, x) & ReceivesRecessiveGene(x, z)) -> HasRecessiveTrait(x))"]}
{"id": "entailmentbank_validation_704", "nl": "blue eye is a recessive trait in human.", "fol": "", "prediction": ["Trait(blue_eye, recessive) & Trait(blue_eye, human)", "all x. (Human(x) -> RecessiveTrait(blue_eye, x))", "all x. ((Human(x) & HasTrait(x, blue_eye)) -> RecessiveTrait(blue_eye))", "RecessiveTrait(blue_eye, human)", "all x. (Human(x) -> (RecessiveTrait(blue_eye, x)))", "RecessiveTraitInHuman(blue_eye)", "RecessiveTrait(blue_eye, human)", "Trait(blue_eye) & Recessive(blue_eye) & InHuman(blue_eye)", "all x. (BlueEye(x) & Human(x) -> RecessiveTrait(x))", "Trait(blue_eye, recessive) & TraitInSpecies(blue_eye, human)", "RecessiveTrait(blue_eye, human)", "Trait(blue_eye, recessive) & InHuman(blue_eye)", "RecessiveTrait(blue_eye, human)", "RecessiveTrait(blue_eye, human)", "Trait(blue_eye, recessive) & InHuman(blue_eye)", "Trait(blue_eye) & Recessive(blue_eye) & all x. (Human(x) -> HasTrait(x, blue_eye))"]}
{"id": "entailmentbank_validation_705", "nl": "to have blue eyes requires receiving the recessive gene from each parent.", "fol": "", "prediction": ["all x. (HasBlueEyes(x) -> exists y, z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGeneFrom(y, x) & ReceivesRecessiveGeneFrom(z, x)))", "all x. (HasBlueEyes(x) -> exists y exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGeneFrom(x, y) & ReceivesRecessiveGeneFrom(x, z)))", "all x, y, z. (HasParent(x, y) & HasParent(x, z) & HasBlueEyes(x) -> ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z))", "all z. (HasBlueEyes(z) -> exists x, y. (Parent(x, z) & Parent(y, z) & ReceivesRecessiveGeneFrom(x, z) & ReceivesRecessiveGeneFrom(y, z)))", "all x. (BlueEyes(x) -> exists y, z. (Parent(y, x) & Parent(z, x) & RecessiveGene(y) & RecessiveGene(z)))", "all x. (HasBlueEyes(x) -> exists y exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z)))", "all x. (HasBlueEyes(x) -> exists y exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z)))", "all x. (HasBlueEyes(x) -> exists y. exists z. (Parent(y, x) & Parent(z, x) & -y = z & ReceivesRecessiveGeneFrom(x, y) & ReceivesRecessiveGeneFrom(x, z)))", "all x. (BlueEyes(x) -> exists p1, p2. (Parent(p1, x) & Parent(p2, x) & ReceivesRecessiveGene(x, p1) & ReceivesRecessiveGene(x, p2)))", "all x. (HasBlueEyes(x) -> (exists p1. (Parent(p1, x) & RecessiveGene(p1)) & exists p2. (Parent(p2, x) & RecessiveGene(p2))))", "all x. (HasBlueEyes(x) -> (exists y. (Parent(y, x) & RecessiveGeneFrom(y, x)) & exists z. (Parent(z, x) & RecessiveGeneFrom(z, x) & y != z)))", "all x. (HasBlueEyes(x) -> exists y. exists z. (Parent(y, x) & Parent(z, x) & y != z & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z)))", "all x. (HasBlueEyes(x) -> exists y exists z. (Parent(y, x) & Parent(z, x) & ReceivesRecessiveGene(x, y) & ReceivesRecessiveGene(x, z)))", "all x. (HasBlueEyes(x) -> (exists y. (Parent(y, x) & RecessiveGene(y)) & exists z. (Parent(z, x) & RecessiveGene(z))))", "all x. (HasBlueEyes(x) -> exists p1, p2. (Parent(p1, x) & Parent(p2, x) & RecessiveGene(p1) & RecessiveGene(p2)))", "all x. (HasBlueEyes(x) -> exists y exists z. (Parent(y, x) & Parent(z, x) & y \u2260 z & ProvidesRecessiveGene(y, x) & ProvidesRecessiveGene(z, x)))"]}
{"id": "entailmentbank_validation_706", "nl": "an egg cell is a kind of sex cell.", "fol": "", "prediction": ["Kind(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "SexCell(egg_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "KindOf(egg_cell, sex_cell)", "all x. (EggCell(x) -> SexCell(x))"]}
{"id": "entailmentbank_validation_707", "nl": "a sperm cell is a kind of sex cell.", "fol": "", "prediction": ["", "KindOf(sperm_cell, sex_cell)", "", "KindOf(sperm_cell, sex_cell)", "all x. (SpermCell(x) -> SexCell(x))", "KindOf(sperm_cell, sex_cell)", "", "", "", "", "", "", "Kind(sperm_cell, sex_cell)", "", "", "SexCell(sperm_cell)"]}
{"id": "entailmentbank_validation_708", "nl": "a mutation in the sex cells of a parent can cause a new trait to appear in the parent's offspring.", "fol": "", "prediction": ["exists x (Parent(x) & SexCellMutation(x) -> exists y (Offspring(x, y) & CausesNewTrait(y)))", "exists m. (MutationInSexCells(parent, m) -> exists t. NewTraitInOffspring(parent, t))", "exists x, y, z. (MutationInSexCells(x) & Parent(x, y) & Offspring(y, z) -> CausesNewTraitInOffspring(z))", "exists m. (MutationInSexCells(m) & ParentOf(a, b) -> CanCauseNewTraitInOffspring(m, b))", "exists x. (Parent(x) & MutationInSexCells(x) -> exists y. (Offspring(x, y) & NewTraitAppears(y)))", "exists m, p, o. (Mutation(m) & InSexCells(m, p) & Parent(p, o) -> Causes(m, NewTraitAppearsInOffspring(o)))", "exists x. (SexCell(x) & Mutation(x) -> exists y. (OffspringOf(y, Parent(x)) & NewTraitAppears(y)))", "exists m, p, t, o. (MutationInSexCells(m, p) -> Causes(m, t) & AppearsIn(t, o) & Offspring(o, p))", "exists x, y, z. (MutationInSexCellsOf(x, y) & Parent(y) & Offspring(z, y) -> CausesNewTrait(x, z))", "exists x, y, z. (Mutation(x) & InSexCells(y) & Parent(y) & Causes(x, z) & NewTrait(z) & AppearsInOffspring(z, y))", "exists m, p, t, o. (MutationInSexCells(m, p) & Parent(p) -> CanCause(m, AppearNewTrait(t, o)) & Offspring(o, p))", "exists x. (SexCell(x) & Mutation(x) & Parent(p) & HasSexCell(p, x) -> exists y. (OffspringOf(y, p) & NewTraitIn(y)))", "exists m, p, o, t. (MutationInSexCellsOf(m, p) & ParentOf(o, p) & AppearInOffspring(m, t, o))", "exists x exists y. (MutationInSexCells(x, y) & Parent(y) -> exists z. (NewTrait(z) & AppearsInOffspring(z, y)))", "exists x, y. (MutationInSexCells(x) & Parent(y, x) -> exists z. (Offspring(z, y) & NewTraitInOffspring(z)))", "exists x. (MutationInSexCells(x) & Parent(x) -> exists y. (NewTrait(y) & AppearsInOffspringOf(x, y)))"]}
{"id": "entailmentbank_validation_709", "nl": "a mutation in sperm or egg of a parent can cause a new trait to appear in the parent's offspring.", "fol": "", "prediction": ["exists x, y. ((Parent(x) & (SpermMutation(x) | EggMutation(x))) -> exists z. (Offspring(z, x) & NewTrait(z)))", "all x y. ((Parent(x) & Offspring(y, x) & (MutationInSpermOrEggOf(x))) -> CanCauseNewTraitAppear(y))", "exists x exists y. (Parent(x) & (Sperm(y) | Egg(y)) & MutationIn(y) -> exists z. (Offspring(z, x) & AppearsNewTrait(z)))", "exists x exists y. ((MutationInSperm(x) | MutationInEgg(y)) & ParentOf(x, y)) -> CanCause(NewTraitInOffspring(y))", "exists x exists y. (Parent(x) & Parent(y) & (Sperm(x) | Egg(x)) & Mutation(x) -> exists z. (Offspring(z, x) & Offspring(z, y) & NewTrait(z)))", "exists p. (Parent(p) & exists s. (Sperm(s, p) & Mutation(s) | exists e. (Egg(e, p) & Mutation(e))) -> exists o. (Offspring(o, p) & NewTrait(o)))", "exists x. exists y. (Parent(x) & (SpermOrEggMutation(y, x) -> exists z. (Offspring(z, x) & NewTrait(z))))", "exists x. (Parent(x) & exists y. (Offspring(x, y) & exists m. (MutationInSpermOrEgg(m, x) & CausesNewTrait(m, y))))", "exists m. (MutationInSpermOrEgg(m) & exists p. (Parent(p) & exists o. (Offspring(o, p) & Causes(m, NewTraitInOffspring(o)))))", "exists x. (Parent(x) & (exists y. (Sperm(y, x) & Mutation(y) | Egg(y, x) & Mutation(y))) -> exists z. (Offspring(z, x) & NewTraitAppearsIn(z)))", "exists x. (Parent(x) & exists y. (SpermOrEgg(y, x) & HasMutation(y) -> exists z. (Offspring(z, x) & NewTraitAppears(z))))", "exists x, y, z. ((Sperm(x) | Egg(y)) & Parent(z) & MutationIn(z, x) | MutationIn(z, y) -> CausesNewTraitIn(x, z) | CausesNewTraitIn(y, z))", "exists x, y, z. (Parent(x) & SpermOrEgg(y) & Offspring(z, x) & MutationIn(y)) -> CausesNewTraitAppears(z)", "exists m. (MutationInSpermOrEgg(m) & Parent(p) & Offspring(o, p) -> CausesNewTrait(m, o))", "exists x. exists y. (Parent(x) & (Sperm(x, y) | Egg(x, y)) & Mutation(y) -> exists z. (Offspring(z, x) & NewTraitAppears(z)))", "exists x, y, z. (Mutation(x) & (Sperm(y) | Egg(y)) & Parent(z) & PartOf(y, z)) -> exists w. (Offspring(w, z) & AppearsNewTrait(w, x))"]}
{"id": "entailmentbank_validation_710", "nl": "smaller dogs have genetic trait of smaller size.", "fol": "", "prediction": ["all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & SmallerSize(x) -> HasGeneticTrait(x, SmallerSize))", "all x. (Dog(x) & SmallerDog(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> GeneticTraitSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasTrait(x, smaller_size))", "all x. ((Dog(x) & Smaller(x)) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasTrait(x, smaller_size))", "all x. (Dog(x) & Smaller(x) -> GeneticTraitSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> GeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))", "all x. (Dog(x) & Smaller(x) -> HasGeneticTraitOfSmallerSize(x))"]}
{"id": "entailmentbank_validation_711", "nl": "human are breeding german shepherd dogs to other smaller dogs.", "fol": "", "prediction": ["exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & Smaller(z, y) & Breeding(x, y, z))", "exists x. (Human(x) & exists y. (exists z. (GermanShepherdDog(y) & SmallerDog(z) & BreedsWith(x, y, z))))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & SmallerDog(z) & BreedsTo(x, y, z))", "exists x. exists y. exists z. (Human(x) & GermanShepherdDog(y) & SmallerDog(z) & Breeds(x, y, z))", "exists x, y. (Human(x) & Dog(y) & GermanShepherd(y) & exists z. (Dog(z) & SmallerDog(z) & Breeds(x, y, z)))", "exists x, y, z. (Human(x) & GermanShepherd(y) & SmallerDog(z) & BreedsTo(y, z, x))", "all x. ((Human(x) & Breeds(x, german_shepherd_dog, y) & SmallerDog(y)) -> exists y. (Dog(y) & Breeds(x, german_shepherd_dog, y)))", "exists x, y. (Human(x) & GermanShepherdDog(y) & exists z. (SmallerDog(z) & Breeds(x, y, z)))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & Smaller(z, y) & BreedsTo(x, y, z))", "exists x exists y exists z. (Human(x) & GermanShepherd(y) & Dog(z) & Smaller(z, y) & Breeds(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherd(y) & SmallerDog(z) & BreedingTo(x, y, z))", "exists x. exists y. (Human(x) & GermanShepherdDog(y) & SmallerDog(z) & IsBreeding(x, y, z))", "exists x, y. (Human(x) & GermanShepherdDog(y) & exists z. (SmallerDog(z) & Breeds(x, y, z)))", "exists x, y, z. (Human(x) & Dog(y) & GermanShepherd(y) & Dog(z) & Smaller(z, y) & Breeds(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(z) & Smaller(z, y) & BreedsTo(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & SmallerDog(z) & BreedsTo(y, z, x))"]}
{"id": "entailmentbank_validation_712", "nl": "human are breeding german shepherd dogs with dogs with genetic trait of smaller size.", "fol": "", "prediction": ["exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & Breeding(x, y, z))", "exists x. exists y. exists z. (Human(x) & GermanShepherdDog(y) & Dog(z) & BreedsWith(x, y, z) & HasGeneticTrait(z, SmallerSize))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x. exists y. exists z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x, y, z. (Human(x) & Dog(y) & Dog(z) & GermanShepherd(y) & HasGeneticTrait(z, SmallerSize) & Breeds(x, y, z))", "Exists x, y, z (Human(x) & GermanShepherd(y) & HasGeneticTrait(z, smaller_size) & Breeds(x, y, z))", "all x. (Human(x) -> exists y. exists z. (Dog(y) & GermanShepherd(y) & Breeds(x, y, z) & Dog(z) & HasGeneticTrait(z, SmallerSize)))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & GeneticTraitOfSmallerSize(z) & BreedsWith(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & Breeds(x, y, z))", "exists x. exists y. exists z. (Human(x) & GermanShepherd(y) & Dog(y) & Breeding(x, y, z) & Dog(z) & HasGeneticTrait(z, SmallerSize))", "exists x. exists y. exists z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & Breeds(x, y, z))", "exists x, y, z. (Human(x) & Dog(y) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))", "exists x. (Human(x) & exists y. (Dog(y) & GermanShepherd(y) & exists z. (Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z))"]}
{"id": "entailmentbank_validation_713", "nl": "selective breeding is when an organism receives selective genetic traits from its parents by human design.", "fol": "", "prediction": ["When(selective_breeding, exists x. (Organism(x) & exists y, z. (ReceivesSelectiveTraits(x, y) & Parent(y, x) & HumanDesign(z) & Causes(z, ReceivesSelectiveTraits(x, y)))))", "When(selective_breeding, exists x. (Organism(x) & ReceivesSelectiveGeneticTraits(x) & FromParents(x) & ByHumanDesign(x)))", "exists x. (Organism(x) & SelectiveBreeding(x) <-> (ReceivesSelectiveGeneticTraitsFromParents(x) & ByHumanDesign(x)))", "SelectiveBreeding(x) <-> (exists y z. (Organism(y) & Parent(z, y) & ReceivesSelectiveGeneticTraitsFrom(y, z) & ByHumanDesign(y)))", "all x. (SelectiveBreeding(x) <-> (Organism(x) & exists y. (Receives(x, y) & SelectiveGeneticTraits(y) & FromParentsByHumanDesign(x))))", "SelectiveBreeding(x) <-> (Organism(x) & exists y, z. (ReceivesSelectiveTraitsFrom(x, y, z) & Parent(y, x) & Parent(z, x) & HumanDesign(x)))", "all o. (SelectiveBreeding(o) <-> (exists t. (GeneticTrait(t) & Receives(o, t)) & hasOrigin(o, DesignByHumans)))", "exists x. (SelectiveBreeding(x) & all y. ((Organism(y) & ReceivesSelectiveGeneticTraits(y, z) & ByHumanDesign(z)) -> HasReceivedTraitsBySelectiveBreeding(y, z)))", "SelectiveBreeding(x) <-> (exists y z. (Organism(x) & ReceivesSelectiveTraitsFrom(y, x) & Parents(y, z) & HumanDesign(y)))", "SelectiveBreeding(x) <-> (exists y, z. (Organism(x) & ReceivesSelectiveGeneticTraitsFrom(x, y, z) & Parents(y, z) & ByHumanDesign(x)))", "exists x. (SelectiveBreeding(x) <-> (Organism(x) & ReceivesSelectiveGeneticTraitsFromParents(x) & HumanDesign(x)))", "SelectiveBreeding(x) <-> (Organism(x) & exists y. (ParentOf(y, x) & HasSelectiveGeneticTraitsFrom(x, y) & ByHumanDesign(x)))", "exists x. (SelectiveBreeding(x) <-> (exists y z. (Organism(y) & ReceivesSelectiveTraits(y, z) & Parents(z, y) & HumanDesign(z))))", "exists x, y, z. (Organism(x) & HumanDesign(y) & SelectiveGeneticTraits(z, y) & Receives(x, z))", "SelectiveBreeding(x) <-> exists y, z. (Organism(x) & ReceivesSelectiveTraitsFrom(y, z, x) & HumanDesign(x))", "SelectiveBreeding(x) <-> (exists y, z, w. (Organism(x) & Parent(y, x) & Parent(z, x) & ReceivesSelectiveGeneticTraits(x, y, z, w) & HumanDesign(w)))"]}
{"id": "entailmentbank_validation_714", "nl": "human breeding german shepherd dogs with dogs with genetic trait of smaller size is an example of selective breeding.", "fol": "", "prediction": ["all x. (exists y. (Human(x) & GermanShepherdDog(y) & Breeding(x, y)) & exists z. (Dog(z) & HasGeneticTrait(z, SmallerSize)) -> SelectiveBreeding(x, y, z))", "exists x exists y exists z. (Human(x) & Breeds(x, y, z) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & ExampleOf(Breeding(x, y, z), SelectiveBreeding))", "exists x, y, z. (Human(x) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z) & ExampleOf(Breeding(x, y, z), SelectiveBreeding))", "exists x. (Human(x) & exists y. (Dog(y) & Breed(y, german_shepherd) & exists z. (Dog(z) & HasGeneticTrait(z, smaller_size)) & SelectiveBreeding(x, y, z)))", "exists x, y, z. (Human(x) & Breeds(x, y, z) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & ExampleOf(SelectiveBreeding, Breeding(x, y, z)))", "exists x. (Human(x) & exists y. (exists z. (GermanShepherdDog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z) & SelectiveBreeding(BreedsWith(x, y, z)))))", "exists x, y, z. (Human(x) & BreedsWith(x, y, z) & Dog(y) & Dog(z) & GermanShepherd(y) & HasGeneticTrait(z, SmallerSize) & ExampleOf(Breeding(x, y, z), SelectiveBreeding))", "exists x, y, z. (Human(x) & Breeds(x, german_shepherd_dogs, y) & Dog(y) & HasGeneticTrait(y, smaller_size) & ExampleOf(z, selective_breeding))", "exists x, y, z, w. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTraitOfSmallerSize(z) & SelectiveBreeding(x, y, z, w) & ExampleOf(w, SelectiveBreeding))", "exists x, y, z. (Human(x) & GermanShepherdDog(y) & Dog(y) & Dog(z) & GeneticTrait(z, SmallerSize) & BreedsWith(x, y, z) & ExampleOf(Breeding(x, y, z), SelectiveBreeding))", "exists x. (Human(x) & all y. ((Dog(y) & Breed(y, german_shepherd) & exists z. (Dog(z) & HasGeneticTrait(z, smaller_size))) -> SelectiveBreeding(x, y, z)))", "ExampleOfSelectiveBreeding(human, german_shepherd_dogs, genetic_trait_smaller_size)", "exists x. exists y. exists z. (Human(x) & Dog(y) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z) & ExampleOf(SelectiveBreeding, BreedsWith(x, y, z)))", "exists x exists y exists z exists w. (Human(x) & Dog(y) & GermanShepherd(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & BreedsWith(x, y, z, w) -> SelectiveBreedingExample(w))", "exists x. exists y. exists z. (HumanBreeds(x, y) & GermanShepherd(y) & Dog(y) & Dog(z) & HasGeneticTrait(z, SmallerSize) & SelectiveBreeding(x, y, z))", "exists x exists y exists z. (Human(x) & GermanShepherdDog(y) & Dog(z) & HasGeneticTraitOfSmallerSize(z) & BreedsWith(x, y, z) -> ExampleOfSelectiveBreeding(x, y, z))"]}
{"id": "entailmentbank_validation_715", "nl": "sexual reproduction requires both sperm and egg.", "fol": "", "prediction": ["all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (RequiresSperm(x) & RequiresEgg(x)))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> exists y. (Sperm(y) & exists z. (Egg(z) & Requires(x, y) & Requires(x, z))))", "FOL Translation:\nall x. (SexualReproduction(x) -> (exists y. Sperm(y) & exists z. Egg(z) & Requires(x, y) & Requires(x, z)))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (exists y. (Sperm(y) & Required(y, x))) & exists z. (Egg(z) & Required(z, x))))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (exists y. (Sperm(y) & Requires(x, y))) & exists z. (Egg(z) & Requires(x, z))))", "all z. (SexualReproduction(z) -> (exists x. (Sperm(x) & InvolvedIn(x, z)) & exists y. (Egg(y) & InvolvedIn(y, z))))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (exists y. (Sperm(y) & RequiredFor(y, x))) & exists z. (Egg(z) & RequiredFor(z, x))))", "all x. (SexualReproduction(x) -> (exists y. (Sperm(y) & Requires(x, y))) & exists z. (Egg(z) & Requires(x, z))))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))", "all x. (SexualReproduction(x) -> (Requires(x, sperm) & Requires(x, egg)))"]}
{"id": "entailmentbank_validation_716", "nl": "the sperm production is prevented in male insects.", "fol": "", "prediction": ["all x. (MaleInsect(x) -> Prevented(SpermProduction(x)))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> -CanProduceSperm(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> Prevented(SpermProduction(x)))", "all x. (MaleInsect(x) -> Prevented(SpermProduction(x)))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> Prevents(SpermProduction(x)))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (Male(x) & Insect(x) -> Prevented(SpermProduction(x)))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> PreventsSpermProduction(x))", "all x. (MaleInsect(x) -> Prevented(SpermProduction(x)))"]}
{"id": "entailmentbank_validation_717", "nl": "if something required for a process is not produced then that process is prevented from occurring.", "fol": "", "prediction": ["all x. (exists y. (RequiredForProcess(y, x) & -Produced(y)) -> PreventedFromOccurring(x))", "all x. all y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x. (all y. (RequiredForProcess(y, x) & -Produced(y) -> PreventedFromOccurring(x)))", "all x. ((RequiredForProcess(x) & -Produced(x)) -> PreventedFromOccurring(x))", "all x, y. ((RequiredFor(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x. (RequiredForProcess(x) & -Produced(x) -> PreventedFromOccurring(x))", "all x. all y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all p. all r. ((RequiredForProcess(r, p) & -Produced(r)) -> PreventedFromOccurring(p))", "all p. all r. ((RequiredForProcess(r, p) & -Produced(r)) -> PreventedFromOccurring(p))", "all x. ((RequiredForProcess(x) & -Produced(x)) -> PreventedFromOccurring(x))", "all x. all y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x. all y. ((RequiredFor(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all x, y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))", "all p. all r. ((RequiredFor(r, p) & -Produced(r)) -> PreventsOccurring(p))", "all x y. ((RequiredForProcess(x, y) & -Produced(x)) -> PreventedFromOccurring(y))"]}
{"id": "entailmentbank_validation_718", "nl": "the sexual reproduction process is prevented in the insects.", "fol": "", "prediction": ["all x. (Insect(x) -> -CanReproduceSexually(x))", "all x. (Insect(x) -> Prevented(SexualReproductionProcess, x))", "all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "PreventedIn(reproduction_process_in_sexual, insects)", "exists y. (Insect(y) & Prevented(SexualReproductionProcess(y)))", "all x. (Insect(x) -> -CanUndergoSexualReproduction(x))", "FOL Translation:\nall x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "all x. (Insect(x) -> Prevents(sexualReproductionProcess, x))", "all x. (Insect(x) -> -CanSexuallyReproduce(x))", "PreventedSexualReproduction(insects)", "PreventedReproduction(insects)", "PreventedInReproduction(insects, sexual_reproduction_process)", "all x. (Insect(x) -> Prevented(SexualReproductionProcess(x)))", "Prevented(sexual_reproduction_process, insects)"]}
{"id": "entailmentbank_validation_719", "nl": "preventing reproduction decreases the rate of reproduction.", "fol": "", "prediction": ["all x. (PreventsReproduction(x) -> DecreasesReproductionRate(x))", "all x. (PreventReproduction(x) -> DecreasesRateOfReproduction(x))", "DecreasesRateOfReproduction(preventing(reproduction), reproduction)", "all x. (PreventReproduction(x) -> DecreasesReproductionRate(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventingReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventingReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (Preventing(x, Reproduction) -> DecreasesRate(Reproduction(x)))", "all x. (PreventsReproduction(x) -> DecreasesReproductionRate(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventsReproduction(x) -> DecreasesRateOfReproduction(x))", "all x. (PreventingReproduction(x) -> DecreasesRateOfReproduction(x))"]}
{"id": "entailmentbank_validation_720", "nl": "sexual reproduction is a kind of reproduction.", "fol": "", "prediction": ["all x. (SexualReproduction(x) -> Reproduction(x))", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)", "Kind(sexual_reproduction, reproduction)", "all x. (SexualReproduction(x) -> Reproduction(x))", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)", "all x. (SexualReproduction(x) -> Reproduction(x))", "KindOfReproduction(sexual_reproduction)", "KindOf(sexual_reproduction, reproduction)", "all x. (SexualReproduction(x) -> Reproduction(x))", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)", "KindOf(sexual_reproduction, reproduction)", "Kind(sexual_reproduction, reproduction)"]}
{"id": "entailmentbank_validation_721", "nl": "the reproduction rate in the insects will decrease.", "fol": "", "prediction": ["To translate \"the reproduction rate in the insects will decrease\" into first-order logic, we need to identify the parts of the sentence and represent them using predicates. Here, we treat \"reproduction rate\" and \"decrease\" as predicates, and \"insects\" indicates the domain.\n\nFOL Translation:\nall x. (Insect(x) -> Decrease(ReproductionRate(x)))", "Involves a more complex scenario than usual because it's not about individual insects but about a rate related to them:\n\nall z. (Insect(z) -> Decrease(ReproductionRate(z)))", "exists x. (Insect(x) & DecreasingReproductionRate(x))", "exists y. (Insect(y) & Decrease(ReproductionRate(y)))", "FOL Translation:\nDecrease(ReproductionRate(insects))", "Decrease(ReproductionRate(insects))", "DecreaseReproductionRate(insects)", "exists x. (Insect(x) & DecreaseInReproductionRate(x))", "FOL Translation:\nall x. (Insect(x) -> DecreaseInReproductionRate(x))", "exists x. (Insect(x) -> Decrease(ReproductionRate(x)))", "exists x. (Insect(x) -> DecreaseReproductionRate(x))", "DecreaseReproductionRate(insects)", "DecreaseReproductionRate(insects)", "exists x. (Insect(x) -> WillDecrease(ReproductionRate(x)))", "exists x. (Insect(x) & Decrease(ReproductionRate(x)))", "exists x. (Insect(x) & Decrease(ReproductionRate(x)))"]}
{"id": "entailmentbank_validation_722", "nl": "as the rate of reproduction decreases, the population will decrease.", "fol": "", "prediction": ["all x. ((Decreases(RateOfReproduction(x))) -> Decreases(Population(x)))", "all x. ((As(ReproductionRateDecreases(x))) -> PopulationDecreases(x))", "FOL Translation:\nall x. (DecreasingReproductionRate(x) -> DecreasingPopulation(x))", "all x. ((RateOfReproductionDecreases(x)) -> PopulationDecreases(x))", "all x. (ReproductionRateDecreases(x) -> PopulationDecreases(x))", "all x. ((RateOfReproductionDecreases(x)) -> (PopulationWillDecrease(x)))", "all x. (DecreasedReproductionRate(x) -> DecreasedPopulation(x))", "all x. (ReproductionRateDecreases(x) -> PopulationDecreases(x))", "all x. (RateOfReproductionDecreases(x) -> PopulationDecreases(x))", "all x. (RateOfReproductionDecreases(x) -> PopulationDecreases(x))", "all t. (Decrease(ReproductionRate(t)) -> Decrease(Population(t)))", "all x. (RateOfReproductionDecreases(x) -> PopulationDecreases(x))", "all r, p. (DecreaseReproductionRate(r) & PopulationCorresponding(p, r) -> WillDecrease(p))", "all x. ((RateOfReproductionDecreases(x) -> PopulationDecreases(x)))", "all x. (ReproductionRateDecreases(x) -> PopulationDecreases(x))", "all r. all p. ((Decreases(ReproductionRate(r)) -> Decreases(Population(p))))"]}
{"id": "entailmentbank_validation_723", "nl": "the population of the insects will decrease.", "fol": "", "prediction": ["Decrease(Population(insects))", "exists x. (Insect(x) & Decrease(Population(x)))", "Decrease(Population(insects))", "Exists t. (Future(t) & Decrease(Population(insects), t))", "exists p. (Population(p) & Of(p, insects) & WillDecrease(p))", "Decrease(Population(Insects))", "exists p. (PopulationOf(insects, p) & Decreases(p))", "exists x. (Insect(x) & PopulationDecrease(x))", "exists x. (Population(x) & Insect(x) & WillDecrease(x))", "To translate the sentence \"the population of the insects will decrease\" into first-order logic, we need to identify the main predicates involved and define the statement formally.\n\nIn this context:\n- The noun \"population\" can be considered as a property of insects.\n- \"Will decrease\" is a future change in this property.\n\nWe might use predicates such as:\n- InsectPopulation(x) to denote the population level or property of insects.\n- Decreases(x) to denote that the property x is decreasing.\n\nSince \"the population\" refers to a specific and singular entity, we can denote it as a constant or a predicate applied to insects collectively.\n\nHere's a possible approach using a variable to capture the property of the population decreasing:\n\nFOL Translation:\nDecreases(InsectPopulation)", "exists x. (Insect(x) & DecreasingPopulation(x))", "Decreases(Population(Insects))", "Decrease(Population(insects))", "exists x. (Insects(x) & WillDecrease(Population(x)))", "exists x. (Insect(x) & PopulationDecrease(x))", "Decrease(Population(insects))"]}
{"id": "entailmentbank_validation_724", "nl": "a hammer often is made of metal.", "fol": "", "prediction": ["exists y. (Hammer(y) & OftenMadeOfMetal(y))", "exists x. (Hammer(x) & Material(x, metal) & Often(MadeOf(x, metal)))", "exists x. (Hammer(x) & Oftentimes(y, (MadeOf(x, metal))))", "exists x. (Hammer(x) & MadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & MadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & MadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists y. (Hammer(y) & Material(y, metal))", "exists x. (Hammer(x) -> OftenMadeOfMetal(x))", "exists x. (Hammer(x) & OftenMadeOf(x, metal))", "exists x. (Hammer(x) & MadeOfMetal(x))"]}
{"id": "entailmentbank_validation_725", "nl": "when a metal rusts, that metal becomes flaky on the surface.", "fol": "", "prediction": ["all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. ((Metal(x) & Rusts(x)) -> FlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. ((Metal(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Metal(x) & Rusts(x) -> FlakySurface(x))"]}
{"id": "entailmentbank_validation_726", "nl": "when a hammer rusts, the hammer will becom flaky on the surface.", "fol": "", "prediction": ["exists x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. (Hammer(x) & Rusts(x) -> BecomesFlakyOnSurface(x))", "all x. ((Hammer(x) & Rusts(x)) -> BecomesFlakyOnSurface(x))"]}
{"id": "entailmentbank_validation_727", "nl": "kim's hammer is flaky on the surface.", "fol": "", "prediction": ["FlakyOnSurface(kim's_hammer)", "FlakyOnSurface(hammer_kim)", "FlakyOnSurface(hammer_kim)", "FlakyOnSurface(hammer_kim)", "FlakyOnSurface(hammer_kim)", "FlakyOnSurface(hammer_kim)", "FlakyOnSurface(kim's_hammer)", "FlakyOnSurface(kim's_hammer)", "FlakySurface(hammer_kim)", "FlakySurface(hammer_of_kim)", "FlakySurface(kim_hammer)", "FlakyOnSurface(kim's_hammer)", "FlakyOnSurface(hammer_of_kim)", "FlakyOnSurface(hammer_kim)", "FlakySurface(hammer_kim)", "FlakyOnSurface(hammer_kim)"]}
{"id": "entailmentbank_validation_728", "nl": "the hammer has rusted.", "fol": "", "prediction": ["Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)", "Rusted(hammer)"]}
{"id": "entailmentbank_validation_729", "nl": "rust forming is a kind of chemical change.", "fol": "", "prediction": ["RustForming(rust) -> ChemicalChange(rust)", "ChemicalChange(rust_forming)", "all x. (RustForming(x) -> ChemicalChange(x))", "all x. (RustForming(x) -> ChemicalChange(x))", "RustForming(x) -> ChemicalChange(x)", "ChemicalChange(rust_forming)", "RustFormingIsChemicalChange", "KindOf(rust_forming, chemical_change)", "RustForming(r) -> ChemicalChange(r)", "ChemicalChange(rust_forming)", "ChemicalChange(rust_forming)", "ChemicalChange(rust_forming)", "KindOf(rust_forming, chemical_change)", "Rust(x) -> ChemicalChange(x)", "KindOf(rust_forming, chemical_change)", "KindOf(FormsRust, ChemicalChange)"]}
{"id": "entailmentbank_validation_730", "nl": "the hammer has undergone a chemical change.", "fol": "", "prediction": ["exists x. (Hammer(x) & UndergoesChemicalChange(x))", "ChemicalChange(hammer)", "exists x. (Hammer(x) & UndergoesChemicalChange(x))", "ChemicalChange(hammer)", "exists z. (Hammer(z) & UndergoChemicalChange(z))", "exists x. (Hammer(x) & UndergoesChemicalChange(x))", "ChemicalChange(hammer)", "Exists y. (Hammer(y) & UndergoesChemicalChange(y))", "Exists x. (Hammer(x) & UndergoChemicalChange(x))", "ChemicalChange(hammer)", "ChemicalChange(hammer)", "ChemicalChange(hammer)", "ChemicalChange(hammer)", "Exists x. (Hammer(x) & UndergoesChemicalChange(x))", "ChemicalChange(hammer)", "ChemicalChange(hammer)"]}
{"id": "entailmentbank_validation_731", "nl": "element 3 turns to a greenish color.", "fol": "", "prediction": ["TurnsToGreenishColor(element3)", "exists x. (Element(x) & x = element3 & TurnsGreenish(x))", "TurnsToColor(element3, greenish)", "TurnsGreenish(element3)", "TurnsGreenish(element3)", "TurnsToGreenishColor(element3)", "TurnsGreenish(element3)", "TurnsGreenish(element3)", "TurnsToColor(element3, greenish)", "TurnsGreenish(element3)", "TurnsGreenish(element3)", "TurnsToColor(element3, greenish)", "TurnsToGreenishColor(element3)", "TurnsToGreenishColor(element3)", "TurnsGreenish(element3)", "TurnsGreenishColor(element3)"]}
{"id": "entailmentbank_validation_732", "nl": "an element is a kind of substance.", "fol": "", "prediction": ["all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> Substance(x))", "all x. (Element(x) -> KindOf(x, Substance))", "all x. (Element(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_733", "nl": "element 3 turning green is an example of a substance turning green.", "fol": "", "prediction": ["exists x. (Element(x) & x = 3 & TurnsGreen(x)) -> exists y. (Substance(y) & TurnsGreen(y))", "exists x. (Element(x) & x = 3 & TurnsGreen(x)) -> exists y. (Substance(y) & TurnsGreen(y))", "exists x. (Element(x) & x = 3 & TurnsGreen(x)) -> exists y. (Substance(y) & TurnsGreen(y))", "exists x. (Element(x) & TurnsGreen(x) & (x = element3) -> exists y. (Substance(y) & TurnsGreen(y)))", "exists x. (Element(x) & x = element3 & TurnsGreen(x)) -> exists y. (Substance(y) & y = x & TurnsGreen(y))", "exists x. (Element(x) & TurnsGreen(x) & x = element3 & exists y. (Substance(y) & TurnsGreen(y)))", "ExampleOf(TurningGreen(element3), exists y. (Substance(y) & TurningGreen(y)))", "exists x. (Element(x) & x = element3 & TurnsGreen(x)) -> exists y. (Substance(y) & TurnsGreen(y) & y = x)", "exists x. (Element(x) & x = 3 & TurningGreen(x)) & all y. (TurningGreen(x) -> Substance(x) & TurningGreen(y))", "exists x. (Element3(x) & TurnsGreen(x) & all y. (Substance(y) & TurnsGreen(y) -> ExampleOf(x, y)))", "exists x. (Element(x) & x = 3 & TurnsGreen(x) & IsExampleOf(x, SubstancesTurningGreen))", "ExampleOf(TurningGreen(element3), exists y. (Substance(y) & TurningGreen(y)))", "exists x. (Element(x) & example_turning_green(element3, x) & TurnsGreen(element3))", "exists x. (Element(x) & Green(x) & x = element3 -> exists y. (Substance(y) & Green(y)))", "ExampleOf(TurningGreen(element3), exists x. (Substance(x) & TurningGreen(x)))", "exists x. (Element(x) & TurnsGreen(element_3) & ExampleOf(TurnsGreen(element_3), TurnsGreen(x)))"]}
{"id": "entailmentbank_validation_734", "nl": "if the color of a substance changes then a chemical change may have occurred.", "fol": "", "prediction": ["exists x. (Substance(x) & ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. ((Substance(x) & ChangesColor(x)) -> MayHaveOccurred(ChemicalChange(x)))", "all x. ((Substance(x) & ChangesColor(x)) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ColorChanges(x) -> ChemicalChangeOccurred(x))", "all x. ((Substance(x) & ChangesColor(x)) -> MayHaveOccurred(ChemicalChange(x)))", "all x. ((Substance(x) & ChangesColor(x)) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (exists y. (ColorOf(y, x) & Changes(y)) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ColorChanges(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ColorChanges(x) -> MayHaveOccurred(ChemicalChangeFor(x)))", "all x. (ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (Substance(x) & ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))", "all x. (ColorChange(x) -> ChemicalChangeMayHaveOccurred(x))", "all s. (ChangeInColor(s) -> MayHaveOccurred(ChemicalChange(s)))", "all x. (ChangesColor(x) -> MayOccur(ChemicalChange(x)))", "all x. (ChangesColor(x) -> MayHaveOccurred(ChemicalChange(x)))"]}
{"id": "entailmentbank_validation_735", "nl": "a chemical change may occur to element 3.", "fol": "", "prediction": ["exists x. (ChemicalChange(x) & OccursTo(x, element3))", "exists x. (ChemicalChange(x) & OccursTo(x, element3))", "exists x. (ChemicalChange(x) & OccursTo(x, element_3))", "exists x. (ChemicalChange(x) & OccursTo(x, element3))", "exists c. (ChemicalChange(c) & MayOccurTo(c, element3))", "exists y. (ChemicalChange(y) & OccursTo(y, element3))", "exists x. (Element3(x) & MayUndergoChemicalChange(x))", "exists y. (Element(y) & ChemicalChangeMayOccur(y) & y = element3)", "exists c. (ChemicalChange(c) & OccursTo(c, Element3))", "exists x. (ChemicalChange(x) & MayOccurTo(x, element3))", "exists x. (Element3(x) & MayUndergoChemicalChange(x))", "exists y. (ChemicalChange(y) & MayOccurTo(y, element3))", "exists x. (ChemicalChangeMayOccur(x) & Element(x, 3))", "FOL Translation:\nexists y. (ChemicalChange(y) & OccursTo(y, element3))", "exists x. (ChemicalChange(x) & OccursTo(x, element3))", "exists x. (Element(x) & IsElement3(x) & MayUndergoChemicalChange(x))"]}
{"id": "entailmentbank_validation_736", "nl": "fire is a kind of chemical reaction.", "fol": "", "prediction": ["ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "all x. (Fire(x) -> ChemicalReaction(x))", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)", "ChemicalReaction(fire)"]}
{"id": "entailmentbank_validation_737", "nl": "fire causes burning.", "fol": "", "prediction": ["all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> CausesBurning(x))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> CausesBurning(x))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, BurningResult(y)))", "all x. (Fire(x) -> CausesBurning(x))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))", "all x. (Fire(x) -> Causes(x, Burning))"]}
{"id": "entailmentbank_validation_738", "nl": "burning something with fire is a kind of chemical reaction.", "fol": "", "prediction": ["all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurningWithFire(x) -> ChemicalReaction(x))", "all x. (BurningWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. all y. ((Burn(x) & WithFire(x, y)) -> ChemicalReaction(x))", "all z. (BurnWithFire(z) -> ChemicalReaction(z))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))", "all x. (BurnWithFire(x) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_739", "nl": "a lit candle is a source of fire.", "fol": "", "prediction": ["LitCandle(x) -> SourceOfFire(x)", "LitCandle(x) -> SourceOfFire(x)", "LitCandle(c) -> SourceOfFire(c)", "LitCandle(c) -> SourceOfFire(c)", "Candle(x) & Lit(x) -> SourceOfFire(x)", "LitCandle(x) -> SourceOfFire(x)", "Candle(x) & Lit(x) -> SourceOfFire(x)", "LitCandle(c) -> SourceOfFire(c)", "Candle(c) & Lit(c) -> SourceOfFire(c)", "LitCandle(c) -> SourceOfFire(c)", "LitCandle(x) -> SourceOfFire(x)", "all x. (LitCandle(x) -> SourceOfFire(x))", "SourceOfFire(x) -> LitCandle(x)", "all x. (LitCandle(x) -> SourceOfFire(x))", "Candle(x) & Lit(x) -> SourceOfFire(x)", "LitCandle(x) -> SourceOfFire(x)"]}
{"id": "entailmentbank_validation_740", "nl": "burning something with a lit candle is a kind of chemical reaction.", "fol": "", "prediction": ["all x. (BurnSomethingWithLitCandle(x) -> ChemicalReaction(x))", "all x. all y. ((Burn(x, y) & LitCandle(y)) -> ChemicalReaction(x))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x y. (Burn(x, y) & LitCandle(y) -> ChemicalReaction(x))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x. (BurnsWithCandle(x) -> ChemicalReaction(x))", "all x. (BurnedWithLitCandle(x) -> ChemicalReaction(x))", "all x y. (BurningWithCandle(x, y) -> ChemicalReaction(x))", "all x y. ((Burn(x) & WithLitCandle(y, x)) -> ChemicalReaction(x))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x. (BurnWithLitCandle(x) -> ChemicalReaction(x))", "all x. all y. (BurningWithLitCandle(x, y) -> ChemicalReaction(x, y))", "all x y. (BurningWithLitCandle(x, y) -> ChemicalReaction(Burning(x, y)))", "all x y. ((Burn(x, y) & LitCandle(y)) -> ChemicalReaction(x))", "all x y. (BurnWithLitCandle(x, y) -> ChemicalReaction(y))"]}
{"id": "entailmentbank_validation_741", "nl": "magnesium is a kind of substance.", "fol": "", "prediction": ["Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)", "Substance(magnesium)"]}
{"id": "entailmentbank_validation_742", "nl": "burning magnesium with a lit candle is a kind of chemical reaction.", "fol": "", "prediction": ["exists x. (BurningMagnesium(x) & LitCandle(x) -> ChemicalReaction(x))", "ChemicalReaction(Burning(magnesium), LitCandle)", "ChemicalReaction(Burning(magnesium, LitCandle))", "exists x exists y. (Burns(magnesium, x) & Lit(y) & Candle(y) & ChemicalReaction(burning_magnesium_with_lit_candle))", "ChemicalReaction(BurningMagnesiumWithLitCandle)", "all x y. ((Magnesium(x) & Candle(y) & Burning(x, y)) -> ChemicalReaction(Burning(x, y)))", "exists x. (Magnesium(x) & exists y. (Candle(y) & Lit(y) & BurnsWith(x, y) & ChemicalReaction(BurnsWith(x, y))))", "exists x. exists y. (Magnesium(x) & LitCandle(y) & Burning(x, y) -> ChemicalReaction(Burning(x, y)))", "exists x. exists y. (Burning(x, magnesium) & LitCandle(y) & ChemicalReaction(Burning(x, magnesium), y))", "`exists x. (Burning(x) & Magnesium(x) & WithLitCandle(x) -> ChemicalReaction(x))`", "all x. (BurningWithLitCandle(x, magnesium) -> ChemicalReaction(x))", "exists x. exists y. (Magnesium(x) & Candle(y) & Lit(y) & Reacts(x, y) & ChemicalReaction(Reacts(x, y)))", "all x y. (Burning(x) & Magnesium(x) & LitCandle(y) & UsedIn(y, x) -> ChemicalReaction(x))", "KindOfChemicalReaction(BurningWithLitCandle(magnesium))", "exists x. (BurningMagnesiumWithLitCandle(x) & ChemicalReaction(x))", "exists x, y. (Magnesium(x) & Candle(y) & Lit(y) & Burning(x, y) -> ChemicalReaction(Burning(x, y)))"]}
{"id": "entailmentbank_validation_743", "nl": "chemical reactions cause chemical change.", "fol": "", "prediction": ["all x. (ChemicalReaction(x) -> CausesChemicalChange(x))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> CausesChemicalChange(x))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> CausesChemicalChange(x))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> CausesChemicalChange(x))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "FOL Translation:\nall x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> Causes(x, ChemicalChange))", "all x. (ChemicalReaction(x) -> CausesChemicalChange(x))"]}
{"id": "entailmentbank_validation_744", "nl": "burning magnesium with fire will lead to a chemical change.", "fol": "", "prediction": ["exists x. (Magnesium(x) & Fire(y) & BurningWith(x, y) -> ChemicalChange(x))", "exists x. (Magnesium(x) & Fire(y) & BurnsWith(x, y) -> ChemicalChange(x))", "all x. (BurningWithFire(x, magnesium) -> ChemicalChange(x))", "exists x. (Magnesium(x) & Fire(y) & BurnsWith(x, y) -> ChemicalChange(x))", "exists a. (BurnsWith(magnesium, fire) -> LeadsTo(a, ChemicalChange))", "exists x y. (Magnesium(x) & Fire(y) -> LeadToChemicalChange(Burning(x, y)))", "exists x. (Magnesium(x) & Fire(f) & Burning(x, f) -> ChemicalChange(leadsTo(x, f)))", "all x. (Magnesium(x) & BurnWithFire(x) -> ChemicalChange(x))", "all x. (BurningWithFire(x) & Magnesium(x) -> ChemicalChange(x))", "all x. all y. all z. ((Burning(x, y) & Fire(y) & Magnesium(x) & LeadsTo(x, z)) -> ChemicalChange(z))", "all x. (Magnesium(x) & BurningWithFire(x) -> LeadsToChemicalChange(x))", "all x. (BurningWithFire(x, magnesium) -> ChemicalChange(x))", "exists x exists y. (Magnesium(x) & Fire(y) & BurnsWith(x, y) -> ChemicalChange(x))", "exists x. (Magnesium(x) & exists y. (Fire(y) & BurnsWith(x, y) -> LeadsTo(x, ChemicalChange)))", "To represent the statement \"burning magnesium with fire will lead to a chemical change\" in first-order logic, we need to identify the entities and the relationships involved. Here's the translation:\n\nexists x. (Magnesium(x) & Fire(y) & BurnsWith(x, y) -> ChemicalChange(x))", "exists x. (Magnesium(x) & Fire(y) & Burning(x, y) -> ChemicalChange(Result(x, y)))"]}
{"id": "entailmentbank_validation_745", "nl": "chemical reactions cause new materials to form.", "fol": "", "prediction": ["all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & CausesFormationOf(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all r. (ChemicalReaction(r) -> exists m. (NewMaterial(m) & CausesFormation(r, m)))", "all x. ((ChemicalReaction(x) & exists y. (NewMaterial(y) & Causes(x, y))) -> FormsNewMaterial(x))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & CausesFormation(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (Causes(x, y) & NewMaterial(y)))", "all r. (ChemicalReaction(r) -> exists m. (NewMaterial(m) & CausesFormation(r, m)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & CausesFormationOf(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewMaterial(y) & Causes(x, y)))"]}
{"id": "entailmentbank_validation_746", "nl": "chemical change is a kind of chemical reaction.", "fol": "", "prediction": ["all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "FOL Translation:\nall x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "KindOf(chemical_change, chemical_reaction)", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "all x. (ChemicalChange(x) -> ChemicalReaction(x))", "FOL Translation:\nall x. (ChemicalChange(x) -> ChemicalReaction(x))"]}
{"id": "entailmentbank_validation_747", "nl": "chemical changes cause new materials to form.", "fol": "", "prediction": ["all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & CausesFormation(x, y)))", "all z. (ChemicalChange(z) -> exists w. (NewMaterial(w) & Causes(z, w)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all c. (ChemicalChange(c) -> exists m. (NewMaterial(m) & Causes(c, m)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))", "all x. (ChemicalChange(x) -> exists y. (NewMaterial(y) & Causes(x, y)))"]}
{"id": "entailmentbank_validation_748", "nl": "an example of a chemical property is the elements making up a compound.", "fol": "", "prediction": ["exists x. (ChemicalProperty(x) & Example(x) & exists y. (ChemicalElement(y) & MakesUp(y, z) & Compound(z)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Element(y) & InCompound(y, z) & Compound(z))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & exists y. (Compound(y) & all z. (Element(z) & MakesUp(z, y))))", "exists y. (ChemicalProperty(y) & ExampleOf(y, elements) & Element(elements) & MakesUp(elements, compound))", "exists x. (ChemicalProperty(x) & IsExample(x, exists y. (Element(y) & MakesUp(y, Compound(z)))))", "exists x. (ChemicalProperty(x) & Example(x, exists y. (Element(y) & PartOf(y, Compound(z)))))", "exists y. (ChemicalProperty(y) & ExampleOf(y, exists z. (Compound(z) & all x. (Element(x) -> MakesUp(x, z)))))", "exists x. (ChemicalProperty(x) & IsExampleOf(x, y) & Compound(y) & exists z. (Element(z) & MakesUp(z, y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & exists z. (Compound(z) & MakesUp(y, z) & Element(y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & all z. (Element(z) & MakesUp(z, y) & Compound(y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, elements_making_up_compound))", "exists x. (ChemicalProperty(x) & IsExampleOf(x, y) & exists z. (Element(z) & MakesUp(z, y) & Compound(y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, CompoundMakingElements))", "exists x. (ChemicalProperty(x) & Example(x) & exists y. (Compound(y) & ElementsMakeUp(y, x)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, Compound(y) & exists z. (Element(z) & MakesUp(z, y))))", "exists x. (Example(x) & ChemicalProperty(x) & exists y. (Element(y) & MakesUp(y, Compound(x))))"]}
{"id": "entailmentbank_validation_749", "nl": "water is a kind of compound.", "fol": "", "prediction": ["Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)", "Compound(water)"]}
{"id": "entailmentbank_validation_750", "nl": "an example of chemical property is the elements making up water.", "fol": "", "prediction": ["exists x. (ExampleOfChemicalProperty(x) & ElementsMakeUp(water, x))", "exists x. (ExampleOf(x, ChemicalProperty) & ElementsMakingUp(x, water))", "exists x. (ChemicalProperty(x) & ExampleOf(x, elements_making_up_water))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & ElementsMakingUp(y, water))", "exists x. (ChemicalPropertyExample(x) & ElementsMakeUpWater(x))", "exists e. (ChemicalProperty(e) & ExampleOf(e, ElementsMakingUpWater))", "exists x. (ChemicalProperty(x) & ExampleOf(x, ElementsMakingUpWater))", "ChemicalProperty(example_of_chemical_property, elements_making_up_water)", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Element(y) & MakesUp(y, water))", "ChemicalProperty(example(x)) & ChemicalProperty(y) & ElementsMakeUp(water, y)", "exists x. (ChemicalProperty(x) & ExampleOf(x, ElementsMakingUpWater))", "ChemicalProperty(example_of_elements_making_water)", "exists x. (ChemicalPropertyExample(x) & y = WaterElements(y) & ExampleOf(x, y))", "ChemicalPropertyExample(elements_making_up_water)", "exists x. (ExampleOf(x, ChemicalProperty) & ElementsMakeUp(x, water))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & ElementsMakingUp(y, water))"]}
{"id": "entailmentbank_validation_751", "nl": "a chemical property of water is that it is made of hydrogen and oxygen.", "fol": "", "prediction": ["ChemicalProperty(water, x) & x = (MadeOf(hydrogen) & MadeOf(oxygen))", "ChemicalProperty(water, MadeOf(hydrogen, oxygen))", "Water(w) & all z. (ChemicalProperty(z, w) <-> (MadeOf(w, hydrogen) & MadeOf(w, oxygen)))", "ChemicalProperty(water, MadeOf(hydrogen) & MadeOf(oxygen))", "ChemicalPropertyOf(water, MadeOf(water, hydrogen & oxygen))", "ChemicalProperty(water, MadeOf(hydrogen, oxygen))", "ChemicalProperty(water, MadeOf(hydrogen, oxygen))", "ChemicalProperty(water, lambda x. (MadeOf(x, hydrogen) & MadeOf(x, oxygen)))", "ChemicalProperty(water, MadeOf(hydrogen, oxygen))", "ChemicalProperty(water, And(MadeOf(water, hydrogen), MadeOf(water, oxygen)))", "ChemicalProperty(water, lambda z. (MadeOf(z, hydrogen) & MadeOf(z, oxygen)))", "ChemicalProperty(water, MadeOf(water, hydrogen, oxygen))", "ChemicalProperty(water, MadeOfHydrogenAndOxygen) & MadeOf(water, hydrogen) & MadeOf(water, oxygen)", "ChemicalProperty(water, all y. ((y = hydrogen | y = oxygen) -> MadeOf(water, y)))", "ChemicalProperty(water, all x. ((x = hydrogen | x = oxygen) & MadeOf(water, x)))", "ChemicalProperty(water, lambda p. (MadeOf(water, hydrogen) & MadeOf(water, oxygen)))"]}
{"id": "entailmentbank_validation_752", "nl": "a compound can be chemically separated into the elements that it is made of.", "fol": "", "prediction": ["all c. (Compound(c) -> exists e. (Element(e) & MadeOf(c, e) & ChemicallySeparableInto(c, e)))", "all c. (Compound(c) -> exists e. (Element(e) & ChemicallySeparatedInto(c, e)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeSeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Elements(y) & ChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeSeparated(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) -> CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & ChemicallySeparatedInto(x, y) & MadeOf(x, y)))", "all c. (Compound(c) -> exists e. (Element(e) & MadeOf(c, e) & CanBeSeparatedInto(c, e)))", "all c. (Compound(c) -> exists e. (Element(e) & MadeOf(c, e) & CanBeChemicallySeparatedInto(c, e)))", "all x. (Compound(x) -> exists y. (Element(y) & ChemicallySeparatedInto(x, y) & MadeOf(x, y)))", "all x. (Compound(x) -> exists y. (Elements(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeSeparatedInto(x, y)))", "all x. (Compound(x) -> exists y. (Element(y) & MadeOf(x, y) & CanBeChemicallySeparatedInto(x, y)))"]}
{"id": "entailmentbank_validation_753", "nl": "water can be separated into hydrogen and oxygen.", "fol": "", "prediction": ["exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))", "all w. (Water(w) -> exists h exists o. (Hydrogen(h) & Oxygen(o) & CanBeSeparatedInto(w, h, o)))", "exists x. (Water(x) & CanBeSeparatedInto(x, hydrogen, oxygen))", "exists w, h, o. (Water(w) & Hydrogen(h) & Oxygen(o) & CanBeSeparatedInto(w, h, o))", "exists w, h, o. (Water(w) & Hydrogen(h) & Oxygen(o) & CanBeSeparatedInto(w, h, o))", "FOL Translation:\nCanBeSeparatedInto(water, hydrogen, oxygen)", "Translation:\nall x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "exists x. (Water(x) -> (exists y. (Hydrogen(y) & PartOf(y, x))) & exists z. (Oxygen(z) & PartOf(z, x)))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen) & CanBeSeparatedInto(x, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))", "exists x. (Water(x) -> CanBeSeparatedInto(x, hydrogen, oxygen))"]}
{"id": "entailmentbank_validation_754", "nl": "carbon dioxide is a new substance produced by sodium bicarbonate.", "fol": "", "prediction": ["NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "Produces(sodium_bicarbonate, carbon_dioxide) & NewSubstance(carbon_dioxide)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "Produces(sodium_bicarbonate, carbon_dioxide) & NewSubstance(carbon_dioxide)", "NewSubstanceProducedBy(carbon_dioxide, sodium_bicarbonate)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "ProducedBy(carbon_dioxide, sodium_bicarbonate) & NewSubstance(carbon_dioxide)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "NewSubstanceProducedBy(carbon_dioxide, sodium_bicarbonate)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "NewSubstance(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)", "Produced(sodium_bicarbonate, carbon_dioxide) & NewSubstance(carbon_dioxide)", "Substance(carbon_dioxide) & New(carbon_dioxide) & ProducedBy(carbon_dioxide, sodium_bicarbonate)"]}
{"id": "entailmentbank_validation_755", "nl": "chemical reactions cause new substances to form.", "fol": "", "prediction": ["all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesFormation(r, s)))", "all z. (ChemicalReaction(z) -> exists w. (NewSubstance(w) & CausesFormation(z, w)))", "all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesFormation(r, s)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesFormation(x, y)))", "all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesFormation(r, s)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesToForm(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesToForm(x, y)))", "all c x. (ChemicalReaction(c) & Involves(c, x) -> exists y. (NewSubstance(y) & FormsFrom(x, y)))", "all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & Forms(r, s)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesFormation(x, y)))", "all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesFormation(r, s)))", "all r. (ChemicalReaction(r) -> exists s. (NewSubstance(s) & CausesToForm(r, s)))", "all x. (ChemicalReaction(x) -> exists y. (Causes(x, y) & NewSubstance(y)))", "all x y. (ChemicalReaction(x) & Causes(x, y) -> NewSubstance(y))", "FOL Translation:\nall x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & FormsFrom(x, y)))", "all x. (ChemicalReaction(x) -> exists y. (NewSubstance(y) & CausesFormation(x, y)))"]}
{"id": "entailmentbank_validation_756", "nl": "sodium bicarbonate releasing carbon dioxide is a chemical reaction.", "fol": "", "prediction": ["exists x. (SodiumBicarbonate(x) & ReleasingCarbonDioxide(x) -> ChemicalReaction(x))", "all x. ((Releases(x, carbon_dioxide) & x = sodium_bicarbonate) -> ChemicalReaction(x))", "exists x. exists y. exists z. (SodiumBicarbonate(x) & Releases(x, y) & CarbonDioxide(y) & ChemicalReaction(z) & Involves(z, x, y))", "exists x y z. (Releases(sodium_bicarbonate, carbon_dioxide) & ChemicalReaction(sodium_bicarbonate, carbon_dioxide))", "exists x. exists y. exists z. (SodiumBicarbonate(x) & CarbonDioxide(y) & ChemicalReaction(z) & Releases(x, y) & Equals(z, Releases(x, y)))", "ChemicalReaction(Releases(sodium_bicarbonate, carbon_dioxide))", "exists x. (SodiumBicarbonate(x) & Releases(x, CarbonDioxide) -> ChemicalReaction(x))", "ChemicalReaction(SodiumBicarbonateReleasesCarbonDioxide)", "exists x. (SodiumBicarbonate(x) & Releases(x, carbon_dioxide) -> ChemicalReaction(x))", "ChemicalReaction(Releases(sodium_bicarbonate, carbon_dioxide))", "ChemicalReaction(releases(sodium_bicarbonate, carbon_dioxide))", "ChemicalReaction(SodiumBicarbonateReleasesCO2)", "exists x. (Releases(sodium_bicarbonate, carbon_dioxide) -> ChemicalReaction(x))", "ChemicalReaction(SodiumBicarbonateReleasingCarbonDioxide)", "exists x. (Releases(sodium_bicarbonate, carbon_dioxide) & ChemicalReaction(x))", "FOL Translation:\nReaction(sodium_bicarbonate_releasing_carbon_dioxide) & Chemical(sodium_bicarbonate_releasing_carbon_dioxide)"]}
{"id": "entailmentbank_validation_757", "nl": "an example of a chemical property is how a material reacts chemically.", "fol": "", "prediction": ["exists x. (ChemicalProperty(x) & ExampleOf(x, how_a_material_reacts_chemically))", "exists x. (ExampleOf(x, ChemicalProperty) & Material(y) & ReactsChemically(y, x))", "exists x y. (ChemicalProperty(x) & ExampleOf(x, y) & ReactsChemically(y))", "exists x. (ChemicalProperty(x) & ExampleOf(x, How(material, ReactsChemically)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Material(y) & ReactsChemically(y))", "exists x. (ChemicalProperty(x) & Example(x, ReactsChemically(material)))", "FOL Translation:\nexists x. (ChemicalProperty(x) & ExampleOf(x, y) & exists y. (Material(y) & ReactsChemically(y)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, ReactsChemically(material)))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Material(y) & ReactsChemically(y))", "exists x. (ChemicalProperty(x) & Example(x, y) & Reaction(y) & Material(y))", "exists x. (Example(x) & ChemicalProperty(x) & Material(y) & ReactsChemically(x, y))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & Material(y) & ReactsChemically(y))", "exists x. (ChemicalProperty(x) & ExampleOf(x, Reaction(y, Chemical(m))))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & exists y. (Material(y) & ReactsChemically(y)))", "exists x. (ChemicalPropertyExample(x) & ReactsChemically(x, material))", "exists x. (ChemicalProperty(x) & ExampleOf(x, y) & exists z. (Material(z) & ReactsChemically(z, y)))"]}
{"id": "entailmentbank_validation_758", "nl": "releasing carbon dioxide is a kind of chemical property of sodium bicarbonate.", "fol": "", "prediction": ["KindOfChemicalProperty(ReleasingCarbonDioxide, SodiumBicarbonate)", "ChemicalProperty(sodium_bicarbonate, releases_carbon_dioxide)", "ChemicalPropertyOf(sodium_bicarbonate, releasing_carbon_dioxide)", "KindOfChemicalProperty(ReleasingCarbonDioxide, SodiumBicarbonate)", "KindOfChemicalProperty_x(sodium_bicarbonate, releasing_carbon_dioxide)", "Releasing(carbon_dioxide, sodium_bicarbonate) & ChemicalPropertyOf(Releasing(carbon_dioxide), sodium_bicarbonate)", "ChemicalPropertyOf(sodium_bicarbonate, Releasing(carbon_dioxide))", "ChemicalProperty(sodium_bicarbonate, releasing_carbon_dioxide)", "ChemicalPropertyOf(sodium_bicarbonate, Releasing(carbon_dioxide))", "KindOf(ChemicalProperty(Releasing(carbon_dioxide)), ChemicalProperty(sodium_bicarbonate))", "ChemicalPropertyReleasesCO2(sodium_bicarbonate)", "Releasing(carbon_dioxide, sodium_bicarbonate) & ChemicalProperty(releasing_carbon_dioxide, sodium_bicarbonate)", "ChemicalPropertyOf(sodium_bicarbonate, Releasing(carbon_dioxide))", "exists x. (ReleasesCarbonDioxide(x) & KindOfChemicalProperty(x, sodium_bicarbonate))", "all x. (ReleasingCarbonDioxide(x) & SodiumBicarbonate(x) -> ChemicalProperty(x))", "exists x. (ReleasesCarbonDioxide(x) & KindOfChemicalProperty(x, sodium_bicarbonate))"]}
{"id": "entailmentbank_validation_759", "nl": "a pencil is a kind of object.", "fol": "", "prediction": ["Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)", "Object(pencil)"]}
{"id": "entailmentbank_validation_760", "nl": "sharpening a pencil changes the shape of the pencil.", "fol": "", "prediction": ["exists x. (Pencil(x) & Sharpen(x) -> ChangesShape(x))", "all x. (Pencil(x) & Sharpening(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpening(x) -> ChangesShape(x))", "exists x. (Pencil(x) & CanSharpen(x) & ChangesShapeWhenSharpened(x))", "exists x. (Pencil(x) & Sharpening(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpen(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpening(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpening(x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))", "all x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))", "all x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))", "all x. (Pencil(x) & Sharpens(y, x) -> ChangesShape(x))", "exists x. (Pencil(x) & Sharpen(y, x) -> ChangesShape(x))", "exists x, y. (Sharpening(x, y) & Pencil(y) -> ChangesShape(y))", "exists x. exists y. (Pencil(x) & Shape(y) & Sharpen(x) -> ChangesShape(x, y))", "all x. (Pencil(x) & Sharpens(x) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_761", "nl": "sharpening a pencil changes the shape of an object.", "fol": "", "prediction": ["exists x. (Object(x) & SharpeningPencil(y) & ChangesShape(y, x))", "exists x. (Pencil(x) & Sharpening(x) -> exists y. (Object(y) & ChangesShape(y)))", "exists s exists p. (Sharpen(p) & Pencil(p) & ChangesShape(s, p))", "exists x. (SharpenPencil(x) & exists y. (Object(y) & ChangesShape(x, y)))", "all x. (SharpenPencil(x) -> exists y. (Object(y) & ChangesShape(y)))", "FOL Translation:\nall x. (Pencil(x) & Sharpens(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (SharpeningPencil(x) -> exists y. (Object(y) & ChangesShape(y)))", "exists x. (Pencil(x) & Sharpens(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (Sharpening(x) & Pencil(x) -> changesTheShapeOf(x, Object(x)))", "all x. (Pencil(x) & Sharpened(x) -> exists y. (Object(y) & ChangesShape(y)))", "exists x. (Pencil(x) -> ShapeChanges(x))", "exists x. (Pencil(x) -> exists y. (Sharpening(x) & Object(y) & ChangesShape(x, y)))", "all x. (SharpeningPencil(x) -> exists y. (Object(y) & ChangesShape(y)))", "exists x. (Pencil(x) & Sharpening(x) -> exists y. (Object(y) & ChangesShape(y)))", "exists x. (Pencil(x) & Object(y) & Sharpen(x, y) -> ChangesShape(y))", "exists x. (SharpenPencil(x) -> exists y. (Object(y) & ChangesShape(y)))"]}
{"id": "entailmentbank_validation_762", "nl": "tearing paper changes the shape of the paper.", "fol": "", "prediction": ["all x. (Tearing(x, paper) -> ChangesShapeOf(x, paper))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tears(x) -> ChangesShape(x))", "all x. (Tearing(x) & Paper(x) -> ChangesShape(x))", "all x. (Paper(x) -> (Tearing(x) -> ChangesShape(x)))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "all x. (Paper(x) & Tears(x) -> ChangesShape(x))", "all x. (Tearing(x) & Paper(x) -> ChangesShape(x))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))", "FOL Translation:\nall x. (Tearing(x, paper) -> ChangesShape(x, paper))", "all x. (Paper(x) & Tearing(x) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_763", "nl": "paper is a kind of object.", "fol": "", "prediction": ["Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)", "Object(paper)"]}
{"id": "entailmentbank_validation_764", "nl": "tearing paper changes the shape of an object.", "fol": "", "prediction": ["all x. (Paper(x) & Tearing(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))", "all x, y. (Tearing(x, y) & Paper(x) -> ChangesShape(y))", "all x. (Paper(x) -> exists y. (ChangesShape(x, y) & Object(y)))", "FOL Translation:\nall x. (Tearing(x, paper) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearPaper(x) -> exists y. (Object(y) & ChangesShapeOf(x, y)))", "all x. (TearPaper(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))", "all x. (Paper(x) & Tear(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShapeOf(x, y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))", "all x. (TearingPaper(x) -> exists y. (Object(y) & ChangesShape(x, y)))", "all x. (TearPaper(x) -> exists y. (Object(y) & ChangesShape(y)))", "all x. (TearPaper(x) -> exists y. (Object(y) & ChangesShape(y)))"]}
{"id": "entailmentbank_validation_765", "nl": "sharpening a pencil and tearing paper both change the shape of the object.", "fol": "", "prediction": ["all x. ((Sharpening(x) | Tearing(x)) -> ChangesShape(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))", "all x. (SharpeningPencil(x) -> ChangesShape(x)) & all y. (TearingPaper(y) -> ChangesShape(y))", "all x. ((Sharpening(x) | TearingPaper(x)) -> ChangesShape(x))", "all x. ((SharpenPencil(x) | TearPaper(x)) -> ChangesShape(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))", "all x. ((SharpeningAPencil(x) | TearingPaper(x)) -> ChangesShapeOfObject(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))", "all x. ((Sharpening(x) & Pencil(x)) -> ChangesShape(x)) & all y. ((Tearing(y) & Paper(y)) -> ChangesShape(y))", "exists x. (Pencil(x) -> Sharpens(x) & ChangesShape(x)) & exists y. (Paper(y) -> Tears(y) & ChangesShape(y))", "all x. ((Sharpen(x) & Pencil(x)) -> ChangesShape(x)) & all y. ((Tear(y) & Paper(y)) -> ChangesShape(y))", "all x. ((Sharpening(x) | Tearing(x)) -> ChangesShape(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesShape(x))", "all x. ( (SharpeningPencil(x) | TearingPaper(x)) -> ChangesShape(x) )", "all x. ( (SharpeningPencil(x) | TearingPaper(x)) -> ChangesShape(x) )", "all x. ((SharpenPencil(x) | TearPaper(x)) -> ChangesShape(x))"]}
{"id": "entailmentbank_validation_766", "nl": "shape is a property of the appearance of an object.", "fol": "", "prediction": ["all x. (Object(x) -> exists y. (AppearanceProperty(y) & Shape(y) & PropertyOf(y, x)))", "all x. (Object(x) -> exists y. (Property(y) & Shape(y) & AspectOf(y, x)))", "all x. ((Object(x) & Property(shape, Appearance(x))) <-> Property(shape, Appearance(x)))", "all x. (Object(x) -> exists y. (AppearanceOf(y, x) & Property(shape, y)))", "all x. (Object(x) -> exists y. (Appearance(y) & PropertyOf(shape, y)))", "all x. (Object(x) -> exists y. (Appearance(y) & PropertyOf(shape, y, x)))", "all x. (Object(x) -> exists y. (Appearance(y) & HasProperty(y, shape)))", "all x. (AppearanceOf(x, y) & Object(y) -> Property(shape, x))", "all x. (Object(x) -> exists y. (Property(y) & Appearances(x, y) & Shape(y)))", "all x. (Object(x) -> exists y. (PropertyOf(y, Appearance(x)) & Shape(y)))", "all x. (Object(x) -> exists y. (PropertyOfAppearance(y, x) & Shape(y)))", "all x. (Object(x) -> exists y. (Property(y) & Shape(y) & AppearanceOf(y, x)))", "all x. (Object(x) -> exists y. (AppearanceOf(y, x) & Property(shape, y)))", "all x. (Object(x) -> exists y. (Shape(y) & PropertyOfAppearance(y, x)))", "all x. (Object(x) -> PropertyOf(shape, Appearance(x)))", "all x. (Object(x) -> exists y. (Appearance(y) & HasProperty(y, Shape)))"]}
{"id": "entailmentbank_validation_767", "nl": "sharpening a pencil and tearing paper both change the appearance of the object.", "fol": "", "prediction": ["all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesAppearance(x, object))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesAppearance(x))", "all x. ((Sharpening(x) & Pencil(x)) -> ChangesAppearance(x)) & all y. ((Tearing(y) & Paper(y)) -> ChangesAppearance(y))", "all x. ((Sharpens(pencil, x) | Tears(paper, x)) -> ChangesAppearance(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesAppearance(x, object))", "all x. ((Pencil(x) & Sharpens(x)) | (Paper(x) & Tears(x)) -> ChangesAppearance(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesAppearance(x))", "all x. ((Sharpening(x) | Tearing(x)) -> ChangesAppearance(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesAppearance(x))", "all x. ( (Sharpening(x) & Pencil(x)) | (Tearing(x) & Paper(x)) -> ChangesAppearance(x) )", "all x. ((Sharpening(x, pencil) | Tearing(x, paper)) -> ChangesAppearance(x, object))", "all x. ((Sharpening(x) | Tearing(x)) -> ChangesAppearance(x))", "all x. ((SharpeningPencil(x) | TearingPaper(x)) -> ChangesAppearance(x))", "all x. ((Sharpened(pencil, x) | Torn(paper, x)) -> ChangesAppearance(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesAppearance(x, object))", "all x. ((Pencil(x) & Sharpens(x)) | (Paper(x) & Tears(x)) -> ChangesAppearance(x))"]}
{"id": "entailmentbank_validation_768", "nl": "appearance is a kind of physical property.", "fol": "", "prediction": ["all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "Kind(appearance, physical_property)", "all y. (Appearance(y) -> PhysicalProperty(y))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "FOL Translation:\nall x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))", "all x. (Appearance(x) -> PhysicalProperty(x))"]}
{"id": "entailmentbank_validation_769", "nl": "sharpending a pencil and tearing paper both change the physical property of the object.", "fol": "", "prediction": ["all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((SharpeningPencil(x) | TearingPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesPhysicalPropertyOf(x))", "all x. (SharpeningPencil(x) -> ChangesPhysicalProperty(x)) & all y. (TearingPaper(y) -> ChangesPhysicalProperty(y))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((Sharpens(x, pencil) | Tears(x, paper)) -> ChangesPhysicalProperty(x, y))", "exists x. exists y. ((Sharpening(x, pencil) & Tearing(y, paper)) -> ChangesPhysicalProperty(x, pencil) & ChangesPhysicalProperty(y, paper))", "all x. (SharpensPencil(x) -> ChangesPhysicalProperty(x)) & all y. (TearsPaper(y) -> ChangesPhysicalProperty(y))", "exists x. (Pencil(x) & Sharpens(x) & ChangesPhysicalProperty(x)) & exists y. (Paper(y) & Tears(y) & ChangesPhysicalProperty(y))", "all x. (SharpeningPencil(x) -> ChangesPhysicalProperty(x)) & all y. (TearingPaper(y) -> ChangesPhysicalProperty(y))", "all x. ((SharpensPencil(x) & ChangePhysicalProperty(x)) | (TearsPaper(x) & ChangePhysicalProperty(x)))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesPhysicalProperty(x))", "all x. ((SharpensPencil(x) | TearsPaper(x)) -> ChangesPhysicalProperty(x))", "all x. (Sharpening(x, pencil) | Tearing(x, paper) -> ChangesPhysicalProperty(x))", "exists x, y. ((SharpeningPencil(x) & ChangesPhysicalProperty(x)) & (TearingPaper(y) & ChangesPhysicalProperty(y)))"]}
{"id": "entailmentbank_validation_770", "nl": "if something undergoes a physical change then the physical properties of that something will change.", "fol": "", "prediction": ["all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> ChangeInPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> WillChange(PhysicalProperties(x)))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))", "all x. (UndergoesPhysicalChange(x) -> PhysicalPropertiesChange(x))", "all x. (UndergoesPhysicalChange(x) -> ChangesPhysicalProperties(x))"]}
{"id": "entailmentbank_validation_771", "nl": "pencil and paper underwent a physical change.", "fol": "", "prediction": ["exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x, y))", "exists x, y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x, y))", "exists x, y. (Pencil(x) & Paper(y) & PhysicalChangeUndergone(x) & PhysicalChangeUndergone(y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "FOL Translation:\nexists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x, y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x. exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "Exists x. Exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x. exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x, y))", "exists x exists y. (Pencil(x) & Paper(y) & UndergoesPhysicalChange(x) & UndergoesPhysicalChange(y))", "exists x. exists y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))", "exists x, y. (Pencil(x) & Paper(y) & UnderwentPhysicalChange(x) & UnderwentPhysicalChange(y))"]}
{"id": "entailmentbank_validation_772", "nl": "heat means temperature increases.", "fol": "", "prediction": ["all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "FOL Translation:\nall x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> IncreasesTemperature(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))", "all x. (Heat(x) -> TemperatureIncreases(x))"]}
{"id": "entailmentbank_validation_773", "nl": "a solid is heated.", "fol": "", "prediction": ["exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "Exists s. (Solid(s) & Heated(s))", "exists x. (Solid(x) & Heated(x))", "exists x. (Solid(x) & Heated(x))", "Heated(solid)"]}
{"id": "entailmentbank_validation_774", "nl": "the temperature of the solid increases.", "fol": "", "prediction": ["Increase(Temperature(Solid))", "IncreaseTemperature(solid)", "exists x. (Solid(x) & Increases(Temperature(x)))", "exists x. (Solid(x) & TemperatureIncreases(x))", "exists x. (Solid(x) & TemperatureIncreases(x))", "Increase(Temperature(Solid))", "exists x. (Solid(x) & TemperatureIncreases(x))", "exists x. (Solid(x) & Increases(TemperatureOf(x)))", "Increase(Temperature(Solid))", "exists x. (Solid(x) & Increases(TemperatureOf(x)))", "exists x. (Solid(x) & Increase(TemperatureOf(x)))", "exists x. (Solid(x) & Increases(Temperature(x)))", "exists x. (Solid(x) & TemperatureIncreases(x))", "Increase(Temperature(solid))", "exists x. (Solid(x) & Increases(TemperatureOf(x)))", "exists x. (Solid(x) & TemperatureIncreases(x))"]}
{"id": "entailmentbank_validation_775", "nl": "a solid is a kind of substance.", "fol": "", "prediction": ["all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))", "all x. (Solid(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_776", "nl": "the temperature of the solid substance increases.", "fol": "", "prediction": ["exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "exists x. (SolidSubstance(x) & TemperatureIncreases(x))", "exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "IncreaseTemperature(solid_substance)", "exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "exists x. (SolidSubstance(x) & Increases(TemperatureOf(x)))", "exists x. (SolidSubstance(x) & Increases(TemperatureOf(x)))", "exists x. (SolidSubstance(x) & IncreasesTemperature(x))", "exists x. (SolidSubstance(x) & IncreasesTemperature(x))", "exists x. (SolidSubstance(x) & IncreasesTemperature(x))", "exists x. (SolidSubstance(x) & TemperatureIncreases(x))", "exists x. (SolidSubstance(x) & Increases(Temperature(x)))", "exists x. (SolidSubstance(x) & TemperatureIncreases(x))", "exists x. (SolidSubstance(x) & TemperatureIncreases(x))", "exists x. (SolidSubstance(x) & TemperatureIncreases(x))", "exists x. (SolidSubstance(x) & IncreasesTemperature(x))"]}
{"id": "entailmentbank_validation_777", "nl": "as the temperature of a substance increases, the molecules in that substance will move faster.", "fol": "", "prediction": ["all x. all y. ((Substance(x) & Molecule(y) & In(x, y) & Increases(Temperature(x))) -> MovesFaster(y))", "all x. all y. ((Substance(x) & TemperatureIncreases(x, y)) -> MoleculesMoveFaster(x, y))", "all x. (Substance(x) -> (IncreasesTemperature(x) -> MovesFaster(MoleculesIn(x))))", "all x. ((Substance(x) & Increases(Temperature(x))) -> MovesFaster(MoleculesIn(x)))", "all x. (Substance(x) -> (TemperatureIncreases(x) -> MoleculesMoveFaster(x)))", "all x. (Substance(x) & IncreasesTemperature(x) -> MoleculesMoveFaster(x))", "all x. (Substance(x) & IncreasesTemperature(x) -> MoleculesMoveFaster(x))", "all x. (Substance(x) -> (IncreaseTemperature(x) -> MoveFaster(MoleculesIn(x))))", "all x. (Substance(x) & TemperatureIncreases(x) -> all y. (MoleculeInSubstance(y, x) -> MovesFaster(y)))", "all x. (Substance(x) & TemperatureIncreases(x) -> MoleculesMoveFaster(x))", "all x. all y. ((Substance(x) & TemperatureIncreases(x)) -> (Molecule(y) & PartOf(y, x) -> MovesFaster(y)))", "all x. (Substance(x) & IncreasesTemperature(x) -> MoleculesMoveFasterIn(x))", "all s. all t. (Substance(s) & TemperatureIncrease(s, t) -> exists m. (MoleculeIn(m, s) & MovesFaster(m, t)))", "all x. (Substance(x) -> (TemperatureIncreases(x) -> MoleculesMoveFaster(x)))", "all s. all t1, t2. ((Substance(s) & Temperature(s, t1) & Temperature(s, t2) & Increases(t1, t2)) -> all m. (Molecule(m) & In(s, m) -> MovesFaster(m)))", "all x. (Substance(x) -> all y. (MoleculeIn(y, x) -> all t1 t2. (Temperature(x, t1) & Temperature(x, t2) & t2 > t1 -> MovesFaster(y, x, t2))))"]}
{"id": "entailmentbank_validation_778", "nl": "the molecules in the solid substance moves faster.", "fol": "", "prediction": ["all x. (Molecule(x) & In(x, solid_substance) -> MovesFaster(x))", "exists x. (Molecule(x) & InSolidSubstance(x) -> MovesFaster(x))", "all x. (Molecule(x) & InSolidSubstance(x) -> MovesFaster(x))", "exists x. (Molecule(x) & InSolidSubstance(x) & MovesFaster(x))", "To faithfully translate the sentence into first-order logic, we need to interpret the components and their relationships logically. We have a specific substance, which is a solid, and its molecules are moving faster.\n\nLet's define the predicates:\n- `Solid(x)`: `x` is a solid substance.\n- `Molecule(y, x)`: `y` is a molecule in substance `x`.\n- `MovesFaster(y)`: `y` moves faster.\n\nGiven these predicates, the sentence translates to:\n\nexists x. (Solid(x) & all y. (Molecule(y, x) -> MovesFaster(y)))", "exists x. (SolidSubstance(x) & MoleculeIn(x, y) -> MovesFaster(y))", "Exists s. (SolidSubstance(s) & all m. (Molecule(m) & InSolidSubstance(m, s) -> MovesFaster(m)))", "Involves\nTranslating the sentence \"the molecules in the solid substance moves faster\" into first-order logic involves identifying the entities and their relationships or properties. This can be broken down into a representation of the logic of the components:\n\n1. There's a solid substance.\n2. The molecules within this solid substance have a property (in this case, the property of \"moving faster\").\n\nHere\u2019s how you might represent that logically:\n\nFOL Translation:\nexists s. (SolidSubstance(s) & all m. (Molecule(m) & In(m, s) -> MovesFaster(m)))", "exists x. (SolidSubstance(x) & all y. (Molecule(y) & In(x, y) -> MovesFaster(y)))", "exists x. (Molecule(x) & InSolidSubstance(x) -> MovesFaster(x))", "exists x. (Molecule(x) & InSolidSubstance(x) & MovesFaster(x))", "exists x. (Molecule(x) & In(x, solid_substance) & MovesFaster(x))", "exists x. (SolidSubstance(x) & all y. (MoleculeIn(y, x) -> MovesFaster(y)))", "all x. (Molecule(x) & In(x, solid_substance) -> MovesFaster(x))", "exists x. (SolidSubstance(x) & MoleculeIn(x, y) -> MovesFaster(y))", "exists x. (Molecule(x) & InSolidSubstance(x) & MovesFaster(x))"]}
{"id": "entailmentbank_validation_779", "nl": "faster means an increase / higher in speed.", "fol": "", "prediction": ["all x y. (Faster(x, y) <-> IncreaseInSpeed(x, y))", "all x y. ((Faster(x, y) & Speed(y)) -> Increase(Speed(x)) & Higher(Speed(x)))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) <-> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x) | HigherInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x, y. (Faster(x, y) <-> IncreaseInSpeed(x, y))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))", "all x. (Faster(x) <-> IncreaseInSpeed(x))", "all x. (Faster(x) -> IncreaseInSpeed(x))"]}
{"id": "entailmentbank_validation_780", "nl": "the molecules in the solid substance increases in speed.", "fol": "", "prediction": ["exists x. (Molecule(x) & In(x, solid_substance) -> IncreasesInSpeed(x))", "exists x. (SolidSubstance(x) & all y. (Molecule(y) & In(x, y) -> IncreasesInSpeed(y)))", "exists x. (SolidSubstance(x) & all y. (MoleculeIn(y, x) -> IncreasesInSpeed(y)))", "exists x. (SolidSubstance(x) & Molecule(y, x) -> IncreasesInSpeed(y))", "exists x. (Molecule(x) & In(x, solid_substance) -> IncreasesSpeed(x))", "exists x. (Molecule(x) & InSolidSubstance(x) -> IncreasesInSpeed(x))", "exists x. (SolidSubstance(x) & Molecule(y, x) -> IncreasesInSpeed(y))", "exists x. (Molecule(x) & In(solid, x) -> IncreasesInSpeed(x))", "exists s. (SolidSubstance(s) & all m. (MoleculeInSolidSubstance(m, s) -> IncreasesInSpeed(m)))", "exists s. (SolidSubstance(s) & all m. (Molecule(m) & In(s, m) -> IncreasesInSpeed(m)))", "There is ambiguity in the sentence you've provided because \"the molecules in the solid substance\" can be interpreted as referring to a set of specific molecules or as a general statement about all molecules within any solid substance. The first-order logic translation can vary based on this interpretation. \n\nHere's a possible translation assuming a generic interpretation about all molecules:\n\nFOL Translation:\nall x. (MoleculeInSolidSubstance(x) -> IncreasesInSpeed(x))", "exists x. (Molecules(x) & InSolidSubstance(x) -> IncreasesInSpeed(x))", "exists x. (Molecule(x) & In(solid_substance, x) & IncreasesInSpeed(x))", "To translate the sentence \"the molecules in the solid substance increases in speed\" into first-order logic, we need to identify the entities and relationships involved. Here's the breakdown:\n\n- **Entities**: Molecules, solid substances\n- **Relationships**: A molecule being part of a solid, increasing speed\n\nNow, translate the sentence into FOL:\n\nFOL Translation:\n```\nall x. (Molecule(x) & InSolid(x, solid_substance) -> IncreasesSpeed(x))\n```\n\nExplanation:\n- `Molecule(x)`: x is a molecule.\n- `InSolid(x, solid_substance)`: x is in the solid substance.\n- `IncreasesSpeed(x)`: x increases in speed. \n\nThe use of \"all x\" implies that this is a general statement about all molecules within the specified context.", "exists x. (Molecule(x) & In(SolidSubstance, x) & IncreasesInSpeed(x))", "exists x. (Molecule(x) & InSolidSubstance(x) -> IncreasesInSpeed(x))"]}
{"id": "entailmentbank_validation_781", "nl": "proton is a kind of subatomic particles.", "fol": "", "prediction": ["SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "Kind(proton, subatomic_particle)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)", "SubatomicParticle(proton)"]}
{"id": "entailmentbank_validation_782", "nl": "neutrons are a kind of subatomic particle.", "fol": "", "prediction": ["all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))", "all x. (Neutron(x) -> SubatomicParticle(x))"]}
{"id": "entailmentbank_validation_783", "nl": "atomic mass is determined by the sum of protons and neutrons numbers in an atom.", "fol": "", "prediction": ["all a. (Atom(a) -> exists n p. (NeutronsIn(a, n) & ProtonsIn(a, p) & AtomicMass(a) = n + p))", "all x. (Atom(x) -> DeterminedBy(AtomicMass(x), Sum(Protons(x), Neutrons(x))))", "all x. (Atom(x) -> exists y exists z exists w. (ProtonsNumber(x, y) & NeutronsNumber(x, z) & AtomicMass(x, w) & Sum(y, z, w)))", "all x. (Atom(x) -> exists p, n. (ProtonsNumber(x, p) & NeutronsNumber(x, n) & AtomicMass(x) = Sum(p, n)))", "all x. (Atom(x) -> exists y z. (Protons(x, y) & Neutrons(x, z) & AtomicMass(x, y + z)))", "all x. (Atom(x) -> exists y exists z exists w. (ProtonCount(x, y) & NeutronCount(x, z) & AtomicMass(x, w) & Sum(y, z, w)))", "all x. (Atom(x) -> AtomicMass(x) = Sum(Protons(x), Neutrons(x)))", "all z. (Atom(z) -> AtomicMass(z) = Sum(ProtonsNumber(z), NeutronsNumber(z)))", "all a. (Atom(a) -> Determined(AtomicMass(a), SumOf(Protons(a) + Neutrons(a))))", "all x. (Atom(x) -> exists y, z. (ProtonNumber(x, y) & NeutronNumber(x, z) & AtomicMass(x, y + z)))", "all x. (Atom(x) -> Equals(AtomicMass(x), Sum(ProtonsNumber(x), NeutronsNumber(x))))", "all x. (Atom(x) -> AtomicMass(x) = Sum(NumberOfProtons(x), NumberOfNeutrons(x)))", "all x. (Atom(x) -> exists y z. (Protons(x, y) & Neutrons(x, z) & Determines(AtomicMass(x), Sum(y, z))))", "all a. (Atom(a) -> AtomicMass(a) = Sum(Protons(a) + Neutrons(a)))", "all x. (Atom(x) -> exists y. exists z. exists w. (Protons(x, y) & Neutrons(x, z) & AtomicMass(x, w) & Sum(w, y, z)))", "all x. (Atom(x) -> exists m, p, n. (AtomicMass(x, m) & Protons(x, p) & Neutrons(x, n) & m = p + n))"]}
{"id": "entailmentbank_validation_784", "nl": "atomic mass is determined by the sum of protons and neutrons particle numbers.", "fol": "", "prediction": ["all x. (AtomicMass(x) -> exists y exists z. (SumOf(x, y, z) & Protons(y) & Neutrons(z)))", "all x. (Particle(x) -> DeterminedBy(AtomicMass(x), Sum(Protons(x), Neutrons(x))))", "all m. (AtomicMass(m) -> exists p. exists n. (Protons(p) & Neutrons(n) & DeterminesBySum(m, p, n)))", "all x. (AtomicMass(x) -> exists y z. (Protons(x, y) & Neutrons(x, z) & Sum(y, z, Mass(x))))", "all x. (AtomicMass(x) -> exists y, z. (Protons(y) & Neutrons(z) & Sum(y, z, x)))", "all x. (AtomicMass(x) -> exists y, z. (SumOfProtonsAndNeutronsParticleNumbers(y, z) & DeterminedBy(x, Sum(y, z))))", "all a. (AtomicMass(a) <-> equals(a, Sum(NumberOfProtons(a), NumberOfNeutrons(a))))", "all x. (AtomicMass(x) -> exists y. exists z. (Protons(x, y) & Neutrons(x, z) & Sum(y, z, x)))", "all x. (AtomicMass(x) -> exists y exists z. (IsSumOfProtons(y, x) & IsSumOfNeutrons(z, x) & Sum(x, y, z)))", "all x. (AtomicMass(x) -> exists y exists z exists w. (SumOf(y, z, w) & Protons(y) & Neutrons(z) & Equals(w, x)))", "all x. (AtomicMass(x) -> exists y, z. (Protons(x, y) & Neutrons(x, z) & Sum(y, z, AtomicMass(x))))", "all x. (AtomicMass(x) -> exists y z. (Protons(y, x) & Neutrons(z, x) & DeterminedBySumOf(y, z, x)))", "all x. (AtomicMass(x) -> exists y z. (Protons(y) & Neutrons(z) & Sum(x, y, z)))", "all x. (AtomicMass(x) -> exists y exists z. (ProtonNumber(y) & NeutronNumber(z) & SumOf(x, y, z)))", "all x. (AtomicMass(x) -> exists y. exists z. (Protons(y, x) & Neutrons(z, x) & SumOfProtonsAndNeutrons(y, z, x)))", "all x. (AtomicMass(x) -> exists y exists z. (Protons(y) & Neutrons(z) & SumOfParticles(y, z, x)))"]}
{"id": "entailmentbank_validation_785", "nl": "a proton has a positive 1 electric charge.", "fol": "", "prediction": ["exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "FOL Translation:\nProton(x) -> HasElectricCharge(x, positive1)", "FOL Translation:\nProton(x) -> HasElectricCharge(x, positive1)", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & ElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive1))", "exists x. (Proton(x) & HasPositiveElectricCharge(x, 1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & ElectricCharge(x, positive1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))", "exists x. (Proton(x) & HasElectricCharge(x, positive1))", "exists x. (Proton(x) & HasElectricCharge(x, positive_1))"]}
{"id": "entailmentbank_validation_786", "nl": "a electron has a negative -1 electric charge.", "fol": "", "prediction": ["exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & ElectricCharge(x, negative_1))", "exists x. (Electron(x) & HasElectricCharge(x, -1) & Negative(x))", "exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & HasElectricCharge(x, negative1))", "Electron(electron) & ElectricCharge(electron, -1)", "exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & HasElectricCharge(x, negative_one))", "Exists x. (Electron(x) & ElectricCharge(x, -1))", "exists e. (Electron(e) & HasElectricCharge(e, negative_1))", "exists x. (Electron(x) & HasElectricCharge(x, -1) & NegativeCharge(x))", "exists x. (Electron(x) & HasElectricCharge(x, negative1))", "exists x. (Electron(x) & HasElectricCharge(x, negative_1))", "exists x. (Electron(x) & ElectricCharge(x, negative_one))", "exists x. (Electron(x) & HasNegativeOneCharge(x))", "exists x. (Electron(x) & NegativeElectricCharge(x, -1))"]}
{"id": "entailmentbank_validation_787", "nl": "equal numbers of protons and electrons result in a neutral 0 electric charge.", "fol": "", "prediction": ["all x y. ((Proton(x) & Electron(y) & Count(x) = Count(y)) -> ResultsIn(NeutralElectricCharge(0)))", "all n. (EqualNumbersOf(protons, n, electrons) -> ResultsIn(NeutralElectricCharge, n, zero))", "all x. (EqualNumbersOfProtonsAndElectrons(x) -> NeutralZeroElectricCharge(x))", "all x. (EqualNumbers(x, protons, electrons) -> ResultsIn(x, NeutralZeroElectricCharge))", "all x, y, z. ((ProtonNumber(x, z) & ElectronNumber(y, z) & Equal(x, y)) -> NeutralCharge(z))", "all x, y. (EqualNumber(x, y) & Proton(x) & Electron(y) -> NeutralElectricCharge(z) & ResultIn(x, y, z))", "all x. (EqualNumbersOfProtonsAndElectrons(x) -> NeutralElectricCharge(x))", "all x, y, z. ((ProtonCount(x, z) = ElectronCount(y, z)) -> NeutralCharge(z))", "all x. (HasEqualProtonsAndElectrons(x) -> NeutralCharge(x))", "all x y z. ((EqualNumbers(x, y) & Protons(x) & Electrons(y) & ResultIn(x, z) & ResultIn(y, z)) -> NeutralElectricCharge(z, 0))", "all n, m. (EqualNumbersOf(protons, n, electrons, m) & n = m -> ResultIn(neutral0ElectricCharge))", "all x. (EqualNumberOf(Protons(x), Electrons(x)) -> NeutralCharge(x, 0))", "all x. ((EqualNumbersOfProtonsAndElectrons(x)) -> NeutralElectricCharge(x, 0))", "all x. (EqualNumberOf(Protons(x), Electrons(x)) -> ResultIn(NeutralElectricCharge(x)))", "all x. (EqualProtonsAndElectrons(x) -> NeutralElectricCharge(x))", "all x. (EqualNumbersOf(x, protons, electrons) -> NeutralElectricCharge(x, 0))"]}
{"id": "entailmentbank_validation_788", "nl": "a neutron has a neutral electric charge.", "fol": "", "prediction": ["exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "Exists x. (Neutron(x) & HasNeutralElectricCharge(x))", "exists x. (Neutron(x) & HasNeutralCharge(x))", "exists x. (Neutron(x) & HasNeutralElectricCharge(x))"]}
{"id": "entailmentbank_validation_789", "nl": "equal numbers of protons and electrons and any number of neutrons result in a neutral 0 electric charge.", "fol": "", "prediction": ["all x. ((EqualNumbers(Protons(x), Electrons(x)) & any y. (Neutrons(y))) -> NeutralElectricCharge(x))", "all n, e, p. (EqualNumbers(protons, electrons) & Neutrons(n) & Protons(p) & Electrons(e) -> NeutralCharge(p, e, n))", "all x. ((equal(NumProtons(x), NumElectrons(x)) & exists y. Neutrons(x, y)) -> NeutralElectricCharge(x, 0))", "all x. ( (EqualNumbers(Protons(x), Electrons(x)) & AnyNumber(Neutrons(x))) -> NeutralElectricCharge(x, 0) )", "all n, p, e. ((Equal(p, e) & NeutralCharge(n, p, e)) -> ElectricCharge(n, p, e) = 0)", "all x. all y. all z. ((NumberOfProtons(x) = NumberOfElectrons(y) & NumberOfNeutrons(z)) -> NeutralElectricCharge(x, y, z))", "all p. all e. all n. ((EqualNumbers(p, e) & AnyNumber(n)) -> ResultInNeutralCharge(p, e, n))", "all x y z. ((EqualNumbers(x, y) & Proton(x) & Electron(y) & Neutron(z)) -> NeutralElectricCharge(x, y, z, 0))", "FOL Translation:\nall x. (EqualNumbers(Protons(x), Electrons(x)) & any y. (Number(Neutrons(y))) -> NeutralElectricCharge(x, 0))", "all n, p, e. (equal_numbers(p, e) & Admin(p, e, n) & any_number(n) -> NeutralCharge(n, p, e, 0))", "all x. (Protons(x) = Electrons(x) & exists y. Neutrons(y) -> NeutralElectricCharge(x))", "all p, e, n, a. ((EqualNumber(p, e) & AnyNumber(n) & IsNeutron(n)) -> (ResultIn(a, NeutralCharge) & ElectricCharge(a, 0)))", "all x. ( (EqualNumber(Protons(x), Electrons(x)) & exists y. Neutrons(y)) -> NeutralElectricCharge(x) )", "all x. (exists y. Exists z. (HasProtons(x, y) & HasElectrons(x, y) & HasNeutrons(x, z)) -> NeutralCharge(x))", "all x y z. ((NumberOfProtons(x) = NumberOfElectrons(y) & NumberOfNeutrons(z)) -> NeutralElectricCharge(x, y, z, 0))", "all n, m, p. ((ProtonNumber(n) & ElectronNumber(m) & NeutronNumber(p) & n = m) -> NeutralElectricCharge(0))"]}
{"id": "entailmentbank_validation_790", "nl": "an atom is made of protons / neutrons / electrons.", "fol": "", "prediction": ["Atom(x) -> (MadeOf(x, protons) & MadeOf(x, neutrons) & MadeOf(x, electrons))", "all x. (Atom(x) -> exists y. (Proton(y) | Neutron(y) | Electron(y)) & MadeOf(x, y))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))", "all x. (Atom(x) -> (exists y. Proton(y) & PartOf(y, x)) & (exists z. Neutron(z) & PartOf(z, x)) & (exists w. Electron(w) & PartOf(w, x)))", "exists x. (Atom(x) -> (exists y. Proton(y) & PartOf(y, x)) & (exists z. Neutron(z) & PartOf(z, x)) & (exists w. Electron(w) & PartOf(w, x)))", "all x. (Atom(x) -> exists p. (Proton(p) & PartOf(x, p)) & exists n. (Neutron(n) & PartOf(x, n)) & exists e. (Electron(e) & PartOf(x, e)))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))", "FOL Translation:\nall x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))", "all x. (Atom(x) -> (exists y. Proton(y) & PartOf(y, x) & exists z. Neutron(z) & PartOf(z, x) & exists w. Electron(w) & PartOf(w, x)))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x) | Neutron(y) & PartOf(y, x) | Electron(y) & PartOf(y, x)))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))", "exists x. (Atom(x) -> (MadeOf(x, proton) & MadeOf(x, neutron) & MadeOf(x, electron)))", "all z. (Atom(z) -> exists x. exists y. exists w. (Proton(x) & Neutron(y) & Electron(w) & MadeOf(z, x) & MadeOf(z, y) & MadeOf(z, w)))", "all x. ((Atom(x)) -> exists y. ((Proton(y) | Neutron(y) | Electron(y)) & PartOf(y, x)))", "all x. (Atom(x) -> exists y. (Proton(y) & PartOf(y, x)) & exists z. (Neutron(z) & PartOf(z, x)) & exists w. (Electron(w) & PartOf(w, x)))"]}
{"id": "entailmentbank_validation_791", "nl": "if an atom has an equal number of protons and electrons, then the atom will have a neutral charge.", "fol": "", "prediction": ["all x. ((Atom(x) & exists p. (Proton(p, x) & exists e. (Electron(e, x) & Count(p, x) = Count(e, x)))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (NumberOfProtons(x, n) & NumberOfElectrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> HasNeutralCharge(x))", "all x. ((Atom(x) & exists p, e. (ProtonCount(x, p) & ElectronCount(x, e) & p = e)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists y. (Proton(y) & In(x, y)) & exists z. (Electron(z) & In(x, z)) & Count(y) = Count(z)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists y. exists z. (Proton(y) & Electron(z) & Has(x, y) & Has(x, z) & NumberOf(y) = NumberOf(z))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists p exists e. (Proton(p) & Electron(e) & NumberOfProtons(x, p) = NumberOfElectrons(x, e))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists y. (Proton(y, x) & exists z. (Electron(z, x) & Count(Proton(y, x)) = Count(Electron(z, x))))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists y. (Proton(y) & PartOf(y, x)) & exists z. (Electron(z) & PartOf(z, x)) & Count(Proton(x)) = Count(Electron(x))) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (Protons(x, n) & Electrons(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (ProtonCount(x, n) & ElectronCount(x, n) & n = n)) -> NeutralCharge(x))", "all x. ((Atom(x) & exists n. (NumProtons(x, n) & NumElectrons(x, n))) -> NeutralCharge(x))"]}
{"id": "entailmentbank_validation_792", "nl": "an normal atom has a neutral electric charge.", "fol": "", "prediction": ["all x. ((Atom(x) & Normal(x)) -> NeutralCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "FOL Translation:\nall x. (Atom(x) & Normal(x) -> NeutralElectricCharge(x))", "all x. (Atom(x) & Normal(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (Atom(x) & Normal(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))", "all x. (NormalAtom(x) -> NeutralElectricCharge(x))"]}
{"id": "entailmentbank_validation_793", "nl": "that atom has an equal number of protons and electrons.", "fol": "", "prediction": ["exists x. (Atom(x) & HasEqualNumber(x, protons, electrons))", "Atom(that) & Protons(that, n) & Electrons(that, n)", "Exists y. (Atom(y) & EqualNumber(Protons(y), Electrons(y)))", "exists x. (Atom(x) & EqualNumber(Protons(x), Electrons(x)))", "Exists a. (Atom(a) & exists b. (Proton(b) & PartOf(b, a) & exists c. (Electron(c) & PartOf(c, a) & NumberOf(b, a) = NumberOf(c, a))))", "Exists x. (Atom(x) & EqualNumber(Protons(x), Electrons(x)))", "Atom(that) & exists x. (Protons(that, x) & Electrons(that, x) & x = x)", "Atom(that_atom) & exists n. (NumberOfProtons(that_atom, n) & NumberOfElectrons(that_atom, n))", "exists z. (Atom(z) & EqualNumber(Protons(z), Electrons(z)))", "Exists x. (Atom(x) & HasEqualNumberOfProtonsAndElectrons(x))", "exists a. (Atom(a) & EqualNumberOfProtonsAndElectrons(a))", "exists x. (Atom(x) & EqualNumberOfProtonsAndElectrons(x))", "Exists x. (Atom(x) & HasEqualNumberOfProtonsAndElectrons(x))", "Exists x. (Atom(x) & HasEqualProtonsElectrons(x))", "Atom(a) & exists x y. (Proton(x) & Electron(y) & HasNumber(a, x) & HasNumber(a, y) & EqualNumber(x, y))", "Exists a single entity 'a' and it fulfills the conditions: \n\nAtom(a) & exists b. (Proton(b) & NumberOf(b, n1) & belongsTo(b, a)) & exists c. (Electron(c) & NumberOf(c, n2) & belongsTo(c, a)) & n1 = n2"]}
{"id": "entailmentbank_validation_794", "nl": "iron in contact with water and oxygen will rust.", "fol": "", "prediction": ["all x. (Iron(x) & InContactWithWater(x) & InContactWithOxygen(x) -> WillRust(x))", "all x. (Iron(x) & InContactWithWater(x) & InContactWithOxygen(x) -> WillRust(x))", "all x. all y. all z. ((Iron(x) & InContactWith(x, y) & InContactWith(x, z) & Water(y) & Oxygen(z)) -> WillRust(x))", "all x. all y. all z. ((Iron(x) & InContactWith(x, y) & Water(y) & Oxygen(z) & InContactWith(x, z)) -> WillRust(x))", "all x. (Iron(x) & InContactWithWater(x) & InContactWithOxygen(x) -> WillRust(x))", "all x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) -> WillRust(x))", "all x. (Iron(x) & InContactWithWater(x) & InContactWithOxygen(x) -> WillRust(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))", "all x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) -> WillRust(x))", "FOL Translation:  \nall x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))", "all x, y, z. ((Iron(x) & InContactWith(x, y) & Water(y) & InContactWith(x, z) & Oxygen(z)) -> WillRust(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))", "all x. all y. all z. ((Iron(x) & InContactWith(x, y) & Water(y) & InContactWith(x, z) & Oxygen(z)) -> WillRust(x))", "all x. (Metal(x) & InContactWith(x, water) & InContactWith(x, oxygen) & x = iron -> Rust(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))", "FOL Translation:\nall x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> WillRust(x))"]}
{"id": "entailmentbank_validation_795", "nl": "iron in contact with water and oxygen causes a chemical change.", "fol": "", "prediction": ["all x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) -> CausesChemicalChange(x))", "all x. all y. all z. ((Iron(x) & ContactWith(x, y) & Water(y) & ContactWith(x, z) & Oxygen(z)) -> CausesChemicalChange(x))", "all x. all y. all z. ((Iron(x) & InContactWith(x, y) & Water(y) & InContactWith(x, z) & Oxygen(z)) -> CausesChemicalChange(x))", "exists x, y, z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) -> CausesChemicalChange(x))", "all x. (Iron(x) & ContactWithWater(x) & ContactWithOxygen(x) -> CausesChemicalChange(x))", "exists x. exists y. exists z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) -> CausesChemicalChange(x))", "all x y z. ((Iron(x) & InContactWith(x, y) & InContactWith(x, z) & Water(y) & Oxygen(z)) -> CausesChemicalChange(x))", "exists x. exists y. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) -> CausesChemicalChange(x))", "all x. all y. all z. ((Iron(x) & InContactWith(x, y) & InContactWith(x, z) & Water(y) & Oxygen(z)) -> CausesChemicalChange(x))", "all x. ((Iron(x) & InContactWithWater(x) & InContactWithOxygen(x)) -> CausesChemicalChange(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> CausesChemicalChange(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> CausesChemicalChange(x))", "all x.((Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen)) -> CausesChemicalChange(x))", "all x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) -> CausesChemicalChange(x))", "exists x y z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) -> CausesChemicalChange(x))", "all x. ((Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen)) -> CausesChemicalChange(x))"]}
{"id": "entailmentbank_validation_796", "nl": "iron in contact with water and oxygen is an example of chemical reactions.", "fol": "", "prediction": ["exists x. (IronInContactWithWaterAndOxygen(x) & ExampleOf(x, ChemicalReaction))", "exists x. (IronInContactWithWaterAndOxygen(x) & ChemicalReaction(x))", "exists x. (Iron(x) & ContactWith(x, water) & ContactWith(x, oxygen) -> ExampleOf(x, ChemicalReaction))", "exists x. (Iron(x) & ContactWithWater(x) & ContactWithOxygen(x) & ChemicalReaction(x))", "exists x. (ChemicalReaction(x) & ExampleOfContactWith(x, iron, water) & ExampleOfContactWith(x, iron, oxygen))", "ExampleOf(ChemicalReaction(iron, water, oxygen))", "exists x. (Iron(x) & InContactWithWater(x) & InContactWithOxygen(x) & ExampleOfChemicalReaction(x))", "exists x. (IronInContactWithWaterAndOxygen(x) & ExampleOf(x, ChemicalReaction))", "exists x y z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) & IsExampleOf(ChemicalReactions, x))", "exists x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) & ExampleOf(x, chemical_reaction))", "exists x. (Iron(x) & ContactWithWater(x) & ContactWithOxygen(x) & ExampleOf(x, ChemicalReactions))", "exists x. (Iron(x) & InContactWith(x, water) & InContactWith(x, oxygen) & ExampleOf(x, ChemicalReaction))", "exists x. (IronInContactWithWaterAndOxygen(x) & ChemicalReaction(x))", "exists x. (IronInContactWithWaterAndOxygen(x) & ChemicalReaction(x))", "exists x y z. (Iron(x) & Water(y) & Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) & ExampleOf(x, ChemicalReaction))", "exists x. (Iron(x) & exists y. (Water(y) & exists z. (Oxygen(z) & InContactWith(x, y) & InContactWith(x, z) & ExampleOf(ChemicalReactions, x))))"]}
{"id": "entailmentbank_validation_797", "nl": "alkaline earth metals are highly chemically reactive.", "fol": "", "prediction": ["`all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))`", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))"]}
{"id": "entailmentbank_validation_798", "nl": "elements from the same group in the periodic table are chemically reactive in a similar way.", "fol": "", "prediction": ["all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> SimilarChemicalReactivity(x, y))", "all x, y. ((Element(x) & Element(y) & SameGroupInPeriodicTable(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroupInPeriodicTable(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x. (all y. ((Element(x) & Element(y) & InSameGroup(x, y)) -> SimilarReactivity(x, y)))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x, y. ((Element(x) & Element(y) & SameGroupInPeriodicTable(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x y. ((Element(x) & Element(y) & InSameGroup(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x. (all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ReactsSimilarly(x, y)))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ChemicallyReactiveSimilarWay(x, y))", "all x, y. ((Element(x) & Element(y) & SameGroup(x, y)) -> SimilarReactivity(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ChemicallyReactiveInSimilarWay(x, y))", "all x. all y. ((Element(x) & Element(y) & FromSameGroup(x, y)) -> SimilarReactivity(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> ReactiveInSimilarWay(x, y))", "all x, y. (Element(x) & Element(y) & Group(x, z) & Group(y, z) -> ReactsSimilarly(x, y))", "all x. all y. ((Element(x) & Element(y) & SameGroup(x, y)) -> SimilarChemicalReactivity(x, y))", "all x. (all y. (Exists z. (Element(x) & Element(y) & Group(z) & InPeriodicTable(x, z) & InPeriodicTable(y, z))) -> ReactsSimilarly(x, y))"]}
{"id": "entailmentbank_validation_799", "nl": "elements that belong to alkaline earth metals are highly chemically reactive.", "fol": "", "prediction": ["all x. (Element(x) & BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (BelongsTo(x, alkaline_earth_metals) -> HighlyChemicallyReactive(x))", "all x. (BelongsTo(x, AlkalineEarthMetals) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (Element(x) & BelongsToAlkalineEarthMetals(x) -> HighlyChemicallyReactive(x))", "all x. (AlkalineEarthMetal(x) -> HighlyChemicallyReactive(x))"]}
{"id": "entailmentbank_validation_800", "nl": "magnesium belongs to alkaline earth metal family, group 2 on the periodic table.", "fol": "", "prediction": ["BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & PeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metals) & PartOfGroup(magnesium, group_2)", "BelongsToFamily(magnesium, alkaline_earth_metals) & BelongsToGroup(magnesium, group_2)", "AlkalineEarthMetalFamily(magnesium) & BelongsToGroup(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metals) & Group(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metal) & BelongsToGroup(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToPeriodicGroup(magnesium, alkaline_earth_metal_family) & PartOfPeriodicTableGroup(magnesium, group_2)", "BelongsToFamily(magnesium, alkaline_earth_metal_family) & Group(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & OnPeriodicTable(magnesium)", "AlkalineEarthMetal(magnesium) & BelongsToGroup(magnesium, 2) & OnPeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & PeriodicTable(magnesium)", "BelongsToFamily(magnesium, alkaline_earth_metal) & Group(magnesium, 2) & OnPeriodicTable(magnesium)"]}
{"id": "entailmentbank_validation_801", "nl": "magnesium is highly chemically reactive.", "fol": "", "prediction": ["ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "HighlyChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "HighlyChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium)", "ChemicallyReactive(magnesium) & High(magnesium)", "ChemicallyReactive(magnesium)"]}
{"id": "entailmentbank_validation_802", "nl": "an element cannot be decomposed into two or more different substances by simple chemical methods.", "fol": "", "prediction": ["all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & ComposeTo(y, z, x) & SimpleChemicalMethods(x)))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & DecomposableInto(x, y, z) & ChemicalMethod(simple)))", "all x. (Element(x) -> -(exists y, z. (DifferentSubstances(y, z) & CanDecomposeInto(x, y, z) & SimpleChemicalMethods(w, x))))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & DecomposesInto(x, y, z) & SimpleChemicalMethodUsed(x)))", "FOL Translation:\nall x. (Element(x) -> -exists y z. (DifferentSubstance(y) & DifferentSubstance(z) & DecomposedBySimpleMethodInto(x, y, z) & y \u2260 z))", "all x. (Element(x) -> -exists y. (DecomposesIntoDifferentSubstances(x, y) & SimpleChemicalMethods(y)))", "FOL Translation:\nall x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & CanBeDecomposedInto(x, y, z) & SimpleChemicalMethod(x)))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & DecomposableBySimpleChemicalMethod(x, y, z)))", "all x. (Element(x) -> -exists y. exists z. (DifferentSubstances(y, z) & CanDecomposeInto(x, y, z) & SimpleChemicalMethodDecomposition(x)))", "all x. (Element(x) -> -exists y. exists z. (DifferentSubstances(y, z) & CanDecomposeBySimpleChemicalMethods(x, y, z)))", "all x. (Element(x) -> -exists y, z. (DifferentSubstances(y, z) & CanBeDecomposedBySimpleChemicalMethods(x, y, z)))", "all x. (Element(x) -> -exists y. (DifferentSubstance(y) & DecomposesInto(x, y)))", "all x. (Element(x) -> -exists y, z. (DifferentSubstances(y, z) & CanBeDecomposedBySimpleChemicalMethods(x, y) & CanBeDecomposedBySimpleChemicalMethods(x, z) & y \u2260 z))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & CanBeDecomposedBySimpleChemicalMethods(x, y, z)))", "all x. (Element(x) -> -exists y, z. (DifferentSubstances(y, z) & CanBeDecomposedInto(x, y, z) & SimpleChemicalMethod(method)))", "all x. (Element(x) -> -exists y z. (DifferentSubstances(y, z) & DecomposableInto(x, y, z) & SimpleChemicalMethodApplicable(x)))"]}
{"id": "entailmentbank_validation_803", "nl": "sulfur cannot be decomposed into different substances by simple chemical methods.", "fol": "", "prediction": ["all x. (Sulfur(x) -> -CanBeDecomposedBySimpleChemicalMethods(x))", "ChemicalMethods(simple_methods)\nall x. (Sulfur(x) -> -(exists y. (Substance(y) & CanBeDecomposedBy(x, y, simple_methods))))", "`-exists x. (SimpleChemicalMethod(x) & CanDecomposeIntoDifferentSubstancesBy(x, sulfur))`", "Substance(sulfur) & -exists x, y. (ChemicalMethod(x) & DecomposesInto(sulfur, y, x))", "Element(sulfur) & -exists x. (DiffSubstance(x) & SimpleChemDecompose(sulfur, x))", "all x. (Sulfur(x) -> -CanBeDecomposedBySimpleChemicalMethods(x))", "Material(sulfur) & -exists x. (DifferentSubstance(x) & SimpleChemicalMethod(y) & CanBeDecomposedInto(sulfur, x, y))", "ChemicalElement(sulfur) & -exists x. (DifferentSubstance(x) & CanBeDecomposedByChemicalMethodsInto(sulfur, x))", "All x. (Sulfur(x) -> -CanBeDecomposedBySimpleChemicalMethods(x))", "-Exists y. (Substance(y) & DecomposableBySimpleChemicalMethods(y) & DifferentFrom(y, sulfur))", "ChemicalElement(sulfur) & -exists y. (DifferentSubstance(y) & CanBeDecomposedBySimpleMethods(sulfur, y))", "", "Element(sulfur) & all x. (SimpleChemicalMethod(x) -> -CanDecompose(sulfur, x))", "Substance(sulfur) & -exists x. (DifferentSubstance(x) & CanBeDecomposedBySimpleMethods(sulfur, x))", "all x. (Sulfur(x) -> -CanBeDecomposedBySimpleChemicalMethods(x))", "all x. (Sulfur(x) -> -exists y. (DifferentSubstance(y) & CanBeDecomposedBySimpleChemicalMethods(x, y)))"]}
{"id": "entailmentbank_validation_804", "nl": "sulfur is a kind of element.", "fol": "", "prediction": ["Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)", "Element(sulfur)"]}
{"id": "entailmentbank_validation_805", "nl": "iron is a kind of element.", "fol": "", "prediction": ["Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)", "Element(iron)"]}
{"id": "entailmentbank_validation_806", "nl": "the chemical symbol for iron is fe.", "fol": "", "prediction": ["ChemicalSymbol(iron, fe)", "Symbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbolFor(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(iron, fe)", "SymbolFor(iron, fe)"]}
{"id": "entailmentbank_validation_807", "nl": "fe is the chemical symbol for iron element.", "fol": "", "prediction": ["Symbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron_element)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(fe, iron)", "ChemicalSymbol(iron, fe)", "ChemicalSymbol(fe, iron)", "Symbol(fe, iron)", "ChemicalSymbol(fe, iron)"]}
{"id": "entailmentbank_validation_808", "nl": "if a substance is made of one element, then the substance is called an element.", "fol": "", "prediction": ["all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledAnElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledAnElement(x))", "all x. (Substance(x) & MadeOfOneElement(x) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. (Substance(x) & MadeOfOneElement(x) -> CalledAnElement(x))", "all x. (MadeOfOneElement(x) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))", "all x. ((Substance(x) & MadeOfOneElement(x)) -> CalledElement(x))"]}
{"id": "entailmentbank_validation_809", "nl": "oxygen gas is made of only oxygen element.", "fol": "", "prediction": ["all x. (OxygenGas(x) -> OnlyContains(x, OxygenElement))", "exists x. (OxygenGas(x) -> all y. (PartOf(y, x) -> OxygenElement(y)))", "all x. (OxygenGas(x) -> MadeOfOnly(x, OxygenElement))", "all x. (OxygenGas(x) -> MadeOfOnlyElement(x, oxygen))", "all x. (OxygenGas(x) -> OnlyContains(x, OxygenElement))", "all x. (OxygenGas(x) -> forall y. (PartOf(y, x) -> OxygenElement(y)))", "all x. (OxygenGas(x) -> MadeOfOnly(x, OxygenElement))", "all x. (OxygenGas(x) -> exists y. (MadeOf(x, y) & OxygenElement(y)))", "exists x. (OxygenGas(x) -> all y. (PartOf(y, x) -> OxygenElement(y)))", "all x. (OxygenGas(x) -> MadeOf(x, oxygenElement))", "all x. (OxygenGas(x) -> OnlyContains(x, OxygenElement))", "all z. (OxygenGas(z) -> MadeOfOnly(z, oxygen_element))", "all x. (OxygenGas(x) -> MadeOfOnly(x, OxygenElement))", "all x. (OxygenGas(x) -> all y. (PartOf(x, y) -> OxygenElement(y)))", "all x. (OxygenGas(x) -> exists y. (OxygenElement(y) & MadeOfOnly(x, y)))", "exists x. (OxygenGas(x) & all y. (Component(y, x) -> OxygenElement(y)))"]}
{"id": "entailmentbank_validation_810", "nl": "oxygen gas is an element.", "fol": "", "prediction": ["Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)", "Element(oxygen_gas)"]}
{"id": "entailmentbank_validation_811", "nl": "o2 is a chemical formula for oxygen gas.", "fol": "", "prediction": ["ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaForOxygenGas(o2)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormula(o2, oxygen_gas)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(oxygen_gas, o2)", "ChemicalFormulaFor(o2, oxygen_gas)", "ChemicalFormulaFor(o2, oxygen_gas)"]}
{"id": "entailmentbank_validation_812", "nl": "o2 is an element.", "fol": "", "prediction": ["Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)", "Element(o2)"]}
{"id": "entailmentbank_validation_813", "nl": "the chemical symbol for tellurium is te.", "fol": "", "prediction": ["ChemicalSymbolFor(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)", "ChemicalSymbol(tellurium, te)"]}
{"id": "entailmentbank_validation_814", "nl": "tellurium is a kind of metalloid.", "fol": "", "prediction": ["Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "KindOf(tellurium, metalloid)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Metalloid(tellurium)", "KindOf(tellurium, metalloid)", "Metalloid(tellurium)", "Metalloid(tellurium)", "Kind(tellurium, metalloid)", "Metalloid(tellurium)", "Metalloid(tellurium)"]}
{"id": "entailmentbank_validation_815", "nl": "te is a kind of metalloid.", "fol": "", "prediction": ["KindOf(te, metalloid)", "Metalloid(te)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "Kind(metalloid, te)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "KindOf(te, metalloid)", "Kind(te, metalloid)", "KindOf(te, metalloid)", "Metalloid(te)", "KindOf(te, metalloid)", "KindOf(te, metalloid)"]}
{"id": "entailmentbank_validation_816", "nl": "antimony is a kind of metalloid.", "fol": "", "prediction": ["Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)", "Metalloid(antimony)"]}
{"id": "entailmentbank_validation_817", "nl": "the chemical symbol for antimony is sb.", "fol": "", "prediction": ["ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "Symbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbolFor(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "Symbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbol(antimony, sb)", "ChemicalSymbolFor(antimony, sb)"]}
{"id": "entailmentbank_validation_818", "nl": "sb is a kind of metalloid.", "fol": "", "prediction": ["Kind(sbt, metalloid)", "Metalloid(sb)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "Metalloid(sb)", "Kind(silicon, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "Kind(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)", "KindOf(sb, metalloid)"]}
{"id": "entailmentbank_validation_819", "nl": "sb and te are both metalloids.", "fol": "", "prediction": ["Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)", "Metalloid(sb) & Metalloid(te)"]}
{"id": "entailmentbank_validation_820", "nl": "helium / neon / argon / krypton / xenon / radon belongs to noble gases family, group 18 on the periodic table.", "fol": "", "prediction": ["Belongs(helium, noble_gases) & Belongs(neon, noble_gases) & Belongs(argon, noble_gases) & Belongs(krypton, noble_gases) & Belongs(xenon, noble_gases) & Belongs(radon, noble_gases) & Group18(helium) & Group18(neon) & Group18(argon) & Group18(krypton) & Group18(xenon) & Group18(radon)", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group18OnPeriodicTable(helium) & Group18OnPeriodicTable(neon) & Group18OnPeriodicTable(argon) & Group18OnPeriodicTable(krypton) & Group18OnPeriodicTable(xenon) & Group18OnPeriodicTable(radon)", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group18(helium) & Group18(neon) & Group18(argon) & Group18(krypton) & Group18(xenon) & Group18(radon)", "NobleGas(helium) & NobleGas(neon) & NobleGas(argon) & NobleGas(krypton) & NobleGas(xenon) & NobleGas(radon) & all x. (NobleGas(x) -> Group18OnPeriodicTable(x))", "NobleGas(helium) & NobleGas(neon) & NobleGas(argon) & NobleGas(krypton) & NobleGas(xenon) & NobleGas(radon) & all x. (NobleGas(x) -> Group18OnPeriodicTable(x))", "NobleGas(helium) & NobleGas(neon) & NobleGas(argon) & NobleGas(krypton) & NobleGas(xenon) & NobleGas(radon) & all z. (NobleGas(z) -> Group18(z))", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group18Element(helium) & Group18Element(neon) & Group18Element(argon) & Group18Element(krypton) & Group18Element(xenon) & Group18Element(radon)", "BelongsToNobleGasesFamilyGroup18(helium) & BelongsToNobleGasesFamilyGroup18(neon) & BelongsToNobleGasesFamilyGroup18(argon) & BelongsToNobleGasesFamilyGroup18(krypton) & BelongsToNobleGasesFamilyGroup18(xenon) & BelongsToNobleGasesFamilyGroup18(radon)", "BelongsToNobleGases(helium) & BelongsToNobleGases(neon) & BelongsToNobleGases(argon) & BelongsToNobleGases(krypton) & BelongsToNobleGases(xenon) & BelongsToNobleGases(radon) & all x. (BelongsToNobleGases(x) -> Group18OnPeriodicTable(x))", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group(helium, 18) & Group(neon, 18) & Group(argon, 18) & Group(krypton, 18) & Group(xenon, 18) & Group(radon, 18)", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group18(helium) & Group18(neon) & Group18(argon) & Group18(krypton) & Group18(xenon) & Group18(radon)", "BelongsToNobleGasesFamily(helium) & BelongsToNobleGasesFamily(neon) & BelongsToNobleGasesFamily(argon) & BelongsToNobleGasesFamily(krypton) & BelongsToNobleGasesFamily(xenon) & BelongsToNobleGasesFamily(radon) & Group(helium, 18) & Group(neon, 18) & Group(argon, 18) & Group(krypton, 18) & Group(xenon, 18) & Group(radon, 18)", "BelongsToGroup(helium, noble_gases) & GroupNumber(helium, 18) & BelongsToGroup(neon, noble_gases) & GroupNumber(neon, 18) & BelongsToGroup(argon, noble_gases) & GroupNumber(argon, 18) & BelongsToGroup(krypton, noble_gases) & GroupNumber(krypton, 18) & BelongsToGroup(xenon, noble_gases) & GroupNumber(xenon, 18) & BelongsToGroup(radon, noble_gases) & GroupNumber(radon, 18)", "NobleGas(helium) & NobleGas(neon) & NobleGas(argon) & NobleGas(krypton) & NobleGas(xenon) & NobleGas(radon)", "BelongsToFamily(helium, noble_gases) & BelongsToFamily(neon, noble_gases) & BelongsToFamily(argon, noble_gases) & BelongsToFamily(krypton, noble_gases) & BelongsToFamily(xenon, noble_gases) & BelongsToFamily(radon, noble_gases) & Group(helium, 18) & Group(neon, 18) & Group(argon, 18) & Group(krypton, 18) & Group(xenon, 18) & Group(radon, 18)", "BelongsToFamily(helium, noble_gases) & Group(helium, 18) & BelongsToFamily(neon, noble_gases) & Group(neon, 18) & BelongsToFamily(argon, noble_gases) & Group(argon, 18) & BelongsToFamily(krypton, noble_gases) & Group(krypton, 18) & BelongsToFamily(xenon, noble_gases) & Group(xenon, 18) & BelongsToFamily(radon, noble_gases) & Group(radon, 18)"]}
{"id": "entailmentbank_validation_821", "nl": "elements in group 18 have complete outer electron shells on the periodic table of elements.", "fol": "", "prediction": ["all x. (ElementInGroup18(x) -> HasCompleteOuterElectronShell(x) & ExistsOnPeriodicTableOfElements(x))", "all x. (Element(x) & InGroup18(x) -> CompleteOuterElectronShell(x))", "all x. (Element(x) & InGroup18(x) -> HasCompleteOuterElectronShell(x))", "all x. (Element(x) & InGroup18(x) -> HasCompleteOuterElectronShell(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x) & OnPeriodicTable(x))", "all x. (ElementInGroup18(x) -> HasCompleteOuterElectronShell(x))", "all x. (Element(x) & InGroup18(x) -> HasCompleteOuterElectronShell(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x) & OnPeriodicTable(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x) & OnPeriodicTableOfElements(x))", "all x. (Element(x) & InGroup18(x) -> CompleteOuterElectronShell(x))", "all x. (Element(x) & Group18(x) -> CompleteOuterElectronShell(x))", "all x. (Element(x) & InGroup18(x) -> HasCompleteOuterElectronShell(x) & OnPeriodicTable(x))", "all x. (ElementInGroup18(x) -> HasCompleteOuterElectronShell(x))", "all x. (Element(x) & InGroup18(x) -> HasCompleteOuterElectronShell(x) & OnPeriodicTable(x))", "all x. (ElementInGroup18(x) -> CompleteOuterElectronShell(x) & OnPeriodicTable(x))"]}
{"id": "entailmentbank_validation_822", "nl": "helium, neon, argon, krypton, xenon, and radon have complete outer electron shells.", "fol": "", "prediction": ["CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteElectronShell(helium) & CompleteElectronShell(neon) & CompleteElectronShell(argon) & CompleteElectronShell(krypton) & CompleteElectronShell(xenon) & CompleteElectronShell(radon)", "CompleteOuterShell(helium) & CompleteOuterShell(neon) & CompleteOuterShell(argon) & CompleteOuterShell(krypton) & CompleteOuterShell(xenon) & CompleteOuterShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "HasCompleteOuterElectronShell(helium) & HasCompleteOuterElectronShell(neon) & HasCompleteOuterElectronShell(argon) & HasCompleteOuterElectronShell(krypton) & HasCompleteOuterElectronShell(xenon) & HasCompleteOuterElectronShell(radon)", "HaveCompleteOuterShell(helium) & HaveCompleteOuterShell(neon) & HaveCompleteOuterShell(argon) & HaveCompleteOuterShell(krypton) & HaveCompleteOuterShell(xenon) & HaveCompleteOuterShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "HasCompleteOuterElectronShell(helium) & HasCompleteOuterElectronShell(neon) & HasCompleteOuterElectronShell(argon) & HasCompleteOuterElectronShell(krypton) & HasCompleteOuterElectronShell(xenon) & HasCompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "CompleteOuterElectronShell(helium) & CompleteOuterElectronShell(neon) & CompleteOuterElectronShell(argon) & CompleteOuterElectronShell(krypton) & CompleteOuterElectronShell(xenon) & CompleteOuterElectronShell(radon)", "HasCompleteOuterShell(helium) & HasCompleteOuterShell(neon) & HasCompleteOuterShell(argon) & HasCompleteOuterShell(krypton) & HasCompleteOuterShell(xenon) & HasCompleteOuterShell(radon)", "HasCompleteOuterShell(helium) & HasCompleteOuterShell(neon) & HasCompleteOuterShell(argon) & HasCompleteOuterShell(krypton) & HasCompleteOuterShell(xenon) & HasCompleteOuterShell(radon)"]}
{"id": "entailmentbank_validation_823", "nl": "if the outermost electron shell of an atom is complete, then the element of those atoms will not react with other elements easily.", "fol": "", "prediction": ["all x. (Atom(x) & CompleteOutermostElectronShell(x) -> -ReactsEasilyWithOtherElements(ElementOf(x)))", "all x. ((Atom(x) & CompleteOutermostElectronShell(x)) -> all y. (ElementOf(x, y) -> -ReactsEasily(y)))", "all x. ((Atom(x) & CompleteOuterShell(x)) -> all y. ((ElementOf(x, y) & Element(y)) -> -ReactsEasily(y)))", "all a. ((Atom(a) & CompleteOutermostElectronShell(a)) -> all e. (ElementOf(a, e) -> -ReactsEasilyWithOtherElements(e)))", "all x. ((Atom(x) & CompleteOuterElectronShell(x)) -> -EasilyReactsWithOtherElements(ElementOf(x)))", "all x. (Atom(x) & CompleteOuterShell(x) -> all y. (ElementOf(x, y) -> -ReactsEasilyWithOtherElements(y)))", "all x. (Atom(x) & CompleteOuterShell(x) -> all y. (ElementOfAtom(x, y) -> -ReactsEasilyWithOtherElements(y)))", "all x. (Atom(x) & CompleteOuterShell(x) -> all y. (ElementOf(x, y) -> -ReactsEasily(y, OtherElements)))", "all x. ((Atom(x) & CompleteShell(x)) -> all y. (ElementOf(x, y) -> -ReactsEasilyWithOtherElements(y)))", "all x. (Atom(x) & CompleteOutermostElectronShell(x) -> -ReactsEasilyWithOtherElements(ElementOf(x)))", "all x. ((Atom(x) & CompleteOuterElectronShell(x)) -> exists y. (ElementOf(x, y) & -ReactsEasily(y)))", "all x. (Atom(x) & CompleteOuterShell(x) -> all y. (ElementOf(x, y) -> -ReactsEasilyWithOtherElements(y)))", "all x. (Atom(x) & CompleteOuterElectronShell(x) -> -EasilyReactsWithOtherElements(ElementOf(x)))", "all a. ((Atom(a) & CompleteOuterShell(a)) -> all e. (ElementOf(a, e) -> -ReactsEasilyWithOthers(e)))", "all x. (Atom(x) & CompleteOutermostElectronShell(x) -> all y. (ElementOf(x, y) -> -ReactsEasily(y)))", "all x. (Atom(x) & CompleteOuterElectronShell(x) -> all y. (Atom(y) & ElementOf(x, y) -> -ReactsEasily(y, OtherElements)))"]}
{"id": "entailmentbank_validation_824", "nl": "helium, neon, argon, krypton, xenon, and radon will not react with other elements easily.", "fol": "", "prediction": ["all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "FOL Translation:\nall x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> all y. (Element(y) -> -ReactsEasily(x, y)))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactEasily(x, others))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. (Element(x) & (x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. (InertGas(x) & (x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasilyWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -EasilyReactsWithOtherElements(x))", "all x. ((x = helium | x = neon | x = argon | x = krypton | x = xenon | x = radon) -> -ReactsEasily(x, y))"]}
{"id": "entailmentbank_validation_825", "nl": "water is a kind of substance.", "fol": "", "prediction": ["Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)", "Substance(water)"]}
{"id": "entailmentbank_validation_826", "nl": "boiling means matter / a substance changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["all x. (Boiling(x) -> ChangesFromLiquidToGas(x) & IncreasesHeatEnergy(x))", "all m. (Boiling(m) -> exists s. (Matter(s) | Substance(s) & ChangesFromLiquidToGas(s) & IncreasesHeatEnergy(s)))", "Boiling(x) <-> (Matter(x) | Substance(x) & ChangesFromTo(x, Liquid, Gas) & IncreasesHeatEnergy(x))", "all x. (Boiling(x) -> (Matter(x) & Substance(x) & ChangesState(x, liquid, gas) & IncreaseHeatEnergy(x)))", "all x. (Boiling(x) -> ChangeState(x, Liquid, Gas) & Requires(IncreasingHeatEnergy, x))", "all x. (Boiling(x) -> (Changes(x, Liquid, Gas) & Increases(x, HeatEnergy)))", "all x. (Boiling(x) -> (Substance(x) & ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x)))", "Boiling(x) <-> (Matter(x) & exists y. (ChangeState(y) & FromState(y, Liquid) & ToState(y, Gas) & Requires(x, y, IncreasingHeatEnergy)))", "all x. (Boiling(x) <-> (ChangesFromTo(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. (Boiling(x) <-> (Matter(x) & Liquid(x) & ChangesTo(x, Gas) & IncreasesHeatEnergy(x)))", "all x. ((Boiling(x) & MatterOrSubstance(x)) -> (ChangesFromLiquidToGas(x) & IncreasesHeatEnergy(x)))", "all x. (Boiling(x) -> (MatterOrSubstance(x) & ChangesFromTo(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. ((Matter(x) | Substance(x)) & Boiling(x) -> ChangesState(x, Liquid, Gas) & ByIncreasingHeatEnergy(x))", "Boiling(x) <-> (MatterOrSubstance(x) & ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x))", "Boiling(x) <-> (Matter(x) & (Liquid(x) & IncreasesHeatEnergy(x) -> Gas(x)))", "all x. (Boiling(x) <-> (Substance(x) & ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x)))"]}
{"id": "entailmentbank_validation_827", "nl": "water boiling is when water changes from a liquid into a gas.", "fol": "", "prediction": ["all x. (Boiling(x) & Water(x) -> ChangesState(x, liquid, gas))", "all x. (WaterBoiling(x) <-> (ChangesState(x, liquid, gas) & Water(x)))", "all x. ((Water(x) & IsBoiling(x)) -> ChangeState(x, liquid, gas))", "all x. ((Water(x) & Boiling(x)) <-> ChangesState(x, liquid, gas))", "all x. (WaterBoiling(x) <-> (ChangeState(x, liquid, gas)))", "Boiling(water) <-> ChangesState(water, liquid, gas)", "all x. (Boiling(x) & Water(x) -> ChangesState(x, liquid, gas))", "all x. (Water(x) & Boils(x) <-> (ChangesState(x, liquid, gas)))", "all x. (Boiling(x) & Water(x) <-> ChangesFrom(x, liquid, gas))", "all w. (Water(w) & Boiling(w) <-> ChangesState(w, liquid, gas))", "all x. (Boiling(x) & Water(x) -> ChangesState(x, liquid, gas))", "all x. (Water(x) & Boiling(x) <-> ChangesState(x, liquid, gas))", "Boiling(water) <-> ChangesState(water, liquid, gas)", "all x. (WaterBoiling(x) <-> (Water(x) & ChangesFrom(x, liquid) & ChangesTo(x, gas)))", "all x. (Boiling(x) & Water(x) -> ChangesState(x, liquid, gas))", "all x. (Water(x) & ChangesToState(x, liquid, gas) -> Boiling(x))"]}
{"id": "entailmentbank_validation_828", "nl": "water is in the gas state, called water vapor / steam, for temperatures above 100 c.", "fol": "", "prediction": ["FOL Translation:\nall x. (Water(x) & TemperatureAbove(x, 100) -> GasState(x) & (WaterVapor(x) | Steam(x)))", "all x. (Water(x) & TemperatureAbove100C(x) -> InGasState(x) & Called(x, water_vapor))", "all x. ((Water(x) & TemperatureAbove(x, 100)) -> (GasState(x) & (Called(x, water_vapor) | Called(x, steam))))", "all x. (Water(x) & TemperatureAbove(x, 100) -> GasState(x) & Called(x, water_vapor_or_steam))", "all x. (Water(x) & TempAbove(x, 100) -> (GasState(x) & (WaterVapor(x) | Steam(x))))", "all y. ((Water(y) & GasState(y) & TemperatureAbove(y, 100)) -> (Called(y, water_vapor) | Called(y, steam)))", "all x. (Water(x) & InGasState(x) & TemperatureAbove(x, 100) -> Called(x, water_vapor_steam))", "all x. (Water(x) & InGasState(x) & TemperatureAbove(x, 100) -> Called(x, water_vapor))", "all t. (Temperature(t) & Above(t, 100) -> (State(water, gas) & Called(water, steam)))", "all x. (Water(x) & TemperatureAbove(x, 100) -> GasState(x) & (Called(x, water_vapor) | Called(x, steam)))", "all x. (Water(x) & Temperature(x) > 100 -> GasState(x) & (Called(x, water_vapor) | Called(x, steam)))", "all x. ((Water(x) & TemperatureAbove100C(x)) -> InGasState(x) & (Called(x, water_vapor) | Called(x, steam)))", "all w. (Water(w) & exists t. (Temperature(t) & Above(t, 100))) -> GasState(w, vapor)", "all x. ((Water(x) & TemperatureAbove(x, 100)) -> (GasState(x) & (Called(x, water_vapor) | Called(x, steam))))", "all x. (Water(x) & Temperature(x) > 100 -> GasState(x) & (WaterVapor(x) | Steam(x)))", "all x. (Water(x) & TemperatureAbove(x, 100) -> InState(x, gas) & Called(x, vapor) & Called(x, steam))"]}
{"id": "entailmentbank_validation_829", "nl": "water is in the liquid state, called liquid water, for temperatures between 0 c and 100 c.", "fol": "", "prediction": ["all t. ((Temperature(t) & 0 < t & t < 100) -> LiquidState(water, t))", "InLiquidState(water) <-> (Temperature(water) > 0 & Temperature(water) < 100)", "all t. ((Temperature(t) & GreaterThanOrEqual(t, 0) & LessThanOrEqual(t, 100)) -> LiquidState(water, t))", "all t. ((Temperature(t) & (0 < t < 100)) -> LiquidWater(water, t))", "all x. ((Water(x) & TemperatureBetween(x, 0, 100)) -> State(x, liquid_water))", "all t. ((Temperature(t) & GreaterThanOrEqual(t, 0) & LessThanOrEqual(t, 100)) -> WaterInState(t, liquid))", "all t. ((Temperature(t) & 0 < t & t < 100) -> State(water, liquid))", "all x. (Water(x) & 0 < Temperature(x) & Temperature(x) < 100 -> InState(x, liquid_water))", "all t. ((Temperature(t) & GreaterThanOrEqual(t, 0) & LessThan(t, 100)) -> IsInState(water, liquid))", "all t. ((Temperature(t) & GreaterOrEqual(t, 0) & LessOrEqual(t, 100)) -> LiquidWater(water, t))", "all t. ((0 < t & t < 100) -> State(water, t, liquid_water))", "all t. ((Temperature(t) & GreaterThanOrEqual(t, 0) & LessThanOrEqual(t, 100)) -> State(water, liquid))", "all x. (Water(x) & TemperatureBetween(x, 0, 100) -> LiquidState(x) & Called(x, liquid_water))", "all t. ((Temperature(t) & 0 < t & t < 100) -> LiquidState(water, t))", "all x. (Water(x) & TemperatureBetween(x, 0, 100) -> LiquidState(x))", "all t. ((0 < t & t < 100) -> LiquidWater(water, t))"]}
{"id": "entailmentbank_validation_830", "nl": "water boiling is when water changes from liquid water to water vapor.", "fol": "", "prediction": ["all w. (Water(w) & Boiling(w) <-> ChangesFrom(w, liquid_water, water_vapor))", "all x. (WaterBoiling(x) <-> (Changes(x, LiquidWater, WaterVapor)))", "all x. ((Water(x) & Boiling(x)) -> (Changes(x, liquid_water, water_vapor)))", "all x. (Boiling(x) & Water(x) -> ChangesFrom(x, LiquidWater, WaterVapor))", "Boiling(water) <-> ChangesState(water, liquid_water, water_vapor)", "all w. (Water(w) & Boiling(w) <-> ChangesState(w, liquid_water, water_vapor))", "all x. (Water(x) & Boiling(x) -> ChangesFromTo(x, LiquidWater, WaterVapor))", "all x. (WaterBoiling(x) <-> ChangesFrom(x, liquid_water, water_vapor))", "Boiling(x) & Water(x) <-> (State(x, Liquid) -> State(x, Vapor))", "Boiling(water) <-> ChangesState(water, liquid, vapor)", "Boiling(water) <-> ChangesState(water, liquid, vapor)", "Exists x. (Boiling(x) & Water(x) & ChangesState(x, liquid_water, water_vapor))", "all x. ((Boiling(x) & ChangesFrom(x, liquid_water, water_vapor)) <-> Water(x))", "all x. ((Water(x) & Boiling(x)) -> (ChangesFrom(x, liquid_water, water_vapor)))", "all x. (WaterBoiling(x) <-> (ChangesState(x, liquid_water, water_vapor)))", "all x. ((Water(x) & Boiling(x)) <-> (ChangesFrom(x, liquid_water, water_vapor)))"]}
{"id": "entailmentbank_validation_831", "nl": "water boiling is when water changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["all x. (Water(x) & Boiling(x) <-> ChangesState(x, Liquid, Gas) & IncreasesHeatEnergy(x))", "all x. (Boiling(x) & Water(x) -> (ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. (WaterBoiling(x) <-> (Water(x) & Liquid(x) & ChangesState(x, Gas) & IncreasesHeatEnergy(x)))", "all w. (Water(w) & Boiling(w) <-> (ChangesState(w, liquid, gas) & ByIncreasing(w, HeatEnergy)))", "all x. (Water(x) & ChangesFromLiquidToGasWhenHeated(x) <-> Boiling(x))", "all w. ((Water(w) & Boiling(w)) <-> (ChangesState(w, liquid, gas) & IncreasesHeatEnergy(w)))", "WaterBoiling(w) <-> (ChangeState(w, liquid, gas) & ByIncreasingHeatEnergy(w))", "all x. (BoilingWater(x) <-> (StateChange(x, liquid, gas) & CausedBy(x, HeatIncrease)))", "Boiling(water) <-> (ChangesState(water, liquid, gas) & Increases(HeatEnergy))", "Boiling(water) <-> ChangeState(water, liquid, gas) & IncreaseHeatEnergy(water)", "all x. (Water(x) & Boiling(x) <-> (LiquidState(x) & ChangesInto(x, GasState) & IncreasesHeatEnergy(x)))", "all x. (Boiling(x) <-> (Water(x) & ChangesFromTo(x, liquid, gas) & Increases(HeatEnergy(x))))", "Boiling(water) <-> (ChangeState(water, liquid, gas) & IncreasesHeatEnergy(water))", "all x. (WaterBoiling(x) <-> (ChangeState(x, liquid, gas) & Cause(IncreaseHeatEnergy(x))))", "all x. (Water(x) & Boiling(x) <-> (ChangesState(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. (Water(x) & Boils(x) <-> (ChangesState(x, liquid, gas) & ByIncreasingHeatEnergy(x)))"]}
{"id": "entailmentbank_validation_832", "nl": "a puddle is a kind of body of water.", "fol": "", "prediction": ["BodyOfWater(puddle)", "BodyOfWater(puddle)", "KindOf(puddle, body_of_water)", "BodyOfWater(puddle)", "BodyOfWater(puddle)", "FOL Translation:\nall x. (Puddle(x) -> BodyOfWater(x))", "BodyOfWater(puddle)", "BodyOfWater(puddle)", "BodyOfWater(puddle)", "Puddle(x) -> BodyOfWater(x)", "BodyOfWater(puddle)", "Puddle(x) -> BodyOfWater(x)", "BodyOfWater(puddle)", "BodyOfWater(puddle)", "KindOf(puddle, body_of_water)", "BodyOfWater(puddle)"]}
{"id": "entailmentbank_validation_833", "nl": "being in the sun will cause the puddle to absorb heat energy.", "fol": "", "prediction": ["exists p. (Puddle(p) & all s. (BeingIn(s, sun) -> Causes(s, AbsorbHeatEnergy(p))))", "BeingInTheSun(puddle) -> Causes(Absorb(puddle, heat_energy))", "exists x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))", "exists x. (Puddle(x) -> (BeingInSun(x) -> AbsorbsHeatEnergy(x)))", "exists x. (Puddle(x) -> (InSun(x) -> AbsorbsHeatEnergy(x)))", "exists x. (Puddle(x) & all y. (Sun(y) -> Causes(BEIn(x, y), AbsorbHeatEnergy(x))))", "Exist x. BeingInSun(puddle) -> Causes(puddle, AbsorbHeatEnergy)", "exists x. (Puddle(x) & all y. (Sun(y) -> Causes(BeingIn(x, y), Absorb(x, HeatEnergy))))", "exists p. (Puddle(p) -> InSun(p) -> AbsorbsHeatEnergy(p))", "exists x. (Puddle(x) & BeingInSun(x) -> AbsorbsHeatEnergy(x))", "all x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))", "Exists x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))", "exists x. (Puddle(x) -> (BeingInSun(x) -> Causes(AbsorbHeatEnergy(x))))", "all x. (Puddle(x) & InSun(x) -> Causes(AbsorbHeatEnergy(x), InSun(x)))", "Exists y. (Puddle(y) & all x. (InSun(x) & IsPuddle(x) -> AbsorbsHeatEnergy(x)))", "exists x. (Puddle(x) & InSun(x) -> AbsorbsHeatEnergy(x))"]}
{"id": "entailmentbank_validation_834", "nl": "the puddle will evaporate.", "fol": "", "prediction": ["Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)", "Evaporates(puddle)"]}
{"id": "entailmentbank_validation_835", "nl": "an example of evaporation is a body of water drying up by absorbing heat energy.", "fol": "", "prediction": ["Exists e. (ExampleOf(e, evaporation) & exists w. (BodyOfWater(w) & DriesUp(w) & AbsorbsHeatEnergy(w)))", "Evaporation(example) & BodyOfWater(example) & DriesUpByAbsorbingHeatEnergy(example)", "exists x. (ExampleOf(x, Evaporation) & DryingUp(x) & isBodyOfWater(x) & AbsorbsHeatEnergy(x))", "exists x y. (ExampleOf(evaporation, x) & BodyOfWater(y) & DriesUp(y) & AbsorbsHeatEnergy(y, x))", "exists x. (ExampleOfEvaporation(x) & BodyOfWater(x) & DriesUpByAbsorbingHeatEnergy(x))", "exists x. (EvaporationExample(x) & BodyOfWater(x) & DriesUp(x) & AbsorbsHeatEnergy(x))", "exists x. (ExampleOfEvaporation(x) & BodyOfWater(y) & DriesUp(y) & AbsorbsHeatEnergy(y))", "Evaporation(x) & ExampleOf(x, y) & BodyOfWater(y) & DriesUp(y) & AbsorbsHeatEnergy(y)", "exists x. exists y. (ExampleOf(x, Evaporation) & BodyOfWater(y) & DryingUp(y) & Absorbing(y, HeatEnergy))", "exists x. (EvaporationExample(x) & BodyOfWater(x) & DriesUp(x) & AbsorbsHeatEnergy(x))", "exists x. (ExampleOf(x, Evaporation) & BodyOfWater(x) & AbsorbsHeatEnergy(x) & DriesUp(x))", "exists x. (ExampleOfEvaporation(x) & IsBodyOfWater(x) & DriesUp(x) & AbsorbsHeatEnergy(x))", "exists x. (ExampleOf(x, evaporation) & BodyOfWater(x) & DriesUp(x) & Absorbs(x, heat_energy))", "exists x. (ExampleOfEvaporation(x) & BodyOfWater(x) & DriesUp(x) & AbsorbingHeatEnergy(x))", "Evaporation(example_of_evaporation) & IsExampleOf(evaporation_by_heat, example_of_evaporation) & BodyOfWater(body_of_water) & DriesUp(body_of_water) & AbsorbsEnergy(body_of_water, heat) & Energy(heat)", "exists x. (ExampleOfEvaporation(x) & BodyOfWater(x) & DryingUp(x) & AbsorbsHeatEnergy(x))"]}
{"id": "entailmentbank_validation_836", "nl": "a puddle drying in the sun is an example of evaporation.", "fol": "", "prediction": ["FOL Translation:\nExampleOf(DryingInTheSun(puddle), Evaporation)", "Exists x. (Puddle(x) & DryingInSun(x) & ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DriesInTheSun(x) & ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInSun(x) & ExampleOf(x, Evaporation))", "Example(puddle_drying_in_sun, evaporation)", "exists x. (Puddle(x) & Drying(x) & InSun(x) & ExampleOf(x, Evaporation))", "Example(puddle_drying_sun, evaporation)", "exists x. (Puddle(x) & DryingInTheSun(x) -> ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DriesInSun(x) -> ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInSun(x) -> ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInSun(x) & ExampleOf(x, evaporation))", "exists x. (Puddle(x) & DryingInTheSun(x) & ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInTheSun(x) -> ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInSun(x) -> ExampleOf(x, Evaporation))", "exists x. (Puddle(x) & DryingInSun(x) -> ExampleOf(x, evaporation))", "Example(puddle_drying_in_the_sun, evaporation)"]}
{"id": "entailmentbank_validation_837", "nl": "if something is in the sunlight then that something will absorb solar energy.", "fol": "", "prediction": ["all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> WillAbsorbSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))", "all x. (InSunlight(x) -> AbsorbsSolarEnergy(x))"]}
{"id": "entailmentbank_validation_838", "nl": "a bucket of water in in the sunlight.", "fol": "", "prediction": ["exists x. (BucketOfWater(x) & InSunlight(x))", "Exists b. Exists w. Exists s. (BucketOfWater(b, w) & Sunlight(s) & In(b, s))", "Exists x. (BucketOfWater(x) & In(x, sunlight))", "Exists x. Exists y. (Bucket(x) & Water(y) & In(x, y) & InSunlight(x))", "Existential quantifiers introduce things that exist while universal quantifiers present things that can concede whether some statements are true. When faced with terms like \"a\" or \"some\", we have to find the suitability of using existential quantifiers. In this translation, we have one subject, bucket. The copula \"in\" that follows provides context that clarifies where the subject is to be found. Thus, our FOL would show the relation of where the subject is located.\n\nHere is the translation:\n\nexists x. (BucketOf(x, water) & InSunlight(x))", "InBucketOfWater(x) & InSunlight(x)", "Exists y. (BucketOfWater(y) & InSunlight(y))", "Exists z (BucketOfWater(z) & InSunlight(z))", "Exists x (BucketOfWater(x) & InSunlight(x))", "Exists x. (BucketOfWater(x) & InInSunlight(x))", "FOL Translation:\nexists x. (Bucket(x) & Contains(x, water) & InSunlight(x))", "Exists x. (BucketOfWater(x) & InSunlight(x))", "Exists x exists y (BucketOfWater(x) & Sunlight(y) & In(x, y))", "Exists x. (BucketOfWater(x) & InSunlight(x))", "exists x. (BucketOfWater(x) & In(x, sunlight))", "Exists x. (Bucket(b) & OfWater(w) & In(x, sunlight))"]}
{"id": "entailmentbank_validation_839", "nl": "the water in the bucket will absorb solar energy.", "fol": "", "prediction": ["exists x. (WaterInBucket(x) -> AbsorbsSolarEnergy(x))", "Exists x. (WaterInBucket(x) -> AbsorbsSolarEnergy(x))", "Exists x. (Water(x) & InBucket(x) -> AbsorbSolarEnergy(x))", "exists x. (Water(x) & InBucket(x) -> WillAbsorbSolarEnergy(x))", "exists x. (WaterInBucket(x) -> AbsorbsSolarEnergy(x))", "Exists x. (WaterInBucket(x) -> AbsorbsSolarEnergy(x))", "Exists x. (WaterInBucket(x) -> WillAbsorbSolarEnergy(x))", "Exists x. (Water(x) & InBucket(x) -> WillAbsorb(x, solarEnergy))", "exists x. (WaterInBucket(x) -> Absorbs(x, SolarEnergy))", "Exists x. (Water(x) & InBucket(x) -> Absorbs(x, SolarEnergy))", "Exists x (WaterInBucket(x) & AbsorbsSolarEnergy(x))", "Exists x. (Water(x) & InBucket(x) -> AbsorbsSolarEnergy(x))", "exists x. (Water(x) & InBucket(x) -> Absorbs(x, solar_energy))", "exists x. (Water(x) & InBucket(x) -> Absorbs(x, solar_energy))", "exists x. (WaterInBucket(x) -> AbsorbsSolarEnergy(x))", "exists x. (Water(x) & InBucket(x) -> Absorbs(x, SolarEnergy))"]}
{"id": "entailmentbank_validation_840", "nl": "if a substance absorbs solar energy then that substance will increase in temperature.", "fol": "", "prediction": ["all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreaseInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreaseInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (Substance(x) & AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))", "all x. (AbsorbsSolarEnergy(x) -> IncreasesInTemperature(x))"]}
{"id": "entailmentbank_validation_841", "nl": "the water in the bucket will increase in temperature.", "fol": "", "prediction": ["exists b. (Bucket(b) & exists w. (Water(w) & InBucket(w, b) & WillIncreaseInTemperature(w)))", "exists x. (Water(x) & InBucket(x) -> IncreasesInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> IncreasesInTemperature(x))", "exists z. (Water(z) & InBucket(z) -> IncreasesInTemperature(z))", "exists x. (WaterInBucket(x) & WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & InBucket(x) -> WillIncreaseInTemperature(x))", "exists x. (Water(x) & In(x, bucket) -> WillIncreaseInTemperature(x))", "IncreaseInTemperature(the_water_in_the_bucket)"]}
{"id": "entailmentbank_validation_842", "nl": "evaporation means a substance changes from a liquid into a gas by increasing heat energy.", "fol": "", "prediction": ["all s. ((Evaporation(s) & Substance(s)) -> (ChangesFromLiquidToGas(s) & IncreasesHeatEnergy(s)))", "all x. (Evaporation(x) <-> (Substance(x) & ChangeState(x, liquid, gas) & IncreasesHeatEnergy(x)))", "all x. (Evaporation(x) <-> exists y. (Substance(y) & Liquid(y) & ChangesState(y, Liquid, Gas) & IncreasesHeatEnergy(x, y)))", "all x. (Evaporation(x) <-> (Substance(x) & ChangesFromLiquidToGas(x) & IncreasesHeatEnergy(x)))", "all x. (Evaporation(x) <-> (Substance(x) & ChangesState(x, Liquid, Gas) & IncreasesHeatEnergy(x)))", "FOL Translation:\nall x. (Evaporation(x) -> exists y. (Substance(y) & ChangesFromTo(y, liquid, gas) & IncreasesHeatEnergy(x, y)))", "all s. (Evaporation(s) <-> exists l, g. (Substance(s) & Liquid(l) & Gas(g) & ChangesFromTo(s, l, g) & ByIncreasing(s, HeatEnergy)))", "all x. (Evaporation(x) <-> (Substance(x) & ChangesFromLiquidToGas(x) & IncreasesHeatEnergy(x)))", "Evaporation(x) <-> (Substance(x) & ChangesFrom(x, liquid, gas) & IncreasesHeatEnergy(x))", "all x. (Evaporation(x) -> (Substance(x) & ChangesFrom(x, liquid) & ChangesTo(x, gas) & ByIncreasingHeatEnergy(x)))", "all s. (Evaporation(s) <-> (Substance(s) & ChangesFromLiquidToGas(s) & IncreasesHeatEnergy(s)))", "Evaporation(x) <-> exists y. (Substance(y) & ChangesFromToBy(y, liquid, gas, increasing_heat_energy))", "all s. (Evaporation(s) <-> (Substance(s) & Changes(s, liquid, gas) & IncreasesHeatEnergy(s)))", "Evaporation(x) <-> (ChangesState(x, liquid, gas) & ByIncreasingHeatEnergy(x))", "all x. ((Evaporation(x) & Substance(x)) -> (Liquid(x) & IncreasesHeatEnergy(x) -> Gas(x)))", "all s. (Evaporation(s) -> (ChangesFromTo(s, liquid, gas) & ByIncreasingHeatEnergy(s)))"]}
{"id": "entailmentbank_validation_843", "nl": "the water in the bucket will evaporate.", "fol": "", "prediction": ["Evaporates(water_in_bucket)", "Exists x. (Water(x) & InBucket(x) -> WillEvaporate(x))", "Evaporate(water_in_bucket)", "Exists x. (WaterInBucket(x) -> WillEvaporate(x))", "Exists x. (WaterInBucket(x) -> WillEvaporate(x))", "Exists w. (In(w, bucket) & Water(w) -> WillEvaporate(w))", "Exists z. (Water(z) & InBucket(z) -> WillEvaporate(z))", "Evaporates(water_in_bucket)", "Exists x. (Water(x) & InBucket(x) -> WillEvaporate(x))", "Exists x. (Water(x) & InBucket(x) -> WillEvaporate(x))", "WaterInBucket(x) -> WillEvaporate(x)", "Evaporates(water_in_bucket)", "WaterInBucket(water) -> WillEvaporate(water)", "Exists y. (Water(y) & InBucket(y) -> WillEvaporate(y))", "Evaporates(water_in_bucket)", "Evaporates(water_in_bucket)"]}
{"id": "entailmentbank_validation_844", "nl": "gas is a kind of substance.", "fol": "", "prediction": ["Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)", "Substance(gas)"]}
{"id": "entailmentbank_validation_845", "nl": "substances are made of molecules.", "fol": "", "prediction": ["all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> MadeOfMolecules(x))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (MadeOf(x, y) & Molecule(y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Substance(x) -> exists y. (Molecule(y) & MadeOf(x, y)))"]}
{"id": "entailmentbank_validation_846", "nl": "a gas is made of its molecules.", "fol": "", "prediction": ["all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))", "all x. (Gas(x) -> exists y. (MoleculesOf(y, x)))", "all x. (Gas(x) -> exists y. (Molecule(y) & MadeOf(x, y)))"]}
{"id": "entailmentbank_validation_847", "nl": "a gas is heated and its temperature increases.", "fol": "", "prediction": ["exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "all x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) & IncreasesTemperature(x))", "all x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "all x. (Gas(x) & Heated(x) -> IncreasesTemperature(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))", "exists x. (Gas(x) & Heated(x) & IncreasesTemperature(x))", "all x. (Gas(x) & Heated(x) -> TemperatureIncreases(x))"]}
{"id": "entailmentbank_validation_848", "nl": "as the temperature of a substance increases, the molecules in that substance will move faster / farther apart.", "fol": "", "prediction": ["all x. (Substance(x) & IncreasesTemperature(x) -> all y. (Molecule(y) & InSubstance(y, x) -> MovesFaster(y) & MovesFartherApart(y)))", "all x. (Substance(x) & TemperatureIncreases(x) -> (MoleculesMoveFaster(x) & MoleculesMoveFartherApart(x)))", "all x. all y. ((Substance(x) & MoleculeIn(y, x) & IncreasesTemperature(x)) -> MovesFasterOrFartherApart(y))", "all x. (Substance(x) -> (Increases(Temperature(x)) -> (MoleculesIn(x) -> (MoveFaster(MoleculesIn(x)) & MoveFartherApart(MoleculesIn(x))))))", "all x. (Substance(x) -> (Increases(Temperature(x)) -> (all y. (Molecule(y) & PartOf(y, x) -> MovesFasterOrFartherApart(y)))))", "all x. all y. ((Substance(x) & TemperatureIncreases(x)) -> (Molecule(y, x) -> (MovesFaster(y) & MovesFartherApart(y))))", "all x. (Substance(x) -> (IncreasesTemperature(x) -> (all y. (MoleculeIn(x, y) -> (MovesFaster(y) & MovesFartherApart(y))))))", "all x. all y. (Substance(x) & TemperatureIncreases(x) & Contains(x, y) & Molecule(y) -> MovesFaster(y) & MovesFartherApart(y))", "all s. all t1. all t2. (Substance(s) & TemperatureIncreases(s, t1, t2) -> (all m. (Molecule(m) & InSubstance(m, s) -> MovesFasterOrFartherApart(m, t2, t1))))", "all x. all y. ((Substance(x) & Molecule(y) & PartOf(y, x)) & TemperatureIncreases(x) -> (MovesFaster(y) & MovesFartherApart(y)))", "all x. all y. (Substance(x) & MoleculeIn(y, x) & Increases(TemperatureOf(x)) -> (Increases(Speed(y)) & Increases(DistanceApart(y))))", "all x. (Substance(x) -> all t1, t2. (TemperatureIncrease(x, t1, t2) -> MoleculesMoveFaster(x, t2) & MoleculesMoveFartherApart(x, t2)))", "all s. all t1, t2. ((Substance(s) & Temperature(t1, s) & Temperature(t2, s) & t1 < t2) -> exists m. (Molecule(m, s) & MovesFaster(m, t2)))", "all x, y. ((Substance(x) & Molecule(y) & In(x, y) & TemperatureIncreases(x)) -> (MovesFaster(y) & MovesFartherApart(y)))", "all x. (Substance(x) & IncreasesTemperature(x) -> (exists y. (Molecule(y) & PartOf(y, x) & MovesFaster(y)) & (all z. (Molecule(z) & PartOf(z, x) -> MovesFartherApart(y, z)))))", "all x. all y. ((Substance(x) & TemperatureIncreases(x) & MoleculeIn(x, y)) -> (MovesFaster(y) & MovesFartherApart(y)))"]}
{"id": "entailmentbank_validation_849", "nl": "the molecules in the gas will move faster.", "fol": "", "prediction": ["exists y. (Gas(y) & all x. (Molecule(x) & In(y, x) -> MovesFaster(x)))", "exists x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "exists x. (Gas(x) -> all y. (MoleculeIn(x, y) -> MovesFaster(y)))", "exists x. (Molecule(x) & InGas(x) -> WillMoveFaster(x))", "exists g. (Gas(g) -> all m. (MoleculeInGas(m, g) -> MovesFaster(m)))", "all x. (MoleculeInGas(x) -> WillMoveFaster(x))", "all x. (InGas(x) -> WillMoveFaster(x))", "exists x. (Molecule(x) & InGas(x) -> WillMoveFaster(x))", "exists x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "all x. (MoleculeInGas(x) -> MovesFaster(x))", "exists x. (MoleculeInGas(x) -> WillMoveFaster(x))", "exists y. (Gas(y) & all x. (Molecule(x) & In(y, x) -> MovesFaster(x)))", "exists x. (Gas(x) & all y. (Molecule(y) & In(x, y) -> MovesFaster(y)))", "exists x. (Molecule(x) & InGas(x) -> MovesFaster(x))", "all x. (MoleculeInGas(x) -> WillMoveFaster(x))", "all x. (MoleculeInGas(x) -> MovesFaster(x))"]}
{"id": "entailmentbank_validation_850", "nl": "comparing a property of two objects requires knowing the property of each object.", "fol": "", "prediction": ["all x, y, p. ((Object(x) & Object(y) & Property(p) & ComparingProperty(x, y, p)) -> (KnowsProperty(x, p) & KnowsProperty(y, p)))", "all x, y, p. (ComparingProperty(x, y, p) -> (KnowsProperty(x, p) & KnowsProperty(y, p)))", "all x, y, p. ((IsPropertyOf(p, x) & IsPropertyOf(p, y)) -> RequiresKnowing(CompareProperty(x, y, p), x) & RequiresKnowing(CompareProperty(x, y, p), y))", "all x, y, p. (ComparingProperty(x, y, p) -> (KnownProperty(x, p) & KnownProperty(y, p)))", "all x, y, p. ((Object(x) & Object(y) & PropertyOf(x, p) & PropertyOf(y, p)) -> CanCompareProperty(x, y, p))", "all x y p. (Property(x, p) & Property(y, p) -> CanCompareProperty(x, y, p))", "all x y p. ((Object(x) & Object(y) & Property(p) & ComparingPropertyOf(x, y, p)) -> (KnowsPropertyOf(x, p) & KnowsPropertyOf(y, p)))", "all x y z. ((Object(x) & Object(y) & Property(z) & Compares(PropertyOf(x, z), PropertyOf(y, z))) -> (Knows(PropertyOf(x, z)) & Knows(PropertyOf(y, z))))", "all x, y, p. (Property(p, x) & Property(p, y) -> CanCompareProperty(x, y, p))", "all x, y, p. ((Object(x) & Object(y) & Property(p, x) & Property(p, y)) -> Requires(KnowProperty(p, x) & KnowProperty(p, y), CompareProperty(p, x, y)))", "all x, y, p. (ComparingProperty(x, y, p) -> (KnowsProperty(x, p) & KnowsProperty(y, p)))", "all x y p. ((PropertyOf(x, p) & PropertyOf(y, p)) -> RequiresKnowledge(PropertyOf(x, p)) & RequiresKnowledge(PropertyOf(y, p)) -> Requires(Comparison(x, y, p)))", "all x, y, p. ((Object(x) & Object(y) & Property(p)) -> (ComparingProperty(x, y, p) -> (KnowsProperty(x, p) & KnowsProperty(y, p))))", "all x, y, p. ((Object(x) & Object(y) & Property(p)) -> (ComparingProperty(x, y, p) -> (KnowsProperty(x, p) & KnowsProperty(y, p))))", "all x, y, p. (Property(p, x) & Property(p, y) -> Requires(Know(Property(p, x))) & Requires(Know(Property(p, y))))", "exists p, q, r, s. all x, y. (PropertyOf(x, p) & PropertyOf(y, q) & ComparingRequires(x, y, r, s) -> (Known(p) & Known(q)))"]}
{"id": "entailmentbank_validation_851", "nl": "a rock is a kind of object.", "fol": "", "prediction": ["Rock(x) -> Object(x)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Object(rock)", "Rock(rock) & Object(rock)", "Object(rock)"]}
{"id": "entailmentbank_validation_852", "nl": "mass is a property of objects / matter.", "fol": "", "prediction": ["all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. (ObjectOrMatter(x) -> HasProperty(x, mass))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(mass, x))", "all x. (Object(x) -> PropertyOf(mass, x)) & all y. (Matter(y) -> PropertyOf(mass, y))", "all x. ((Object(x) | Matter(x)) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))", "all x. (Object(x) | Matter(x) -> HasProperty(x, mass))"]}
{"id": "entailmentbank_validation_853", "nl": "comparing the mass of two rocks requires knowing the mass of each rock.", "fol": "", "prediction": ["all x all y. ((Rock(x) & Rock(y) & x != y) -> (KnowMass(x) & KnowMass(y) -> CanCompareMass(x, y)))", "all x y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowsMass(x) & KnowsMass(y))))", "all x y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x, y. ((Rock(x) & Rock(y) & x != y) -> (ComparingMass(x, y) -> (KnowsMass(x) & KnowsMass(y))))", "all x, y. ((Rock(x) & Rock(y) & x != y) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x y. (Rock(x) & Rock(y) -> (RequiresComparingMass(x, y) -> (KnownMass(x) & KnownMass(y))))", "all x, y. (Rock(x) & Rock(y) & ComparingMasses(x, y) -> (KnowsMass(x) & KnowsMass(y)))", "all x y. ((Rock(x) & Rock(y)) -> (RequiresComparing(MassOf(x), MassOf(y)) <-> (KnowMass(MassOf(x)) & KnowMass(MassOf(y)))))", "all x y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x, y. (Rock(x) & Rock(y) & x != y -> (Requires(KnowMass(x)) & Requires(KnowMass(y)) -> CanCompareMass(x, y)))", "all x y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x, y. ((Rock(x) & Rock(y)) -> (ComparingMass(x, y) -> (KnowsMass(x) & KnowsMass(y))))", "all x, y. (Rock(x) & Rock(y) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x y. (Rock(x) & Rock(y) & x != y -> (RequiresComparingMasses(x, y) -> (KnowsMass(x) & KnowsMass(y))))", "all x, y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))", "all x, y. ((Rock(x) & Rock(y)) -> (CompareMass(x, y) -> (KnowMass(x) & KnowMass(y))))"]}
{"id": "entailmentbank_validation_854", "nl": "student is trying to compare the mass of two small rocks.", "fol": "", "prediction": ["exists x, y, z. (Student(x) & SmallRock(y) & SmallRock(z) & TryingToCompareMass(x, y, z))", "exists x, y. (Student(x) & SmallRock(y) & SmallRock(z) & TryingToCompareMass(x, y, z))", "exists x, y, z. (Student(z) & Rock(x) & Small(x) & Rock(y) & Small(y) & TriesToCompareMass(z, x, y))", "FOL Translation:\nexists x, y, z. (Student(x) & SmallRock(y) & SmallRock(z) & ComparingMass(x, y, z))", "exists x exists y. (Student(student) & SmallRock(x) & SmallRock(y) & TryingToCompareMass(student, x, y))", "exists s, r1, r2. (Student(s) & SmallRock(r1) & SmallRock(r2) & TriesToCompareMass(s, r1, r2))", "exists x, y, z. (Student(x) & TryingToCompareMass(x, y, z) & SmallRock(y) & SmallRock(z))", "exists y exists z. (SmallRock(y) & SmallRock(z) & TryingToCompareMass(student, y, z))", "exists x exists y. (StudentTryingCompareMass(x, y) & SmallRock(x) & SmallRock(y))", "exists x, y. (Student(student) & SmallRock(x) & SmallRock(y) & TriesToCompareMass(student, x, y))", "FOL Translation:\nexists x exists y. (Student(student) & Rock(x) & Small(x) & Rock(y) & Small(y) & TriesToCompareMass(student, x, y))", "exists x, y, z. (Student(x) & Rock(y) & Small(y) & Rock(z) & Small(z) & CompareMass(x, y, z))", "exists x exists y. (Student(x) & Rock(y) & Small(y) & Rock(z) & Small(z) & CompareMass(x, y, z))", "exists x exists y. (Student(z) & Rock(x) & Small(x) & Rock(y) & Small(y) & TryingToCompareMass(z, x, y))", "exists x, y, z. (Student(x) & Rock(y) & Rock(z) & Small(y) & Small(z) & TryingToCompareMass(x, y, z))", "Assuming that the context is about a specific student and objects being rocks:\n\nFOL Translation:\nexists x, y. (Student(student) & SmallRock(x) & SmallRock(y) & TriesToCompareMass(student, x, y))"]}
{"id": "entailmentbank_validation_855", "nl": "the student has to know the mass of each rock to compare them.", "fol": "", "prediction": ["exists s. (Student(s) -> all r. (Rock(r) -> KnowsMass(s, r) & CanCompare(s, r)))", "all x. (Rock(x) -> all y. (Student(y) -> (HasToKnowMass(y, x) -> CanCompare(y, x))))", "all x. (Rock(x) -> exists y. (Student(y) & HasToKnowMassOf(y, x) & CanCompare(y, x)))", "all x. (Rock(x) -> KnowsMass(student, x) & CanCompare(student, x))", "exists x. (Student(x) & all y. (Rock(y) -> KnowsMassOf(x, y) & CanCompareRocks(x)))", "all x. (Rock(x) -> KnowMass(student, x) & Compare(student, x))", "all x. (Rock(x) -> exists y. (Student(y) & HasToKnowMass(y, x) & all z. (Rock(z) -> CanCompare(y, x, z))))", "all x. (Rock(x) -> (exists y. (Student(y) & HasToKnowMass(y, x))))", "all x. (Rock(x) -> (exists y. (Student(y) & HasToKnowMass(y, x) & Compare(y, x))))", "all x. (Rock(x) -> (Student(y) & HasToKnowMass(y, x) -> CanCompareRocks(y)))", "exists x. (Student(x) & all y. (Rock(y) -> HasToKnowMass(x, y) & all z. (Rock(z) & Compare(x, y, z))))", "all x. (Rock(x) -> KnowsMass(student, x)) & CanCompare(student, all x)", "all x. (Rock(x) -> NeedsToKnowMass(student, x))", "all r. (Rock(r) -> exists s. (Student(s) & KnowsMass(s, r) & HasToCompare(s, r)))", "exists x. (Student(x) & all y. (Rock(y) -> KnowsMassOf(x, y)) & CanCompare(x, y))", "all x. (Rock(x) -> KnowMass(student, x) -> Compare(student, x))"]}
{"id": "entailmentbank_validation_856", "nl": "a balance is used for measuring mass / weight of an object / of a substance.", "fol": "", "prediction": ["exists x, y. (Balance(x) & UsedFor(x, MeasureMassOrWeight(y)) & (Object(y) | Substance(y)))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOrWeight) & exists y. (Object(y) | Substance(y)))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOrWeightOfObjectOrSubstance))", "exists x. (Balance(x) -> UsedForMeasuring(x, mass_weight(y)) & (Object(y) | Substance(y)))", "exists x. (Balance(x) & usedFor(x, Measuring(Mass(object)) | Measuring(Weight(object)) | Measuring(Mass(substance)) | Measuring(Weight(substance))))", "exists x. (Balance(x) & UsedFor(x, MeasuringMass) & UsedFor(x, MeasuringWeight))", "all x. (Balance(x) -> (UsedFor(x, Measuring(mass/weight, y)) & Object(y)))", "exists x, y. (Balance(x) & (Object(y) | Substance(y)) & UsedForMeasuringMassOrWeight(x, y))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOrWeight(y) & Of(y, z)))", "exists x. (Balance(x) & UsedFor(x, Measuring(MassOrWeight(y))) & (Object(y) | Substance(y)))", "exists x. (Balance(x) -> UsedFor(x, MeasuringMass) & UsedFor(x, MeasuringWeight))", "exists x. (Balance(x) & all y. (Object(y) | Substance(y) -> UsedForMeasuringMassOrWeight(x, y)))", "all x. (Balance(x) -> UsedFor(x, MeasuringMass) | UsedFor(x, MeasuringWeight) | UsedFor(x, MeasuringObject) | UsedFor(x, MeasuringSubstance))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassWeight))", "exists x. (Balance(x) & forall y. (Object(y) | Substance(y) -> UsedForMeasuring(x, MassOrWeight(y))))", "exists x. (Balance(x) & (UsedFor(x, MeasuringMass) | UsedFor(x, MeasuringWeightOfObject) | UsedFor(x, MeasuringWeightOfSubstance)))"]}
{"id": "entailmentbank_validation_857", "nl": "a balance is a kind of instrument.", "fol": "", "prediction": ["all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))", "all x. (Balance(x) -> Instrument(x))"]}
{"id": "entailmentbank_validation_858", "nl": "the student can use balance to know the mass of each rock to compare them.", "fol": "", "prediction": ["exists x. (Student(x) -> uses_balance(x) & all y. (Rock(y) -> knows_mass_of(x, y) & can_compare(x, y)))", "exists x. (Student(x) & exists b. (Balance(b) & CanUse(x, b) & all y. (Rock(y) -> KnowMassOf(x, y)) & CompareRocks(x)))", "exists x. (Student(x) & exists y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> KnowsMassOf(x, z)) & CanCompareMasses(x, z)))", "exists x. (Student(x) -> exists y. (Balance(y) & CanUse(x, y) & forall z. (Rock(z) -> (KnowMassOf(x, z) & CompareMass(x, z)))))", "exists x, y, z. (Student(x) & Rock(y) & Rock(z) & KnowsMass(x, y) & KnowsMass(x, z) & UsesBalance(x, y) & UsesBalance(x, z) & Compares(x, y, z))", "exists x, y. (Student(x) & Balance(y) -> CanUseToKnowMass(x, y) & all z. (Rock(z) -> CanCompare(x, z)))", "exists x. (Student(x) & CanUseBalance(x) & all y. (Rock(y) -> exists z. (Mass(y, z) & CanCompare(x, y))))", "exists x. (Student(x) -> exists y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> exists w. (Mass(w, z) & Know(x, w) & Compare(x, z)))))", "exists x. (Student(x) & exists y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> (KnowsMass(x, z) & CompareMass(x, z)))))", "exists x. (Student(x) & exists y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> (KnowsMass(x, z) & CanCompareMass(x, z)))))", "exists s. (Student(s) & exists b. (Balance(b) -> all r. (Rock(r) -> CanUseToKnowMass(s, b, r) & CanCompareMass(s, r))))", "exists y. (Student(y) & CanUseBalance(y) & all z. (Rock(z) -> (exists m. (Mass(z, m) & CanKnowMass(y, z, m)) & CanCompareRocks(y, z))))", "exist x. (Student(x) & exist y. (Balance(y) & CanUse(x, y) & all z. (Rock(z) -> exist m. (MassOf(z, m) & KnowsMass(x, z, m)))) & all a, b. (Rock(a) & Rock(b) & KnowsMass(x, a, ma) & KnowsMass(x, b, mb) -> CanCompare(x, a, b)))", "all x. (Rock(x) -> (exists y. (Student(y) & CanUseBalance(y, x))) & KnowsMassOf(y, x) & CanCompareWithEachOther(y, x))", "exists x. (Student(x) & exists y. (Balance(y) & CanUse(x, y) & forall z. (Rock(z) -> KnowsMass(x, z) & CompareMass(x, z))))", "exists s, b, r1, r2. (Student(s) & Balance(b) & Rock(r1) & Rock(r2) & CanUse(s, b) & KnowMass(s, r1) & KnowMass(s, r2) & CompareMass(s, r1, r2))"]}
{"id": "entailmentbank_validation_859", "nl": "a balance is used for measuring mass of a substance.", "fol": "", "prediction": ["exists x. (Balance(x) & UsedFor(x, MeasuringMass(y)) & Substance(y))", "exists x. (Balance(x) & UsedForMeasuringMass(x, y) & Substance(y))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOfSubstance))", "exists y. (Balance(y) & UsedForMeasuringMass(y) & Substance(y))", "exists x. (Balance(x) -> UsedFor(x, MeasuringMassOf(substance)))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOf(substance)))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOfSubstance))", "exists x. (Balance(x) -> UsedForMeasuringMassOfSubstance(x))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOfSubstance))", "exists x. (Balance(x) & UsedFor(x, MeasureMass(substance)))", "exists x. (Balance(x) & UsedForMeasuring(x, MassOf(substance)))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOfSubstance))", "Using(x, balance, all y. (Substance(y) -> CanMeasureMass(balance, y)))", "FOL Translation:\nall x. (Balance(x) -> UsedForMeasuringMassOfSubstance(x))", "exists x. (Balance(x) & UsedFor(x, MeasuringMassOfSubstance))", "exists x. (Balance(x) -> UsedForMeasuringMass(x, substance))"]}
{"id": "entailmentbank_validation_860", "nl": "sand is a kind of substance.", "fol": "", "prediction": ["Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)", "Substance(sand)"]}
{"id": "entailmentbank_validation_861", "nl": "a balance can be used for measure the mass of sand.", "fol": "", "prediction": ["all x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) & UsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedForMeasuringMassOf(x, sand))", "exists x. (Balance(x) & exists y. (Mass(y) & Sand(y) & CanBeUsedForMeasure(x, y)))", "exists x. (Balance(x) & CanBeUsedFor(x, Measuring(TheMassOf(sand))))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "all x. ((Balance(x) & Sand(y)) -> CanMeasureMassOf(x, y))", "exists x. (Balance(x) & CanBeUsedFor(x, Measure(y, Mass(sand))))", "exists y. (Balance(y) -> CanBeUsedFor(y, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))", "exists x. (Balance(x) -> CanBeUsedToMeasureMassOf(x, sand))", "exists x. (Balance(x) -> CanBeUsedFor(x, Measure(sand_mass)))", "exists x. (Balance(x) -> CanBeUsedFor(x, MeasureMass(sand)))"]}
{"id": "entailmentbank_validation_862", "nl": "determining something often requires measuring that something.", "fol": "", "prediction": ["all x. (Thing(x) -> (Determining(x) -> Requires(Measuring(x))))", "all x. (Determining(x) -> Requires(Measuring(x)))", "all x. (Determining(x) -> Requires(Measuring(x)))", "all x. (Determining(x) -> OftenRequires(Measuring(x)))", "all x. (Determining(x) -> OftenRequires(Measuring(x)))", "all x. (Thing(x) -> (Determining(x) -> RequiresMeasuring(x)))", "all x. (Determining(x) -> OftenRequires(Measuring(x)))", "all x. (Determining(x) -> (exists y. (Measure(y) & Requires(y, x))))", "all x. (Thing(x) -> (Determining(x) -> Requires(Determining(x), Measuring(x))))", "all x. (Determines(x) -> exists y. (Requires(x, y) & Measures(y, x)))", "all x. (Determining(x) -> Requires(Measuring(x)))", "all x. (Determining(x) -> (exists y. (OftenRequires(y) & Measuring(y) & y = x)))", "all x. (Determining(x) -> Often(Requires(Measuring(x))))", "all x. (Determining(x) -> Requires(Measuring(x)))", "all x. (Determining(x) -> (exists y. (Measuring(x, y) & Required(y, x))))", "all x. (Thing(x) -> (Determining(x) -> Requires(Determining(x), Measuring(x))))"]}
{"id": "entailmentbank_validation_863", "nl": "determining the mass of the sand requires using a balance to measure the mass of the sand.", "fol": "", "prediction": ["Requires(DetermineMass(sand), UseBalanceToMeasureMass(sand))", "Requires(DetermineMass(sand), Use(balance, MeasureMass(sand)))", "Requires(DetermineMass(sand), UseBalanceToMeasureMass(sand))", "all x. (MassOf(x) & Sand(x) -> Requires(Determine(x), UseBalanceToMeasure(x)))", "all x. (Sand(x) -> (Requires(DetermineMass(x), UseBalanceToMeasureMass(x))))", "all x. (Sand(x) -> (DeterminingMass(x) -> Requires(UsingBalanceToMeasureMass(x), DeterminingMass(x))))", "Requires(DetermineMass(sand), Use(balance, MeasureMass(sand)))", "DetermineMass(sand) -> Requires(UseBalanceToMeasureMass(sand))", "all x. (DeterminingMassOf(x, sand) -> RequiresUsing(x, balance, MeasureMassOf(sand)))", "Requires(DetermineMassOf(sand), UseBalanceToMeasureMass(sand))", "all x. (Sand(x) -> (DetermineMass(x) -> UseBalance(y) & MeasureMass(y, x)))", "Requires(DeterminingMass(sand), UsingBalanceToMeasureMass(sand))", "Requires(DetermineMass(sand), UseBalanceToMeasureMass(sand))", "all x. (Sand(x) -> Requires(DeterminingMass(x), exists y. (Balance(y) & Use(y, MeasureMass(x)))))", "all x. (DeterminingMass(x) & Sand(x) -> Requires(UseBalanceToMeasureMass(x)))", "Requires(DetermineMassOf(sand), Use(balance) & MeasureMassOf(sand, balance))"]}
{"id": "entailmentbank_validation_864", "nl": "a balance is used for measuring the mass of an object.", "fol": "", "prediction": ["all x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMassOf(x, y)))", "exists x, y. (Balance(x) & Object(y) -> UsedForMeasuringMass(x, y))", "all x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "exists x. (Balance(x) & all y. (Object(y) -> UsedFor(x, MeasuringMassOf(y))))", "all x. (Balance(x) -> exists y. (Object(y) & UsesForMeasuringMass(x, y)))", "exists x. (Balance(x) & usedFor(x, y) & MeasuringMass(y) & Object(y))", "FOL Translation:\nall x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "exists x y. (Balance(x) & Object(y) & UsedFor(x, MeasureMass(y)))", "all x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "all x. (Balance(x) -> exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "exists x. exists y. (Balance(x) & Object(y) & UsedFor(x, MeasureMass(y)))", "exists x. (Balance(x) & exists y. (Object(y) & UsedForMeasuringMass(x, y)))", "exists x. (Balance(x) -> UsedFor(x, y) & Measuring(y, z) & Mass(z) & Object(z))", "exists x. (Balance(x) & all y. (Object(y) -> UsedForMeasuringMass(x, y)))", "exists x. (Balance(x) & exists y. (Object(y) & UsedFor(x, MeasuringMass(y))))", "exists x. (Balance(x) & all y. (Object(y) -> UsedForMeasuringMass(x, y)))"]}
{"id": "entailmentbank_validation_865", "nl": "density can be calculated by measuring the mass of an object divided by the volume of that object.", "fol": "", "prediction": ["all x. (Object(x) -> CanCalculateDensityBy(Measuring(Mass(x) / Volume(x))))", "all x. (Object(x) -> (DensityCanBeCalculated(x) <-> exists m v. (MassOf(x, m) & VolumeOf(x, v) & DensityFormula(x, m, v))))", "all x, y, z. ((Object(x) & Mass(y, x) & Volume(z, x)) -> (DensityCanBeCalculated(x) <-> Divide(y, z)))", "all x. (Object(x) -> exists y exists z. (Mass(x, y) & Volume(x, z) & CalculatedDensity(x, y, z)))", "all x. ((Object(x) & Mass(x, m) & Volume(x, v)) -> CanCalculateDensity(x, m/v))", "all x. (Object(x) -> (MeasureMass(x) & MeasureVolume(x) -> CanCalculateDensity(x)))", "all x. (Object(x) -> CanCalculateDensity(x, MeasureMass(x) / MeasureVolume(x)))", "all x. (Object(x) -> (Density(x) = Calculate(Mass(x) / Volume(x))))", "all x. (Object(x) -> CanCalculateDensity(x) <-> (exists m, v. (Mass(m, x) & Volume(v, x) & Divide(m, v, d))))", "all x. (Object(x) -> (DensityCanBeCalculated(x) <-> (Measures(Mass(x)) & Measures(Volume(x)) & Divides(Mass(x), Volume(x)))))", "all x. (Object(x) -> CanCalculateDensityBy(x))", "all x. (Object(x) -> (Density(x) = CalculateBy(Measuring(Mass(x)/Volume(x)))))", "all x. (Object(x) -> CanCalculateDensity(x) <-> (MeasureMass(x) & MeasureVolume(x)))", "all x. (Object(x) -> (DensityCanBeCalculated(x) <-> exists m, v. (Mass(x, m) & Volume(x, v) & DensityFormula(m, v))))", "all x. (Object(x) -> CanCalculateDensity(x, Measure(Mass(x), Volume(x))))", "all x. (Object(x) -> exists d. (Density(x, d) & CanBeCalculated(d, Measure(Mass(x), Volume(x)))))"]}
{"id": "entailmentbank_validation_866", "nl": "a graduated cylinder is used to measure volume of an object.", "fol": "", "prediction": ["exists x. (GraduatedCylinder(x) -> UsedToMeasureVolumeOf(x, y))", "all x. ((GraduatedCylinder(x) & Object(y)) -> UsedToMeasureVolumeOf(x, y))", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolume(x, object))", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolume(x, Object(y)))", "exists x. (GraduatedCylinder(x) & all y. (Object(y) -> UsedToMeasureVolume(x, y)))", "exists y. (GraduatedCylinder(y) -> UsedToMeasureVolume(y, z) & Object(z))", "exists x. (GraduatedCylinder(x) -> UsedFor(x, MeasuringVolumeOfObject))", "all x. (GraduatedCylinder(x) -> UsedToMeasureVolumeOf(x, object))", "exists x, y. (GraduatedCylinder(x) & Object(y) -> UsedToMeasureVolume(x, y))", "exists x. (GraduatedCylinder(x) -> UsedToMeasure(x, VolumeOf(y)))", "exists x. (GraduatedCylinder(x) -> UsedToMeasure(x, y) & VolumeOf(y, z) & Object(z))", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolumeOfObject(x))", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolume(x, y)) & exists y. Object(y)", "exists x. (GraduatedCylinder(x) -> UsedToMeasureVolumeOf(x, y) & Object(y))", "exists x. (GraduatedCylinder(x) & all y. (Object(y) -> UsedToMeasureVolume(x, y)))", "all x. (GraduatedCylinder(x) -> exists y. (Object(y) & UsedToMeasure(x, Volume(y))))"]}
{"id": "entailmentbank_validation_867", "nl": "the density of an object can be measured using a graduated cylinder and a balance.", "fol": "", "prediction": ["all x. (Object(x) -> CanMeasureDensityUsingGraduatedCylinderAndBalance(x))", "all x. (Object(x) -> CanMeasureDensityWith(x, graduated_cylinder, balance))", "all x. (Object(x) -> (exists y. (GraduatedCylinder(y) & HasMeasureTool(y)) & exists z. (Balance(z) & HasMeasureTool(z)) -> CanMeasureDensity(x)))", "all x. (Object(x) -> CanMeasureDensityUsing(x, graduated_cylinder, balance))", "all x. (Object(x) -> exists y z. (GraduatedCylinder(y) & Balance(z) & CanMeasureDensityUsing(x, y, z)))", "all x. (Object(x) -> CanMeasureDensityUsing(x, graduated_cylinder) & CanMeasureDensityUsing(x, balance))", "all x. (Object(x) -> CanMeasureDensityUsingGraduatedCylinderAndBalance(x))", "all x. (Object(x) -> CanMeasureDensity(x, graduated_cylinder, balance))", "all x. (Object(x) -> CanMeasureDensity(x, graduated_cylinder) & CanMeasureDensity(x, balance))", "all x. (Object(x) -> exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensityUsing(x, y, z))))", "all x. (Object(x) -> CanMeasureDensityUsing(x, graduated_cylinder) & CanMeasureDensityUsing(x, balance))", "all x. (Object(x) -> CanMeasureDensityUsingGraduatedCylinderAndBalance(x))", "all x. (Object(x) -> CanMeasureDensityWith(x, graduated_cylinder, balance))", "all x. (Object(x) -> (exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanBeMeasuredDensityUsing(x, y, z)))))", "all x. (Object(x) -> CanMeasureDensityUsing(x, graduated_cylinder) & CanMeasureDensityUsing(x, balance))", "all x. (Object(x) -> CanMeasureDensity(x, graduated_cylinder, balance))"]}
{"id": "entailmentbank_validation_868", "nl": "a marble is a kind of object.", "fol": "", "prediction": ["Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)", "Object(marble)"]}
{"id": "entailmentbank_validation_869", "nl": "the density of a marble can be measured using a graduated cylinder and a balance.", "fol": "", "prediction": ["exists x. (Marble(x) -> CanMeasureDensity(x, GraduatedCylinder) & CanMeasureDensity(x, Balance))", "exists x. (Marble(x) -> (exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z)))))", "exists x. (Marble(x) & exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensityUsing(x, y, z))))", "exists x. (Marble(x) -> (MeasureDensity(x) <-> (UsingGraduatedCylinder(x) & UsingBalance(x))))", "exists x. (Marble(x) -> exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x. (Marble(x) -> exists y. exists z. (GraduatedCylinder(y) & Balance(z) & CanMeasureDensity(x, y, z)))", "exists x. (Marble(x) -> exists y. exists z. (GraduatedCylinder(y) & Balance(z) & CanMeasureDensityWith(x, y, z)))", "exists x. (Marble(x) & exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x. (Marble(x) -> CanBeMeasuredUsing(x, graduated_cylinder) & CanBeMeasuredUsing(x, balance))", "exists x. (Marble(x) -> (exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z)))))", "exists x. (Marble(x) -> exists y exists z. (GraduatedCylinder(y) & Balance(z) & CanMeasureDensity(x, y, z)))", "exists x. (Marble(x) -> exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensityWith(x, y, z))))", "exists x. (Marble(x) -> (exists y. (GraduatedCylinder(y)) & exists z. (Balance(z))) & CanMeasureDensity(x, y, z))", "exists x. (Marble(x) & exists y. (GraduatedCylinder(y) & exists z. (Balance(z) & CanMeasureDensity(x, y, z))))", "exists x y z. (Marble(x) & DensityOf(x, y) & GraduatedCylinder(z) & Balance(z) -> CanBeMeasuredUsing(y, z))", "exists x. (Marble(x) -> CanBeMeasuredUsing(x, graduadedCylinder) & CanBeMeasuredUsing(x, balance))"]}
{"id": "entailmentbank_validation_870", "nl": "if a unit of for something is being measured, then it requires a measurement tool for measuring that something.", "fol": "", "prediction": ["all x. (UnitOfMeasure(x) -> exists y. (MeasurementTool(y) & Requires(y, x)))", "all x all y. (UnitOf(x, y) & BeingMeasured(x) -> exists z. (MeasurementTool(z) & Requires(z, y) & ForMeasuring(z, y)))", "all x all y. (UnitOf(x, y) & BeingMeasured(x) -> exists z. (MeasurementTool(z) & Requires(z, y)))", "all x y. (UnitOf(x, y) -> exists z. (MeasurementTool(z) & RequiresMeasurementTool(y, z)))", "all x. (UnitOfMeasurement(x) -> exists y. (MeasurementTool(y) & RequiresForMeasurement(x, y)))", "all x y. (UnitOfMeasure(x, y) -> exists z. (MeasurementTool(z) & Requires(x, z)))", "all u, s. (UnitOf(s, u) & Measured(s) -> exists t. (MeasurementTool(t) & Requires(s, t)))", "all x y. (UnitOf(x, y) & BeingMeasured(y) -> RequiresMeasurementTool(x, y))", "all x y. (UnitOf(x, y) -> exists z. (MeasurementTool(z) & RequiresFor(z, y)))", "all x y. (UnitOf(x, y) & Measured(y) -> exists z. (MeasurementTool(z) & RequiresMeasurementTool(y, z)))", "all x y. (UnitOf(x, y) & BeingMeasured(x) -> exists z. (MeasurementTool(z) & RequiresFor(z, y)))", "all x y. (MeasuresUnit(x, y) -> exists z. (MeasurementTool(z) & RequiresMeasurementTool(y, z)))", "all u. (UnitOf(u, s) & BeingMeasured(s) -> exists t. (MeasurementTool(t) & Requires(s, t)))", "all x. all y. (UnitOfMeasurementFor(x, y) -> RequiresMeasurementTool(x, y))", "all x. (UnitOf(y, x) & BeingMeasured(y) -> exists z. (MeasurementTool(z) & RequiresForMeasuring(z, y)))", "all x y. ((Unit(x) & Measures(x, y)) -> exists z. (MeasurementTool(z) & Requires(x, z) & ForMeasuring(z, y)))"]}
{"id": "entailmentbank_validation_871", "nl": "milliliters ml are a metric unit used for measuring volume.", "fol": "", "prediction": ["all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, Volume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedForMeasuringVolume(x)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedForMeasuring(x, volume)))", "all x. (Milliliter(x) -> MetricUnit(x) & UsedFor(Measuring(x, Volume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, MeasuringVolume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedForMeasuring(x, volume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedForMeasuring(x, Volume)))", "all z. (Milliliter(z) -> MetricUnit(z) & UsedFor(z, MeasuringVolume))", "all x. (Milliliter(x) -> MetricUnit(x) & UsedFor(MeasuringVolume, x))", "all x. (Milliliter(x) -> MetricUnit(x) & UsedFor(x, MeasuringVolume))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, volume)))", "all x. (Milliliter(x) -> MetricUnit(x) & UsedFor(x, Volume))", "all x. (Milliliter(x) -> MetricUnit(x) & UsedForMeasuring(x, volume))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedForMeasuring(x, volume)))", "all x. (Milliliter(x) -> (MetricUnit(x) & UsedFor(x, MeasuringVolume)))", "all x. (Milliliters(x) -> (MetricUnit(x) & UsedForMeasuringVolume(x)))"]}
{"id": "entailmentbank_validation_872", "nl": "measuring milliliters requires a tool for measuring volume.", "fol": "", "prediction": ["all x. (Measuring(x, milliliters) -> exists y. (Tool(y) & MeasuresVolume(y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasureMilliliters(x) -> exists y. (Tool(y) & MeasuresVolume(y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (Tool(y) & MeasuresVolume(y)))", "all x. (Measuring(x, milliliters) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuresMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (Milliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (Milliliter(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (Tool(y) & ForMeasuringVolume(y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForVolumeMeasurement(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (ToolForMeasuringVolume(y) & Requires(x, y)))", "all x. (MeasuringMilliliters(x) -> exists y. (Tool(y) & ForMeasuringVolume(y)))"]}
{"id": "entailmentbank_validation_873", "nl": "measuring milliliters requires a graduated cylinder.", "fol": "", "prediction": ["all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuresInMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuresInMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, GraduatedCylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, GraduatedCylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, GraduatedCylinder))", "all x. (MeasuresInMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))", "all x. (MeasuringMilliliters(x) -> Requires(x, graduated_cylinder))"]}
{"id": "entailmentbank_validation_874", "nl": "a sample in a cylindrical container has a cylindrical shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & LocatedIn(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & InCylindricalContainer(x) -> (CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y))) & CylindricalShape(x) & FixedVolume(x)", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(y, x) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y))) & CylindricalShape(x) & FixedVolume(x)", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y))) & CylindricalShape(x) & FixedVolume(x)", "exists x. (Sample(x) & Exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & InContainer(x, cylindrical) & HasShape(x, cylindrical) & HasFixedVolume(x))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & Contains(y, x) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & InContainer(x, y) & Cylindrical(y) & CylindricalShape(x) & FixedVolume(x))", "exists x. (Sample(x) & InContainer(x, cylindrical) & HasShape(x, cylindrical) & HasFixedVolume(x))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))", "exists x. (Sample(x) & exists y. (CylindricalContainer(y) & In(x, y) & CylindricalShape(x) & FixedVolume(x)))"]}
{"id": "entailmentbank_validation_875", "nl": "a sample is a kind of matter.", "fol": "", "prediction": ["Matter(sample)", "Sample(x) -> Matter(x)", "all x. (Sample(x) -> Matter(x))", "Matter(sample)", "KindOf(sample, matter)", "all x. (Sample(x) -> Matter(x))", "Matter(sample)", "Matter(sample)", "Matter(sample)", "Matter(sample)", "Matter(sample)", "KindOf(sample, matter)", "Matter(sample)", "Matter(sample)", "Matter(sample)", "all x. (Sample(x) -> Matter(x))"]}
{"id": "entailmentbank_validation_876", "nl": "the matter has the same shape as the container and fixed volume.", "fol": "", "prediction": ["Matter(m) & Container(c) & HasSameShapeAs(m, c) & FixedVolume(m)", "exists x. (Matter(x) & exists y. (Container(y) & HasSameShapeAs(x, y) & FixedVolume(x)))", "Matter(m) & Container(c) & SameShape(m, c) & FixedVolume(m)", "Exists x, y. (Matter(x) & Container(y) & SameShape(x, y) & FixedVolume(x))", "Matter(m) & Container(c) & SameShape(m, c) & FixedVolume(m)", "Exists x. (Matter(x) & Exists y. (Container(y) & SameShape(x, y) & HasFixedVolume(x)))", "exists x. (Matter(x) & exists y. (Container(y) & SameShape(x, y) & FixedVolume(x)))", "Exists x. (Matter(x) & Exists y. (Container(y) & SameShapeAs(x, y) & FixedVolume(x)))", "same_shape_as(matter, container) & fixed_volume(matter)", "Exists x. (Matter(x) & exists y. (Container(y) & SameShapeAs(x, y) & FixedVolume(x)))", "exists x. (Matter(x) & exists y. (Container(y) & SameShapeAs(x, y) & FixedVolume(x)))", "Matter(m) & Container(c) & HasShape(m, c) & FixedVolume(m)", "Exists x. (Matter(x) & exists y. (Container(y) & SameShape(x, y) & FixedVolume(x)))", "Matter(the_matter) & Container(the_container) & SameShape(the_matter, the_container) & FixedVolume(the_matter)", "Exists x. (Matter(x) & HasSameShapeAsContainer(x) & HasFixedVolume(x))", "Exists x. (Matter(x) & hasSameShapeAsContainer(x) & FixedVolume(x))"]}
{"id": "entailmentbank_validation_877", "nl": "matter with variable shape changes shape in different container.", "fol": "", "prediction": ["all x. ((Matter(x) & VariableShape(x)) -> (exists y exists z. (Container(y) & Container(z) & Different(y, z) & ChangesShapeIn(x, y) & ChangesShapeIn(x, z) & DifferentShapeIn(x, y, z))))", "all x. (Matter(x) & VariableShape(x) -> (exists y. Container(y) & ChangesShape(x, y)))", "all x. ((Matter(x) & VariableShape(x)) -> exists y exists z. (Container(y) & Container(z) & Different(y, z) & ChangesShapeIn(x, y) & ChangesShapeIn(x, z) & Different(y, z)))", "all x. (Matter(x) & VariableShape(x) -> all y. (Container(y) -> ChangesShapeInDifferentContainer(x, y)))", "FOL Translation:\nall x. ((Matter(x) & VariableShape(x)) -> all y. all z. ((Container(y) & Container(z) & y \u2260 z) -> ChangesShape(x, y, z)))", "all x. ((Matter(x) & VariableShape(x)) -> ChangesShapeInDifferentContainer(x))", "FOL Translation:\nall x. ((Matter(x) & VariableShape(x)) -> all y z. (Container(y) & Container(z) & y \u2260 z -> ChangesShapeIn(x, y, z)))", "all x. (Matter(x) & VariableShape(x) -> all y z. (DifferentContainer(y, z) & Contains(y, x) -> ChangesShape(x, z)))", "all x. (Matter(x) & VariableShape(x) -> (forall y. (Container(y) -> ExistsDifferentContainer(y, x)) -> ShapeChanges(x, y)))", "all x. (Matter(x) & VariableShape(x) -> all y. (Container(y) -> ChangesShapeIn(x, y)))", "all x. ((Matter(x) & VariableShape(x)) -> (exists y. (Container(y) & ChangesShapeIn(x, y))))", "all x. (Matter(x) & VariableShape(x) -> ForDifferentContainers(x, y) -> ChangesShapeIn(x, y))", "FOL Translation:\nall x. ((Matter(x) & VariableShape(x)) -> (all y. (Container(y) & In(x, y) -> ChangesShape(x, y))))", "all x. ((Matter(x) & VariableShape(x)) -> all y. (Container(y) -> ChangesShapeIn(x, y)))", "all x. (Matter(x) & VariableShape(x) -> all y. all z. (Container(y) & Container(z) & Different(y, z) -> ChangesShapeIn(x, y, z)))", "all x. ((Matter(x) & VariableShape(x)) -> all y. all z. (Container(y) & Container(z) & Different(y, z) -> ChangesShapeIn(x, y, z)))"]}
{"id": "entailmentbank_validation_878", "nl": "the matter may have a variable shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & VariableShape(x) & FixedVolume(x))", "exists x. (Matter(x) -> (MayHaveVariableShape(x) & HasFixedVolume(x)))", "exists y. (Matter(y) & MayHaveVariableShape(y) & FixedVolume(y))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "FOL Translation:\nMatter(m) -> (HasVariableShape(m) & HasFixedVolume(m))", "exists x. (Matter(x) & MayHaveVariableShape(x) & FixedVolume(x))", "exists x. ((Matter(x) & MayHaveVariableShape(x)) & HasFixedVolume(x))", "exists x. (Matter(x) & VariableShape(x) & FixedVolume(x))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & MaybeHasVariableShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & MayHaveVariableShape(x) & HasFixedVolume(x))", "exists m. (Matter(m) & MayHaveVariableShape(m) & HasFixedVolume(m))", "exists x. (Matter(x) & (VariableShape(x) | FixedVolume(x)))"]}
{"id": "entailmentbank_validation_879", "nl": "the matter may have a fixed shape and a fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & FixedShape(x) & FixedVolume(x))", "There exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "FOL Translation:\nexists x. (Matter(x) & HasFixedShape(x) & HasFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & FixedShape(x) & FixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))", "exists x. (Matter(x) & MayHaveFixedShape(x) & MayHaveFixedVolume(x))"]}
{"id": "entailmentbank_validation_880", "nl": "the matter may have a fixed or variable shape and fixed volume.", "fol": "", "prediction": ["exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))", "exists x. (Matter(x) & ( (FixedShape(x) | VariableShape(x)) & FixedVolume(x) ))", "exists x. ((Matter(x) & (HasShape(x, fixed) | HasShape(x, variable))) & HasVolume(x, fixed))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & (MayHaveFixedShape(x) | MayHaveVariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & ((HasFixedShape(x) | HasVariableShape(x)) & HasFixedVolume(x)))", "exists x. (Matter(x) & ((FixedShape(x) & FixedVolume(x)) | (VariableShape(x) & FixedVolume(x))))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))", "exists x. (Matter(x) -> (FixedShape(x) | VariableShape(x)) & FixedVolume(x))", "exists x. (Matter(x) & ((FixedShape(x) | VariableShape(x)) & FixedVolume(x)))"]}
{"id": "entailmentbank_validation_881", "nl": "matter in the solid phase has definite shape.", "fol": "", "prediction": ["all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. ((Matter(x) & SolidPhase(x)) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all z. (Matter(z) & SolidPhase(z) -> DefiniteShape(z))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteShape(x))", "all x. (Matter(x) & InSolidPhase(x) -> HasDefiniteShape(x))"]}
{"id": "entailmentbank_validation_882", "nl": "matter in the solid phase has definite volume.", "fol": "", "prediction": ["all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. ((Matter(x) & SolidPhase(x)) -> DefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x))", "all x. ((Matter(x) & SolidPhase(x)) -> DefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & InPhase(x, solid) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x))", "all x. (MatterInSolidPhase(x) -> HasDefiniteVolume(x))", "all x. ((Matter(x) & SolidPhase(x)) -> DefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x))", "all x. (MatterInSolidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x))"]}
{"id": "entailmentbank_validation_883", "nl": "matter in solid phase has definite volume and definite shape.", "fol": "", "prediction": ["all x. ((Matter(x) & SolidPhase(x)) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & InSolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & InSolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. ((Matter(x) & SolidPhase(x)) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & SolidPhase(x) -> HasDefiniteVolume(x) & HasDefiniteShape(x))", "all x. ((Matter(x) & SolidPhase(x)) -> (DefiniteVolume(x) & DefiniteShape(x)))", "all x. (Matter(x) & SolidPhase(x) -> DefiniteVolume(x) & DefiniteShape(x))", "all x. (Matter(x) & SolidPhase(x) -> (DefiniteVolume(x) & DefiniteShape(x)))"]}
{"id": "entailmentbank_validation_884", "nl": "matter in the liquid phase has variable shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & InLiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasVariableShape(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasVariableShape(x))", "all m. (Matter(m) & InLiquidPhase(m) -> HasVariableShape(m))", "all x. (Matter(x) & InLiquidPhase(x) -> HasVariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> VariableShape(x))", "all x. (MatterInLiquidPhase(x) -> HasVariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x))"]}
{"id": "entailmentbank_validation_885", "nl": "matter in the liquid phase has definite volume.", "fol": "", "prediction": ["all x. (Matter(x) & InLiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasDefiniteVolume(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> DefiniteVolume(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> DefiniteVolume(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> DefiniteVolume(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & InLiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))", "all x. (Matter(x) & LiquidPhase(x) -> HasDefiniteVolume(x))"]}
{"id": "entailmentbank_validation_886", "nl": "matter in the liquid phase has a variable shape and definite volume.", "fol": "", "prediction": ["all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x) & DefiniteVolume(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. (Matter(x) & InLiquidPhase(x) -> VariableShape(x) & DefiniteVolume(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x) & DefiniteVolume(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (HasVariableShape(x) & HasDefiniteVolume(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))", "all x. (Matter(x) & LiquidPhase(x) -> VariableShape(x) & DefiniteVolume(x))", "all x. ((Matter(x) & IsInLiquidPhase(x)) -> (VariableShape(x) & DefiniteVolume(x)))"]}
{"id": "entailmentbank_validation_887", "nl": "the matter may be in solid phase or in liquid phase.", "fol": "", "prediction": ["exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "The translated sentence in FOL would be:\n\nexists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (InSolidPhase(x) | InLiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "exists x. (Matter(x) & (InSolidPhase(x) | InLiquidPhase(x)))", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))", "`exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))`", "exists x. (Matter(x) & (SolidPhase(x) | LiquidPhase(x)))"]}
{"id": "entailmentbank_validation_888", "nl": "seeing small things with bare eyes is difficult.", "fol": "", "prediction": ["all x. (Small(x) & CanBeSeenWithBareEyes(x) -> DifficultToSee(x))", "Difficulty(all x. (SmallThing(x) & SeenWithBareEyes(x)))", "all x. (SmallThing(x) -> DifficultToSeeWithBareEyes(x))", "Difficult(SeeingWithBareEyes(small_things))", "all x. (SmallThing(x) -> DifficultToSeeWithBareEyes(x))", "all x. (Small(x) & Thing(x) -> DifficultToSeeWithBareEyes(x))", "all x. (Small(x) & SeenWithBareEyes(x) -> DifficultToSee(x))", "exists x. (SmallThing(x) -> DifficultToSeeWithBareEyes(x))", "all y. (SmallThing(y) -> DifficultToSeeWithBareEyes(y))", "all x. (SmallThing(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (SmallThing(x) -> Difficult(SeesWithBareEyes(x)))", "all x. (SmallThing(x) -> DifficultToSeeWithBareEyes(x))", "FOL Translation:\nall x. (Small(x) & SeenWithBareEyes(x) -> Difficult(Seeing(x)))", "exists x. (SmallThing(x) -> Difficult(SeeWithBareEyes(x)))", "`all x. (SmallThing(x) & -CanSeeWithBareEyes(x) -> DifficultToSee(x))`", "Difficulty(all x. (SmallThing(x) & SeenWithBareEyes(x)))"]}
{"id": "entailmentbank_validation_889", "nl": "an insect usually has a small size.", "fol": "", "prediction": ["all x. (Insect(x) -> Usually(SmallSize(x)))", "all x. (Insect(x) -> Usually(HasSmallSize(x)))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "all x. (Insect(x) -> UsuallSmall(x))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "all x. (Insect(x) -> Usually(HasSmallSize(x)))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "`all x. (Insect(x) -> UsuallyHasSmallSize(x))`", "all x. (Insect(x) -> UsuallyHasSmallSize(x))", "all x. (Insect(x) -> UsuallyHasSmallSize(x))", "all x. (Insect(x) -> Usually(HasSmallSize(x)))", "To translate 'an insect usually has a small size' into first-order logic (FOL), we need to capture the idea that generally, or usually, insects are small. In conventional FOL, \"usually\" and similar probabilistic or general tendency concepts are difficult to represent directly, as FOL is typically used for absolute quantifications rather than probabilistic ones.\n\nHowever, if one needed to express a general tendency in pure FOL, we might approximate it with a weaker statement that for every insect, if it is not small, then it is exceptional in some way. Alternatively, we may simply assume for this exercise that \"usually\" can be approximated as universally:\n\nall x. (Insect(x) -> SmallSize(x))", "all x. (Insect(x) -> Usually(SmallSize(x)))", "exists x. (Insect(x) & UsuallyHasSmallSize(x))", "all x. (Insect(x) -> UsuallyHasSmallSize(x))"]}
{"id": "entailmentbank_validation_890", "nl": "seeing an insect with bare eyes is difficult.", "fol": "", "prediction": ["exists x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "FOL Translation:\nall x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) & -EasyToSeeWithBareEyes(x))", "exists x. (Insect(x) & DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) & Difficult(SeeWithBareEyes(x)))", "exists x. (Insect(x) & DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) & DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) & Difficult(SeeWithBareEyes(x)))", "all x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "FOL Translation:\nall x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) -> DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) & DifficultToSeeWithBareEyes(x))", "exists x. (Insect(x) -> DifficultToSeeBareEyes(x))"]}
{"id": "entailmentbank_validation_891", "nl": "magnifying glass is used to see small things by making objects appear bigger.", "fol": "", "prediction": ["exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakeObjectsAppearBigger(x))", "exists o. (Object(o) & MagnifyingGlass(magnifying_glass) & UsedToSee(magnifying_glass, o) & Small(o) & AppearBigger(magnifying_glass, o))", "Exists y. (MagnifyingGlass(y) & UsedToSeeSmallThings(y) & all x. (SmallObject(x) -> MakesAppearBigger(y, x)))", "exists x. (MagnifyingGlass(x) & UsedFor(x, SeeingSmallThings) & MakesAppearBigger(x, Objects))", "exists x. (MagnifyingGlass(x) & all y. (SmallThing(y) -> UsedToSeeByMakingAppearBigger(x, y)))", "all x. (SmallThing(x) -> exists y. (MagnifyingGlass(y) & UsedToSee(y, x) & AppearsBigger(y, x)))", "Use(magnifying_glass, SeeSmallThings) & MakesObjectsAppearBigger(magnifying_glass)", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "Uses(magnifying_glass, SmallThings) & MakesAppearBigger(magnifying_glass, SmallThings)", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThingsByMakingObjectsAppearBigger(x))", "exists x. (MagnifyingGlass(x) & UsedToSeeSmallThings(x) & MakesObjectsAppearBigger(x))", "Exists modeled using instances for unique purposes:\nexists x. (MagnifyingGlass(x) & all y. (SmallThing(y) -> UsedToSee(x, y) & MakesAppearBigger(x, y)))", "exists x. (MagnifyingGlass(x) & all y. (SmallThing(y) -> (UsedToSeeWith(x, y) & MakesAppearBigger(x, y))))", "all x. (SmallThing(x) -> (exists y. (MagnifyingGlass(y) & UsedToSee(y, x) & MakesAppearBigger(y, x))))"]}
{"id": "entailmentbank_validation_892", "nl": "magnifying glass can be used to see an insect by making it appear bigger.", "fol": "", "prediction": ["exists x exists y. (MagnifyingGlass(x) & Insect(y) -> CanBeUsedToSee(x, y) & MakesAppearBigger(x, y))", "exists x. (MagnifyingGlass(x) & CanBeUsedToSeeInsectByMakingItAppearBigger(x))", "exists x, y. (MagnifyingGlass(x) & Insect(y) & CanBeUsedToSee(x, y) & MakesAppearBigger(x, y))", "FOL Translation:\nall x. (Insect(x) -> exists y. (MagnifyingGlass(y) & CanBeUsedToSeeAsBigger(x, y)))", "exists x. (MagnifyingGlass(x) & all y. (Insect(y) -> CanBeUsedToMakeAppearBigger(x, y) & CanBeUsedToSee(x, y)))", "exists x. (MagnifyingGlass(x) -> (exists y. (Insect(y) & CanBeSeenWith(x, y) & MakesAppearBigger(x, y))))", "exists x. (MagnifyingGlass(x) -> exists y. (Insect(y) & CanBeUsedToSee(y, x) & MakesAppearBigger(y, x)))", "exists x. (MagnifyingGlass(x) -> exists y. (Insect(y) & CanSeeBiggerWith(x, y)))", "exists x. (MagnifyingGlass(x) & exists y. (Insect(y) -> CanBeUsedToSee(x, y) & MakesAppearBigger(x, y)))", "exists x. (MagnifyingGlass(x) -> exists y. (Insect(y) & AppearsBigger(y, x) & CanBeUsedToSee(x, y)))", "exists x y. (MagnifyingGlass(x) & Insect(y) & CanBeUsedToSee(x, y) & MakesAppearBigger(x, y))", "exists x. (MagnifyingGlass(x) -> exists y. (Insect(y) & CanBeUsedToSee(x, y) & MakesAppearBigger(x, y)))", "exists x, y, z. (MagnifyingGlass(x) & Insect(y) & MakesAppearBigger(x, y, z) & See(z, y))", "exists x. (MagnifyingGlass(x) & CanUseToSeeInsect(x) & MakesAppearBigger(x, y) & Insect(y))", "FOL Translation:\nexists x. (MagnifyingGlass(x) & all y. (Insect(y) -> CanBeUsedToSee(x, y) & MakesAppearBigger(x, y)))", "exists x. (MagnifyingGlass(x) -> exists y. (Insect(y) & UsedToSee(x, y) & MakesAppearBigger(x, y)))"]}
{"id": "entailmentbank_validation_893", "nl": "a hand lens is a kind of magnifying glass.", "fol": "", "prediction": ["Kind(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "Kind(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "Kind(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "KindOf(hand_lens, magnifying_glass)", "Kind(hand_lens, magnifying_glass)", "`all x. (HandLens(x) -> MagnifyingGlass(x))`", "KindOf(hand_lens, magnifying_glass)"]}
{"id": "entailmentbank_validation_894", "nl": "a hand lens can help seeing the insect by magnifying the insect.", "fol": "", "prediction": ["exists x. (HandLens(x) & all y. (Insect(y) -> CanHelpSee(x, y) & Magnifies(x, y)))", "exists x. (HandLens(x) & helpsSeeingInsect(x) & MagnifiesInsect(x))", "exists x. (HandLens(x) -> CanHelpSeeing(x, insect, Magnify(x, insect)))", "exists x. (HandLens(x) & HelpsSeeingInsect(x) & MagnifiesInsect(x))", "exists x. (HandLens(x) & CanHelpSeeingInsect(x) & ByMagnifyingInsect(x))", "exists x. (HandLens(x) -> (exists y. (Insect(y) & HelpsSeeing(x, y, Magnifies(y)))))", "exists x. (HandLens(x) -> CanHelpSeeingInsect(x) & Magnifies(x, Insect))", "exists x. (HandLens(x) -> HelpsSeeingInsect(x) & Magnifies(x, insect))", "exists x. (HandLens(x) -> (CanHelpSeeingInsect(x) & MagnifiesInsect(x)))", "exists y. (HandLens(y) -> all x. (Insect(x) -> (HelpsSeeing(y, x) & Magnifies(y, x))))", "exists l, i. (HandLens(l) & Insect(i) & CanHelpSeeingByMagnifying(l, i))", "exists x. (HandLens(x) -> (HelpsSeeingInsect(x) & MagnifiesInsect(x)))", "exists x. (HandLens(x) & CanHelp(x, Seeing(y, Insect(y)), Magnifying(y, Insect(y))))", "exists x. (HandLens(x) -> CanHelpSeeingInsect(x) & MagnifiesInsect(x))", "exists h, i. (HandLens(h) & Insect(i) & CanHelpSeeing(h, i) & Magnifies(h, i))", "exists x. (HandLens(x) -> (exists y. (Insect(y) & Magnifies(x, y) & HelpsSeeing(x, y))))"]}
{"id": "entailmentbank_validation_895", "nl": "building a doghouse requires cutting materials into a fixed size.", "fol": "", "prediction": ["exists y. (Building(y, doghouse) -> exists z. (Material(z) & RequiresCuttingToFixedSize(y, z)))", "all x. ((Building(x) & Doghouse(x)) -> exists y. (Material(y) & RequiresCuttingIntoFixedSize(x, y)))", "all x. (Doghouse(x) -> exists y. (Material(y) & CutsIntoSize(y)))", "exists y. (Building(y) & Doghouse(y) -> Requires(y, CuttingMaterialsIntoFixedSize))", "exists b. (Doghouse(b) -> Requires(b, exists m. (Material(m) & CutIntoFixedSize(m))))", "all x. (BuildingDoghouse(x) -> exists y. (Material(y) & CutToFixedSize(y)))", "all m. (Material(m) & RequiredForBuilding(doghouse, m) -> RequiresCuttingToFixedSize(m))", "all x. (BuildingADoghouse(x) -> exists y. (Material(y) & RequiresCuttingIntoFixedSize(y)))", "exists x. (Building(x) & Doghouse(x) -> Requires(x, CuttingMaterialsFixedSize))", "all x. (BuildingADoghouse(x) -> exists y. (Material(y) & RequiresCutting(y) & FixedSize(y)))", "all x. (BuildingDoghouse(x) -> exists y. (Material(y) & CutToFixedSize(y)))", "all x. (BuildingDoghouse(x) -> exists y. (CuttingMaterials(y) & FixedSize(y)))", "all x. (BuildingDoghouse(x) -> exists y. (Material(y) & RequiresCuttingIntoFixedSize(y)))", "FOL Translation:\nall x. (Doghouse(x) -> exists y. (Material(y) & CuttingIntoFixedSize(y)))", "all x. (Building(x, doghouse) -> Requires(x, y, CuttingMaterials(y, FixedSize(y))))", "all x. (Doghouse(x) -> exists y. (Cut(y, FixedSize) & Materials(y) & RequiredToBuild(x, y)))"]}
{"id": "entailmentbank_validation_896", "nl": "cutting a material usually requires measuring length.", "fol": "", "prediction": ["all x. (Material(x) -> (MeasureLength(x) -> RequiresCutting(x)))", "all x. (Material(x) -> (Cutting(x) -> UsuallyRequires(Cutting(x), MeasuringLength)))", "all x. ((Material(x) & RequiresCutting(x)) -> Usually(y. (y = LengthMeasurement(y) & Requires(y, x))))", "all x y. (CutMaterial(x, y) -> UsuallyRequires(MeasuringLength(y)))", "all x. (Material(x) -> (Cutting(x) -> (exists y. (Measuring(y) & Length(y)))))", "exists x. (Material(x) -> UsuallyRequires(Cutting(x), MeasuringLength(x)))", "all x. (Material(x) -> (Cutting(x) -> Usually(MeasuringLength(x))))", "exists x. (Material(x) -> (usually(MeasuringLength(x)) & Requires(Cutting(x), MeasuringLength(x))))", "all x. (Material(x) -> (Cutting(x) -> Usually(Requires(MeasuringLength(x)))))", "all x. (Material(x) -> (Cutting(x) -> Usually(Exists y. (MeasuringLength(y, x)))))", "all x, y. (Cut(x, y) -> Usually(MeasuringLength(x)))", "all x y. (CuttingMaterial(x) & Material(x) -> (UsuallyRequires(Cutting(x), MeasuringLength(y))))", "all x. (Material(x) -> (Cutting(x) -> UsuallyRequires(MeasuringLength(x))))", "exists x. (Material(x) -> (Cutting(x) -> MeasuringLength(x)))", "all x. (Material(x) -> (CuttingRequiresMeasurement(x, length) & Usually(CuttingRequiresMeasurement(x, length))))", "all x. (Material(x) -> Usually(Requires(Cutting(x), MeasuringLength(x))))"]}
{"id": "entailmentbank_validation_897", "nl": "cutting a material when building a doghouse  requires measuring length.", "fol": "", "prediction": ["all x. ((Cutting(x) & Material(x) & Building(doghouse)) -> Requires(x, MeasuringLength))", "all m. (Material(m) & Building(doghouse) & Cutting(m, doghouse) -> Requires(MeasuringLength(m, doghouse)))", "all x. (Material(x) & Doghouse(y) & Building(y, x) -> Requires(MeasuringLength(), Cutting(x)))", "all x. (Building(x, doghouse) & CuttingMaterial(x) -> Requires(x, MeasuringLength))", "all x. ((Material(x) & Activity(BuildingDoghouse) & Action(Cutting, x)) -> requires(MeasuringLength, Action(Cutting, x)))", "exists x. (Material(x) & Building(doghouse) & Cutting(x, doghouse) -> Requires(Measuring(length)))", "all x y. ((Material(x) & DoghouseBuilding(y) & UsedForCutting(x, y)) -> Requires(MeasuringLength, x, y))", "all x. (BuildingDoghouse(x) & CuttingMaterial(x) -> Requires(MeasuringLength(x)))", "all x. (BuildingDoghouse(x) & CuttingMaterial(x) -> Requires(MeasuringLength(x)))", "all x. (Material(x) & UsedInBuilding(x, doghouse) -> Requires(MeasuringLength(x), Cutting(x)))", "exists x. exists y. (Material(x) & Doghouse(y) & Building(y) & Cutting(x, y) -> Requires(Cutting(x, y), MeasuringLength))", "exists x exists y. (CuttingMaterial(x) & BuildingDoghouse(y) -> Requires(MeasuringLength))", "", "all x. (BuildingDoghouse(x) & CuttingMaterial(x) -> Requires(CuttingMaterial(x), MeasuringLength))", "", "all x y. (Cutting(x) & Material(y) & WhenBuilding(x, doghouse) -> Requires(x, MeasuringLength))"]}
{"id": "entailmentbank_validation_898", "nl": "a tape can be used to measure length.", "fol": "", "prediction": ["exists x. (Tape(x) & CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) & CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) & CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) & CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) & CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))", "exists x. (Tape(x) -> CanBeUsedToMeasure(x, length))", "exists x. (Tape(x) -> CanBeUsedToMeasureLength(x))"]}
{"id": "entailmentbank_validation_899", "nl": "cutting wood when building a doghouse requires using a tape.", "fol": "", "prediction": ["all x. (Building(x, doghouse) & Involves(x, Cutting(wood)) -> Requires(x, Using(tape)))", "all x. (Building(x, doghouse) & Cutting(x, wood) -> RequiresUsing(x, tape))", "all x. (Building(x) & Doghouse(x) & Involves(x, CuttingWood) -> Requires(x, UsingTape))", "all x. ((Building(x) & Doghouse(x) & CuttingWood(x)) -> Requires(x, UsingTape))", "all x, y. ((Building(x, doghouse) & CuttingWood(x)) -> UsingTape(y))", "all x y. ((Building(x, doghouse) & Cutting(y, wood) & PartOf(y, x)) -> Requires(y, tape))", "all x. (BuildingDoghouse(x) & CuttingWood(x) -> Requires(x, UseTape))", "all x y. ((Activity(x, BuildingDoghouse) & Action(x, Cutting, Wood) & Tool(y, Tape)) -> Requires(x, y))", "all x. (Building(x, doghouse) & Requires(x, cutting_wood) -> Requires(x, using_tape))", "all x. (BuildingDoghouse(x) & CuttingWood(x) -> RequiresUsingTape(x))", "all x. (Building(x) & Doghouse(x) & Wood(y) & Uses(x, y) -> RequiresUsing(x, tape))", "all x. ((Wood(x) & Building(y, doghouse) & Cutting(x, y)) -> RequiresUsing(x, tape))", "all x. (Building(x, doghouse) & CutsWood(x) -> Requires(x, UseTape))", "all x. (Building(x) & Doghouse(x) & Requires(x, Cutting(wood)) -> Requires(x, Using(tape)))", "all x. ((Building(x, doghouse) & Task(x, cutting_wood)) -> Requires(x, using_tape))", "all x. (Building(x, doghouse) & Activity(x, cutting_wood) -> Requires(x, using_tape))"]}
{"id": "entailmentbank_validation_900", "nl": "food is a kind of substance.", "fol": "", "prediction": ["all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "Substance(food)", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "FOL Translation:\nall x. (Food(x) -> Substance(x))", "all x. (Food(x) -> Substance(x))", "Substance(food)", "all x. (Food(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_901", "nl": "candy is a kind of food.", "fol": "", "prediction": ["Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)", "Food(candy)"]}
{"id": "entailmentbank_validation_902", "nl": "candy is a kind of substance.", "fol": "", "prediction": ["Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)", "Substance(candy)"]}
{"id": "entailmentbank_validation_903", "nl": "a thermometer is used to measure temperature of substance.", "fol": "", "prediction": ["exists x exists y exists z. (Thermometer(x) & Substance(y) & Temperature(z) & UsedToMeasure(x, z, y))", "all x. (Thermometer(x) -> exists y. (Substance(y) & MeasuresTemperatureOf(x, y)))", "all x. (Thermometer(x) -> exists y. (Substance(y) & MeasuresTemperatureOf(x, y)))", "exists x. (Thermometer(x) & UsedToMeasureTemperatureOf(x, substance))", "all x. (Thermometer(x) -> exists y z. (Substance(y) & Temperature(z) & UsedToMeasure(x, y, z)))", "exists x. (Thermometer(x) & all y. (Substance(y) -> UsedToMeasure(x, Temperature(y))))", "exists x. (Thermometer(x) -> UsedToMeasureTemp(x, substance))", "exists x. (Thermometer(x) & all y. (Substance(y) -> UsedToMeasureTemperature(x, y)))", "exists x. (Thermometer(x) -> exists y. (Substance(y) & MeasuresTemperatureOf(x, y)))", "all x. (Thermometer(x) -> exists y. (Substance(y) & UsedToMeasureTemperature(x, y)))", "exists x. (Thermometer(x) -> exists y. (Substance(y) & UsedToMeasureTemperatureOf(x, y)))", "exists x. (Thermometer(x) -> exists y. (Substance(y) & MeasuresTemperatureOf(x, y)))", "all x. (Thermometer(x) -> exists y. (Substance(y) & UsedToMeasureTemperatureOf(x, y)))", "exists x. (Thermometer(x) -> exists y. (Substance(y) & UsedToMeasureTemperatureOf(x, y)))", "all x. (Thermometer(x) -> exists y. (Substance(y) & MeasuresTemperatureOf(x, y)))", "exists x. (Thermometer(x) & all y. (Substance(y) -> MeasuresTemperatureOf(x, y)))"]}
{"id": "entailmentbank_validation_904", "nl": "a thermometer is used to measure the temperautre of the candy.", "fol": "", "prediction": ["exists x, y. (Thermometer(x) & Candy(y) & UsedToMeasureTemperature(x, y))", "exists x. exists y. (Thermometer(x) & Candy(y) & MeasuresTemperatureOf(x, y))", "exists t, c. (Thermometer(t) & Candy(c) & UsedToMeasureTemperatureOf(t, c))", "exists x. (Thermometer(x) & UsedToMeasureTemperature(x, candy))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature, candy))", "exists x. (Thermometer(x) & UsedToMeasureTemperatureOf(x, candy))", "exists x. (Thermometer(x) & exists y. (Candy(y) & MeasuresTemperatureOf(x, y)))", "exists x. exists y. (Thermometer(x) & Candy(y) & UsedToMeasureTemperatureOf(x, y))", "exists x. (Thermometer(x) & UsedToMeasure(x, y) & Temperature(y) & Candy(y))", "exists x. (Thermometer(x) & exists y. (Candy(y) & MeasuresTemperatureOf(x, y)))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature, candy))", "exists x y z. (Thermometer(x) & Candy(y) & Temperature(z) & Measures(x, z) & Of(z, y))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature, candy))", "exists x, y. (Thermometer(x) & Candy(y) -> UsedToMeasureTemperatureOf(x, y))", "exists x. (Thermometer(x) & UsedToMeasure(x, temperature_of(candy)))", "exists x. exists y. exists z. (Thermometer(x) & Temperature(y) & Candy(z) & UsedToMeasure(x, y, z))"]}
{"id": "entailmentbank_validation_905", "nl": "a string is short in length.", "fol": "", "prediction": ["ShortLength(string)", "ShortInLength(string)", "ShortLength(string)", "ShortInLength(string)", "Short(string)", "ShortLength(string)", "ShortInLength(string)", "Short(string)", "String(x) -> Short(x)", "ShortLength(x)", "ShortInLength(string)", "ShortInLength(string)", "ShortLength(string)", "all x. (String(x) -> ShortLength(x))", "ShortInLength(string)", "ShortString(x)"]}
{"id": "entailmentbank_validation_906", "nl": "centimeter is usually used to measure short length.", "fol": "", "prediction": ["all x. (Centimeter(x) -> UsuallyUsedToMeasureShortLength(x))", "all x. (Centimeter(x) -> UsuallyUsedToMeasure(x, ShortLength))", "exists x. (UnitOfMeasure(x, centimeter) & UsedToMeasure(x, short_length))", "Usually(x, P(x)) -> UsedToMeasure(x, ShortLength(x)) & Unit(x, centimeter)", "all x. (Centimeter(x) -> UsedToMeasureShortLength(x))", "all x. (ShortLength(x) -> UsuallyUsedToMeasure(centimeter, x))", "all x. (Centimeter(x) -> UsuallyUsedToMeasure(x, ShortLength))", "all x. (UnitOfMeasure(x, centimeter) & ShortLength(x) -> UsuallyUsed(x, centimeter))", "exists x. (Centimeter(x) & UsuallyUsedToMeasureShortLength(x))", "all x. (Centimeter(x) -> UsuallyUsedToMeasureShortLength(x))", "all x. (CentimeterUsed(x) & ShortLength(x) -> Measures(x, short_length))", "all x. (Centimeter(x) -> UsuallyUsedToMeasure(x, ShortLength))", "all x. (Centimeter(x) -> UsedToMeasure(x, ShortLength))", "all x. (Centimeter(x) -> UsedToMeasureShortLength(x))", "all x. (Centimeter(x) -> UsedToMeasure(x, short_length))", "all x. (Centimeter(x) -> UsedToMeasureShortLength(x))"]}
{"id": "entailmentbank_validation_907", "nl": "centimeter is a better unit to measure the length of the string.", "fol": "", "prediction": ["BetterUnitToMeasureLength(centimeter, string)", "BetterUnitToMeasureLength(centimeter, string)", "BetterUnitToMeasureLength(string, centimeter)", "BetterUnitToMeasure(centimeter, lengthOf(string))", "Measure(length, string, centimeter) & BetterUnit(centimeter, length, string)", "BetterUnitToMeasure(length_of_string, centimeter)", "BetterUnitToMeasure(length_of_string, centimeter)", "BetterUnit(centimeter, string, length)", "MeasureWith(cm, string) & BetterUnit(cm, lengthOf(string))", "Centimeter is likely being referred to as a specific unit of measurement here, so let's say we interpret this as meaning \"The unit of centimeter is better than other units to measure the length of a specific string.\" Given this interpretation, we might translate the sentence into first-order logic as:\n\nBetterUnitToMeasure(centimeter, length_of_string)", "BetterUnitToMeasureLengthOfString(centimeter)", "BetterUnitToMeasure(centimeter, length, string)", "BetterUnitToMeasure(length_of_string, centimeter)", "BetterUnitToMeasure(centimeter, length_of_string)", "`BetterUnitToMeasureLength(string, centimeter)`", "BetterUnitToMeasureLengthOf(string, centimeter)"]}
{"id": "entailmentbank_validation_908", "nl": "meters m are a metric / si unit used for measuring length.", "fol": "", "prediction": ["all m. (Meter(m) -> MetricUnit(m) & SIUnit(m) & UsedFor(m, MeasuringLength))", "MetricUnit(m) & SIUnit(m) & UsedFor(m, MeasuringLength)", "MetricSIUnit(meters) & UsedFor(measuring_length, meters)", "all m. (Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedForMeasuring(m, length)))", "MetricUnit(m) & SIUnit(m) & UsedFor(m, Length)", "all m. (Meter(m) -> MetricUnit(m) & SiUnit(m) & UsedFor(MeasuringLength, m))", "all m. (Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedFor(m, MeasuringLength)))", "all m. (Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedFor(m, measuring_length)))", "all m. (Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedForMeasuring(m, length)))", "all m. (Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedFor(m, length)))", "all m. (Meter(m) -> (MetricSystemUnit(m) & UsedFor(m, MeasuringLength)))", "MetricUnit(m) & SIUnit(m) & UsedForMeasuring(m, length)", "all m. ((Meter(m) -> (MetricUnit(m) & SIUnit(m) & UsedForMeasuringLength(m))))", "MetricSIUnit(meters) & UsedFor(meters, MeasuringLength)", "all x. (Meter(x) -> (MetricUnit(x) & SIUnit(x) & UsedFor(x, MeasuringLength)))", "MetricUnit(m) & SIUnit(m) & UsedFor(measuring_length, m)"]}
{"id": "entailmentbank_validation_909", "nl": "yard is an imperial unit used for measuring length.", "fol": "", "prediction": ["ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)", "ImperialUnit(yard) & UsedFor(yard, MeasuringLength)", "ImperialUnit(yard) & UsedForMeasuring(yard, length)"]}
{"id": "entailmentbank_validation_910", "nl": "yard and meter are both unit used for measuring length.", "fol": "", "prediction": ["Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedFor(yard, measuring_length) & UsedFor(meter, measuring_length)", "UnitOfLength(yard) & UnitOfLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "(UsedForMeasuring(unit, length) is a predicate that indicates the unit is used for measuring length.)\n\nUnit(yard) & Unit(meter) & UsedForMeasuring(yard, length) & UsedForMeasuring(meter, length)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "(UsedForMeasuringLength(yard) & Unit(yard)) & (UsedForMeasuringLength(meter) & Unit(meter))", "Unit(yard) & Unit(meter) & UsedForMeasuring(yard, length) & UsedForMeasuring(meter, length)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuringLength(yard) & UsedForMeasuringLength(meter)", "Unit(yard) & Unit(meter) & UsedForMeasuring(yard, length) & UsedForMeasuring(meter, length)", "Unit(yard) & Unit(meter) & UsedForMeasuring(yard, length) & UsedForMeasuring(meter, length)"]}
{"id": "entailmentbank_validation_911", "nl": "1 yard equals to 09 meter.", "fol": "", "prediction": ["EqualsTo(1yard, 0.9144meter)", "Equals(1yard, 0.9meter)", "Equals(1_yard, 0.9_meter)", "1 yard = 0.9 meter", "Equals(yard, meter) & yard = 1 & meter = 0.9", "EqualsTo(1yard, 0.9meter)", "Equals(yard, meter) & yard = 1 & meter = 0.9", "Equals(1yard, 0.91meter)", "Equals(1_yard, 0.9_meter)", "Equals(yard1, meter0.9144)", "Equals(1_yard, 0.9_meter)", "Equals(yard1, meter09)", "Equals(yard_1, meter_0.91)", "Equals(1yard, 0.9meter)", "Equals(1_yard, 0.9_meter)", "Equals(yard_1, meter_09)"]}
{"id": "entailmentbank_validation_912", "nl": "meter is the metric unit that is the most similar to yard.", "fol": "", "prediction": ["MetricUnit(meter) & MostSimilarTo(meter, yard)", "MostSimilar(meter, yard) & MetricUnit(meter)", "MostSimilarTo(meter, yard) & MetricUnit(meter)", "MetricUnit(meter) & (MeterUnit(meter) & MostSimilarTo(meter, yard))", "MetricUnit(meter) & all x. (MetricUnit(x) -> (SimilarTo(x, yard) -> x = meter))", "MetricUnit(meter) & MostSimilarTo(meter, yard)", "MetricUnit(meter) & SimilarTo(meter, yard) & all x. ((MetricUnit(x) & SimilarTo(x, yard)) -> x = meter)", "MetricUnit(meter) & all x. ((MetricUnit(x) & SimilarTo(x, yard)) -> x = meter)", "MetricUnit(meter) & SimilarTo(meter, yard) & all x. ((MetricUnit(x) & SimilarTo(x, yard)) -> x = meter)", "Similar(meter, yard) & all x. ((MetricUnit(x) & Similar(x, yard)) -> x = meter)", "MetricUnit(meter) & MostSimilarTo(meter, yard)", "MetricUnit(meter) & SimilarTo(meter, yard) & all x. ((MetricUnit(x) & SimilarTo(x, yard)) -> x = meter)", "exists x. (MetricUnit(x) & MostSimilarTo(x, yard) & x = meter)", "MetricUnit(meter) & MostSimilarTo(meter, yard)", "MetricUnit(meter) & MostSimilarTo(meter, yard)", "MostSimilarMetricUnitTo(meter, yard)"]}
{"id": "entailmentbank_validation_913", "nl": "zinc is a kind of metal.", "fol": "", "prediction": ["Metal(zinc)", "Metal(zinc)", "Metal(zinc)", "KindOf(zinc, metal)", "KindOf(zinc, metal)", "Metal(zinc)", "Metal(zinc)", "Metal(zinc)", "Metal(zinc)", "Metal(zinc)", "KindOf(zinc, metal)", "Metal(zinc)", "Metal(zinc)", "KindOf(zinc, metal)", "Metal(zinc)", "Metal(zinc)"]}
{"id": "entailmentbank_validation_914", "nl": "copper is a kind of metal.", "fol": "", "prediction": ["Metal(copper)", "KindOf(copper, metal)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Kind(copper, metal)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)", "Metal(copper)"]}
{"id": "entailmentbank_validation_915", "nl": "copper and zinc are two metals.", "fol": "", "prediction": ["Metal(copper) & Metal(zinc) & copper \u2260 zinc", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc) & TwoMetals(copper, zinc)", "Metal(copper) & Metal(zinc) & copper \u2260 zinc", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc) & copper \u2260 zinc", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc) & TwoMetals(copper, zinc)", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc) & TwoMetals(copper, zinc)", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc) & copper \u2260 zinc", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc)", "Metal(copper) & Metal(zinc)"]}
{"id": "entailmentbank_validation_916", "nl": "brass is made of copper and zinc.", "fol": "", "prediction": ["MadeOf(brass, copper) & MadeOf(brass, zinc)", "Exists x, exists y, Brass(x) & Copper(y) & Zinc(y) & MadeOf(x,y).", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "Material(brass, copper) & Material(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)", "MadeOf(brass, copper) & MadeOf(brass, zinc)"]}
{"id": "entailmentbank_validation_917", "nl": "brass is made of two metals.", "fol": "", "prediction": ["exists x, y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x. exists y. (Metal(x) & Metal(y) & x != y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x, y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists x, y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists x. exists y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists x, y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x. exists y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists x. exists y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists m1, m2. (Metal(m1) & Metal(m2) & m1 != m2 & MadeOf(brass, m1) & MadeOf(brass, m2))", "exists x. exists y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & x \u2260 y)", "exists x. exists y. (Metal(x) & Metal(y) & IsMadeOf(brass, x, y))", "exists x. exists y. (Metal(x) & Metal(y) & (Brass = MadeOf(x, y)))", "exists x, y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x. exists y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x. exists y. (Metal(x) & Metal(y) & x \u2260 y & MadeOf(brass, x) & MadeOf(brass, y))", "exists x, y. (Metal(x) & Metal(y) & MadeOf(brass, x) & MadeOf(brass, y) & Distinct(x, y))"]}
{"id": "entailmentbank_validation_918", "nl": "an alloy is made of two or more metals.", "fol": "", "prediction": ["all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y, z. (Metal(y) & Metal(z) & PartOf(y, x) & PartOf(z, x) & y \u2260 z))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y. exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y. exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & y \u2260 z & MadeOf(x, y) & MadeOf(x, z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))", "all x. (Alloy(x) -> exists y, z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & -(y = z)))", "all x. (Alloy(x) -> exists y exists z. (Metal(y) & Metal(z) & MadeOf(x, y) & MadeOf(x, z) & y \u2260 z))"]}
{"id": "entailmentbank_validation_919", "nl": "brass is a kind of alloy.", "fol": "", "prediction": ["KindOf(brass, alloy)", "Alloy(brass)", "KindOf(brass, alloy)", "KindOf(brass, alloy)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "KindOf(brass, alloy)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)", "Alloy(brass)"]}
{"id": "entailmentbank_validation_920", "nl": "a rough surface can absorb sound.", "fol": "", "prediction": ["all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "exists x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "exists x. (RoughSurface(x) & CanAbsorbSound(x))", "exists x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "exists x. (RoughSurface(x) & CanAbsorbSound(x))", "exists x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))", "all x. (RoughSurface(x) -> CanAbsorbSound(x))"]}
{"id": "entailmentbank_validation_921", "nl": "a carpet can absorb sound.", "fol": "", "prediction": ["exists x. (Carpet(x) & CanAbsorbSound(x))", "FOL Translation:\nall x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "FOL Translation:\nall x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) & CanAbsorbSound(x))", "exists x. (Carpet(x) -> CanAbsorbSound(x))"]}
{"id": "entailmentbank_validation_922", "nl": "if sound is absorbed, then sound can not reflect off the surface.", "fol": "", "prediction": ["all x. (Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Absorbed(x, sound) -> -Reflects(x, sound))", "all x. ((Absorbed(sound, x) -> -CanReflect(sound, x)))", "all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all x. (Sound(x) & Absorbed(x) -> -Reflects(x, surface))", "all x. (Absorbed(sound, x) -> -ReflectsOff(sound, x))", "all x. (Sound(x) & Absorbed(x) -> -CanReflectOffSurface(x))", "all s. (Sound(s) & Absorbed(s) -> -CanReflect(s))", "all x. (Absorbed(sound, x) -> -CanReflect(sound, x))", "all s. (Sound(s) & Absorbed(s) -> -CanReflectOffSurface(s))", "all x. (AbsorbedSound(x) -> -CanReflectOffSurface(x))", "all x. (Absorbed(x) -> -CanReflect(x))", "all x. (Sound(x) & Absorbed(x) -> -ReflectsOffSurface(x))"]}
{"id": "entailmentbank_validation_923", "nl": "sound cannot reflect off the surface of a carpet.", "fol": "", "prediction": ["all x. ((Sound(x) & SurfaceOfCarpet(y)) -> -ReflectsOff(x, y))", "all x. (Surface(x) & Carpet(x) -> -CanReflectSound(x))", "all x y. (Sound(x) & CarpetSurface(y) -> -ReflectsOff(x, y))", "all x. ((Surface(x) & Carpet(x)) -> -CanReflectSound(x))", "all x. (Surface(x) & Carpet(x) -> -CanReflectSound(x))", "all x y. (Sound(x) & Surface(y) & Carpet(y) -> -ReflectsOff(x, y))", "all x. (Carpet(x) -> -ReflectsOff(x, sound))", "all x. (Surface(x) & Carpet(x) -> -ReflectsSound(x))", "all x. (Carpet(x) -> -ReflectSoundOff(x, SurfaceOf(x)))", "all x. (Surface(x) & Carpet(x) -> -CanReflectSoundOff(x))", "all x y. (Sound(x) & Carpet(y) -> -ReflectsOff(x, y))", "all x. (Surface(x) & Carpet(x) -> -CanReflectSound(x))", "all x. (Sound(x) & Surface(x) & Carpet(x) -> -CanReflectOff(x))", "all x. (Sound(x) -> -ReflectsOffSurfaceOf(x, carpet))", "all x. (Surface(x) & Carpet(x) -> -CanReflectSound(x))", "all x. (Surface(x) & Carpet(x) -> -CanReflect(sound, x))"]}
{"id": "entailmentbank_validation_924", "nl": "echo is when sound reflects off a smooth surface.", "fol": "", "prediction": ["all x. (Echo(x) <-> (Sound(x) & exists y. (ReflectsOff(x, y) & SmoothSurface(y))))", "Echo(y) <-> exists x. (Sound(x) & ReflectsOff(x, SmoothSurface) & y = x)", "Exists x. (Sound(x) & ReflectsOffSmoothSurface(x) -> Echo(x))", "exists x. (Echo(x) <-> exists y. (Sound(y) & ReflectsOff(y, smooth_surface)))", "Echo(x) <-> exists y. (Sound(x) & ReflectsOff(x, y) & SmoothSurface(y))", "Echo(x) <-> (Sound(x) & exists y. (SmoothSurface(y) & ReflectsOff(x, y)))", "Echo(x) <-> (Sound(x) & exists y. (ReflectsOff(x, y) & SmoothSurface(y)))", "Echo(x) <-> (Sound(x) & exists y. (ReflectsOff(x, y) & SmoothSurface(y)))", "Echo(x) <-> (Sound(x) & exists y. (SmoothSurface(y) & Reflects(x, y)))", "all x. (Echo(x) <-> (Sound(x) & exists y. (ReflectsOff(x, y) & SmoothSurface(y))))", "exists x. (Echo(x) & all y. (Sound(y) & ReflectsOff(y, z) & SmoothSurface(z) -> x = Reflection(y)))", "all x. (Echo(x) <-> exists y. (Sound(y) & ReflectsOff(y, SmoothSurface)))", "Echo(x) <-> (Sound(x) & ReflectsOff(x, SmoothSurface(y)))", "Echo(x) <-> (Sound(x) & exists y. (SmoothSurface(y) & ReflectsOff(x, y)))", "Echo(x) <-> exists y. (Sound(y) & ReflectsOff(y, x) & SmoothSurface(x))", "Echo(x) <-> (SoundReflectsOffSmoothSurface(x))"]}
{"id": "entailmentbank_validation_925", "nl": "echo will not be produced.", "fol": "", "prediction": ["-Produced(echo)", "-Produced(echo)", "-Exists(echo, Produced(echo))", "-EchoProduced(echo)", "-Produced(echo)", "-Produced(echo)", "-Produced(echo)", "-Produced(echo)", "-Produced(echo)", "-Produced(echo)", "-EchoProduced", "-Producing(echo)", "-Produced(echo)", "-EchoProduced(echo)", "-Produced(echo)", "-Produced(echo)"]}
{"id": "entailmentbank_validation_926", "nl": "helium is less in density than air.", "fol": "", "prediction": ["LessDense(helium, air)", "LessDense(helium, air)", "LessDense(helium, air)", "LessDense(helium, air)", "LessDense(helium, air)", "LessInDensity(helium, air)", "LessDense(helium, air)", "LessInDensity(helium, air)", "LessDense(helium, air)", "LessDense(helium, air)", "Density(helium, d1) & Density(air, d2) & d1 < d2", "LessDense(helium, air)", "LessDense(helium, air)", "Density(helium) < Density(air)", "LessDense(helium, air)", "LessInDensity(helium, air)"]}
{"id": "entailmentbank_validation_927", "nl": "a balloon is a kind of container.", "fol": "", "prediction": ["Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Balloon(b) -> Container(b)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)", "Container(balloon)"]}
{"id": "entailmentbank_validation_928", "nl": "a balloon filled with helium is an example of a container contains a substance with less density than air.", "fol": "", "prediction": ["exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & exists y. (Substance(y) & Contains(x, y) & LessDensityThan(y, air)))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, y) & Container(y) & exists z. (Substance(z) & Contains(x, z) & LessDensity(z, air)))", "exists x. exists y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, z) & Container(z) & Contains(x, y) & Substance(y) & LessDensity(y, air))", "exists x. (Balloon(x) & FilledWith(x, helium) & Container(x) & exists y. (Substance(y) & Contains(x, y) & LessDensityThan(y, air)))", "exists x. (Balloon(x) & FilledWith(x, helium) & IsExampleOf(x, y) & Container(y) & exists z. (Substance(z) & Contains(x, z) & LessDensityThan(z, air)))", "exists x. (Balloon(x) & FilledWith(x, helium) & exists y. (Container(y) & ExampleOf(x, y) & exists z. (Substance(z) & Contains(y, z) & LessDensityThan(z, air))))", "exists a, b. (Balloon(a) & FilledWith(a, helium) & Container(a) & Substance(b) & -Contains(a, b) & LessDenseThan(b, air))", "exists x. exists y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, y) & Container(y) & Contains(x, z) & Substance(z) & LessDensityThan(z, air))", "exists x. exists y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & Contains(x, y) & Substance(y) & LessDensityThan(y, air))", "exists x, y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & Contains(y) & Substance(y, helium) & LessDensityThan(y, air))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & exists y. (Contains(x, y) & Substance(y) & LessDensityThan(y, air)))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, Container) & exists y. (Substance(y) & Contains(x, y) & LessDensityThan(y, air)))", "exists x. exists y. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, z) & Container(z) & Substance(y) & Contains(x, y) & LessDensityThan(y, air))", "exists x. (Balloon(x) & FilledWith(x, helium) & IsExampleOf(x, exists y. (Container(y) & Contains(y, z) & Substance(z) & LessDensityThan(z, air))))", "exists b. (Balloon(b) & FilledWith(b, helium) & ContainerContainsSubstanceWithLessDensityThanAir(b))", "exists x. (Balloon(x) & FilledWith(x, helium) & ExampleOf(x, y) & Container(y) & exists z. (Substance(z) & Contains(x, z) & LessDensityThan(z, air)))"]}
{"id": "entailmentbank_validation_929", "nl": "if a container contains a substance with less density than air then that container may move upward.", "fol": "", "prediction": ["all x. all y. ((Container(x) & Contains(x, y) & LessDenseThan(y, air)) -> MayMoveUpward(x))", "all x. (all y. (Container(x) & Contains(x, y) & Substance(y) & DensityLessThan(y, air) -> MayMoveUpward(x)))", "all x. all y. (Container(x) & Contains(x, y) & DensityLessThan(y, air) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Contains(x, y) & (Density(y) < Density(air))) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Contains(x, y) & Substance(y) & DensityLessThan(y, air)) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Contains(x, y) & Substance(y) & LessDensityThanAir(y)) -> MayMoveUpward(x))", "all x. (all y. (Container(x) & Contains(x, y) & LessDensityThanAir(y) -> MayMoveUpward(x)))", "all x. (all y. (Container(x) & Contains(x, y) & LessDenseThan(y, air) -> MayMoveUpward(x)))", "all x. all y. ((Container(x) & Contains(x, y) & Density(y) < Density(air)) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Contains(x, y) & LessDensityThanAir(y)) -> MayMoveUpward(x))", "all x, y. ((Container(x) & Contains(x, y) & DensityLessThan(y, air)) -> MayMoveUpward(x))", "all c. all s. ((Container(c) & Contains(c, s) & LessDensityThanAir(s)) -> MayMoveUpward(c))", "all x. (all y. ((Container(x) & Contains(x, y) & LessDensityThanAir(y)) -> MayMoveUpward(x)))", "all x. all y. ((Container(x) & Contains(x, y) & LessDensityThan(y, air)) -> MayMoveUpward(x))", "all x. all y. ((Container(x) & Substance(y) & Contains(x, y) & LessDenseThan(y, air)) -> MayMoveUpward(x))", "all x. (contains(x, y) & LessDensityThan(y, air) -> MayMoveUpward(x))"]}
{"id": "entailmentbank_validation_930", "nl": "the balloon filled with helium may move upward if released.", "fol": "", "prediction": ["exists x. (Balloon(x) & FilledWithHelium(x) -> Released(x) -> MayMoveUpward(x))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists y. (Balloon(y) & FilledWithHelium(y) -> IfReleased(y) -> MayMoveUpward(y))", "exists x. (Balloon(x) & FilledWithHelium(x) & (Released(x) -> MayMoveUpward(x)))", "exists x. (Balloon(x) & FilledWithHelium(x) -> MayMoveUpward(x) if Released(x))", "exists x. (Balloon(x) & FilledWithHelium(x) -> (Released(x) -> MayMoveUpward(x)))", "Exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists y. (Balloon(y) & FilledWith(y, helium) -> (Released(y) -> MovesUpward(y)))", "exists x. ((Balloon(x) & FilledWithHelium(x)) -> (Released(x) -> MayMoveUpward(x)))", "exists x. (Balloon(x) & FilledWithHelium(x) -> MayMoveUpwardIfReleased(x))", "FOL Translation:\nall x. (Balloon(x) & FilledWith(x, helium) & Released(x) -> MayMoveUpward(x))", "exists x. (Balloon(x) & FilledWithHelium(x) -> MayMoveUpwardIfReleased(x))", "exists x. (Balloon(x) & FilledWithHelium(x) -> (Released(x) -> MayMoveUpward(x)))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))", "exists x. (Balloon(x) & FilledWith(x, helium) -> MayMoveUpwardIfReleased(x))"]}
{"id": "entailmentbank_validation_931", "nl": "a white object reflects all visible light.", "fol": "", "prediction": ["all x. (Object(x) & White(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "FOL Translation:\nall x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((Object(x) & IsWhite(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((Object(x) & White(x)) -> (all y. (VisibleLight(y) -> Reflects(x, y))))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((Object(x) & White(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteObject(x) -> ReflectsAllVisibleLight(x))", "exists x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((WhiteObject(x) & VisibleLight(y)) -> Reflects(x, y))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "exists x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. ((Object(x) & White(x)) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteObject(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))"]}
{"id": "entailmentbank_validation_932", "nl": "the floor is a kind of object.", "fol": "", "prediction": ["Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)", "Object(floor)"]}
{"id": "entailmentbank_validation_933", "nl": "a white door will reflect all visible light.", "fol": "", "prediction": ["exists x. (Door(x) & White(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteDoor(x) -> Reflects(x, VisibleLight))", "FOL Translation:\nall x. (Door(x) & White(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteDoor(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "FOL Translation:\n\nall x. (WhiteDoor(x) -> Reflects(x, VisibleLight))", "all x. (WhiteDoor(x) -> ReflectsAllVisibleLight(x))", "exists x. (WhiteDoor(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (Door(x) & White(x) -> Reflects(x, visible_light))", "all x. (WhiteDoor(x) -> Reflects(x, VisibleLight))", "all y. ((Door(y) & White(y)) -> ReflectsAllVisibleLight(y))", "all x. (WhiteDoor(x) -> ReflectsAllVisibleLight(x))", "all x. (WhiteDoor(x) -> ReflectsAllVisibleLight(x))", "all x. (WhiteDoor(x) -> Reflects(x, VisibleLight))", "all x. (WhiteDoor(x) -> Reflects(x, VisibleLight))", "exists x. (WhiteDoor(x) -> all y. (VisibleLight(y) -> Reflects(x, y)))", "all x. (WhiteDoor(x) -> Reflects(x, VisibleLight))"]}
{"id": "entailmentbank_validation_934", "nl": "the ice melts.", "fol": "", "prediction": ["Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)", "Melts(ice)"]}
{"id": "entailmentbank_validation_935", "nl": "melting is a kind of phase change.", "fol": "", "prediction": ["KindOf(melting, phase_change)", "PhaseChange(melting)", "all x. (Melting(x) -> PhaseChange(x))", "KindOf(melting, phase_change)", "PhaseChange(melting)", "PhaseChange(melting)", "PhaseChange(melting)", "PhaseChange(melting)", "all x. (Melting(x) -> PhaseChange(x))", "KindOf(melting, phase_change)", "PhaseChange(melting)", "PhaseChange(melting)", "PhaseChange(melting)", "PhaseChange(melting)", "KindOf(melting, phase_change)", "PhaseChange(melting)"]}
{"id": "entailmentbank_validation_936", "nl": "the ice undergoes a phase change.", "fol": "", "prediction": ["PhaseChange(ice)", "PhaseChange(ice)", "Exists y. (PhaseChange(y) & Undergoes(ice, y))", "PhaseChange(ice)", "exists x. (Ice(x) & UndergoesPhaseChange(x))", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)", "PhaseChange(ice)"]}
{"id": "entailmentbank_validation_937", "nl": "phase changes do not change mass.", "fol": "", "prediction": ["all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> -ChangesMass(x))", "all x. (PhaseChange(x) -> all y. (Mass(y) -> -ChangesMass(x, y)))", "FOL Translation:\nall x. (PhaseChange(x) -> -ChangesMass(x))"]}
{"id": "entailmentbank_validation_938", "nl": "the mass of the ice will not change.", "fol": "", "prediction": ["exists x. (Ice(x) -> -Change(Mass(x)))", "all x. (Ice(x) -> -Changes(MassOf(x)))", "all x. (Ice(x) -> -ChangesMass(x))", "Change(Mass(ice)) = false", "The FOL translation for the sentence \"the mass of the ice will not change.\" involves capturing the idea that there exists some specific ice whose mass does not change. Here is how you might translate that:\n\nexists x. (Ice(x) & -ChangesMass(x))", "Exist x. (IceMass(x) & -Change(IceMass(x)))", "exists x. (Ice(x) -> -ChangesMass(x))", "Change(mass(ice)) -> False", "all x. (Ice(x) -> -ChangesMass(x))", "Change(mass(ice))", "Mass(ice, m) & -Change(m)", "all x. (Ice(x) -> -Change(Mass(x)))", "Change(Mass(ice)) = false", "Change(mass(ice))", "Change(mass(ice))", "exists x. (Ice(x) & -Change(Mass(x)))"]}
{"id": "entailmentbank_validation_939", "nl": "a bubble is made of pockets of gas trapped inside a liquid or solid.", "fol": "", "prediction": ["all x. (Bubble(x) -> exists y. (Gas(y) & TrappedInside(y, z) & (Liquid(z) | Solid(z))))", "exists x. (Bubble(x) & (exists y. (PocketsOfGas(y) & MadeOf(x, y) & (exists z. (TrappedInside(y, z) & (Liquid(z) | Solid(z)))))))", "FOL Translation:\nall x. (Bubble(x) -> exists y. (Gas(y) & TrappedInside(y, x) & (Liquid(x) | Solid(x))))", "all x. (Bubble(x) -> exists y. (Gas(y) & MadeOfPocketsOf(x, y) & (TrappedInside(x, Liquid) | TrappedInside(x, Solid))))", "all x. (Bubble(x) -> exists y. (exists z. (Gas(y) & (Liquid(z) | Solid(z)) & MadeOfPockets(x, y, z))))", "exists x. (Bubble(x) & (Liquid(y) | Solid(y)) & MadeOf(x, GasPockets(z, y)))", "exists x. (Bubble(x) & (exists y. (PocketOfGas(y) & TrappedInside(y, LiquidOrSolid(x)))))", "exists x. (Bubble(x) & (exists y. (Gas(y) & PocketsOfGas(y, x)) & (exists z. ((Liquid(z) | Solid(z)) & TrappedInside(x, z)))))", "exists x. (Bubble(x) & (exists y. (PocketsOfGas(y) & TrappedInside(y, z) & (Liquid(z) | Solid(z)))))", "exists x. (Bubble(x) & exists y. (Gas(y) & TrappedIn(y, x) & (Liquid(x) | Solid(x))))", "all x. (Bubble(x) -> exists y. (Gas(y) & PocketsOf(y, x) & (Inside(x, Liquid(x)) | Inside(x, Solid(x)))))", "exists x. (Bubble(x) -> exists y. (GasPockets(y) & TrappedInside(y, x) & (Liquid(x) | Solid(x))))", "exists x. (Bubble(x) & (exists y. (PocketOfGas(y) & TrappedIn(y, Liquid) | TrappedIn(y, Solid))))", "all x. (Bubble(x) -> exists y. (PocketsOfGas(y) & TrappedInside(y, LiquidOrSolid(x))))", "all x. (Bubble(x) -> exists y. (PocketOfGas(y) & TrappedInside(y, LiquidOrSolid)))", "exists x. (Bubble(x) & exists y. (Gas(y) & Pockets(y) & exists z. ((Liquid(z) | Solid(z)) & TrappedInside(y, z))))"]}
{"id": "entailmentbank_validation_940", "nl": "soap bubbles are made of air trapped inside soap liquid.", "fol": "", "prediction": ["all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, TrappedInside(y, SoapLiquid))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, TrappedInside(y, SoapLiquid))))", "all x. (SoapBubble(x) -> exists y exists z. (Air(y) & SoapLiquid(z) & MadeOf(x, y) & TrappedInside(y, z)))", "all x. (SoapBubble(x) -> exists y. (MadeOf(x, Air(y)) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, TrappedInside(y, SoapLiquid))))", "all z. (SoapBubble(z) -> exists x. exists y. (Air(x) & SoapLiquid(y) & TrappedInside(x, y) & MadeOf(z, Trapped(x, y))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, x) & MadeOf(x, SoapLiquid)))", "all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, AirInsideSoapLiquid(y))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, x) & SoapLiquid(x)))", "all x. (SoapBubble(x) -> exists y exists z. (Air(y) & SoapLiquid(z) & MadeOf(x, y, z) & TrappedIn(y, z)))", "all z. (SoapBubble(z) -> exists x. (Air(x) & TrappedInside(x, SoapLiquid(z))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & TrappedInside(y, SoapLiquid(x))))", "all x. (SoapBubble(x) -> exists y. (Air(y) & MadeOf(x, TrappedInside(y, SoapLiquid))))"]}
{"id": "entailmentbank_validation_941", "nl": "air is inside the soap bubbles.", "fol": "", "prediction": ["exists x. (SoapBubble(x) & exists y. (Air(y) & Inside(y, x)))", "exists x. (SoapBubble(x) & Inside(air, x))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))", "exists x. (SoapBubble(x) & exists y. (Air(y) & Inside(y, x)))", "exists x. (SoapBubble(x) -> Inside(air, x))", "exists x. (SoapBubble(x) & Inside(air, x))", "exists x. (SoapBubble(x) & Inside(air, x))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))", "exists x. (SoapBubble(x) & AirInside(x))", "all b. (SoapBubble(b) -> exists a. (Air(a) & Inside(a, b)))", "exists x. (SoapBubble(x) & Inside(air, x))", "exists x. (SoapBubble(x) & Inside(air, x))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))", "all x. (SoapBubble(x) -> Inside(air, x))", "all x. (SoapBubble(x) -> exists y. (Air(y) & Inside(y, x)))", "exists x. (SoapBubble(x) & Inside(air, x))"]}
{"id": "entailmentbank_validation_942", "nl": "matter in the liquid phase has definite volume and variable shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (HasDefiniteVolume(x) & HasVariableShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & VariableShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "FOL Translation:\nall x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & VariableShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (HasDefiniteVolume(x) & HasVariableShape(x)))"]}
{"id": "entailmentbank_validation_943", "nl": "indefinite means variable.", "fol": "", "prediction": ["Means(indefinite, variable)", "Indefinite(means, variable)", "Means(indefinite, variable)", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> IsVariable(x))", "Means(indefinite, variable)", "Means(indefinite, variable)", "all x. (Indefinite(x) -> Variable(x))", "all x. (Indefinite(x) -> Variable(x))", "Means(indefinite, variable)", "Indefinite(variable)", "all x. (Indefinite(x) -> Variable(x))", "Means(indefinite, variable)", "Indefinite(variable)"]}
{"id": "entailmentbank_validation_944", "nl": "matter in the liquid phase has definite volume and indefinite shape.", "fol": "", "prediction": ["all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Matter(x) & InLiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. ((Matter(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. ((Matter(x) & InLiquidPhase(x)) -> (HasDefiniteVolume(x) & HasIndefiniteShape(x)))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. (Matter(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))"]}
{"id": "entailmentbank_validation_945", "nl": "substances are made of matter.", "fol": "", "prediction": ["all x. (Substance(x) -> MadeOf(x, matter))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))", "all x. (Substance(x) -> MadeOfMatter(x))"]}
{"id": "entailmentbank_validation_946", "nl": "a compound is a kind of substance.", "fol": "", "prediction": ["all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))", "all x. (Compound(x) -> Substance(x))"]}
{"id": "entailmentbank_validation_947", "nl": "a compound is made of matter.", "fol": "", "prediction": ["all x. (Compound(x) -> MadeOf(x, matter))", "exists x. (Compound(x) -> MadeOf(x, matter))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all c. (Compound(c) -> exists m. (Matter(m) & MadeOf(c, m)))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all x. (Compound(x) -> MadeOfMatter(x))", "exists x. (Compound(x) -> MadeOf(x, matter))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "all x. (Compound(x) -> MadeOf(x, matter))", "exists x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "exists x. (Compound(x) -> Matter(x))", "all x. (Compound(x) -> exists y. (Matter(y) & MadeOf(x, y)))", "exists x. (Compound(x) -> MadeOf(x, Matter))"]}
{"id": "entailmentbank_validation_948", "nl": "a compound in the liquid phase has definite volume and indefinite shape.", "fol": "", "prediction": ["exists x. (Compound(x) & LiquidPhase(x) & DefiniteVolume(x) & IndefiniteShape(x))", "exists x. ((Compound(x) & LiquidPhase(x)) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "exists x. (Compound(x) & HasPhase(x, liquid) & DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & InLiquidPhase(x) -> (HasDefiniteVolume(x) & HasIndefiniteShape(x)))", "exists x. (Compound(x) & LiquidPhase(x) & DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & HasPhase(x, liquid) -> DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & InLiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "all x. (Compound(x) & LiquidPhase(x) -> HasDefiniteVolume(x) & HasIndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Compound(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) & DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) -> HasDefiniteVolume(x) & HasIndefiniteShape(x))", "exists x. (Compound(x) & Phase(x, liquid) -> (DefiniteVolume(x) & IndefiniteShape(x)))", "all x. (Compound(x) & LiquidPhase(x) -> DefiniteVolume(x) & IndefiniteShape(x))", "exists x. (Compound(x) & LiquidPhase(x) -> (DefiniteVolume(x) & IndefiniteShape(x)))"]}
{"id": "entailmentbank_validation_949", "nl": "water is in the solid state, called ice.", "fol": "", "prediction": ["Solid(water) & Called(ice, water) & Ice(ice)", "InSolidState(water) & Ice(water)", "SolidState(water) & Called(ice, water)", "SolidState(water) & Ice(water)", "SolidState(water) & Called(water, ice)", "SolidState(water) & Called(ice)", "SolidState(water) & Called(ice, \"solid state\")", "Exists x. (SolidState(x) & Water(x) & Called(x, ice))", "SolidState(water) & Called(ice, solidState)", "SolidState(water) & Called(ice, water)", "Exists x. (Water(x) & SolidState(x) & Ice(x))", "SolidState(water) & Called(ice)", "SolidState(water) & Called(ice, water)", "Ice(water) & SolidState(water)", "Exists x. (Water(x) & SolidState(x) & Called(x, ice))", "Exists x. (Water(x) & SolidState(x) & Called(x, ice))"]}
{"id": "entailmentbank_validation_950", "nl": "hail is a kind of ice.", "fol": "", "prediction": ["KindOf(hail, ice)", "Ice(hail)", "Ice(hail)", "KindOf(hail, ice)", "Ice(hail)", "Kind(hail, ice)", "KindOf(hail, ice)", "Ice(hail)", "Ice(hail)", "Ice(hail)", "Ice(hail)", "Ice(hail)", "Ice(hail)", "KindOf(hail, ice)", "KindOf(hail, ice)", "KindOf(hail, ice)"]}
{"id": "entailmentbank_validation_951", "nl": "hail is water in solid ice.", "fol": "", "prediction": ["all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> Water(x) & SolidIce(x))", "all x. (Hail(x) -> Water(x) & SolidIce(x))", "all x. (Hail(x) -> Water(x) & SolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> (Water(x) & SolidIce(x)))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all z. (Hail(z) -> exists w. (Water(w) & SolidIce(w) & Contains(z, w)))", "all x. (Hail(x) -> Water(x) & SolidIce(x))", "all x. (Hail(x) -> Water(x) & InSolidForm(x, ice))", "all x. (Hail(x) -> Water(x) & SolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> WaterInSolidIce(x))", "all x. (Hail(x) -> (Water(x) & SolidIce(x)))"]}
{"id": "entailmentbank_validation_952", "nl": "an airplane is used for moving people to far away places.", "fol": "", "prediction": ["exists x. (Airplane(x) & usedFor(x, movingPeople) & Purpose(x, moveToFarPlaces))", "exists x. (Airplane(x) & UsedFor(x, MovePeopleFarAway))", "exists x. (Airplane(x) & UsedForMovingPeopleToFarAwayPlaces(x))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "exists x. (Airplane(x) & UsedFor(x, y) & MovingPeople(y) & FarAwayPlaces(y))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "exists x exists y exists z. (Airplane(x) & People(y) & FarAwayPlace(z) & UsedFor(x, Moving(y, z)))", "exists x. (Airplane(x) & UsedForMovingPeopleToFarAwayPlaces(x))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "Exists x. (Airplane(x) & UsedFor(x, 'moving people to far away places'))", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "exists x. (Airplane(x) & UsedFor(x, movingPeopleToFarAwayPlaces))", "Exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))", "exists x. (Airplane(x) & UsedFor(x, MovePeopleToFarAwayPlaces))", "Airplane(x) -> UsedForMovingPeopleToFarAwayPlaces(x)", "exists x. (Airplane(x) & UsedFor(x, MovingPeopleToFarAwayPlaces))"]}
{"id": "entailmentbank_validation_953", "nl": "an airplane is fast in speed.", "fol": "", "prediction": ["FastSpeed(airplane)", "FastInSpeed(airplane)", "FastInSpeed(airplane)", "FastSpeed(airplane)", "FastSpeed(airplane)", "FastInSpeed(airplane)", "FastInSpeed(airplane)", "FastInSpeed(airplane)", "Airplane(airplane) & FastInSpeed(airplane)", "Fast(airplane)", "FastInSpeed(airplane)", "Fast(airplane)", "FastInSpeed(airplane)", "FastInSpeed(airplane)", "FastInSpeed(airplane)", "Fast(airplane)"]}
{"id": "entailmentbank_validation_954", "nl": "an airplane can move people to far away places quickly.", "fol": "", "prediction": ["exists a. (Airplane(a) -> CanMoveToFarAwayPlacesQuickly(a))", "exists a. (Airplane(a) & exists p. (Person(p) & exists d. (FarAwayPlace(d) & CanMoveToQuickly(a, p, d))))", "exists x. (Airplane(x) -> CanMovePeopleToFarAwayPlacesQuickly(x))", "exists x. (Airplane(x) -> CanMovePeopleQuicklyToFarAwayPlaces(x))", "exists x. (Airplane(x) -> CanMovePeopleToFarPlacesQuickly(x))", "exists x. (Airplane(x) -> exists y. (Person(y) & exists z. (FarAwayPlace(z) & CanMoveToQuickly(x, y, z))))", "exists x. (Airplane(x) -> CanMovePeopleToFarPlacesQuickly(x))", "exists x. (Airplane(x) -> exists y z. (Person(y) & Place(z) & MovesTo(x, y, z) & FarAway(z) & Quickly(x)))", "exists x. (Airplane(x) -> (exists y. (Person(y) & FarAwayPlace(z) & CanMoveToQuickly(x, y, z))))", "exists x. (Airplane(x) -> CanMovePeopleToFarAwayPlacesQuickly(x))", "exists x. (Airplane(x) -> CanMovePeopleToFarAwayPlacesQuickly(x))", "exists x. (Airplane(x) -> all y z. (Person(y) & FarAwayPlace(z) -> CanMoveQuickly(x, y, z)))", "exists a, p, f. (Airplane(a) & People(p) & FarAwayPlace(f) & CanMoveQuicklyTo(a, p, f))", "exists a. (Airplane(a) & all p. (Person(p) -> exists l. (FarAwayPlace(l) & CanMoveToQuickly(a, p, l))))", "exists x. (Airplane(x) -> exists y. (Person(y) & exists z. (FarAwayPlace(z) & MoveQuickly(x, y, z))))", "exists x. (Airplane(x) & all y. (Person(y) -> exists z. (FarAwayPlace(z) & CanMoveToQuickly(x, y, z))))"]}
{"id": "entailmentbank_validation_955", "nl": "a cake is a kind of baked product.", "fol": "", "prediction": ["Cake(a) -> BakedProduct(a)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "Cake(a) -> BakedProduct(a)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "BakedProduct(cake)", "Cake(x) -> BakedProduct(x)", "BakedProduct(cake)", "BakedProduct(cake)"]}
{"id": "entailmentbank_validation_956", "nl": "baking is when a human makes food by adding heat.", "fol": "", "prediction": ["all x. (Baking(x) <-> (Human(y) & Makes(y, x) & Food(x) & AddsHeat(y, x)))", "all x, y, z. (Baking(y, z) <-> (Human(x) & Makes(x, y) & Food(y) & AddsHeat(x, y)))", "all x. (Baking(x) <-> exists y. (Human(y) & Makes(y, x) & Food(x) & AddsHeat(y, x)))", "all x. (Baking(x) <-> exists y exists z. (Human(y) & Makes(y, z) & Food(z) & AddsHeat(y, z)))", "all x. (Baking(x) <-> exists y z. (Human(y) & Food(z) & Makes(y, z) & AddsHeat(y, z)))", "all x. (Baking(x) <-> exists y, z, w. (Human(y) & Makes(y, z) & Food(z) & AddsHeat(y, z) & Food(z) = x))", "To properly translate the sentence \"baking is when a human makes food by adding heat\" into first-order logic, we look to define it in terms of predicates that give conditions under which a person performs baking. The predicates that can be used are:\n\n- `Human(x)`: `x` is a human.\n- `Makes(x, y)`: `x` makes `y`.\n- `Food(y)`: `y` is food.\n- `AddsHeat(x, y)`: `x` adds heat to `y`.\n- `Baking(x, y)`: `x` bakes `y`.\n\nFOL Translation:\nall x, y. (Human(x) & Food(y) & Makes(x, y) & AddsHeat(x, y) -> Baking(x, y))", "all x. (Baking(x) <-> (Human(x) & MakesFood(x) & AddsHeat(x)))", "all x y z. (Baking(x, y, z) <-> (Human(x) & Makes(x, y) & Food(y) & AddsHeat(x, y, z)))", "all x. (Baking(x) <-> exists y. exists z. (Human(y) & Food(z) & Makes(y, z) & AddsHeat(y, z)))", "all x. (Baking(x) <-> (exists y. (Human(y) & MakesFoodByAddingHeat(y, x))))", "all x. (Baking(x) <-> (exists y z. (Human(x) & Makes(x, z) & Food(z) & AddsHeat(x, z))))", "Baking(x) <-> exists y. (Human(y) & Makes(y, x) & Food(x) & AddingHeat(y, x))", "all x y. (Baking(x) <-> (Human(y) & MakesFoodByAddingHeat(y, x)))", "all x. (Baking(x) <-> exists y z. (Human(y) & Food(z) & Makes(y, z, x) & AddsHeat(x)))", "all x. (Baking(x) <-> (exists y, z. (Human(y) & Food(z) & Makes(y, z) & AddsHeat(y, z))))"]}
{"id": "entailmentbank_validation_957", "nl": "a cake is a product made by human adding heat to it.", "fol": "", "prediction": ["exists x. (Cake(x) -> exists y. (Product(y) & MadeByHuman(x, y) & AddedHeatTo(x, y)))", "exists x. (Cake(x) & Product(x) & exists y. (Human(y) & Makes(y, x) & AddsHeat(y, x)))", "exists y. (Cake(y) & Product(y) & exists x. (Human(x) & AddsHeatTo(x, y)))", "exists x. (Cake(x) & Product(x) & exists y. (Human(y) & Makes(x, y) & AddsHeat(y, x)))", "Cake(x) -> exists y. (Product(x) & MadeByHuman(x) & AddsHeat(y, x))", "all x. ((Cake(x) & exists y. (Human(y) & MakesWithHeat(y, x))) -> Product(x))", "exists x. (Cake(x) & exists y. (Product(y) & all z. ((Human(z) & AddsHeatTo(z, x)) -> MadeBy(y, z))))", "Cake(a) -> exists b. (Product(a) & MadeByHuman(a) & Human(b) & AddsHeat(b, a))", "exists x. (Cake(x) & Product(x) & exists y. (Human(y) & AddsHeat(y, x)))", "exists x. (Cake(x) & exists y. (Product(y) & MadeByHuman(y) & AddsHeatTo(x, y)))", "Cake(a) & Product(a) & exists b. (Human(b) & MakesByAddingHeatTo(a, b))", "exists x. (Cake(x) & exists y. (Human(y) & MakesByAddingHeat(y, x) & Product(x)))", "exists x. (Cake(x) & exists y. (Product(y) & Made(x, y) & exists z. (Human(z) & AddsHeat(z, x))))", "exists x. (Cake(x) & Product(x) & exists y. (Human(y) & AddsHeatTo(y, x)))", "exists x. (Cake(x) -> exists y. (Product(y) & MadeByAddingHeat(x, y) & MadeBy(x, human)))", "exists x. (Cake(x) -> exists y. (Product(y) & MadeByAddingHeat(y, x) & exists z. (Human(z) & Makes(z, y))))"]}
{"id": "entailmentbank_validation_958", "nl": "transportation technology is a kind of system for moving people and products.", "fol": "", "prediction": ["all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))", "System(transportation_technology) & all x. ((People(x) | Product(x)) -> CanMove(transportation_technology, x))", "all x. ((TransportationTechnology(x)) -> (SystemForMoving(x) & Moves(x, people) & Moves(x, products)))", "all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))", "all x. (TransportationTechnology(x) -> KindOfSystemForMovingPeopleAndProducts(x))", "KindOf(transportation_technology, system) & ForMoving(transportation_technology, people) & ForMoving(transportation_technology, products)", "all x. (TransportationTechnology(x) -> (System(x) & ForMovingPeopleAndProducts(x)))", "all x. (TransportationTechnology(x) -> SystemForMoving(x, people, products))", "all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))", "all x. (TransportationTechnology(x) -> (System(x) & ForMovingPeopleAndProducts(x)))", "all x. (TransportationTechnology(x) -> exists y. (System(y) & Moves(x, PeopleAndProducts(y))))", "System(transportation_technology) & KindOf(transportation_technology, System) & ForMovingPeopleAndProducts(transportation_technology)", "all x. (TransportationTechnology(x) -> SystemForMoving(x, People) & SystemForMoving(x, Products))", "all x. ((TransportationTechnology(x) & System(x)) -> (exists y z. (Moves(y, x) & Moves(z, x) & (Person(y) | Product(z)))))", "all x. ((TransportationTechnology(x) -> System(x)) & (Function(x, MovingPeople) & Function(x, MovingProducts)))", "all x. (TransportationTechnology(x) -> SystemForMovingPeopleAndProducts(x))"]}
{"id": "entailmentbank_validation_959", "nl": "transportation technology is used for moving people / products.", "fol": "", "prediction": ["exists x. (TransportationTechnology(x) & UsedFor(x, MovingPeopleOrProducts))", "exists x. (TransportationTechnology(x) & UsedFor(x, moving_people_products))", "exists x. (TransportationTechnology(x) & UsedForMoving(x, people)) | exists y. (TransportationTechnology(y) & UsedForMoving(y, products))", "exists x. (TransportationTechnology(x) & UsedFor(x, moving_people_products))", "exists y. (TransportationTechnology(y) & UsedFor(y, moving_people_products))", "exists x. ((TransportationTechnology(x) & UsedFor(x, MovingPeople)) | (TransportationTechnology(x) & UsedFor(x, MovingProducts)))", "exists t. (TransportationTechnology(t) & all x. (Person(x) | Product(x) -> UsedForMoving(t, x)))", "exists x. (TransportationTechnology(x) & UsedForMovingPeopleProducts(x))", "exists x. (TransportationTechnology(x) & UsedFor(x, MovingPeopleOrProducts))", "exists x. (TransportationTechnology(x) & UsedFor(x, MovingPeopleOrProducts))", "exists x. (TransportationTechnology(x) & UsedForMoving(x, people) & UsedForMoving(x, products))", "exists t. (TransportationTechnology(t) & UsedFor(t, move)) & all x. ((Person(x) | Product(x)) -> CanMove(x, t))", "exists x. (TransportationTechnology(x) & UsedFor(x, MovingPeopleAndProducts))", "exists x. (TransportationTechnology(x) -> UsedFor(x, MovingPeople) | UsedFor(x, MovingProducts))", "FOL Translation:\nall x. (TransportationTechnology(x) -> UsedFor(x, MovingPeopleOrProducts))", "exists x. (TransportationTechnology(x) & UsedFor(x, MovingPeople) & UsedFor(x, MovingProducts))"]}
{"id": "entailmentbank_validation_960", "nl": "transportation technology is a system that moves people and products.", "fol": "", "prediction": ["System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "all x. (TransportationTechnology(x) -> System(x) & Moves(x, people) & Moves(x, products))", "all x. (TransportationTechnology(x) -> System(x) & Moves(x, people) & Moves(x, products))", "System(transportation_technology) & all y. (Moves(transportation_technology, y) -> (Person(y) | Product(y)))", "System(transportation_technology) & MovesPeople(transportation_technology) & MovesProducts(transportation_technology)", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "all x. (TransportationTechnology(x) -> System(x) & MovesPeopleAndProducts(x))", "all x. (TransportationTechnology(x) -> IsSystem(x) & Moves(x, people) & Moves(x, products))", "all x. (TransportationTechnology(x) -> System(x) & MovesPeople(x) & MovesProducts(x))", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "all x. (TransportationTechnology(x) -> System(x) & MovesPeopleAndProducts(x))", "System(transportation_technology) & MovesPeople(transportation_technology) & MovesProducts(transportation_technology)", "System(transportation_technology) & all x. ((Person(x) | Product(x)) -> Moves(transportation_technology, x))", "all x. (TransportationTechnology(x) -> (System(x) & Moves(x, people) & Moves(x, products)))"]}
{"id": "entailmentbank_validation_961", "nl": "a refrigerator is used for keeping food fresh for a long period of time.", "fol": "", "prediction": ["UsedFor(refrigerator, KeepingFoodFreshForLongTime)", "exists x. (Refrigerator(x) -> UsedForKeepingFoodFreshForLong(x))", "UsedFor(refrigerator, KeepingFoodFreshForLongPeriod)", "exists x. (Refrigerator(x) & all y. (Food(y) -> UsedFor(x, KeepsFreshForLongPeriod(y))))", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongTime))", "UsedFor(refrigerator, KeepingFoodFreshForLongPeriodOfTime)", "UsedFor(refrigerator, KeepingFoodFreshForLongPeriod)", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongPeriod))", "Exists x. (Refrigerator(x) & UsedFor(x, y) & KeepingFoodFresh(y) & LongPeriodOfTime(y))", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongTime))", "Refrigerator(obj) -> UsedFor(obj, KeepingFresh(food, long_time))", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFresh) & ForLongPeriodOfTime(x))", "UsedFor(refrigerator, KeepingFoodFreshForLongTime)", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongPeriodOfTime))", "exists x. (Refrigerator(x) & UsedFor(x, KeepingFoodFreshForLongTime))", "Refrigerator(refrigerator) -> UsedFor(refrigerator, KeepingFoodFreshForLongPeriod)"]}
{"id": "entailmentbank_validation_962", "nl": "the invention of the refrigerator with self-contained unit occurred in 1923.", "fol": "", "prediction": ["InventionOccurred(refrigerator_with_self_contained_unit, 1923)", "Exists x. (Invention(x) & RefrigeratorWithSelfContainedUnit(x) & OccurredIn(x, 1923))", "Existentially quantified terms are typically best for unique historical events or specific instances. Thus, transforming the given sentence into FOL would look something like this:\n\nexists x. (Invention(x) & RefrigeratorWithSelfContainedUnit(x) & OccurredIn(x, 1923))", "Exists x. (Invention(x) & RefrigeratorWithSelfContainedUnit(x) & OccurredIn(x, 1923))", "Exists x. (Refrigerator(x) & SelfContainedUnit(x) & Invented(x) & YearOfInvention(x, 1923))", "exists x. (Invention(x) & SelfContainedUnitRefrigerator(x) & OccurredIn(x, 1923))", "exists x. (Refrigerator(x) & SelfContainedUnit(x) & InventionOf(x) & OccurredIn(x, 1923))", "InventionOfSelfContainedUnitRefrigeratorOccurredIn(invention, 1923)", "Exists x. (Invention(x) & RefrigeratorWithSelfContainedUnit(x) & OccurredIn(x, 1923))", "Exists x. (RefrigeratorWithSelfContainedUnit(x) & Invention(x) & Occurred(x, 1923))", "Exists x. (RefrigeratorWithSelfContainedUnit(x) & InventionOf(x, 1923))", "Exists x. (RefrigeratorWithSelfContainedUnit(x) & InventionOccurred(x, 1923))", "Exists x. (Refrigerator(x) & SelfContainedUnit(x) & InventionOccurred(x, 1923))", "Exists x. (Refrigerator(x) & SelfContainedUnit(x) & InventionOccurred(x, 1923))", "exists x. (Invention(x) & Refrigerator(x) & SelfContainedUnit(x) & OccurredIn1923(x))", "Exists x. (InventionOfRefrigeratorWithSelfContainedUnit(x) & OccurredIn(x, 1923))"]}
{"id": "entailmentbank_validation_963", "nl": "refrigerator is the invention that can keep food fresh for a long period of time.", "fol": "", "prediction": ["Invention(refrigerator) & CanKeepFoodFreshLong(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLongTime(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLongTime(refrigerator)", "Invention(refrigerator) & CanKeepFoodFresh(refrigerator, long_period_of_time)", "Invention(refrigerator) & CanKeepFoodFreshForLongPeriod(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLong(refrigerator)", "Invention(refrigerator) & CanKeepFreshForLong(refrigerator, food)", "Invention(refrigerator) & CanKeepFoodFresh(refrigerator)", "Invention(refrigerator) & all y. (Food(y) -> (CanKeepFreshForLong(refrigerator, y)))", "Invention(refrigerator) & all x. (Food(x) -> KeepsFreshForLongPeriod(refrigerator, x))", "Invention(refrigerator) & CanKeepFoodFreshForLong(refrigerator)", "Invention(refrigerator) & all x. (Food(x) -> (CanKeepFreshForLongPeriod(refrigerator, x)))", "Invention(refrigerator) & CanKeepFoodFreshForLongPeriod(refrigerator)", "Invention(refrigerator) & all x. (Food(x) -> CanKeepFreshForLongTime(refrigerator, x))", "Invention(refrigerator) & CanKeepFoodFreshForLongPeriod(refrigerator)", "Invention(refrigerator) & CanKeepFoodFreshForLongPeriodOfTime(refrigerator)"]}
{"id": "entailmentbank_validation_964", "nl": "radio station broadcasting is a source of radio waves.", "fol": "", "prediction": ["exists x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "SourceOfRadioWaves(radio_station_broadcasting)", "exists x. (RadioStationBroadcasting(x) & SourceOfRadioWaves(x))", "all x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "SourceOfRadioWaves(radio_station_broadcasting)", "all x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "all x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "exists x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "SourceOfRadioWaves(radio_station_broadcasting)", "all x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "SourceOf(radio_station_broadcasting, radio_waves)", "FOL Translation:\nall x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "all x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "exists x. (RadioStationBroadcasting(x) & SourceOf(x, radio_waves))", "exists x. (RadioStationBroadcasting(x) -> SourceOfRadioWaves(x))", "SourceOfRadioWaves(radio_station_broadcasting)"]}
{"id": "entailmentbank_validation_965", "nl": "a source of something emits that something.", "fol": "", "prediction": ["all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. (SourceOf(y, x) -> Emits(y, x))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x y. (SourceOf(x, y) -> Emits(x, y))", "all x. all y. (SourceOf(x, y) -> Emits(x, y))", "all x y. (SourceOf(x, y) -> Emits(x, y))"]}
{"id": "entailmentbank_validation_966", "nl": "radio station broadcasting emits radio waves.", "fol": "", "prediction": ["exists x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasts(x) -> EmitsRadioWaves(x))", "all z. ((RadioStation(z) & Broadcasting(z)) -> Emits(z, radiowaves))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStationBroadcasting(x) -> EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasting(x) -> Emits(x, radiowaves))", "```FOL\nall x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))\n```", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "all x. (RadioStation(x) & Broadcasting(x) -> EmitsRadioWaves(x))", "exists x. (RadioStation(x) & Broadcasts(x) -> EmitsRadioWaves(x))", "Exists x. ((RadioStation(x) & Broadcasting(x)) -> Emits(x, RadioWaves))"]}
{"id": "entailmentbank_validation_967", "nl": "radio transmitter emits radio waves.", "fol": "", "prediction": ["Emits(radio_transmitter, radio_waves)", "exists x. (RadioTransmitter(x) -> EmitsRadioWaves(x))", "Emits(radio_transmitter, radio_waves)", "Exists x. (RadioTransmitter(x) & exists y. (RadioWave(y) & Emits(x, y)))", "exists x. (RadioTransmitter(x) & Emits(x, RadioWaves))", "Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "Exists xt. (RadioTransmitter(xt) & emitsRadioWaves(xt))", "exists x. (RadioTransmitter(x) & exists y. (RadioWaves(y) & Emits(x, y)))", "exists x. (RadioTransmitter(x) -> EmitsRadioWaves(x))", "Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "Emits(radio_transmitter, radio_waves)", "exists x. (RadioTransmitter(x) -> EmitsRadioWaves(x))"]}
{"id": "entailmentbank_validation_968", "nl": "radio station is a radio transmitter.", "fol": "", "prediction": ["all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))", "all x. (RadioStation(x) -> RadioTransmitter(x))"]}
{"id": "entailmentbank_validation_969", "nl": "pliers are a kind of hand tool.", "fol": "", "prediction": ["all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))", "all x. (Pliers(x) -> HandTool(x))"]}
{"id": "entailmentbank_validation_970", "nl": "pliers are made of two levers for gripping.", "fol": "", "prediction": ["all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & GrippingTool(x)))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & Function(y, Gripping)))", "all x. (Pliers(x) -> exists y. exists z. (Lever(y) & Lever(z) & MadeOfTwoLeversForGripping(x, y, z)))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> IsMadeOf(x, TwoLevers) & ForPurposeOf(x, Gripping))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> exists y exists z. (Lever(y) & Lever(z) & PartOf(y, x) & PartOf(z, x) & ForGripping(x)))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> exists y, z. (Lever(y) & Lever(z) & PartOf(y, x) & PartOf(z, x) & ForGripping(x)))", "all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & Gripping(x)))", "all x. (Pliers(x) -> MadeOfTwoLeversForGripping(x))", "all x. (Pliers(x) -> exists y, z. (Lever(y) & Lever(z) & PartOf(y, x) & PartOf(z, x) & UsedForGripping(x)))", "all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & Gripping(y, x)))", "all x. (Pliers(x) -> exists y. (Lever(y) & PartOf(y, x) & UsedFor(y, Gripping)))"]}
{"id": "entailmentbank_validation_971", "nl": "pliers are a tool made of two levers for gripping.", "fol": "", "prediction": ["all x. (Pliers(x) -> Tool(x) & MadeOf(x, Levers) & EqualsNumberOfParts(x, 2) & ForPurpose(x, Gripping))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> (Tool(x) & MadeOfTwoLevers(x) & ForGripping(x)))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> (Tool(x) & MadeOf(x, two_levers) & ForGripping(x)))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & UsedForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOf(x, twoLevers) & UsedFor(x, Gripping))", "all x. (Pliers(x) -> Tool(x) & ConsistsOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> Tool(x) & MadeOf(x, Levers) & Count(Levers, 2) & Function(x, Gripping))", "all x. (Pliers(x) -> (Tool(x) & MadeOfTwoLevers(x) & ForGripping(x)))", "all x. (Pliers(x) -> Tool(x) & MadeOfTwoLevers(x) & ForGripping(x))", "all x. (Pliers(x) -> (Tool(x) & MadeOfTwoLevers(x) & UsedForGripping(x)))"]}
{"id": "entailmentbank_validation_972", "nl": "gripping produces gripping force.", "fol": "", "prediction": ["all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> Produces(x, GrippingForce))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> Produces(x, GrippingForce(x)))", "all x. (Gripping(x) -> Produces(x, GrippingForce))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> Produces(x, GrippingForce))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> ProducesGrippingForce(x))", "all x. (Gripping(x) -> Produces(x, GrippingForce))", "all x. (Gripping(x) -> Produces(x, GrippingForce))", "all x. (Gripping(x) -> ProducesGrippingForce(x))"]}
{"id": "entailmentbank_validation_973", "nl": "pliers are a tool that can produce gripping force.", "fol": "", "prediction": ["all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> Tool(x) & CanProduceGrippingForce(x))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> Tool(x) & CanProduceGrippingForce(x))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> Tool(x) & CanProduceGrippingForce(x))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))", "all x. (Pliers(x) -> (Tool(x) & CanProduceGrippingForce(x)))"]}
{"id": "entailmentbank_validation_974", "nl": "a gripping force can be used to tighten a mechanical fastener.", "fol": "", "prediction": ["FOL Translation:\nall x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "exists x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "exists x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanTighten(x, y)))", "exists x y. (GrippingForce(x) & MechanicalFastener(y) -> CanBeUsedToTighten(x, y))", "exist x y. (GrippingForce(x) & MechanicalFastener(y) -> CanBeUsedToTighten(x, y))", "exists f. (GrippingForce(f) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(f, y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "exists x. (GrippingForce(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "all x. (GrippingForce(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))"]}
{"id": "entailmentbank_validation_975", "nl": "pliers can be used to tighten a mechanical fastener.", "fol": "", "prediction": ["exists x. (Pliers(x) -> CanBeUsedToTighten(x, MechanicalFastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, some y. MechanicalFastener(y)))", "all x. (Pliers(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, MechanicalFastener(y)))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, MechanicalFastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTightenFastener(x))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, MechanicalFastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, MechanicalFastener))", "all x. (Pliers(x) -> exists y. (MechanicalFastener(y) & CanBeUsedToTighten(x, y)))", "all x. (Pliers(x) -> CanBeUsedToTighten(x, mechanical_fastener))"]}
{"id": "entailmentbank_validation_976", "nl": "advances in technology sometimes cause human jobs to be replaced by more efficient machines.", "fol": "", "prediction": ["exists x. (AdvanceInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & CausesReplacement(x, y, z))))", "exists t. (AdvancesInTechnology(t) & exists j. (HumanJob(j) & exists m. (EfficientMachine(m) & CausesReplacement(t, j, m))))", "exists x. (AdvancesInTechnology(x) & exists y. (Job(y) & exists z. (Machine(z) & Efficient(z) & Replaces(y, z))))", "exists t. (AdvancesInTechnology(t) & causes(t, exists j. (HumanJob(j) & exists m. (EfficientMachine(m) & Replaces(m, j)))))", "exists x. (AdvancesInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & Causes(x, ReplacedBy(y, z)))))", "exists x, y. (AdvancesInTechnology(x) & HumanJob(y) & ReplacedByEfficientMachine(y, x))", "exists x. (AdvanceInTechnology(x) & -all y. (HumanJob(y) -> exists z. (EfficientMachine(z) & Replaces(z, y))))", "exists x. (AdvanceInTechnology(x) & exists y. (HumanJob(y) & -all z. (Machine(z) -> -(Replaces(z, y) & MoreEfficient(z)))))", "exists x. (AdvancesInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & Replaces(z, y))))", "exists x. (AdvancesInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & Causes(x, Replaced(y, z)))))", "exists x. (AdvancesInTechnology(x) & exists y. (Machine(y) & MoreEfficient(y) & exists z. (Job(z) & HumanDoes(z) & Causes(x, ReplacedBy(z, y)))))", "exists x. (AdvanceInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & Causes(x, Replaces(z, y)))))", "exists x. (AdvanceInTechnology(x) & exists y. (HumanJob(y) & exists z. (EfficientMachine(z) & CausesReplacement(x, y, z))))", "exists x. (AdvanceInTechnology(x) & exists y. (exists z. (HumanJob(z) & ReplacedBy(y, z) & EfficientMachine(y))))", "exists t. (AdvancesInTechnology(t) & exists j. (HumanJob(j) & exists m. (EfficientMachine(m) & CausesReplacement(t, j, m))))", "exists t, j, m. (AdvancesInTechnology(t) & HumanJob(j) & Machine(m) & Causes(t, ReplacedBy(j, m)) & MoreEfficient(m, j))"]}
{"id": "entailmentbank_validation_977", "nl": "replacing something decreases that something.", "fol": "", "prediction": ["all x. (exists y. (Replaces(y, x)) -> Decreases(x))", "all x. (Replaced(x) -> Decreases(x))", "all x. (Replaced(x) -> Decreases(x))", "all x. (Replaces(x, y) -> Decreases(y))", "all x. (exists y. (Replaced(y, x)) -> Decreases(y, x))", "all x. (Replaced(x) -> Decreases(x))", "all x. (Replace(x) -> Decreases(x, x))", "all x. (Replacing(x) -> Decreases(x, x))", "all x. (exists y. (Replaces(y, x)) -> Decreases(x))", "all x. (Decreases(x, x))", "all x. (exists y. Replacing(x, y) -> Decreases(y))", "all x. (Replacable(x) -> exists y. (Replacement(y) & Decreases(y, x)))", "all x. (Decreases(replacing, x) -> Replaces(x))", "all x. (Replaces(x) -> Decreases(x, x))", "all x. (Decreases(replace(x), x))", "all x. all y. (Replaces(y, x) -> Decreases(x))"]}
{"id": "entailmentbank_validation_978", "nl": "advances in technology decrease human jobs by replacing them with efficient machines.", "fol": "", "prediction": ["exists a, b. (Advances(a) & Technology(a) & Decreases(b, HumanJobs) & Replaces(b, Machines) & Efficient(Machines))", "exists a. (AdvanceInTechnology(a) & all x. (HumanJob(x) -> exists y. (EfficientMachine(y) & Replaces(y, x))))", "exists x. (TechnologyAdvance(x) & all y. (HumanJob(y) -> exists z. (Machine(z) & Replaces(z, y) & Efficient(z))))", "exists x, y, z. (AdvancesInTechnology(x) & HumanJobs(y) & EfficientMachines(z) & Decrease(x, y, z) & Replace(z, y))", "all x. (AdvanceInTechnology(x) -> exists y. (HumanJob(y) & ReplacedBy(y, EfficientMachine) & Decreases(y)))", "all x. ((AdvanceInTechnology(x) & replaces(x, y, z) & HumanJob(y) & EfficientMachine(z)) -> Decreases(y))", "exists a. (AdvancesInTechnology(a) -> all x. (HumanJob(x) & ReplacedBy(x, EfficientMachines) -> Decrease(x)))", "exists x. (AdvancesInTechnology(x) & all y. (HumanJob(y) -> exists z. (EfficientMachine(z) & Replaces(z, y) & Decreases(y, x))))", "exists t. (AdvancesInTechnology(t) & all j. (HumanJob(j) -> exists m. (EfficientMachine(m) & ReplacesWith(m, j))))", "all x. (AdvancesInTechnology(x) -> exists y. (HumanJob(y) & ReplacedBy(y, EfficientMachines) & Decreases(y)))", "exists a, b, c. (AdvancesInTechnology(a) & HumanJobs(b) & EfficientMachines(c) & Replaces(c, b) & Causes(a, Decreases(b)))", "exists x. (TechnologyAdvances(x) -> all y. (HumanJob(y) -> exists z. (EfficientMachine(z) & Replaces(z, y))))", "exists t. (AdvanceInTechnology(t) -> all j. (HumanJob(j) & ReplacedBy(j, m) & Efficient(m) & Machine(m) -> Decreases(j)))", "exists x y z. (AdvancesInTechnology(x) & HumanJob(y) & Machine(z) & Efficient(z) & Replaces(x, y, z) & Decreases(x, y))", "exists x. (TechnologyAdvance(x) & all y. (HumanJob(y) -> exists z. (EfficientMachine(z) & Replaces(z, y))))", "exists a, b, c. (AdvancesInTechnology(a) & HumanJobs(b) & EfficientMachines(c) & Decrease(jobs, a, b) & ReplaceWith(c, b))"]}
{"id": "entailmentbank_validation_979", "nl": "having a job has a positive impact on a human.", "fol": "", "prediction": ["all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(HavingJob, x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Job(y) & Has(x, y) & Human(x) -> PositiveImpactOn(y, x))", "FOL Translation:\nall x. (Human(x) -> (exists y. (Job(y) & Has(x, y)) -> PositiveImpactOn(x)))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(HavingJob, x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpact(x))", "all x. (Human(x) & HasJob(x) -> PositiveImpactOn(x))"]}
{"id": "entailmentbank_validation_980", "nl": "decreasing something positive has a negative impact on a thing.", "fol": "", "prediction": ["all x, y. (Positive(x) & Decreases(x) & Thing(y) -> NegativeImpact(x, y))", "all x y. (Positive(x) & Decreasing(x) & Thing(y) -> NegativeImpact(x, y))", "all x y. (Positive(x) & Decreases(x, y) -> HasNegativeImpactOn(y))", "all x. all y. (Positive(x) & Decrease(x) -> exists z. (NegativeImpact(z, y) & Thing(y)))", "all x y. (Positive(x) & Decreasing(x) -> NegativeImpact(y, x))", "all x y. (Positive(x) & Decreases(x, y) -> NegativeImpact(y))", "all x. all y. (Positive(x) & Decrease(x) & Affects(x, y) -> NegativeImpact(y))", "all x y. (Positive(x) & Decreasing(x) -> NegativeImpact(y))", "FOL Translation:\nall x y. (Positive(x) & Decreasing(x) & ImpactOn(x, y) -> NegativeImpact(y))", "all x. (Positive(x) & Decreases(x) -> exists y. (NegativeImpact(y) & On(y, x)))", "`all x. all y. (Positive(x) & Decreases(x) & Thing(y) -> NegativeImpactOn(x, y))`", "all x all y. (Decreasing(x) & Positive(x) & Thing(y) -> NegativeImpactOn(x, y))", "all x all y. (Positive(x) & Decrease(x, y) -> HasNegativeImpact(y))", "all x y. (Positive(x) & Decreases(y, x) -> HasNegativeImpact(y, z))", "all x y. (Positive(x) & Decreases(x) & Impacts(y, x) -> NegativeImpact(y))", "all x y. (Positive(x) & DecreaseImpact(x, y) -> NegativeImpact(y))"]}
{"id": "entailmentbank_validation_981", "nl": "advances in technology decreasing human jobs by more efficient machines has a negative impact on human.", "fol": "", "prediction": ["exists x y. (AdvancesInTechnology(x) & DecreasesHumanJobs(x, y) & Machines(y) & MoreEfficient(y) & NegativeImpactOnHumans(x))", "exists x, y. (AdvanceInTechnology(x) & HumanJob(y) & Decreases(x, y) & MoreEfficientMachines(x) & ImpactsNegatively(x, human))", "Exists a situation where if advances in technology decrease jobs by more efficient machines, it has a negative impact on humans.\n\nFOL Translation:\nexists t, h, m. (TechnologyAdvances(t) & DecreasesJobsByMachines(t, h, m) & Efficient(m) -> NegativeImpactOnHumans(h))", "exists x, y. (AdvancesInTechnology(x) & EfficientMachine(y) & DecreasesJobs(y) & NegativeImpactOnHumans(x))", "exists t, m. (AdvancesInTechnology(t) & EfficientMachines(m) & DecreasesJobs(m) -> NegativeImpactOnHumans(t, m))", "exists m. (Machine(m) & Efficient(m) & DecreasesHumanJobs(m) -> NegativeImpactOnHuman(m))", "exists x, y, z. (AdvancesInTechnology(x) & DecreasesHumanJobsByMoreEfficientMachines(x, y) & HasNegativeImpactOnHuman(y, z))", "all x. ((AdvancesInTechnology(x) & DecreasesHumanJobsByEfficientMachines(x)) -> HasNegativeImpactOnHumans(x))", "exists a, b. (AdvancesInTechnology(a) & DecreasingHumanJobsByEfficientMachines(a, b) & EfficientMachines(b) & NegativeImpactOnHuman(b))", "exists m. (AdvanceInTechnology(m) & DecreasesHumanJobs(m) & MoreEfficient(m) & Machine(m) & HasNegativeImpactOnHuman(m))", "exists x. exists y. (AdvancesInTechnology(x) & MoreEfficient(y) & Machine(y) & DecreasesHumanJobs(y) -> NegativeImpactOnHuman(x))", "exists x y. (AdvancesInTechnology(x) & MoreEfficientMachines(y) & DecreasesHumanJobs(y) & NegativeImpactOnHuman(y))", "", "exists x. (AdvancesInTechnology(x) & DecreasesHumanJobsByEfficientMachines(x) -> NegativeImpactOnHuman(x))", "exists x. (AdvancesInTechnology(x) & DecreasesHumanJobsByEfficientMachines(x) -> HasNegativeImpactOnHuman(x))", "exists x, y. (AdvancesInTechnology(x) & EfficientMachines(y) & Decreases(y, HumanJobs) & NegativeImpact(x, Human))"]}
{"id": "entailmentbank_validation_982", "nl": "days are a kind of unit for measuring time.", "fol": "", "prediction": ["all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "FOL Translation:\nall x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all z. (Day(z) -> UnitForMeasuringTime(z))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitOfMeasureForTime(x))", "all x. (Day(x) -> TimeUnit(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))", "all x. (Day(x) -> UnitForMeasuringTime(x))"]}
{"id": "entailmentbank_validation_983", "nl": "a student wants to record the data of the growth of a vine over a period of a day.", "fol": "", "prediction": ["exists x. (Student(x) & exists y. (Vine(y) & wantsToRecordDataOfGrowth(x, y) & overPeriodOf(x, day)))", "exists x, y, z, t. (Student(x) & Vine(y) & Data(z) & Day(t) & WantsToRecord(x, z) & GrowthOf(y, z) & OverPeriod(z, t))", "exists x. (Student(x) & exists y. (Data(y) & Record(x, y) & GrowthOf(y, vine) & OverPeriod(y, day)))", "exists x. (Student(x) & exists y. (Vine(y) & WantsToRecordDataOfGrowthOf(x, y) & OverPeriodOf(x, day)))", "exists x. (Student(x) & exists y. (Vine(y) & WantsToRecordDataOfGrowth(x, y, dayPeriod)))", "exists x. (Student(x) & exists y. (WantsToRecord(x, y) & DataOfGrowth(y) & Vine(y) & OverPeriodOfDay(y)))", "exists x. (Student(x) & exists y. (Data(y) & WantsToRecord(x, y) & exists z. (GrowthOfVine(z) & OverPeriodOf(z, day) & RelatedTo(y, z))))", "exists x. (Student(x) & exists y. (Vine(y) & WantsToRecordDataOfGrowth(x, y) & OverPeriodOfDay(y)))", "exists x. (Student(x) & exists y. (DataOfGrowth(y) & Vine(v) & Period(y, day) & WantsToRecord(x, y)))", "exists x. (Student(x) & exists y. (Data(y) & Growth(z) & Vine(z) & Period(u) & Day(u) & WantsToRecord(x, y)))", "exists x. (Student(x) & exists y. (Vine(y) & exists z. (Data(z) & Growth(y, z) & OverADayPeriod(z) & WantsToRecord(x, z))))", "exists x. (Student(x) & wantsToRecordDataOfGrowth(x, vine, dayPeriod))", "exists x y. (Student(x) & Vine(y) & WantsToRecordData(x, y) & GrowthOf(y) & OverPeriodOf(y, day))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOf(vine, y) & Record(x, y) & OverPeriod(y, one_day)))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOfVineData(y) & WantsToRecord(x, y) & Period(z) & Day(z) & OverPeriod(y, z)))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOf(y, vine) & overPeriodOf(y, day) & WantsToRecord(x, y)))"]}
{"id": "entailmentbank_validation_984", "nl": "the student wants to record the data of the growth of a vine over a period of time.", "fol": "", "prediction": ["exists x, y, z, w. (Student(x) & Data(y) & Growth(z) & Vine(w) & WantsToRecord(x, y) & Of(y, z) & Of(z, w) & OverPeriodOfTime(y))", "exists x. exists y. exists z. (Student(x) & Data(y) & Vine(z) & PeriodOfTime(t) & GrowthOf(z, t) & WantsToRecord(x, y) & About(y, GrowthOf(z, t)))", "exists x. (Student(x) & exists y. (DataOfGrowth(y) & Vine(y) & exists z. (PeriodOfTime(z) & WantsToRecord(x, y, z))))", "Existential quantifiers should be used in this case since particular entities like the student, the data, the growth, the vine, and the period of time are mentioned. Here is the suitable FOL translation:\n\n```\nexists x, y, z, w. (Student(x) & Data(y) & Growth(z, vine) & PeriodOfTime(w) & WantsToRecord(x, y, z, w))\n```", "exists s, d, v, t. (Student(s) & Data(d) & Vine(v) & PeriodOfTime(t) & WantsToRecord(s, d) & OfGrowth(d, v) & OverPeriod(d, t))", "`exists x y z. (Student(x) & Data(y) & Vine(z) & WantsToRecord(x, y) & GrowthOf(z, y) & OverPeriodOfTime(y))`", "exists x. (Student(x) & exists y. (Data(y) & GrowthOfVine(y) & PeriodOfTime(z) & WantsToRecord(x, y, z)))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOf(Plant(Vine))(y) & WantsToRecord(x, y) & PeriodOfTime(z) & RelatesTo(y, z)))", "The FOL Translation for the sentence is:\n\nexists x, y, z, w. (Student(x) & Vine(y) & Data(z) & TimePeriod(w) & WantsToRecordDataOfGrowthOfVineOverPeriod(x, y, z, w))", "exists x y. (Student(x) & Vine(y) & WantsToRecordGrowthData(x, y))", "Exists x. (Student(x) & WantsToRecordData(x) & Exists y. (Growth(y) & Of(y, Vine) & OverPeriodOfTime(y)))", "exists x. (Student(x) & exists y. (Vine(y) & wantsToRecordGrowthDataOf(x, y)))", "exists x. (Student(x) & exists y. (Data(y) & Record(x, y) & GrowthOf(vine, y) & OverPeriodOfTime(y)))", "exists x. (Student(x) & exists y. (Data(y) & Record(x, y) & involves(y, Growth) & of(Growth, Vine) & over(Growth, PeriodOfTime)))", "exists x. (Student(x) & exists y. (DataOfGrowth(y) & Vine(y) & PeriodOfTime(z) & WantsToRecord(x, y, z)))", "exists x. (Student(x) & exists y. (Data(y) & GrowthOf(y, vine) & OverPeriodOfTime(y) & WantsToRecord(x, y)))"]}
{"id": "entailmentbank_validation_985", "nl": "a line graph is used for showing change / data over time.", "fol": "", "prediction": ["all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedForShowingChangeOverTime(x) | UsedForShowingDataOverTime(x))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime(x)))", "all x. (LineGraph(x) -> UsedFor(x, ShowChangeOverTime) | UsedFor(x, ShowDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedForShowingChangeOverTime(x))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedFor(x, ShowingChangeOrDataOverTime))", "all x. (LineGraph(x) -> UsedForShowingChangeOverTime(x))"]}
{"id": "entailmentbank_validation_986", "nl": "a line graph an be used to show the data of the growth of the vine over a period of time.", "fol": "", "prediction": ["exists x. (LineGraph(x) & UsedToShow(x, Data(y)) & Growth(y, vine) & PeriodOfTime(z) & Over(y, z))", "exists x. (LineGraph(x) & CanShowDataOfGrowth(x, vine) & OverPeriodOfTime(x))", "exists x. (LineGraph(x) & CanBeUsedToShowData(x, GrowthOfVine, PeriodOfTime))", "exists x. (LineGraph(x) & CanShowData(x) & Data(x, GrowthOfVine) & PeriodOfTime(y) & OverPeriodOfTime(x, y))", "all x. (LineGraph(x) -> (exists y. (Data(y) & GrowthOfVine(y) & OverPeriodOfTime(y)) & CanShow(x, y)))", "exists x. (LineGraph(x) & UsedToShowDataOf(x, GrowthOf(vine, TimePeriod)))", "exists x, y, z, w. (LineGraph(x) & Data(y) & Growth(y, z) & Vine(z) & PeriodOfTime(w) & Shows(x, y))", "FOL Translation:\nexists x. (LineGraph(x) & UsedToShow(x, GrowthOfVineData) & OverPeriodOfTime(x))", "exists x. (LineGraph(x) & CanBeUsedToShow(x, DataOf(GrowthOf(vine), PeriodOfTime)))", "exists x. (LineGraph(x) & CanShowData(x, Growth(vine), PeriodOfTime))", "exists x. (LineGraph(x) & CanBeUsedToShow(x, DataOfGrowthOfVine, PeriodOfTime))", "exists x. (LineGraph(x) & CanBeUsedToShowData(x, GrowthOf(vine, PeriodOf(time))))", "exists x. (LineGraph(x) & exists y. (Data(y) & Shows(x, y) & exists z. (Growth(z) & OfVine(z) & exists t. (PeriodOfTime(t) & Over(z, t)))))", "exists x. (LineGraph(x) -> CanShowDataOf(x, GrowthOf(vine), OverPeriodOfTime))", "all x. (LineGraph(x) -> canBeUsedToShowDataOfGrowthOfVine(x, timePeriod))", "all x. (LineGraph(x) -> CanBeUsedToShow(x, DataOf(GrowthOf(Vine), PeriodOfTime)))"]}
